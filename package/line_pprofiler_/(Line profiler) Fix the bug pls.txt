Total duration: 22.6246s
File: D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\Mix_Run_Ratio.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|exec("""import os\ntry:\n    with open(os.path.join(os.path.abspath(os.path.dirname(__file__)), "package", "log_to_file", "import.txt")) as f: exec(f.read())\nexcept:pass""")
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import pandas as pd
     4|         0|            0|            0|  0.00%|import numpy as np
     5|         0|            0|            0|  0.00%|import platform
     6|         0|            0|            0|  0.00%|from DBSrv5ConnPy.db_object import DBObject
     7|         0|            0|            0|  0.00%|import os
     8|         0|            0|            0|  0.00%|import sys
     9|         0|            0|            0|  0.00%|from datetime import datetime, timedelta
    10|         0|            0|            0|  0.00%|import time
    11|         0|            0|            0|  0.00%|import csv
    12|         0|            0|            0|  0.00%|import pickle
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|class Mix_Run_Ratio:
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|    def __init__(self, FAB, date = "last_day", mode = "online", \
    19|         0|            0|            0|  0.00%|                 use_tqdm = False, EQP_ID_upper_limit = 50):
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|        # Set DB.
    22|         0|            0|            0|  0.00%|        self.db_obj = DBObject(fab = FAB, db = "MES")
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|        # Get today and tomorrow for the SQL.
    25|         0|            0|            0|  0.00%|        if date == "last_day":
    26|         0|            0|            0|  0.00%|            self.today =  ( datetime.now() - timedelta(days = 1) ).strftime("%Y/%m/%d")
    27|         0|            0|            0|  0.00%|        else:
    28|         0|            0|            0|  0.00%|            self.today = date
    29|         0|            0|            0|  0.00%|        self.tomorrow = (datetime.strptime(self.today, "%Y/%m/%d") + \
    30|         0|            0|            0|  0.00%|                         timedelta(days = 1)).strftime("%Y/%m/%d")
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|        # Set the mode.
    33|         0|            0|            0|  0.00%|        self.mode = mode
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|        # Get the output_path and max_job.
    36|         0|            0|            0|  0.00%|        sql = \
    37|         0|            0|            0|  0.00%|            """
    38|         0|            0|            0|  0.00%|            SELECT PARM_NAME, PARM_VALUES
    39|         0|            0|            0|  0.00%|            FROM MFGDEV.AUTO_MINE_SYSTEM_CONFIG_UT
    40|         0|            0|            0|  0.00%|            WHERE 1=1
    41|         0|            0|            0|  0.00%|            AND TEMPLATE_ID = 'DEFAULT'
    42|         0|            0|            0|  0.00%|            AND PARM_NAME IN ('RCP_RATIO_DATA_FOLDER', 'TRIGGER_MAX_JOB_CNT_MIXRUN_RATIO')
    43|         0|            0|            0|  0.00%|            """
    44|         0|            0|            0|  0.00%|        config_table = self.db_obj.query(sql = sql)
    45|         0|            0|            0|  0.00%|        for index, row in config_table.iterrows():
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|            if row["PARM_NAME"] == "RCP_RATIO_DATA_FOLDER":
    48|         0|            0|            0|  0.00%|                if self.mode == "online":
    49|         0|            0|            0|  0.00%|                    self.output_path = row["PARM_VALUES"].replace("*", "\\")
    50|         0|            0|            0|  0.00%|                elif self.mode == "offline":
    51|         0|            0|            0|  0.00%|                    self.output_path = "output"
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|            elif row["PARM_NAME"] == "TRIGGER_MAX_JOB_CNT_MIXRUN_RATIO":
    54|         0|            0|            0|  0.00%|                self.max_job = int( row["PARM_VALUES"] )
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|        # Set three threshold for recipe.
    57|         0|            0|            0|  0.00%|        self.absolute_threshold = 3
    58|         0|            0|            0|  0.00%|        self.relative_threshold = 0.01
    59|         0|            0|            0|  0.00%|        self.total_amount_threshold = 24
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|        # Others.
    62|         0|            0|            0|  0.00%|        self.use_tqdm = use_tqdm
    63|         0|            0|            0|  0.00%|        self.EQP_ID_upper_limit = EQP_ID_upper_limit
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|    def query_5_times(self, sql):
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|        # Hit the DB at most 5 times.
    69|         0|            0|            0|  0.00%|        fail_count, successful = 0, False
    70|         0|            0|            0|  0.00%|        while fail_count < 5 and successful == False:
    71|         0|            0|            0|  0.00%|            try:
    72|         0|            0|            0|  0.00%|                table = self.db_obj.query(sql)
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\DBSrv5ConnPy\db_object.py:224 query
    73|         0|            0|            0|  0.00%|                successful = True
    74|         0|            0|            0|  0.00%|            except Exception as e:
    75|         0|            0|            0|  0.00%|                print(e)
    76|         0|            0|            0|  0.00%|                fail_count = fail_count + 1
    77|         0|            0|            0|  0.00%|        if successful == False:
    78|         0|            0|            0|  0.00%|            raise Exception("Wow, I tried ...")
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|        return table
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|    def load_pickle(self, input_path, file_name):
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|        data = []
    86|         0|            0|            0|  0.00%|        with open(os.path.join(input_path, file_name + ".pickle"), "rb") as pickle_file:
    87|         0|            0|            0|  0.00%|            try:
    88|         0|            0|            0|  0.00%|                while True:
    89|        30|            0|            0|  0.00%|                    data.append(pickle.load(pickle_file))
    90|         0|            0|            0|  0.00%|            except EOFError:
    91|         0|            0|            0|  0.00%|                pass
    92|         0|            0|            0|  0.00%|        return data
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|    def store_combination_table(self):
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|        def sorted_k_partitions(seq, k):
    98|         0|            0|            0|  0.00%|            # Returns a list of all unique k-partitions of `seq`.
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|            # Each partition is a list of parts, and each part is a tuple.
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|            # The parts in each individual partition will be sorted in shortlex
   103|         0|            0|            0|  0.00%|            # order (i.e., by length first, then lexicographically).
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|            # The overall list of partitions will then be sorted by the length
   106|         0|            0|            0|  0.00%|            # of their first part, the length of their second part, ...,
   107|         0|            0|            0|  0.00%|            # the length of their last part, and then lexicographically.
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|            n = len(seq)
   110|         0|            0|            0|  0.00%|            groups = []  # a list of lists, currently empty
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|            def generate_partitions(i):
   113|         0|            0|            0|  0.00%|                if i >= n:
   114|         0|            0|            0|  0.00%|                    yield list(map(tuple, groups))
   115|         0|            0|            0|  0.00%|                else:
   116|         0|            0|            0|  0.00%|                    if n - i > k - len(groups):
   117|         0|            0|            0|  0.00%|                        for group in groups:
   118|         0|            0|            0|  0.00%|                            group.append(seq[i])
   119|         0|            0|            0|  0.00%|                            yield from generate_partitions(i + 1)
   120|         0|            0|            0|  0.00%|                            group.pop()
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|                    if len(groups) < k:
   123|         0|            0|            0|  0.00%|                        groups.append([seq[i]])
   124|         0|            0|            0|  0.00%|                        yield from generate_partitions(i + 1)
   125|         0|            0|            0|  0.00%|                        groups.pop()
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|            result = generate_partitions(0)
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|            # Sort the parts in each partition in shortlex order
   130|         0|            0|            0|  0.00%|            result = [sorted(ps, key = lambda p: (len(p), p)) for ps in result]
   131|         0|            0|            0|  0.00%|            # Sort partitions by the length of each part, then lexicographically.
   132|         0|            0|            0|  0.00%|            result = sorted(result, key = lambda ps: (*map(len, ps), ps))
   133|         0|            0|            0|  0.00%|            return result
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|        """ Main function for store_combination_table. """
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|        # Get the output_path_combination.
   139|         0|            0|            0|  0.00%|        output_path_combination = os.path.join(self.output_path, "combination_table")
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|        # Create output folder.
   142|         0|            0|            0|  0.00%|        if not os.path.exists(output_path_combination):
   143|         0|            0|            0|  0.00%|            os.makedirs(output_path_combination)
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|        # Calculate all combinations.
   146|         0|            0|            0|  0.00%|        for total_amount in range(2, self.total_amount_threshold + 1):
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|            print("Create combination_table for total_amount = " + str(total_amount) + " ...")
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|            # Generate recipe_index_list.
   151|         0|            0|            0|  0.00%|            recipe_index_list = sorted_k_partitions( [ i for i in range(total_amount) ], 2 )
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|            # Write to pickle.
   154|         0|            0|            0|  0.00%|            with open(os.path.join(output_path_combination, str(total_amount) + ".pickle"), "wb") as pickle_file:
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|                for recipe_index in recipe_index_list:
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|                    # Get index_for_group.
   159|         0|            0|            0|  0.00%|                    index_for_group_1 = list(recipe_index[0])
   160|         0|            0|            0|  0.00%|                    index_for_group_2 = list(recipe_index[1])
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|                    # Get recipe_index_for_group.
   163|         0|            0|            0|  0.00%|#                    recipe_index_for_group_1  = ",".join([ str(i) for i in index_for_group_1 ])
   164|         0|            0|            0|  0.00%|#                    recipe_index_for_group_2  = ",".join([ str(i) for i in index_for_group_2 ])
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|                    # Add index_for_group into pickle.
   167|         0|            0|            0|  0.00%|                    pickle.dump([ index_for_group_1, index_for_group_2 ], \
   168|         0|            0|            0|  0.00%|                                pickle_file, pickle.HIGHEST_PROTOCOL)
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    def insert_recipe_table(self):
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|        def get_EQP_ID_list():
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|            sql = \
   175|         0|            0|            0|  0.00%|                """
   176|         0|            0|            0|  0.00%|                SELECT DISTINCT SUBSTR(A.EQP_ID, 1, 6) AS EQP_ID
   177|         0|            0|            0|  0.00%|                FROM F12AS.AFT_BKM_TOOL_BT A
   178|         0|            0|            0|  0.00%|                WHERE 1 = 1
   179|         0|            0|            0|  0.00%|                AND A.EQP_CATEGORY = 'Process'
   180|         0|            0|            0|  0.00%|                """
   181|         0|            0|            0|  0.00%|            table = self.query_5_times(sql)
   182|         0|            0|            0|  0.00%|            EQP_ID_list = list(table["EQP_ID"])
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|#            return EQP_ID_list[:3]
   185|         0|            0|            0|  0.00%|            return EQP_ID_list
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|        def yield_successive_chunks(l, n):
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|            for i in range(0, len(l), n):
   191|         0|            0|            0|  0.00%|                yield l[ i : i + n ]
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|        """ Main function for insert_recipe_table. """
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|        # Get EQP_ID_list.
   197|         0|            0|            0|  0.00%|        EQP_ID_list = get_EQP_ID_list()
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|        # Split EQP_ID_list into chunks.
   200|         0|            0|            0|  0.00%|        EQP_ID_list_with_chunks = \
   201|         0|            0|            0|  0.00%|            list( yield_successive_chunks(EQP_ID_list, self.EQP_ID_upper_limit) )
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|        # Determine that we're using tqdm or not.
   204|         0|            0|            0|  0.00%|        print_statement = "Insert the recipe table for " + self.today + " ..."
   205|         0|            0|            0|  0.00%|        if self.use_tqdm == False:
   206|         0|            0|            0|  0.00%|            print(print_statement)
   207|         0|            0|            0|  0.00%|            for_statement = """EQP_ID_list_with_chunks"""
   208|         0|            0|            0|  0.00%|        else:
   209|         0|            0|            0|  0.00%|            for_statement = """tqdm(EQP_ID_list_with_chunks, desc = print_statement)"""
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|            # Import tqdm.
   212|         0|            0|            0|  0.00%|            package_path = os.path.join(os.path.abspath(os.path.dirname(__file__)), "package")
   213|         0|            0|            0|  0.00%|            if package_path not in sys.path: sys.path.insert(0, package_path)
   214|         0|            0|            0|  0.00%|            exec("from tqdm import tqdm")
   215|         0|            0|            0|  0.00%|            import colorama
   216|         0|            0|            0|  0.00%|            colorama.deinit()
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|        # For every smaller_EQP_ID_list, we need to get corresponding recipe_table.
   219|         0|            0|            0|  0.00%|            # And then, we insert this recipe_table into DB.
   220|         0|            0|            0|  0.00%|        for smaller_EQP_ID_list in eval(for_statement):
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|            # Get the recipe_table.
   223|         0|            0|            0|  0.00%|            sql = \
   224|         0|            0|            0|  0.00%|                """
   225|         0|            0|            0|  0.00%|                SELECT
   226|         0|            0|            0|  0.00%|                A.EQP_ID, A.DATE_TIME, A.RECIPE_ID, COUNT(A.WAFER_ID) AS WAFER_CNT
   227|         0|            0|            0|  0.00%|                FROM
   228|         0|            0|            0|  0.00%|                (
   229|         0|            0|            0|  0.00%|                	Select TRUNC(T.UPDATE_DT, 'DD') AS DATE_TIME,EQP_ID, RECIPE_ID, WAFER_ID
   230|         0|            0|            0|  0.00%|                	FROM MFGDEV.EES_AEC_FDC_WAFER_INFO_VW T
   231|         0|            0|            0|  0.00%|                	WHERE 1 = 1
   232|         0|            0|            0|  0.00%|                	AND T.UPDATE_DT >= TO_DATE('   {today} 00:00:00','YYYY/MM/DD HH24:MI:SS')
   233|         0|            0|            0|  0.00%|                	AND T.UPDATE_DT <= TO_DATE('{tomorrow} 00:00:00','YYYY/MM/DD HH24:MI:SS')
   234|         0|            0|            0|  0.00%|                	AND T.EQP_ID IN ({EQP_ID_string})
   235|         0|            0|            0|  0.00%|                ) A
   236|         0|            0|            0|  0.00%|                GROUP BY EQP_ID, DATE_TIME, RECIPE_ID
   237|         0|            0|            0|  0.00%|                """
   238|         0|            0|            0|  0.00%|            EQP_ID_string = \
   239|         0|            0|            0|  0.00%|                ", ".join( [ "'" + EQP_ID + "'" for EQP_ID in smaller_EQP_ID_list ] )
   240|         0|            0|            0|  0.00%|            recipe_table = \
   241|         0|            0|            0|  0.00%|                self.query_5_times( sql.format(today = self.today, \
   242|         0|            0|            0|  0.00%|                                               tomorrow = self.tomorrow, \
   243|         0|            0|            0|  0.00%|                                               EQP_ID_string = EQP_ID_string) )
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|            # Calculate RECIPE_CNT and add into recipe_table.
   246|         0|            0|            0|  0.00%|            count_list = list(recipe_table.groupby("EQP_ID")["RECIPE_ID"] \
   247|         0|            0|            0|  0.00%|                              .apply(lambda x: x.unique().shape[0]))
   248|         0|            0|            0|  0.00%|            count_list = [ [count] * count for count in count_list ]
   249|         0|            0|            0|  0.00%|            count_list = [ item for sublist in count_list for item in sublist ]
   250|         0|            0|            0|  0.00%|            recipe_table["RECIPE_CNT"] = count_list
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|            # Add STATUS, START_TIME, END_TIME, SVR_NAME, REMARK.
   253|         0|            0|            0|  0.00%|            claim_time = datetime.strptime( datetime.now().strftime("%Y/%m/%d %H:%M:%S"), \
   254|         0|            0|            0|  0.00%|                                            "%Y/%m/%d %H:%M:%S" )
   255|         0|            0|            0|  0.00%|            recipe_table["CLAIM_TIME"] = [claim_time] * (recipe_table.index.max() + 1)
   256|         0|            0|            0|  0.00%|            recipe_table["REMARK"] = [np.nan] * (recipe_table.index.max() + 1)
   257|         0|            0|            0|  0.00%|            recipe_table["STATUS"] = ["Wait"] * (recipe_table.index.max() + 1)
   258|         0|            0|            0|  0.00%|            recipe_table["START_TIME"] = [np.nan] * (recipe_table.index.max() + 1)
   259|         0|            0|            0|  0.00%|            recipe_table["END_TIME"] = [np.nan] * (recipe_table.index.max() + 1)
   260|         0|            0|            0|  0.00%|            recipe_table["SVR_NAME"] = [np.nan] * (recipe_table.index.max() + 1)
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|            # If RECIPE_CNT = 1, then STATUS should be done.
   263|         0|            0|            0|  0.00%|            for index, row in recipe_table.iterrows():
   264|         0|            0|            0|  0.00%|                if row["RECIPE_CNT"] == 1:
   265|         0|            0|            0|  0.00%|                    recipe_table.loc[index, "STATUS"] = "Done"
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|            # Insert the recipe_table.
   268|         0|            0|            0|  0.00%|            self.db_obj.non_query( df = recipe_table, \
   269|         0|            0|            0|  0.00%|                                   cols = recipe_table.columns.tolist(), \
   270|         0|            0|            0|  0.00%|                                   table = "MFGDEV3.AUTO_MINE_TOOL_RCP_BT", \
   271|         0|            0|            0|  0.00%|                                   nqtype = "insert", \
   272|         0|            0|            0|  0.00%|                                   chunksize = 400000 )
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|    def store_single_ratio_table(self, single_recipe_table):
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|        # Get EQP_ID, DATE_TIME, recipe_id, recipe_id_index, wafer_cnt.
   278|         0|            0|            0|  0.00%|        EQP_ID = single_recipe_table["EQP_ID"][0]
   279|         0|            0|            0|  0.00%|        DATE_TIME = single_recipe_table["DATE_TIME"][0]
   280|         0|            0|            0|  0.00%|        recipe_id = list(single_recipe_table["RECIPE_ID"])
   281|         0|            0|            0|  0.00%|        recipe_id_index = [ i for i in range(len(recipe_id)) ]
   282|         0|            0|            0|  0.00%|        wafer_cnt = list(single_recipe_table["WAFER_CNT"])
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|        # Get the output_path_ratio.
   285|         0|            0|            0|  0.00%|        DATE_TIME_str = DATE_TIME.strftime("%Y%m%d")
   286|         0|            0|            0|  0.00%|        output_path_ratio = os.path.join(self.output_path, DATE_TIME_str)
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|        # Create output folder.
   289|         0|            0|            0|  0.00%|        if not os.path.exists(output_path_ratio):
   290|         0|            0|            0|  0.00%|            os.makedirs(output_path_ratio)
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|        # Create hash table for recipe_id.
   293|         0|            0|            0|  0.00%|        hast_table = pd.DataFrame()
   294|         0|            0|            0|  0.00%|        hast_table["RECIPE_ID"] = recipe_id
   295|         0|            0|            0|  0.00%|        hast_table["RECIPE_INDEX"] = recipe_id_index
   296|         0|            0|            0|  0.00%|        hast_table.to_pickle(os.path.join(output_path_ratio, DATE_TIME_str + "_" + EQP_ID + "_hash_table.pickle"))
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|        # Get all the combinations of recipe_id from combination_table.
   299|         0|            0|            0|  0.00%|        recipe_index_list = self.load_pickle( os.path.join(self.output_path, "combination_table") , str( len(recipe_id) ) )
(call)|        30|            0|            0|  0.00%|# D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\Mix_Run_Ratio.py:83 load_pickle
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|        # Determine that we're using tqdm or not.
   302|         0|            0|            0|  0.00%|        print_statement = "Store the ratio table for " + self.today + " " + EQP_ID + " ..."
   303|         0|            0|            0|  0.00%|        if self.use_tqdm == False:
   304|         0|            0|            0|  0.00%|            print(print_statement)
   305|         0|            0|            0|  0.00%|            for_statement = """recipe_index_list"""
   306|         0|            0|            0|  0.00%|        else:
   307|         0|            0|            0|  0.00%|            for_statement = """tqdm(recipe_index_list, desc = print_statement)"""
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|            # Import tqdm.
   310|         0|            0|            0|  0.00%|            package_path = os.path.join(os.path.abspath(os.path.dirname(__file__)), "package")
   311|         0|            0|            0|  0.00%|            if package_path not in sys.path: sys.path.insert(0, package_path)
   312|         0|            0|            0|  0.00%|            exec("from tqdm import tqdm")
   313|         0|            0|            0|  0.00%|            import colorama
   314|         0|            0|            0|  0.00%|            colorama.deinit()
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|        # Write to pickle.
   317|         0|            0|            0|  0.00%|        with open(os.path.join(output_path_ratio, DATE_TIME_str + "_" + EQP_ID + ".pickle"), "wb") as pickle_file:
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|            for recipe_index in eval(for_statement):
(call)|         9|            0|            0|  0.00%|# D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\package\tqdm\_tqdm.py:1005 __iter__
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|                # Get index_for_group.
   322|         1|            0|            0|  0.00%|                index_for_group_1 = recipe_index[0]
   323|         0|            0|            0|  0.00%|                index_for_group_2 = recipe_index[1]
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|                # Get wafer_cnt_for_group.
   326|         0|            0|            0|  0.00%|                wafer_cnt_for_group_1 = \
   327|         4|            0|            0|  0.00%|                    sum([ wafer_cnt[i] for i in range(len(wafer_cnt)) if i in index_for_group_1 ])
(call)|         4|            0|            0|  0.00%|# D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\Mix_Run_Ratio.py:327 <listcomp>
   328|         0|            0|            0|  0.00%|                wafer_cnt_for_group_2 = \
   329|         1|            0|            0|  0.00%|                    sum([ wafer_cnt[i] for i in range(len(wafer_cnt)) if i in index_for_group_2 ])
(call)|         1|            0|            0|  0.00%|# D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\Mix_Run_Ratio.py:329 <listcomp>
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|                # Get ratio.
   332|         0|            0|            0|  0.00%|                ratio = wafer_cnt_for_group_1 / wafer_cnt_for_group_2
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|                # Add wafer_cnt_for_group, ratio into pickle.
   335|         2|            0|            0|  0.00%|                pickle.dump(",".join([str(wafer_cnt_for_group_1), str(wafer_cnt_for_group_2), "{:.2f}".format(ratio)]), \
   336|       135|            0|            0|  0.00%|                             pickle_file, pickle.HIGHEST_PROTOCOL)
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|    def pipeline_for_ratio_table(self):
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|        # Judge the amount of jobs.
   344|         0|            0|            0|  0.00%|        SVR_NAME = platform.node()
   345|         0|            0|            0|  0.00%|        sql = \
   346|         0|            0|            0|  0.00%|            """
   347|         0|            0|            0|  0.00%|            SELECT DISTINCT EQP_ID
   348|         0|            0|            0|  0.00%|            FROM MFGDEV3.AUTO_MINE_TOOL_RCP_BT
   349|         0|            0|            0|  0.00%|            WHERE 1 = 1
   350|         0|            0|            0|  0.00%|            AND STATUS = 'Start'
   351|         0|            0|            0|  0.00%|            AND SVR_NAME = '{SVR_NAME}'
   352|         0|            0|            0|  0.00%|            """
   353|         0|            0|            0|  0.00%|        job_number_table = self.db_obj.query(sql = sql.format(SVR_NAME = SVR_NAME))
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\DBSrv5ConnPy\db_object.py:224 query
   354|         0|            0|            0|  0.00%|        job_number = job_number_table.shape[0]
   355|         0|            0|            0|  0.00%|        if job_number >= self.max_job:
   356|         0|            0|            0|  0.00%|            print("I'm so busy right now.")
   357|         0|            0|            0|  0.00%|            return
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|        find_the_target = False
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|        while find_the_target == False:
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|            # Get the first (by CLAIM_TIME) EQP_ID that is \
   365|         0|            0|            0|  0.00%|                # in the "Wait" status and corresponding date.
   366|         0|            0|            0|  0.00%|            sql = \
   367|         0|            0|            0|  0.00%|                """
   368|         0|            0|            0|  0.00%|                SELECT EQP_ID
   369|         0|            0|            0|  0.00%|                FROM MFGDEV3.AUTO_MINE_TOOL_RCP_BT
   370|         0|            0|            0|  0.00%|                WHERE 1 = 1
   371|         0|            0|            0|  0.00%|                AND STATUS = 'Wait'
   372|         0|            0|            0|  0.00%|                AND DATE_TIME = TO_DATE('{today} 00:00:00','YYYY/MM/DD HH24:MI:SS')
   373|         0|            0|            0|  0.00%|                ORDER BY CLAIM_TIME
   374|         0|            0|            0|  0.00%|                """
   375|         0|            0|            0|  0.00%|            target_EQP_ID_table = self.query_5_times( sql.format(today = self.today) )
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|            # Determine that whether or not we have the job needs to do.
   378|         0|            0|            0|  0.00%|            if target_EQP_ID_table.shape[0] == 0:
   379|         0|            0|            0|  0.00%|                print("We don't have any job needs to do.")
   380|         0|            0|            0|  0.00%|                return
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|            ### Insert SVR_NAME and check it after one second. ###
   383|         0|            0|            0|  0.00%|            # Update the single_recipe_table's SVR_NAME.
   384|         0|            0|            0|  0.00%|            EQP_ID = target_EQP_ID_table["EQP_ID"][0]
   385|         0|            0|            0|  0.00%|            sql = \
   386|         0|            0|            0|  0.00%|                """
   387|         0|            0|            0|  0.00%|                UPDATE MFGDEV3.AUTO_MINE_TOOL_RCP_BT
   388|         0|            0|            0|  0.00%|                SET SVR_NAME = '{SVR_NAME}', STATUS = 'Start'
   389|         0|            0|            0|  0.00%|                WHERE 1 = 1
   390|         0|            0|            0|  0.00%|                AND EQP_ID = '{EQP_ID}'
   391|         0|            0|            0|  0.00%|                AND DATE_TIME = TO_DATE('{today} 00:00:00','YYYY/MM/DD HH24:MI:SS')
   392|         0|            0|            0|  0.00%|                """
   393|         0|            0|            0|  0.00%|            self.db_obj.non_query( sql = sql.format(EQP_ID = EQP_ID, \
   394|         0|            0|            0|  0.00%|                                                    today = self.today, \
   395|         0|            0|            0|  0.00%|                                                    SVR_NAME = SVR_NAME) )
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|            # Wait for one second.
   398|         9|            0|            0|  0.00%|            time.sleep(1)
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|            # Get the new SVR_NAME and check if SVR_NAME is the same.
   401|         0|            0|            0|  0.00%|            sql = \
   402|         0|            0|            0|  0.00%|                """
   403|         0|            0|            0|  0.00%|                SELECT SVR_NAME
   404|         0|            0|            0|  0.00%|                FROM MFGDEV3.AUTO_MINE_TOOL_RCP_BT
   405|         0|            0|            0|  0.00%|                WHERE 1 = 1
   406|         0|            0|            0|  0.00%|                AND EQP_ID = '{EQP_ID}'
   407|         0|            0|            0|  0.00%|                AND DATE_TIME = TO_DATE('{today} 00:00:00','YYYY/MM/DD HH24:MI:SS')
   408|         0|            0|            0|  0.00%|                """
   409|         0|            0|            0|  0.00%|            new_SVR_NAME_table = self.query_5_times( sql = sql.format(EQP_ID = EQP_ID, \
   410|         0|            0|            0|  0.00%|                                                                       today = self.today) )
   411|         0|            0|            0|  0.00%|            new_SVR_NAME = new_SVR_NAME_table["SVR_NAME"][0]
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|            # We can store the single_ratio_table.
   414|         0|            0|            0|  0.00%|            if new_SVR_NAME == SVR_NAME:
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|                # Set find_the_target to True.
   417|         0|            0|            0|  0.00%|                find_the_target = True
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|                # Get START_TIME.
   420|         0|            0|            0|  0.00%|                START_TIME = datetime.strptime( datetime.now().strftime("%Y/%m/%d %H:%M:%S"), \
   421|         0|            0|            0|  0.00%|                                                "%Y/%m/%d %H:%M:%S" )
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|                # Get the single_recipe_table's SVR_NAME and check if SVR_NAME is the same.
   424|         0|            0|            0|  0.00%|                sql = \
   425|         0|            0|            0|  0.00%|                    """
   426|         0|            0|            0|  0.00%|                    SELECT EQP_ID, DATE_TIME, RECIPE_ID, WAFER_CNT
   427|         0|            0|            0|  0.00%|                    FROM MFGDEV3.AUTO_MINE_TOOL_RCP_BT
   428|         0|            0|            0|  0.00%|                    WHERE 1 = 1
   429|         0|            0|            0|  0.00%|                    AND EQP_ID = '{EQP_ID}'
   430|         0|            0|            0|  0.00%|                    AND DATE_TIME = TO_DATE('{today} 00:00:00','YYYY/MM/DD HH24:MI:SS')
   431|         0|            0|            0|  0.00%|                    """
   432|         0|            0|            0|  0.00%|                single_recipe_table = self.query_5_times( sql = sql.format(EQP_ID = EQP_ID, \
   433|         0|            0|            0|  0.00%|                                                                           today = self.today) )
(call)|         2|            0|            0|  0.00%|# D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\Mix_Run_Ratio.py:66 query_5_times
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|                # Start storing single_ratio_table.
   436|         0|            0|            0|  0.00%|                print("Start the job with", EQP_ID)
   437|         1|            0|            0|  0.00%|                self.store_single_ratio_table(single_recipe_table)
(call)|       182|            0|            0|  0.00%|# D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\Mix_Run_Ratio.py:275 store_single_ratio_table
   438|         0|            0|            0|  0.00%|                print("Finish the job with", EQP_ID)
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|                # Get END_TIME.
   441|         0|            0|            0|  0.00%|                END_TIME = datetime.strptime( datetime.now().strftime("%Y/%m/%d %H:%M:%S"), \
   442|         0|            0|            0|  0.00%|                                              "%Y/%m/%d %H:%M:%S" )
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|                # Update START_TIME, END_TIME and STATUS.
   445|         0|            0|            0|  0.00%|                sql = \
   446|         0|            0|            0|  0.00%|                    """
   447|         0|            0|            0|  0.00%|                    UPDATE MFGDEV3.AUTO_MINE_TOOL_RCP_BT
   448|         0|            0|            0|  0.00%|                    SET
   449|         0|            0|            0|  0.00%|                    START_TIME = TO_DATE('{START_TIME}','YYYY/MM/DD HH24:MI:SS'),
   450|         0|            0|            0|  0.00%|                    END_TIME = TO_DATE('{END_TIME}','YYYY/MM/DD HH24:MI:SS'),
   451|         0|            0|            0|  0.00%|                    STATUS = 'Done'
   452|         0|            0|            0|  0.00%|                    WHERE 1 = 1
   453|         0|            0|            0|  0.00%|                    AND EQP_ID = '{EQP_ID}'
   454|         0|            0|            0|  0.00%|                    AND DATE_TIME = TO_DATE('{today} 00:00:00','YYYY/MM/DD HH24:MI:SS')
   455|         0|            0|            0|  0.00%|                    """
   456|         0|            0|            0|  0.00%|                self.db_obj.non_query( sql = sql.format(EQP_ID = EQP_ID, \
   457|         0|            0|            0|  0.00%|                                                        today = self.today, \
   458|         0|            0|            0|  0.00%|                                                        START_TIME = START_TIME, \
   459|         0|            0|            0|  0.00%|                                                        END_TIME = END_TIME) )
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|            # We need to find a new EQP_ID's single_recipe_table.
   462|         0|            0|            0|  0.00%|            else:
   463|         0|            0|            0|  0.00%|                print("My job is stolen by:", new_SVR_NAME)
   464|         0|            0|            0|  0.00%|                pass
File: D:\Application\Anaconda\lib\site-packages\zmq\sugar\socket.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# coding: utf-8
     2|         0|            0|            0|  0.00%|"""0MQ Socket pure Python methods."""
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|# Copyright (C) PyZMQ Developers
     5|         0|            0|            0|  0.00%|# Distributed under the terms of the Modified BSD License.
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|import errno
     9|         0|            0|            0|  0.00%|import random
    10|         0|            0|            0|  0.00%|import sys
    11|         0|            0|            0|  0.00%|import warnings
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|import zmq
    14|         0|            0|            0|  0.00%|from zmq.backend import Socket as SocketBase
    15|         0|            0|            0|  0.00%|from .poll import Poller
    16|         0|            0|            0|  0.00%|from . import constants
    17|         0|            0|            0|  0.00%|from .attrsettr import AttributeSetter
    18|         0|            0|            0|  0.00%|from zmq.error import ZMQError, ZMQBindError
    19|         0|            0|            0|  0.00%|from zmq.utils import jsonapi
    20|         0|            0|            0|  0.00%|from zmq.utils.strtypes import bytes, unicode, basestring
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|from .constants import (
    24|         0|            0|            0|  0.00%|    SNDMORE, ENOTSUP, POLLIN,
    25|         0|            0|            0|  0.00%|    int64_sockopt_names,
    26|         0|            0|            0|  0.00%|    int_sockopt_names,
    27|         0|            0|            0|  0.00%|    bytes_sockopt_names,
    28|         0|            0|            0|  0.00%|    fd_sockopt_names,
    29|         0|            0|            0|  0.00%|)
    30|         0|            0|            0|  0.00%|try:
    31|         0|            0|            0|  0.00%|    import cPickle
    32|         0|            0|            0|  0.00%|    pickle = cPickle
    33|         0|            0|            0|  0.00%|except:
    34|         0|            0|            0|  0.00%|    cPickle = None
    35|         0|            0|            0|  0.00%|    import pickle
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|try:
    38|         0|            0|            0|  0.00%|    DEFAULT_PROTOCOL = pickle.DEFAULT_PROTOCOL
    39|         0|            0|            0|  0.00%|except AttributeError:
    40|         0|            0|            0|  0.00%|    DEFAULT_PROTOCOL = pickle.HIGHEST_PROTOCOL
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|class Socket(SocketBase, AttributeSetter):
    44|         0|            0|            0|  0.00%|    """The ZMQ socket object
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|    To create a Socket, first create a Context::
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|        ctx = zmq.Context.instance()
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|    then call ``ctx.socket(socket_type)``::
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|        s = ctx.socket(zmq.ROUTER)
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|    """
    55|         0|            0|            0|  0.00%|    _shadow = False
    56|         0|            0|            0|  0.00%|    _monitor_socket = None
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|    def __init__(self, *a, **kw):
    59|         0|            0|            0|  0.00%|        super(Socket, self).__init__(*a, **kw)
    60|         0|            0|            0|  0.00%|        if 'shadow' in kw:
    61|         0|            0|            0|  0.00%|            self._shadow = True
    62|         0|            0|            0|  0.00%|        else:
    63|         0|            0|            0|  0.00%|            self._shadow = False
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    def __del__(self):
    66|         0|            0|            0|  0.00%|        if not self._shadow:
    67|         0|            0|            0|  0.00%|            self.close()
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|    # socket as context manager:
    70|         0|            0|            0|  0.00%|    def __enter__(self):
    71|         0|            0|            0|  0.00%|        """Sockets are context managers
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|        .. versionadded:: 14.4
    74|         0|            0|            0|  0.00%|        """
    75|         0|            0|            0|  0.00%|        return self
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|    def __exit__(self, *args, **kwargs):
    78|         0|            0|            0|  0.00%|        self.close()
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
    81|         0|            0|            0|  0.00%|    # Socket creation
    82|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|    def __copy__(self, memo=None):
    85|         0|            0|            0|  0.00%|        """Copying a Socket creates a shadow copy"""
    86|         0|            0|            0|  0.00%|        return self.__class__.shadow(self.underlying)
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|    __deepcopy__ = __copy__
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|    @classmethod
    91|         0|            0|            0|  0.00%|    def shadow(cls, address):
    92|         0|            0|            0|  0.00%|        """Shadow an existing libzmq socket
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|        address is the integer address of the libzmq socket
    95|         0|            0|            0|  0.00%|        or an FFI pointer to it.
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|        .. versionadded:: 14.1
    98|         0|            0|            0|  0.00%|        """
    99|         0|            0|            0|  0.00%|        from zmq.utils.interop import cast_int_addr
   100|         0|            0|            0|  0.00%|        address = cast_int_addr(address)
   101|         0|            0|            0|  0.00%|        return cls(shadow=address)
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|    def close(self, linger=None):
   104|         0|            0|            0|  0.00%|        if self.context:
   105|         0|            0|            0|  0.00%|            self.context._rm_socket(self)
   106|         0|            0|            0|  0.00%|        super(Socket, self).close(linger=linger)
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   109|         0|            0|            0|  0.00%|    # Deprecated aliases
   110|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|    @property
   113|         0|            0|            0|  0.00%|    def socket_type(self):
   114|         0|            0|            0|  0.00%|        warnings.warn("Socket.socket_type is deprecated, use Socket.type",
   115|         0|            0|            0|  0.00%|            DeprecationWarning
   116|         0|            0|            0|  0.00%|        )
   117|         0|            0|            0|  0.00%|        return self.type
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   120|         0|            0|            0|  0.00%|    # Hooks for sockopt completion
   121|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|    def __dir__(self):
   124|         0|            0|            0|  0.00%|        keys = dir(self.__class__)
   125|         0|            0|            0|  0.00%|        for collection in (
   126|         0|            0|            0|  0.00%|            bytes_sockopt_names,
   127|         0|            0|            0|  0.00%|            int_sockopt_names,
   128|         0|            0|            0|  0.00%|            int64_sockopt_names,
   129|         0|            0|            0|  0.00%|            fd_sockopt_names,
   130|         0|            0|            0|  0.00%|        ):
   131|         0|            0|            0|  0.00%|            keys.extend(collection)
   132|         0|            0|            0|  0.00%|        return keys
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   135|         0|            0|            0|  0.00%|    # Getting/Setting options
   136|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   137|         0|            0|            0|  0.00%|    setsockopt = SocketBase.set
   138|         0|            0|            0|  0.00%|    getsockopt = SocketBase.get
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|    def __setattr__(self, key, value):
   141|         0|            0|            0|  0.00%|        """Override to allow setting zmq.[UN]SUBSCRIBE even though we have a subscribe method"""
   142|         0|            0|            0|  0.00%|        if key in self.__dict__:
   143|         0|            0|            0|  0.00%|            object.__setattr__(self, key, value)
   144|         0|            0|            0|  0.00%|            return
   145|         0|            0|            0|  0.00%|        _key = key.lower()
   146|         0|            0|            0|  0.00%|        if _key in ('subscribe', 'unsubscribe'):
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|            if isinstance(value, unicode):
   149|         0|            0|            0|  0.00%|                value = value.encode('utf8')
   150|         0|            0|            0|  0.00%|            if _key == 'subscribe':
   151|         0|            0|            0|  0.00%|                self.set(zmq.SUBSCRIBE, value)
   152|         0|            0|            0|  0.00%|            else:
   153|         0|            0|            0|  0.00%|                self.set(zmq.UNSUBSCRIBE, value)
   154|         0|            0|            0|  0.00%|            return
   155|         0|            0|            0|  0.00%|        super(Socket, self).__setattr__(key, value)
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|    def fileno(self):
   158|         0|            0|            0|  0.00%|        """Return edge-triggered file descriptor for this socket.
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|        This is a read-only edge-triggered file descriptor for both read and write events on this socket.
   161|         0|            0|            0|  0.00%|        It is important that all available events be consumed when an event is detected,
   162|         0|            0|            0|  0.00%|        otherwise the read event will not trigger again.
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|        .. versionadded:: 17.0
   165|         0|            0|            0|  0.00%|        """
   166|         0|            0|            0|  0.00%|        return self.FD
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|    def subscribe(self, topic):
   169|         0|            0|            0|  0.00%|        """Subscribe to a topic
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|        Only for SUB sockets.
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|        .. versionadded:: 15.3
   174|         0|            0|            0|  0.00%|        """
   175|         0|            0|            0|  0.00%|        if isinstance(topic, unicode):
   176|         0|            0|            0|  0.00%|            topic = topic.encode('utf8')
   177|         0|            0|            0|  0.00%|        self.set(zmq.SUBSCRIBE, topic)
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|    def unsubscribe(self, topic):
   180|         0|            0|            0|  0.00%|        """Unsubscribe from a topic
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|        Only for SUB sockets.
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|        .. versionadded:: 15.3
   185|         0|            0|            0|  0.00%|        """
   186|         0|            0|            0|  0.00%|        if isinstance(topic, unicode):
   187|         0|            0|            0|  0.00%|            topic = topic.encode('utf8')
   188|         0|            0|            0|  0.00%|        self.set(zmq.UNSUBSCRIBE, topic)
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|    def set_string(self, option, optval, encoding='utf-8'):
   191|         0|            0|            0|  0.00%|        """Set socket options with a unicode object.
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|        This is simply a wrapper for setsockopt to protect from encoding ambiguity.
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|        See the 0MQ documentation for details on specific options.
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|        Parameters
   198|         0|            0|            0|  0.00%|        ----------
   199|         0|            0|            0|  0.00%|        option : int
   200|         0|            0|            0|  0.00%|            The name of the option to set. Can be any of: SUBSCRIBE,
   201|         0|            0|            0|  0.00%|            UNSUBSCRIBE, IDENTITY
   202|         0|            0|            0|  0.00%|        optval : unicode string (unicode on py2, str on py3)
   203|         0|            0|            0|  0.00%|            The value of the option to set.
   204|         0|            0|            0|  0.00%|        encoding : str
   205|         0|            0|            0|  0.00%|            The encoding to be used, default is utf8
   206|         0|            0|            0|  0.00%|        """
   207|         0|            0|            0|  0.00%|        if not isinstance(optval, unicode):
   208|         0|            0|            0|  0.00%|            raise TypeError("unicode strings only")
   209|         0|            0|            0|  0.00%|        return self.set(option, optval.encode(encoding))
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|    setsockopt_unicode = setsockopt_string = set_string
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|    def get_string(self, option, encoding='utf-8'):
   214|         0|            0|            0|  0.00%|        """Get the value of a socket option.
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|        See the 0MQ documentation for details on specific options.
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|        Parameters
   219|         0|            0|            0|  0.00%|        ----------
   220|         0|            0|            0|  0.00%|        option : int
   221|         0|            0|            0|  0.00%|            The option to retrieve.
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|        Returns
   224|         0|            0|            0|  0.00%|        -------
   225|         0|            0|            0|  0.00%|        optval : unicode string (unicode on py2, str on py3)
   226|         0|            0|            0|  0.00%|            The value of the option as a unicode string.
   227|         0|            0|            0|  0.00%|        """
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|        if option not in constants.bytes_sockopts:
   230|         0|            0|            0|  0.00%|            raise TypeError("option %i will not return a string to be decoded"%option)
   231|         0|            0|            0|  0.00%|        return self.getsockopt(option).decode(encoding)
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|    getsockopt_unicode = getsockopt_string = get_string
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|    def bind_to_random_port(self, addr, min_port=49152, max_port=65536, max_tries=100):
   236|         0|            0|            0|  0.00%|        """Bind this socket to a random port in a range.
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|        If the port range is unspecified, the system will choose the port.
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|        Parameters
   241|         0|            0|            0|  0.00%|        ----------
   242|         0|            0|            0|  0.00%|        addr : str
   243|         0|            0|            0|  0.00%|            The address string without the port to pass to ``Socket.bind()``.
   244|         0|            0|            0|  0.00%|        min_port : int, optional
   245|         0|            0|            0|  0.00%|            The minimum port in the range of ports to try (inclusive).
   246|         0|            0|            0|  0.00%|        max_port : int, optional
   247|         0|            0|            0|  0.00%|            The maximum port in the range of ports to try (exclusive).
   248|         0|            0|            0|  0.00%|        max_tries : int, optional
   249|         0|            0|            0|  0.00%|            The maximum number of bind attempts to make.
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|        Returns
   252|         0|            0|            0|  0.00%|        -------
   253|         0|            0|            0|  0.00%|        port : int
   254|         0|            0|            0|  0.00%|            The port the socket was bound to.
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|        Raises
   257|         0|            0|            0|  0.00%|        ------
   258|         0|            0|            0|  0.00%|        ZMQBindError
   259|         0|            0|            0|  0.00%|            if `max_tries` reached before successful bind
   260|         0|            0|            0|  0.00%|        """
   261|         0|            0|            0|  0.00%|        if hasattr(constants, 'LAST_ENDPOINT') and min_port == 49152 and max_port == 65536:
   262|         0|            0|            0|  0.00%|            # if LAST_ENDPOINT is supported, and min_port / max_port weren't specified,
   263|         0|            0|            0|  0.00%|            # we can bind to port 0 and let the OS do the work
   264|         0|            0|            0|  0.00%|            self.bind("%s:*" % addr)
   265|         0|            0|            0|  0.00%|            url = self.last_endpoint.decode('ascii', 'replace')
   266|         0|            0|            0|  0.00%|            _, port_s = url.rsplit(':', 1)
   267|         0|            0|            0|  0.00%|            return int(port_s)
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|        for i in range(max_tries):
   270|         0|            0|            0|  0.00%|            try:
   271|         0|            0|            0|  0.00%|                port = random.randrange(min_port, max_port)
   272|         0|            0|            0|  0.00%|                self.bind('%s:%s' % (addr, port))
   273|         0|            0|            0|  0.00%|            except ZMQError as exception:
   274|         0|            0|            0|  0.00%|                en = exception.errno
   275|         0|            0|            0|  0.00%|                if en == zmq.EADDRINUSE:
   276|         0|            0|            0|  0.00%|                    continue
   277|         0|            0|            0|  0.00%|                elif sys.platform == 'win32' and en == errno.EACCES:
   278|         0|            0|            0|  0.00%|                    continue
   279|         0|            0|            0|  0.00%|                else:
   280|         0|            0|            0|  0.00%|                    raise
   281|         0|            0|            0|  0.00%|            else:
   282|         0|            0|            0|  0.00%|                return port
   283|         0|            0|            0|  0.00%|        raise ZMQBindError("Could not bind socket to random port.")
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|    def get_hwm(self):
   286|         0|            0|            0|  0.00%|        """Get the High Water Mark.
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|        On libzmq ? 3, this gets SNDHWM if available, otherwise RCVHWM
   289|         0|            0|            0|  0.00%|        """
   290|         0|            0|            0|  0.00%|        major = zmq.zmq_version_info()[0]
   291|         0|            0|            0|  0.00%|        if major >= 3:
   292|         0|            0|            0|  0.00%|            # return sndhwm, fallback on rcvhwm
   293|         0|            0|            0|  0.00%|            try:
   294|         0|            0|            0|  0.00%|                return self.getsockopt(zmq.SNDHWM)
   295|         0|            0|            0|  0.00%|            except zmq.ZMQError:
   296|         0|            0|            0|  0.00%|                pass
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|            return self.getsockopt(zmq.RCVHWM)
   299|         0|            0|            0|  0.00%|        else:
   300|         0|            0|            0|  0.00%|            return self.getsockopt(zmq.HWM)
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|    def set_hwm(self, value):
   303|         0|            0|            0|  0.00%|        """Set the High Water Mark.
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|        On libzmq ? 3, this sets both SNDHWM and RCVHWM
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|        .. warning::
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|            New values only take effect for subsequent socket
   311|         0|            0|            0|  0.00%|            bind/connects.
   312|         0|            0|            0|  0.00%|        """
   313|         0|            0|            0|  0.00%|        major = zmq.zmq_version_info()[0]
   314|         0|            0|            0|  0.00%|        if major >= 3:
   315|         0|            0|            0|  0.00%|            raised = None
   316|         0|            0|            0|  0.00%|            try:
   317|         0|            0|            0|  0.00%|                self.sndhwm = value
   318|         0|            0|            0|  0.00%|            except Exception as e:
   319|         0|            0|            0|  0.00%|                raised = e
   320|         0|            0|            0|  0.00%|            try:
   321|         0|            0|            0|  0.00%|                self.rcvhwm = value
   322|         0|            0|            0|  0.00%|            except Exception as e:
   323|         0|            0|            0|  0.00%|                raised = e
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|            if raised:
   326|         0|            0|            0|  0.00%|                raise raised
   327|         0|            0|            0|  0.00%|        else:
   328|         0|            0|            0|  0.00%|            return self.setsockopt(zmq.HWM, value)
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|    hwm = property(get_hwm, set_hwm,
   331|         0|            0|            0|  0.00%|        """Property for High Water Mark.
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|        Setting hwm sets both SNDHWM and RCVHWM as appropriate.
   334|         0|            0|            0|  0.00%|        It gets SNDHWM if available, otherwise RCVHWM.
   335|         0|            0|            0|  0.00%|        """
   336|         0|            0|            0|  0.00%|    )
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   339|         0|            0|            0|  0.00%|    # Sending and receiving messages
   340|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|    def send(self, data, flags=0, copy=True, track=False, routing_id=None, group=None):
   343|         0|            0|            0|  0.00%|        """Send a single zmq message frame on this socket.
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|        This queues the message to be sent by the IO thread at a later time.
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|        With flags=NOBLOCK, this raises :class:`ZMQError` if the queue is full;
   348|         0|            0|            0|  0.00%|        otherwise, this waits until space is available.
   349|         0|            0|            0|  0.00%|        See :class:`Poller` for more general non-blocking I/O.
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|        Parameters
   352|         0|            0|            0|  0.00%|        ----------
   353|         0|            0|            0|  0.00%|        data : bytes, Frame, memoryview
   354|         0|            0|            0|  0.00%|            The content of the message. This can be any object that provides
   355|         0|            0|            0|  0.00%|            the Python buffer API (i.e. `memoryview(data)` can be called).
   356|         0|            0|            0|  0.00%|        flags : int
   357|         0|            0|            0|  0.00%|            0, NOBLOCK, SNDMORE, or NOBLOCK|SNDMORE.
   358|         0|            0|            0|  0.00%|        copy : bool
   359|         0|            0|            0|  0.00%|            Should the message be sent in a copying or non-copying manner.
   360|         0|            0|            0|  0.00%|        track : bool
   361|         0|            0|            0|  0.00%|            Should the message be tracked for notification that ZMQ has
   362|         0|            0|            0|  0.00%|            finished with it? (ignored if copy=True)
   363|         0|            0|            0|  0.00%|        routing_id : int
   364|         0|            0|            0|  0.00%|            For use with SERVER sockets
   365|         0|            0|            0|  0.00%|        group : str
   366|         0|            0|            0|  0.00%|            For use with RADIO sockets
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|        Returns
   369|         0|            0|            0|  0.00%|        -------
   370|         0|            0|            0|  0.00%|        None : if `copy` or not track
   371|         0|            0|            0|  0.00%|            None if message was sent, raises an exception otherwise.
   372|         0|            0|            0|  0.00%|        MessageTracker : if track and not copy
   373|         0|            0|            0|  0.00%|            a MessageTracker object, whose `pending` property will
   374|         0|            0|            0|  0.00%|            be True until the send is completed.
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|        Raises
   377|         0|            0|            0|  0.00%|        ------
   378|         0|            0|            0|  0.00%|        TypeError
   379|         0|            0|            0|  0.00%|            If a unicode object is passed
   380|         0|            0|            0|  0.00%|        ValueError
   381|         0|            0|            0|  0.00%|            If `track=True`, but an untracked Frame is passed.
   382|         0|            0|            0|  0.00%|        ZMQError
   383|         0|            0|            0|  0.00%|            If the send does not succeed for any reason (including
   384|         0|            0|            0|  0.00%|            if NOBLOCK is set and the outgoing queue is full).
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|        .. versionchanged:: 17.0
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|            DRAFT support for routing_id and group arguments.
   389|         0|            0|            0|  0.00%|        """
   390|         0|            0|            0|  0.00%|        if routing_id is not None:
   391|         0|            0|            0|  0.00%|            if not isinstance(data, zmq.Frame):
   392|         0|            0|            0|  0.00%|                data = zmq.Frame(data, track=track, copy=copy or None,
   393|         0|            0|            0|  0.00%|                                 copy_threshold=self.copy_threshold)
   394|         0|            0|            0|  0.00%|            data.routing_id = routing_id
   395|         0|            0|            0|  0.00%|        if group is not None:
   396|         0|            0|            0|  0.00%|            if not isinstance(data, zmq.Frame):
   397|         0|            0|            0|  0.00%|                data = zmq.Frame(data, track=track, copy=copy or None,
   398|         0|            0|            0|  0.00%|                                 copy_threshold=self.copy_threshold)
   399|         0|            0|            0|  0.00%|            data.group = group
   400|         8|            0|            0|  0.00%|        return super(Socket, self).send(data, flags=flags, copy=copy, track=track)
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|    def send_multipart(self, msg_parts, flags=0, copy=True, track=False, **kwargs):
   403|         0|            0|            0|  0.00%|        """Send a sequence of buffers as a multipart message.
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|        The zmq.SNDMORE flag is added to all msg parts before the last.
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|        Parameters
   408|         0|            0|            0|  0.00%|        ----------
   409|         0|            0|            0|  0.00%|        msg_parts : iterable
   410|         0|            0|            0|  0.00%|            A sequence of objects to send as a multipart message. Each element
   411|         0|            0|            0|  0.00%|            can be any sendable object (Frame, bytes, buffer-providers)
   412|         0|            0|            0|  0.00%|        flags : int, optional
   413|         0|            0|            0|  0.00%|            Any valid flags for :func:`Socket.send`.
   414|         0|            0|            0|  0.00%|            SNDMORE is added automatically for frames before the last.
   415|         0|            0|            0|  0.00%|        copy : bool, optional
   416|         0|            0|            0|  0.00%|            Should the frame(s) be sent in a copying or non-copying manner.
   417|         0|            0|            0|  0.00%|            If copy=False, frames smaller than self.copy_threshold bytes
   418|         0|            0|            0|  0.00%|            will be copied anyway.
   419|         0|            0|            0|  0.00%|        track : bool, optional
   420|         0|            0|            0|  0.00%|            Should the frame(s) be tracked for notification that ZMQ has
   421|         0|            0|            0|  0.00%|            finished with it (ignored if copy=True).
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|        Returns
   424|         0|            0|            0|  0.00%|        -------
   425|         0|            0|            0|  0.00%|        None : if copy or not track
   426|         0|            0|            0|  0.00%|        MessageTracker : if track and not copy
   427|         0|            0|            0|  0.00%|            a MessageTracker object, whose `pending` property will
   428|         0|            0|            0|  0.00%|            be True until the last send is completed.
   429|         0|            0|            0|  0.00%|        """
   430|         0|            0|            0|  0.00%|        # typecheck parts before sending:
   431|         0|            0|            0|  0.00%|        for i,msg in enumerate(msg_parts):
   432|         0|            0|            0|  0.00%|            if isinstance(msg, (zmq.Frame, bytes, memoryview)):
   433|         0|            0|            0|  0.00%|                continue
   434|         0|            0|            0|  0.00%|            try:
   435|         0|            0|            0|  0.00%|                memoryview(msg)
   436|         0|            0|            0|  0.00%|            except Exception:
   437|         0|            0|            0|  0.00%|                rmsg = repr(msg)
   438|         0|            0|            0|  0.00%|                if len(rmsg) > 32:
   439|         0|            0|            0|  0.00%|                    rmsg = rmsg[:32] + '...'
   440|         0|            0|            0|  0.00%|                raise TypeError(
   441|         0|            0|            0|  0.00%|                    "Frame %i (%s) does not support the buffer interface." % (
   442|         0|            0|            0|  0.00%|                    i, rmsg,
   443|         0|            0|            0|  0.00%|                ))
   444|         0|            0|            0|  0.00%|        for msg in msg_parts[:-1]:
   445|         0|            0|            0|  0.00%|            self.send(msg, SNDMORE|flags, copy=copy, track=track)
   446|         0|            0|            0|  0.00%|        # Send the last part without the extra SNDMORE flag.
   447|         0|            0|            0|  0.00%|        return self.send(msg_parts[-1], flags, copy=copy, track=track)
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|    def recv_multipart(self, flags=0, copy=True, track=False):
   450|         0|            0|            0|  0.00%|        """Receive a multipart message as a list of bytes or Frame objects
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|        Parameters
   453|         0|            0|            0|  0.00%|        ----------
   454|         0|            0|            0|  0.00%|        flags : int, optional
   455|         0|            0|            0|  0.00%|            Any valid flags for :func:`Socket.recv`.
   456|         0|            0|            0|  0.00%|        copy : bool, optional
   457|         0|            0|            0|  0.00%|            Should the message frame(s) be received in a copying or non-copying manner?
   458|         0|            0|            0|  0.00%|            If False a Frame object is returned for each part, if True a copy of
   459|         0|            0|            0|  0.00%|            the bytes is made for each frame.
   460|         0|            0|            0|  0.00%|        track : bool, optional
   461|         0|            0|            0|  0.00%|            Should the message frame(s) be tracked for notification that ZMQ has
   462|         0|            0|            0|  0.00%|            finished with it? (ignored if copy=True)
   463|         0|            0|            0|  0.00%|
   464|         0|            0|            0|  0.00%|        Returns
   465|         0|            0|            0|  0.00%|        -------
   466|         0|            0|            0|  0.00%|        msg_parts : list
   467|         0|            0|            0|  0.00%|            A list of frames in the multipart message; either Frames or bytes,
   468|         0|            0|            0|  0.00%|            depending on `copy`.
   469|         0|            0|            0|  0.00%|
   470|         0|            0|            0|  0.00%|        Raises
   471|         0|            0|            0|  0.00%|        ------
   472|         0|            0|            0|  0.00%|        ZMQError
   473|         0|            0|            0|  0.00%|            for any of the reasons :func:`~Socket.recv` might fail
   474|         0|            0|            0|  0.00%|        """
   475|         0|            0|            0|  0.00%|        parts = [self.recv(flags, copy=copy, track=track)]
   476|         0|            0|            0|  0.00%|        # have first part already, only loop while more to receive
   477|         0|            0|            0|  0.00%|        while self.getsockopt(zmq.RCVMORE):
   478|         0|            0|            0|  0.00%|            part = self.recv(flags, copy=copy, track=track)
   479|         0|            0|            0|  0.00%|            parts.append(part)
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|        return parts
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|    def _deserialize(self, recvd, load):
   484|         0|            0|            0|  0.00%|        """Deserialize a received message
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|        Override in subclass (e.g. Futures) if recvd is not the raw bytes.
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|        The default implementation expects bytes and returns the deserialized message immediately.
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|        Parameters
   491|         0|            0|            0|  0.00%|        ----------
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|        load: callable
   494|         0|            0|            0|  0.00%|            Callable that deserializes bytes
   495|         0|            0|            0|  0.00%|        recvd:
   496|         0|            0|            0|  0.00%|            The object returned by self.recv
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|        """
   499|         0|            0|            0|  0.00%|        return load(recvd)
   500|         0|            0|            0|  0.00%|
   501|         0|            0|            0|  0.00%|    def send_serialized(self, msg, serialize, flags=0, copy=True, **kwargs):
   502|         0|            0|            0|  0.00%|        """Send a message with a custom serialization function.
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|        .. versionadded:: 17
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|        Parameters
   507|         0|            0|            0|  0.00%|        ----------
   508|         0|            0|            0|  0.00%|        msg : The message to be sent. Can be any object serializable by `serialize`.
   509|         0|            0|            0|  0.00%|        serialize : callable
   510|         0|            0|            0|  0.00%|            The serialization function to use.
   511|         0|            0|            0|  0.00%|            serialize(msg) should return an iterable of sendable message frames
   512|         0|            0|            0|  0.00%|            (e.g. bytes objects), which will be passed to send_multipart.
   513|         0|            0|            0|  0.00%|        flags : int, optional
   514|         0|            0|            0|  0.00%|            Any valid flags for :func:`Socket.send`.
   515|         0|            0|            0|  0.00%|        copy : bool, optional
   516|         0|            0|            0|  0.00%|            Whether to copy the frames.
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|        """
   519|         0|            0|            0|  0.00%|        frames = serialize(msg)
   520|         0|            0|            0|  0.00%|        return self.send_multipart(frames, flags=flags, copy=copy, **kwargs)
   521|         0|            0|            0|  0.00%|
   522|         0|            0|            0|  0.00%|    def recv_serialized(self, deserialize, flags=0, copy=True):
   523|         0|            0|            0|  0.00%|        """Receive a message with a custom deserialization function.
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|        .. versionadded:: 17
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|        Parameters
   528|         0|            0|            0|  0.00%|        ----------
   529|         0|            0|            0|  0.00%|        deserialize : callable
   530|         0|            0|            0|  0.00%|            The deserialization function to use.
   531|         0|            0|            0|  0.00%|            deserialize will be called with one argument: the list of frames
   532|         0|            0|            0|  0.00%|            returned by recv_multipart() and can return any object.
   533|         0|            0|            0|  0.00%|        flags : int, optional
   534|         0|            0|            0|  0.00%|            Any valid flags for :func:`Socket.recv`.
   535|         0|            0|            0|  0.00%|        copy : bool, optional
   536|         0|            0|            0|  0.00%|            Whether to recv bytes or Frame objects.
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|        Returns
   539|         0|            0|            0|  0.00%|        -------
   540|         0|            0|            0|  0.00%|        obj : object
   541|         0|            0|            0|  0.00%|            The object returned by the deserialization function.
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|        Raises
   544|         0|            0|            0|  0.00%|        ------
   545|         0|            0|            0|  0.00%|        ZMQError
   546|         0|            0|            0|  0.00%|            for any of the reasons :func:`~Socket.recv` might fail
   547|         0|            0|            0|  0.00%|        """
   548|         0|            0|            0|  0.00%|        frames = self.recv_multipart(flags=flags, copy=copy)
   549|         0|            0|            0|  0.00%|        return self._deserialize(frames, deserialize)
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|    def send_string(self, u, flags=0, copy=True, encoding='utf-8', **kwargs):
   552|         0|            0|            0|  0.00%|        """Send a Python unicode string as a message with an encoding.
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|        0MQ communicates with raw bytes, so you must encode/decode
   555|         0|            0|            0|  0.00%|        text (unicode on py2, str on py3) around 0MQ.
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|        Parameters
   558|         0|            0|            0|  0.00%|        ----------
   559|         0|            0|            0|  0.00%|        u : Python unicode string (unicode on py2, str on py3)
   560|         0|            0|            0|  0.00%|            The unicode string to send.
   561|         0|            0|            0|  0.00%|        flags : int, optional
   562|         0|            0|            0|  0.00%|            Any valid flags for :func:`Socket.send`.
   563|         0|            0|            0|  0.00%|        encoding : str [default: 'utf-8']
   564|         0|            0|            0|  0.00%|            The encoding to be used
   565|         0|            0|            0|  0.00%|        """
   566|         0|            0|            0|  0.00%|        if not isinstance(u, basestring):
   567|         0|            0|            0|  0.00%|            raise TypeError("unicode/str objects only")
   568|         0|            0|            0|  0.00%|        return self.send(u.encode(encoding), flags=flags, copy=copy, **kwargs)
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|    send_unicode = send_string
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|    def recv_string(self, flags=0, encoding='utf-8'):
   573|         0|            0|            0|  0.00%|        """Receive a unicode string, as sent by send_string.
   574|         0|            0|            0|  0.00%|
   575|         0|            0|            0|  0.00%|        Parameters
   576|         0|            0|            0|  0.00%|        ----------
   577|         0|            0|            0|  0.00%|        flags : int
   578|         0|            0|            0|  0.00%|            Any valid flags for :func:`Socket.recv`.
   579|         0|            0|            0|  0.00%|        encoding : str [default: 'utf-8']
   580|         0|            0|            0|  0.00%|            The encoding to be used
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|        Returns
   583|         0|            0|            0|  0.00%|        -------
   584|         0|            0|            0|  0.00%|        s : unicode string (unicode on py2, str on py3)
   585|         0|            0|            0|  0.00%|            The Python unicode string that arrives as encoded bytes.
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|        Raises
   588|         0|            0|            0|  0.00%|        ------
   589|         0|            0|            0|  0.00%|        ZMQError
   590|         0|            0|            0|  0.00%|            for any of the reasons :func:`~Socket.recv` might fail
   591|         0|            0|            0|  0.00%|        """
   592|         0|            0|            0|  0.00%|        msg = self.recv(flags=flags)
   593|         0|            0|            0|  0.00%|        return self._deserialize(msg, lambda buf: buf.decode(encoding))
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|    recv_unicode = recv_string
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|    def send_pyobj(self, obj, flags=0, protocol=DEFAULT_PROTOCOL, **kwargs):
   598|         0|            0|            0|  0.00%|        """Send a Python object as a message using pickle to serialize.
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|        Parameters
   601|         0|            0|            0|  0.00%|        ----------
   602|         0|            0|            0|  0.00%|        obj : Python object
   603|         0|            0|            0|  0.00%|            The Python object to send.
   604|         0|            0|            0|  0.00%|        flags : int
   605|         0|            0|            0|  0.00%|            Any valid flags for :func:`Socket.send`.
   606|         0|            0|            0|  0.00%|        protocol : int
   607|         0|            0|            0|  0.00%|            The pickle protocol number to use. The default is pickle.DEFAULT_PROTOCOL
   608|         0|            0|            0|  0.00%|            where defined, and pickle.HIGHEST_PROTOCOL elsewhere.
   609|         0|            0|            0|  0.00%|        """
   610|         0|            0|            0|  0.00%|        msg = pickle.dumps(obj, protocol)
   611|         0|            0|            0|  0.00%|        return self.send(msg, flags=flags, **kwargs)
   612|         0|            0|            0|  0.00%|
   613|         0|            0|            0|  0.00%|    def recv_pyobj(self, flags=0):
   614|         0|            0|            0|  0.00%|        """Receive a Python object as a message using pickle to serialize.
   615|         0|            0|            0|  0.00%|
   616|         0|            0|            0|  0.00%|        Parameters
   617|         0|            0|            0|  0.00%|        ----------
   618|         0|            0|            0|  0.00%|        flags : int
   619|         0|            0|            0|  0.00%|            Any valid flags for :func:`Socket.recv`.
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|        Returns
   622|         0|            0|            0|  0.00%|        -------
   623|         0|            0|            0|  0.00%|        obj : Python object
   624|         0|            0|            0|  0.00%|            The Python object that arrives as a message.
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|        Raises
   627|         0|            0|            0|  0.00%|        ------
   628|         0|            0|            0|  0.00%|        ZMQError
   629|         0|            0|            0|  0.00%|            for any of the reasons :func:`~Socket.recv` might fail
   630|         0|            0|            0|  0.00%|        """
   631|         0|            0|            0|  0.00%|        msg = self.recv(flags)
   632|         0|            0|            0|  0.00%|        return self._deserialize(msg, pickle.loads)
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|    def send_json(self, obj, flags=0, **kwargs):
   635|         0|            0|            0|  0.00%|        """Send a Python object as a message using json to serialize.
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|        Keyword arguments are passed on to json.dumps
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|        Parameters
   640|         0|            0|            0|  0.00%|        ----------
   641|         0|            0|            0|  0.00%|        obj : Python object
   642|         0|            0|            0|  0.00%|            The Python object to send
   643|         0|            0|            0|  0.00%|        flags : int
   644|         0|            0|            0|  0.00%|            Any valid flags for :func:`Socket.send`
   645|         0|            0|            0|  0.00%|        """
   646|         0|            0|            0|  0.00%|        send_kwargs = {}
   647|         0|            0|            0|  0.00%|        for key in ('routing_id', 'group'):
   648|         0|            0|            0|  0.00%|            if key in kwargs:
   649|         0|            0|            0|  0.00%|                send_kwargs[key] = kwargs.pop(key)
   650|         0|            0|            0|  0.00%|        msg = jsonapi.dumps(obj, **kwargs)
   651|         0|            0|            0|  0.00%|        return self.send(msg, flags=flags, **send_kwargs)
   652|         0|            0|            0|  0.00%|
   653|         0|            0|            0|  0.00%|    def recv_json(self, flags=0, **kwargs):
   654|         0|            0|            0|  0.00%|        """Receive a Python object as a message using json to serialize.
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|        Keyword arguments are passed on to json.loads
   657|         0|            0|            0|  0.00%|
   658|         0|            0|            0|  0.00%|        Parameters
   659|         0|            0|            0|  0.00%|        ----------
   660|         0|            0|            0|  0.00%|        flags : int
   661|         0|            0|            0|  0.00%|            Any valid flags for :func:`Socket.recv`.
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|        Returns
   664|         0|            0|            0|  0.00%|        -------
   665|         0|            0|            0|  0.00%|        obj : Python object
   666|         0|            0|            0|  0.00%|            The Python object that arrives as a message.
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|        Raises
   669|         0|            0|            0|  0.00%|        ------
   670|         0|            0|            0|  0.00%|        ZMQError
   671|         0|            0|            0|  0.00%|            for any of the reasons :func:`~Socket.recv` might fail
   672|         0|            0|            0|  0.00%|        """
   673|         0|            0|            0|  0.00%|        msg = self.recv(flags)
   674|         0|            0|            0|  0.00%|        return self._deserialize(msg, lambda buf: jsonapi.loads(buf, **kwargs))
   675|         0|            0|            0|  0.00%|
   676|         0|            0|            0|  0.00%|    _poller_class = Poller
   677|         0|            0|            0|  0.00%|
   678|         0|            0|            0|  0.00%|    def poll(self, timeout=None, flags=POLLIN):
   679|         0|            0|            0|  0.00%|        """Poll the socket for events.
   680|         0|            0|            0|  0.00%|        See :class:`Poller` to wait for multiple sockets at once.
   681|         0|            0|            0|  0.00%|
   682|         0|            0|            0|  0.00%|        Parameters
   683|         0|            0|            0|  0.00%|        ----------
   684|         0|            0|            0|  0.00%|        timeout : int [default: None]
   685|         0|            0|            0|  0.00%|            The timeout (in milliseconds) to wait for an event. If unspecified
   686|         0|            0|            0|  0.00%|            (or specified None), will wait forever for an event.
   687|         0|            0|            0|  0.00%|        flags : int [default: POLLIN]
   688|         0|            0|            0|  0.00%|            POLLIN, POLLOUT, or POLLIN|POLLOUT. The event flags to poll for.
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|        Returns
   691|         0|            0|            0|  0.00%|        -------
   692|         0|            0|            0|  0.00%|        events : int
   693|         0|            0|            0|  0.00%|            The events that are ready and waiting,
   694|         0|            0|            0|  0.00%|            0 if the timeout was reached with no events.
   695|         0|            0|            0|  0.00%|        """
   696|         0|            0|            0|  0.00%|
   697|         0|            0|            0|  0.00%|        if self.closed:
   698|         0|            0|            0|  0.00%|            raise ZMQError(ENOTSUP)
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|        p = self._poller_class()
   701|         0|            0|            0|  0.00%|        p.register(self, flags)
   702|         0|            0|            0|  0.00%|        evts = dict(p.poll(timeout))
   703|         0|            0|            0|  0.00%|        # return 0 if no events, otherwise return event bitfield
   704|         0|            0|            0|  0.00%|        return evts.get(self, 0)
   705|         0|            0|            0|  0.00%|
   706|         0|            0|            0|  0.00%|    def get_monitor_socket(self, events=None, addr=None):
   707|         0|            0|            0|  0.00%|        """Return a connected PAIR socket ready to receive the event notifications.
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|        .. versionadded:: libzmq-4.0
   710|         0|            0|            0|  0.00%|        .. versionadded:: 14.0
   711|         0|            0|            0|  0.00%|
   712|         0|            0|            0|  0.00%|        Parameters
   713|         0|            0|            0|  0.00%|        ----------
   714|         0|            0|            0|  0.00%|        events : int [default: ZMQ_EVENT_ALL]
   715|         0|            0|            0|  0.00%|            The bitmask defining which events are wanted.
   716|         0|            0|            0|  0.00%|        addr :  string [default: None]
   717|         0|            0|            0|  0.00%|            The optional endpoint for the monitoring sockets.
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|        Returns
   720|         0|            0|            0|  0.00%|        -------
   721|         0|            0|            0|  0.00%|        socket :  (PAIR)
   722|         0|            0|            0|  0.00%|            The socket is already connected and ready to receive messages.
   723|         0|            0|            0|  0.00%|        """
   724|         0|            0|            0|  0.00%|        # safe-guard, method only available on libzmq >= 4
   725|         0|            0|            0|  0.00%|        if zmq.zmq_version_info() < (4,):
   726|         0|            0|            0|  0.00%|            raise NotImplementedError("get_monitor_socket requires libzmq >= 4, have %s" % zmq.zmq_version())
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|        # if already monitoring, return existing socket
   729|         0|            0|            0|  0.00%|        if self._monitor_socket:
   730|         0|            0|            0|  0.00%|            if self._monitor_socket.closed:
   731|         0|            0|            0|  0.00%|                self._monitor_socket = None
   732|         0|            0|            0|  0.00%|            else:
   733|         0|            0|            0|  0.00%|                return self._monitor_socket
   734|         0|            0|            0|  0.00%|
   735|         0|            0|            0|  0.00%|        if addr is None:
   736|         0|            0|            0|  0.00%|            # create endpoint name from internal fd
   737|         0|            0|            0|  0.00%|            addr = "inproc://monitor.s-%d" % self.FD
   738|         0|            0|            0|  0.00%|        if events is None:
   739|         0|            0|            0|  0.00%|            # use all events
   740|         0|            0|            0|  0.00%|            events = zmq.EVENT_ALL
   741|         0|            0|            0|  0.00%|        # attach monitoring socket
   742|         0|            0|            0|  0.00%|        self.monitor(addr, events)
   743|         0|            0|            0|  0.00%|        # create new PAIR socket and connect it
   744|         0|            0|            0|  0.00%|        self._monitor_socket = self.context.socket(zmq.PAIR)
   745|         0|            0|            0|  0.00%|        self._monitor_socket.connect(addr)
   746|         0|            0|            0|  0.00%|        return self._monitor_socket
   747|         0|            0|            0|  0.00%|
   748|         0|            0|            0|  0.00%|    def disable_monitor(self):
   749|         0|            0|            0|  0.00%|        """Shutdown the PAIR socket (created using get_monitor_socket)
   750|         0|            0|            0|  0.00%|        that is serving socket events.
   751|         0|            0|            0|  0.00%|
   752|         0|            0|            0|  0.00%|        .. versionadded:: 14.4
   753|         0|            0|            0|  0.00%|        """
   754|         0|            0|            0|  0.00%|        self._monitor_socket = None
   755|         0|            0|            0|  0.00%|        self.monitor(None, 0)
   756|         0|            0|            0|  0.00%|
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|__all__ = ['Socket']
File: D:\Application\Anaconda\lib\threading.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Thread module emulating a subset of Java's threading model."""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import sys as _sys
     4|         0|            0|            0|  0.00%|import _thread
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|from time import monotonic as _time
     7|         0|            0|            0|  0.00%|from traceback import format_exc as _format_exc
     8|         0|            0|            0|  0.00%|from _weakrefset import WeakSet
     9|         0|            0|            0|  0.00%|from itertools import islice as _islice, count as _count
    10|         0|            0|            0|  0.00%|try:
    11|         0|            0|            0|  0.00%|    from _collections import deque as _deque
    12|         0|            0|            0|  0.00%|except ImportError:
    13|         0|            0|            0|  0.00%|    from collections import deque as _deque
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|# Note regarding PEP 8 compliant names
    16|         0|            0|            0|  0.00%|#  This threading model was originally inspired by Java, and inherited
    17|         0|            0|            0|  0.00%|# the convention of camelCase function and method names from that
    18|         0|            0|            0|  0.00%|# language. Those original names are not in any imminent danger of
    19|         0|            0|            0|  0.00%|# being deprecated (even for Py3k),so this module provides them as an
    20|         0|            0|            0|  0.00%|# alias for the PEP 8 compliant names
    21|         0|            0|            0|  0.00%|# Note that using the new PEP 8 compliant names facilitates substitution
    22|         0|            0|            0|  0.00%|# with the multiprocessing module, which doesn't provide the old
    23|         0|            0|            0|  0.00%|# Java inspired names.
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|__all__ = ['get_ident', 'active_count', 'Condition', 'current_thread',
    26|         0|            0|            0|  0.00%|           'enumerate', 'main_thread', 'TIMEOUT_MAX',
    27|         0|            0|            0|  0.00%|           'Event', 'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Thread',
    28|         0|            0|            0|  0.00%|           'Barrier', 'BrokenBarrierError', 'Timer', 'ThreadError',
    29|         0|            0|            0|  0.00%|           'setprofile', 'settrace', 'local', 'stack_size']
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|# Rename some stuff so "from threading import *" is safe
    32|         0|            0|            0|  0.00%|_start_new_thread = _thread.start_new_thread
    33|         0|            0|            0|  0.00%|_allocate_lock = _thread.allocate_lock
    34|         0|            0|            0|  0.00%|_set_sentinel = _thread._set_sentinel
    35|         0|            0|            0|  0.00%|get_ident = _thread.get_ident
    36|         0|            0|            0|  0.00%|ThreadError = _thread.error
    37|         0|            0|            0|  0.00%|try:
    38|         0|            0|            0|  0.00%|    _CRLock = _thread.RLock
    39|         0|            0|            0|  0.00%|except AttributeError:
    40|         0|            0|            0|  0.00%|    _CRLock = None
    41|         0|            0|            0|  0.00%|TIMEOUT_MAX = _thread.TIMEOUT_MAX
    42|         0|            0|            0|  0.00%|del _thread
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|# Support for profile and trace hooks
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|_profile_hook = None
    48|         0|            0|            0|  0.00%|_trace_hook = None
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|def setprofile(func):
    51|         0|            0|            0|  0.00%|    """Set a profile function for all threads started from the threading module.
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|    The func will be passed to sys.setprofile() for each thread, before its
    54|         0|            0|            0|  0.00%|    run() method is called.
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|    """
    57|         0|            0|            0|  0.00%|    global _profile_hook
    58|         0|            0|            0|  0.00%|    _profile_hook = func
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|def settrace(func):
    61|         0|            0|            0|  0.00%|    """Set a trace function for all threads started from the threading module.
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|    The func will be passed to sys.settrace() for each thread, before its run()
    64|         0|            0|            0|  0.00%|    method is called.
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|    """
    67|         0|            0|            0|  0.00%|    global _trace_hook
    68|         0|            0|            0|  0.00%|    _trace_hook = func
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|# Synchronization classes
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|Lock = _allocate_lock
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|def RLock(*args, **kwargs):
    75|         0|            0|            0|  0.00%|    """Factory function that returns a new reentrant lock.
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|    A reentrant lock must be released by the thread that acquired it. Once a
    78|         0|            0|            0|  0.00%|    thread has acquired a reentrant lock, the same thread may acquire it again
    79|         0|            0|            0|  0.00%|    without blocking; the thread must release it once for each time it has
    80|         0|            0|            0|  0.00%|    acquired it.
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|    """
    83|         0|            0|            0|  0.00%|    if _CRLock is None:
    84|         0|            0|            0|  0.00%|        return _PyRLock(*args, **kwargs)
    85|         0|            0|            0|  0.00%|    return _CRLock(*args, **kwargs)
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|class _RLock:
    88|         0|            0|            0|  0.00%|    """This class implements reentrant lock objects.
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|    A reentrant lock must be released by the thread that acquired it. Once a
    91|         0|            0|            0|  0.00%|    thread has acquired a reentrant lock, the same thread may acquire it
    92|         0|            0|            0|  0.00%|    again without blocking; the thread must release it once for each time it
    93|         0|            0|            0|  0.00%|    has acquired it.
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|    """
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|    def __init__(self):
    98|         0|            0|            0|  0.00%|        self._block = _allocate_lock()
    99|         0|            0|            0|  0.00%|        self._owner = None
   100|         0|            0|            0|  0.00%|        self._count = 0
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|    def __repr__(self):
   103|         0|            0|            0|  0.00%|        owner = self._owner
   104|         0|            0|            0|  0.00%|        try:
   105|         0|            0|            0|  0.00%|            owner = _active[owner].name
   106|         0|            0|            0|  0.00%|        except KeyError:
   107|         0|            0|            0|  0.00%|            pass
   108|         0|            0|            0|  0.00%|        return "<%s %s.%s object owner=%r count=%d at %s>" % (
   109|         0|            0|            0|  0.00%|            "locked" if self._block.locked() else "unlocked",
   110|         0|            0|            0|  0.00%|            self.__class__.__module__,
   111|         0|            0|            0|  0.00%|            self.__class__.__qualname__,
   112|         0|            0|            0|  0.00%|            owner,
   113|         0|            0|            0|  0.00%|            self._count,
   114|         0|            0|            0|  0.00%|            hex(id(self))
   115|         0|            0|            0|  0.00%|        )
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|    def acquire(self, blocking=True, timeout=-1):
   118|         0|            0|            0|  0.00%|        """Acquire a lock, blocking or non-blocking.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|        When invoked without arguments: if this thread already owns the lock,
   121|         0|            0|            0|  0.00%|        increment the recursion level by one, and return immediately. Otherwise,
   122|         0|            0|            0|  0.00%|        if another thread owns the lock, block until the lock is unlocked. Once
   123|         0|            0|            0|  0.00%|        the lock is unlocked (not owned by any thread), then grab ownership, set
   124|         0|            0|            0|  0.00%|        the recursion level to one, and return. If more than one thread is
   125|         0|            0|            0|  0.00%|        blocked waiting until the lock is unlocked, only one at a time will be
   126|         0|            0|            0|  0.00%|        able to grab ownership of the lock. There is no return value in this
   127|         0|            0|            0|  0.00%|        case.
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|        When invoked with the blocking argument set to true, do the same thing
   130|         0|            0|            0|  0.00%|        as when called without arguments, and return true.
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|        When invoked with the blocking argument set to false, do not block. If a
   133|         0|            0|            0|  0.00%|        call without an argument would block, return false immediately;
   134|         0|            0|            0|  0.00%|        otherwise, do the same thing as when called without arguments, and
   135|         0|            0|            0|  0.00%|        return true.
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|        When invoked with the floating-point timeout argument set to a positive
   138|         0|            0|            0|  0.00%|        value, block for at most the number of seconds specified by timeout
   139|         0|            0|            0|  0.00%|        and as long as the lock cannot be acquired.  Return true if the lock has
   140|         0|            0|            0|  0.00%|        been acquired, false if the timeout has elapsed.
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|        """
   143|         0|            0|            0|  0.00%|        me = get_ident()
   144|         0|            0|            0|  0.00%|        if self._owner == me:
   145|         0|            0|            0|  0.00%|            self._count += 1
   146|         0|            0|            0|  0.00%|            return 1
   147|         0|            0|            0|  0.00%|        rc = self._block.acquire(blocking, timeout)
   148|         0|            0|            0|  0.00%|        if rc:
   149|         0|            0|            0|  0.00%|            self._owner = me
   150|         0|            0|            0|  0.00%|            self._count = 1
   151|         0|            0|            0|  0.00%|        return rc
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|    __enter__ = acquire
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|    def release(self):
   156|         0|            0|            0|  0.00%|        """Release a lock, decrementing the recursion level.
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|        If after the decrement it is zero, reset the lock to unlocked (not owned
   159|         0|            0|            0|  0.00%|        by any thread), and if any other threads are blocked waiting for the
   160|         0|            0|            0|  0.00%|        lock to become unlocked, allow exactly one of them to proceed. If after
   161|         0|            0|            0|  0.00%|        the decrement the recursion level is still nonzero, the lock remains
   162|         0|            0|            0|  0.00%|        locked and owned by the calling thread.
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|        Only call this method when the calling thread owns the lock. A
   165|         0|            0|            0|  0.00%|        RuntimeError is raised if this method is called when the lock is
   166|         0|            0|            0|  0.00%|        unlocked.
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|        There is no return value.
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|        """
   171|         0|            0|            0|  0.00%|        if self._owner != get_ident():
   172|         0|            0|            0|  0.00%|            raise RuntimeError("cannot release un-acquired lock")
   173|         0|            0|            0|  0.00%|        self._count = count = self._count - 1
   174|         0|            0|            0|  0.00%|        if not count:
   175|         0|            0|            0|  0.00%|            self._owner = None
   176|         0|            0|            0|  0.00%|            self._block.release()
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    def __exit__(self, t, v, tb):
   179|         0|            0|            0|  0.00%|        self.release()
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|    # Internal methods used by condition variables
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    def _acquire_restore(self, state):
   184|         0|            0|            0|  0.00%|        self._block.acquire()
   185|         0|            0|            0|  0.00%|        self._count, self._owner = state
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|    def _release_save(self):
   188|         0|            0|            0|  0.00%|        if self._count == 0:
   189|         0|            0|            0|  0.00%|            raise RuntimeError("cannot release un-acquired lock")
   190|         0|            0|            0|  0.00%|        count = self._count
   191|         0|            0|            0|  0.00%|        self._count = 0
   192|         0|            0|            0|  0.00%|        owner = self._owner
   193|         0|            0|            0|  0.00%|        self._owner = None
   194|         0|            0|            0|  0.00%|        self._block.release()
   195|         0|            0|            0|  0.00%|        return (count, owner)
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|    def _is_owned(self):
   198|         0|            0|            0|  0.00%|        return self._owner == get_ident()
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|_PyRLock = _RLock
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|class Condition:
   204|         0|            0|            0|  0.00%|    """Class that implements a condition variable.
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|    A condition variable allows one or more threads to wait until they are
   207|         0|            0|            0|  0.00%|    notified by another thread.
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|    If the lock argument is given and not None, it must be a Lock or RLock
   210|         0|            0|            0|  0.00%|    object, and it is used as the underlying lock. Otherwise, a new RLock object
   211|         0|            0|            0|  0.00%|    is created and used as the underlying lock.
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|    """
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|    def __init__(self, lock=None):
   216|         0|            0|            0|  0.00%|        if lock is None:
   217|         0|            0|            0|  0.00%|            lock = RLock()
   218|         0|            0|            0|  0.00%|        self._lock = lock
   219|         0|            0|            0|  0.00%|        # Export the lock's acquire() and release() methods
   220|         0|            0|            0|  0.00%|        self.acquire = lock.acquire
   221|         0|            0|            0|  0.00%|        self.release = lock.release
   222|         0|            0|            0|  0.00%|        # If the lock defines _release_save() and/or _acquire_restore(),
   223|         0|            0|            0|  0.00%|        # these override the default implementations (which just call
   224|         0|            0|            0|  0.00%|        # release() and acquire() on the lock).  Ditto for _is_owned().
   225|         0|            0|            0|  0.00%|        try:
   226|         0|            0|            0|  0.00%|            self._release_save = lock._release_save
   227|         0|            0|            0|  0.00%|        except AttributeError:
   228|         0|            0|            0|  0.00%|            pass
   229|         0|            0|            0|  0.00%|        try:
   230|         0|            0|            0|  0.00%|            self._acquire_restore = lock._acquire_restore
   231|         0|            0|            0|  0.00%|        except AttributeError:
   232|         0|            0|            0|  0.00%|            pass
   233|         0|            0|            0|  0.00%|        try:
   234|         0|            0|            0|  0.00%|            self._is_owned = lock._is_owned
   235|         0|            0|            0|  0.00%|        except AttributeError:
   236|         0|            0|            0|  0.00%|            pass
   237|         0|            0|            0|  0.00%|        self._waiters = _deque()
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|    def __enter__(self):
   240|         0|            0|            0|  0.00%|        return self._lock.__enter__()
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|    def __exit__(self, *args):
   243|         0|            0|            0|  0.00%|        return self._lock.__exit__(*args)
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|    def __repr__(self):
   246|         0|            0|            0|  0.00%|        return "<Condition(%s, %d)>" % (self._lock, len(self._waiters))
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|    def _release_save(self):
   249|         0|            0|            0|  0.00%|        self._lock.release()           # No state to save
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|    def _acquire_restore(self, x):
   252|         0|            0|            0|  0.00%|        self._lock.acquire()           # Ignore saved state
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|    def _is_owned(self):
   255|         0|            0|            0|  0.00%|        # Return True if lock is owned by current_thread.
   256|         0|            0|            0|  0.00%|        # This method is called only if _lock doesn't have _is_owned().
   257|         0|            0|            0|  0.00%|        if self._lock.acquire(0):
   258|         0|            0|            0|  0.00%|            self._lock.release()
   259|         0|            0|            0|  0.00%|            return False
   260|         0|            0|            0|  0.00%|        else:
   261|         0|            0|            0|  0.00%|            return True
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|    def wait(self, timeout=None):
   264|         0|            0|            0|  0.00%|        """Wait until notified or until a timeout occurs.
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|        If the calling thread has not acquired the lock when this method is
   267|         0|            0|            0|  0.00%|        called, a RuntimeError is raised.
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|        This method releases the underlying lock, and then blocks until it is
   270|         0|            0|            0|  0.00%|        awakened by a notify() or notify_all() call for the same condition
   271|         0|            0|            0|  0.00%|        variable in another thread, or until the optional timeout occurs. Once
   272|         0|            0|            0|  0.00%|        awakened or timed out, it re-acquires the lock and returns.
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|        When the timeout argument is present and not None, it should be a
   275|         0|            0|            0|  0.00%|        floating point number specifying a timeout for the operation in seconds
   276|         0|            0|            0|  0.00%|        (or fractions thereof).
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|        When the underlying lock is an RLock, it is not released using its
   279|         0|            0|            0|  0.00%|        release() method, since this may not actually unlock the lock when it
   280|         0|            0|            0|  0.00%|        was acquired multiple times recursively. Instead, an internal interface
   281|         0|            0|            0|  0.00%|        of the RLock class is used, which really unlocks it even when it has
   282|         0|            0|            0|  0.00%|        been recursively acquired several times. Another internal interface is
   283|         0|            0|            0|  0.00%|        then used to restore the recursion level when the lock is reacquired.
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|        """
   286|         0|            0|            0|  0.00%|        if not self._is_owned():
   287|         0|            0|            0|  0.00%|            raise RuntimeError("cannot wait on un-acquired lock")
   288|         0|            0|            0|  0.00%|        waiter = _allocate_lock()
   289|         0|            0|            0|  0.00%|        waiter.acquire()
   290|         0|            0|            0|  0.00%|        self._waiters.append(waiter)
   291|         0|            0|            0|  0.00%|        saved_state = self._release_save()
   292|         0|            0|            0|  0.00%|        gotit = False
   293|         0|            0|            0|  0.00%|        try:    # restore state no matter what (e.g., KeyboardInterrupt)
   294|         0|            0|            0|  0.00%|            if timeout is None:
   295|         1|            0|            0|  0.00%|                waiter.acquire()
   296|         0|            0|            0|  0.00%|                gotit = True
   297|         0|            0|            0|  0.00%|            else:
   298|         0|            0|            0|  0.00%|                if timeout > 0:
   299|         1|            0|            0|  0.00%|                    gotit = waiter.acquire(True, timeout)
   300|         0|            0|            0|  0.00%|                else:
   301|         0|            0|            0|  0.00%|                    gotit = waiter.acquire(False)
   302|         0|            0|            0|  0.00%|            return gotit
   303|         0|            0|            0|  0.00%|        finally:
   304|         0|            0|            0|  0.00%|            self._acquire_restore(saved_state)
   305|         0|            0|            0|  0.00%|            if not gotit:
   306|         0|            0|            0|  0.00%|                try:
   307|         0|            0|            0|  0.00%|                    self._waiters.remove(waiter)
   308|         0|            0|            0|  0.00%|                except ValueError:
   309|         0|            0|            0|  0.00%|                    pass
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|    def wait_for(self, predicate, timeout=None):
   312|         0|            0|            0|  0.00%|        """Wait until a condition evaluates to True.
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|        predicate should be a callable which result will be interpreted as a
   315|         0|            0|            0|  0.00%|        boolean value.  A timeout may be provided giving the maximum time to
   316|         0|            0|            0|  0.00%|        wait.
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|        """
   319|         0|            0|            0|  0.00%|        endtime = None
   320|         0|            0|            0|  0.00%|        waittime = timeout
   321|         0|            0|            0|  0.00%|        result = predicate()
   322|         0|            0|            0|  0.00%|        while not result:
   323|         0|            0|            0|  0.00%|            if waittime is not None:
   324|         0|            0|            0|  0.00%|                if endtime is None:
   325|         0|            0|            0|  0.00%|                    endtime = _time() + waittime
   326|         0|            0|            0|  0.00%|                else:
   327|         0|            0|            0|  0.00%|                    waittime = endtime - _time()
   328|         0|            0|            0|  0.00%|                    if waittime <= 0:
   329|         0|            0|            0|  0.00%|                        break
   330|         0|            0|            0|  0.00%|            self.wait(waittime)
   331|         0|            0|            0|  0.00%|            result = predicate()
   332|         0|            0|            0|  0.00%|        return result
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|    def notify(self, n=1):
   335|         0|            0|            0|  0.00%|        """Wake up one or more threads waiting on this condition, if any.
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|        If the calling thread has not acquired the lock when this method is
   338|         0|            0|            0|  0.00%|        called, a RuntimeError is raised.
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|        This method wakes up at most n of the threads waiting for the condition
   341|         0|            0|            0|  0.00%|        variable; it is a no-op if no threads are waiting.
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|        """
   344|         0|            0|            0|  0.00%|        if not self._is_owned():
   345|         0|            0|            0|  0.00%|            raise RuntimeError("cannot notify on un-acquired lock")
   346|         0|            0|            0|  0.00%|        all_waiters = self._waiters
   347|         0|            0|            0|  0.00%|        waiters_to_notify = _deque(_islice(all_waiters, n))
   348|         0|            0|            0|  0.00%|        if not waiters_to_notify:
   349|         0|            0|            0|  0.00%|            return
   350|         0|            0|            0|  0.00%|        for waiter in waiters_to_notify:
   351|         0|            0|            0|  0.00%|            waiter.release()
   352|         0|            0|            0|  0.00%|            try:
   353|         0|            0|            0|  0.00%|                all_waiters.remove(waiter)
   354|         0|            0|            0|  0.00%|            except ValueError:
   355|         0|            0|            0|  0.00%|                pass
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|    def notify_all(self):
   358|         0|            0|            0|  0.00%|        """Wake up all threads waiting on this condition.
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|        If the calling thread has not acquired the lock when this method
   361|         0|            0|            0|  0.00%|        is called, a RuntimeError is raised.
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|        """
   364|         0|            0|            0|  0.00%|        self.notify(len(self._waiters))
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|    notifyAll = notify_all
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|class Semaphore:
   370|         0|            0|            0|  0.00%|    """This class implements semaphore objects.
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|    Semaphores manage a counter representing the number of release() calls minus
   373|         0|            0|            0|  0.00%|    the number of acquire() calls, plus an initial value. The acquire() method
   374|         0|            0|            0|  0.00%|    blocks if necessary until it can return without making the counter
   375|         0|            0|            0|  0.00%|    negative. If not given, value defaults to 1.
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|    """
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|    # After Tim Peters' semaphore class, but not quite the same (no maximum)
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|    def __init__(self, value=1):
   382|         0|            0|            0|  0.00%|        if value < 0:
   383|         0|            0|            0|  0.00%|            raise ValueError("semaphore initial value must be >= 0")
   384|         0|            0|            0|  0.00%|        self._cond = Condition(Lock())
   385|         0|            0|            0|  0.00%|        self._value = value
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|    def acquire(self, blocking=True, timeout=None):
   388|         0|            0|            0|  0.00%|        """Acquire a semaphore, decrementing the internal counter by one.
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|        When invoked without arguments: if the internal counter is larger than
   391|         0|            0|            0|  0.00%|        zero on entry, decrement it by one and return immediately. If it is zero
   392|         0|            0|            0|  0.00%|        on entry, block, waiting until some other thread has called release() to
   393|         0|            0|            0|  0.00%|        make it larger than zero. This is done with proper interlocking so that
   394|         0|            0|            0|  0.00%|        if multiple acquire() calls are blocked, release() will wake exactly one
   395|         0|            0|            0|  0.00%|        of them up. The implementation may pick one at random, so the order in
   396|         0|            0|            0|  0.00%|        which blocked threads are awakened should not be relied on. There is no
   397|         0|            0|            0|  0.00%|        return value in this case.
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|        When invoked with blocking set to true, do the same thing as when called
   400|         0|            0|            0|  0.00%|        without arguments, and return true.
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|        When invoked with blocking set to false, do not block. If a call without
   403|         0|            0|            0|  0.00%|        an argument would block, return false immediately; otherwise, do the
   404|         0|            0|            0|  0.00%|        same thing as when called without arguments, and return true.
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|        When invoked with a timeout other than None, it will block for at
   407|         0|            0|            0|  0.00%|        most timeout seconds.  If acquire does not complete successfully in
   408|         0|            0|            0|  0.00%|        that interval, return false.  Return true otherwise.
   409|         0|            0|            0|  0.00%|
   410|         0|            0|            0|  0.00%|        """
   411|         0|            0|            0|  0.00%|        if not blocking and timeout is not None:
   412|         0|            0|            0|  0.00%|            raise ValueError("can't specify timeout for non-blocking acquire")
   413|         0|            0|            0|  0.00%|        rc = False
   414|         0|            0|            0|  0.00%|        endtime = None
   415|         0|            0|            0|  0.00%|        with self._cond:
   416|         0|            0|            0|  0.00%|            while self._value == 0:
   417|         0|            0|            0|  0.00%|                if not blocking:
   418|         0|            0|            0|  0.00%|                    break
   419|         0|            0|            0|  0.00%|                if timeout is not None:
   420|         0|            0|            0|  0.00%|                    if endtime is None:
   421|         0|            0|            0|  0.00%|                        endtime = _time() + timeout
   422|         0|            0|            0|  0.00%|                    else:
   423|         0|            0|            0|  0.00%|                        timeout = endtime - _time()
   424|         0|            0|            0|  0.00%|                        if timeout <= 0:
   425|         0|            0|            0|  0.00%|                            break
   426|         0|            0|            0|  0.00%|                self._cond.wait(timeout)
   427|         0|            0|            0|  0.00%|            else:
   428|         0|            0|            0|  0.00%|                self._value -= 1
   429|         0|            0|            0|  0.00%|                rc = True
   430|         0|            0|            0|  0.00%|        return rc
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|    __enter__ = acquire
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|    def release(self):
   435|         0|            0|            0|  0.00%|        """Release a semaphore, incrementing the internal counter by one.
   436|         0|            0|            0|  0.00%|
   437|         0|            0|            0|  0.00%|        When the counter is zero on entry and another thread is waiting for it
   438|         0|            0|            0|  0.00%|        to become larger than zero again, wake up that thread.
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|        """
   441|         0|            0|            0|  0.00%|        with self._cond:
   442|         0|            0|            0|  0.00%|            self._value += 1
   443|         0|            0|            0|  0.00%|            self._cond.notify()
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|    def __exit__(self, t, v, tb):
   446|         0|            0|            0|  0.00%|        self.release()
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|class BoundedSemaphore(Semaphore):
   450|         0|            0|            0|  0.00%|    """Implements a bounded semaphore.
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|    A bounded semaphore checks to make sure its current value doesn't exceed its
   453|         0|            0|            0|  0.00%|    initial value. If it does, ValueError is raised. In most situations
   454|         0|            0|            0|  0.00%|    semaphores are used to guard resources with limited capacity.
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|    If the semaphore is released too many times it's a sign of a bug. If not
   457|         0|            0|            0|  0.00%|    given, value defaults to 1.
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|    Like regular semaphores, bounded semaphores manage a counter representing
   460|         0|            0|            0|  0.00%|    the number of release() calls minus the number of acquire() calls, plus an
   461|         0|            0|            0|  0.00%|    initial value. The acquire() method blocks if necessary until it can return
   462|         0|            0|            0|  0.00%|    without making the counter negative. If not given, value defaults to 1.
   463|         0|            0|            0|  0.00%|
   464|         0|            0|            0|  0.00%|    """
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|    def __init__(self, value=1):
   467|         0|            0|            0|  0.00%|        Semaphore.__init__(self, value)
   468|         0|            0|            0|  0.00%|        self._initial_value = value
   469|         0|            0|            0|  0.00%|
   470|         0|            0|            0|  0.00%|    def release(self):
   471|         0|            0|            0|  0.00%|        """Release a semaphore, incrementing the internal counter by one.
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|        When the counter is zero on entry and another thread is waiting for it
   474|         0|            0|            0|  0.00%|        to become larger than zero again, wake up that thread.
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|        If the number of releases exceeds the number of acquires,
   477|         0|            0|            0|  0.00%|        raise a ValueError.
   478|         0|            0|            0|  0.00%|
   479|         0|            0|            0|  0.00%|        """
   480|         0|            0|            0|  0.00%|        with self._cond:
   481|         0|            0|            0|  0.00%|            if self._value >= self._initial_value:
   482|         0|            0|            0|  0.00%|                raise ValueError("Semaphore released too many times")
   483|         0|            0|            0|  0.00%|            self._value += 1
   484|         0|            0|            0|  0.00%|            self._cond.notify()
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|class Event:
   488|         0|            0|            0|  0.00%|    """Class implementing event objects.
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|    Events manage a flag that can be set to true with the set() method and reset
   491|         0|            0|            0|  0.00%|    to false with the clear() method. The wait() method blocks until the flag is
   492|         0|            0|            0|  0.00%|    true.  The flag is initially false.
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|    """
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|    # After Tim Peters' event class (without is_posted())
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|    def __init__(self):
   499|         0|            0|            0|  0.00%|        self._cond = Condition(Lock())
   500|         0|            0|            0|  0.00%|        self._flag = False
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|    def _reset_internal_locks(self):
   503|         0|            0|            0|  0.00%|        # private!  called by Thread._reset_internal_locks by _after_fork()
   504|         0|            0|            0|  0.00%|        self._cond.__init__(Lock())
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|    def is_set(self):
   507|         0|            0|            0|  0.00%|        """Return true if and only if the internal flag is true."""
   508|         0|            0|            0|  0.00%|        return self._flag
   509|         0|            0|            0|  0.00%|
   510|         0|            0|            0|  0.00%|    isSet = is_set
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|    def set(self):
   513|         0|            0|            0|  0.00%|        """Set the internal flag to true.
   514|         0|            0|            0|  0.00%|
   515|         0|            0|            0|  0.00%|        All threads waiting for it to become true are awakened. Threads
   516|         0|            0|            0|  0.00%|        that call wait() once the flag is true will not block at all.
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|        """
   519|         0|            0|            0|  0.00%|        with self._cond:
   520|         0|            0|            0|  0.00%|            self._flag = True
   521|         0|            0|            0|  0.00%|            self._cond.notify_all()
   522|         0|            0|            0|  0.00%|
   523|         0|            0|            0|  0.00%|    def clear(self):
   524|         0|            0|            0|  0.00%|        """Reset the internal flag to false.
   525|         0|            0|            0|  0.00%|
   526|         0|            0|            0|  0.00%|        Subsequently, threads calling wait() will block until set() is called to
   527|         0|            0|            0|  0.00%|        set the internal flag to true again.
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|        """
   530|         0|            0|            0|  0.00%|        with self._cond:
   531|         0|            0|            0|  0.00%|            self._flag = False
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|    def wait(self, timeout=None):
   534|         0|            0|            0|  0.00%|        """Block until the internal flag is true.
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|        If the internal flag is true on entry, return immediately. Otherwise,
   537|         0|            0|            0|  0.00%|        block until another thread calls set() to set the flag to true, or until
   538|         0|            0|            0|  0.00%|        the optional timeout occurs.
   539|         0|            0|            0|  0.00%|
   540|         0|            0|            0|  0.00%|        When the timeout argument is present and not None, it should be a
   541|         0|            0|            0|  0.00%|        floating point number specifying a timeout for the operation in seconds
   542|         0|            0|            0|  0.00%|        (or fractions thereof).
   543|         0|            0|            0|  0.00%|
   544|         0|            0|            0|  0.00%|        This method returns the internal flag on exit, so it will always return
   545|         0|            0|            0|  0.00%|        True except if a timeout is given and the operation times out.
   546|         0|            0|            0|  0.00%|
   547|         0|            0|            0|  0.00%|        """
   548|         0|            0|            0|  0.00%|        with self._cond:
   549|         0|            0|            0|  0.00%|            signaled = self._flag
   550|         0|            0|            0|  0.00%|            if not signaled:
   551|         0|            0|            0|  0.00%|                signaled = self._cond.wait(timeout)
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\threading.py:263 wait
   552|         0|            0|            0|  0.00%|            return signaled
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|# A barrier class.  Inspired in part by the pthread_barrier_* api and
   556|         0|            0|            0|  0.00%|# the CyclicBarrier class from Java.  See
   557|         0|            0|            0|  0.00%|# http://sourceware.org/pthreads-win32/manual/pthread_barrier_init.html and
   558|         0|            0|            0|  0.00%|# http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/
   559|         0|            0|            0|  0.00%|#        CyclicBarrier.html
   560|         0|            0|            0|  0.00%|# for information.
   561|         0|            0|            0|  0.00%|# We maintain two main states, 'filling' and 'draining' enabling the barrier
   562|         0|            0|            0|  0.00%|# to be cyclic.  Threads are not allowed into it until it has fully drained
   563|         0|            0|            0|  0.00%|# since the previous cycle.  In addition, a 'resetting' state exists which is
   564|         0|            0|            0|  0.00%|# similar to 'draining' except that threads leave with a BrokenBarrierError,
   565|         0|            0|            0|  0.00%|# and a 'broken' state in which all threads get the exception.
   566|         0|            0|            0|  0.00%|class Barrier:
   567|         0|            0|            0|  0.00%|    """Implements a Barrier.
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|    Useful for synchronizing a fixed number of threads at known synchronization
   570|         0|            0|            0|  0.00%|    points.  Threads block on 'wait()' and are simultaneously once they have all
   571|         0|            0|            0|  0.00%|    made that call.
   572|         0|            0|            0|  0.00%|
   573|         0|            0|            0|  0.00%|    """
   574|         0|            0|            0|  0.00%|
   575|         0|            0|            0|  0.00%|    def __init__(self, parties, action=None, timeout=None):
   576|         0|            0|            0|  0.00%|        """Create a barrier, initialised to 'parties' threads.
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|        'action' is a callable which, when supplied, will be called by one of
   579|         0|            0|            0|  0.00%|        the threads after they have all entered the barrier and just prior to
   580|         0|            0|            0|  0.00%|        releasing them all. If a 'timeout' is provided, it is uses as the
   581|         0|            0|            0|  0.00%|        default for all subsequent 'wait()' calls.
   582|         0|            0|            0|  0.00%|
   583|         0|            0|            0|  0.00%|        """
   584|         0|            0|            0|  0.00%|        self._cond = Condition(Lock())
   585|         0|            0|            0|  0.00%|        self._action = action
   586|         0|            0|            0|  0.00%|        self._timeout = timeout
   587|         0|            0|            0|  0.00%|        self._parties = parties
   588|         0|            0|            0|  0.00%|        self._state = 0 #0 filling, 1, draining, -1 resetting, -2 broken
   589|         0|            0|            0|  0.00%|        self._count = 0
   590|         0|            0|            0|  0.00%|
   591|         0|            0|            0|  0.00%|    def wait(self, timeout=None):
   592|         0|            0|            0|  0.00%|        """Wait for the barrier.
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|        When the specified number of threads have started waiting, they are all
   595|         0|            0|            0|  0.00%|        simultaneously awoken. If an 'action' was provided for the barrier, one
   596|         0|            0|            0|  0.00%|        of the threads will have executed that callback prior to returning.
   597|         0|            0|            0|  0.00%|        Returns an individual index number from 0 to 'parties-1'.
   598|         0|            0|            0|  0.00%|
   599|         0|            0|            0|  0.00%|        """
   600|         0|            0|            0|  0.00%|        if timeout is None:
   601|         0|            0|            0|  0.00%|            timeout = self._timeout
   602|         0|            0|            0|  0.00%|        with self._cond:
   603|         0|            0|            0|  0.00%|            self._enter() # Block while the barrier drains.
   604|         0|            0|            0|  0.00%|            index = self._count
   605|         0|            0|            0|  0.00%|            self._count += 1
   606|         0|            0|            0|  0.00%|            try:
   607|         0|            0|            0|  0.00%|                if index + 1 == self._parties:
   608|         0|            0|            0|  0.00%|                    # We release the barrier
   609|         0|            0|            0|  0.00%|                    self._release()
   610|         0|            0|            0|  0.00%|                else:
   611|         0|            0|            0|  0.00%|                    # We wait until someone releases us
   612|         0|            0|            0|  0.00%|                    self._wait(timeout)
   613|         0|            0|            0|  0.00%|                return index
   614|         0|            0|            0|  0.00%|            finally:
   615|         0|            0|            0|  0.00%|                self._count -= 1
   616|         0|            0|            0|  0.00%|                # Wake up any threads waiting for barrier to drain.
   617|         0|            0|            0|  0.00%|                self._exit()
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|    # Block until the barrier is ready for us, or raise an exception
   620|         0|            0|            0|  0.00%|    # if it is broken.
   621|         0|            0|            0|  0.00%|    def _enter(self):
   622|         0|            0|            0|  0.00%|        while self._state in (-1, 1):
   623|         0|            0|            0|  0.00%|            # It is draining or resetting, wait until done
   624|         0|            0|            0|  0.00%|            self._cond.wait()
   625|         0|            0|            0|  0.00%|        #see if the barrier is in a broken state
   626|         0|            0|            0|  0.00%|        if self._state < 0:
   627|         0|            0|            0|  0.00%|            raise BrokenBarrierError
   628|         0|            0|            0|  0.00%|        assert self._state == 0
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|    # Optionally run the 'action' and release the threads waiting
   631|         0|            0|            0|  0.00%|    # in the barrier.
   632|         0|            0|            0|  0.00%|    def _release(self):
   633|         0|            0|            0|  0.00%|        try:
   634|         0|            0|            0|  0.00%|            if self._action:
   635|         0|            0|            0|  0.00%|                self._action()
   636|         0|            0|            0|  0.00%|            # enter draining state
   637|         0|            0|            0|  0.00%|            self._state = 1
   638|         0|            0|            0|  0.00%|            self._cond.notify_all()
   639|         0|            0|            0|  0.00%|        except:
   640|         0|            0|            0|  0.00%|            #an exception during the _action handler.  Break and reraise
   641|         0|            0|            0|  0.00%|            self._break()
   642|         0|            0|            0|  0.00%|            raise
   643|         0|            0|            0|  0.00%|
   644|         0|            0|            0|  0.00%|    # Wait in the barrier until we are released.  Raise an exception
   645|         0|            0|            0|  0.00%|    # if the barrier is reset or broken.
   646|         0|            0|            0|  0.00%|    def _wait(self, timeout):
   647|         0|            0|            0|  0.00%|        if not self._cond.wait_for(lambda : self._state != 0, timeout):
   648|         0|            0|            0|  0.00%|            #timed out.  Break the barrier
   649|         0|            0|            0|  0.00%|            self._break()
   650|         0|            0|            0|  0.00%|            raise BrokenBarrierError
   651|         0|            0|            0|  0.00%|        if self._state < 0:
   652|         0|            0|            0|  0.00%|            raise BrokenBarrierError
   653|         0|            0|            0|  0.00%|        assert self._state == 1
   654|         0|            0|            0|  0.00%|
   655|         0|            0|            0|  0.00%|    # If we are the last thread to exit the barrier, signal any threads
   656|         0|            0|            0|  0.00%|    # waiting for the barrier to drain.
   657|         0|            0|            0|  0.00%|    def _exit(self):
   658|         0|            0|            0|  0.00%|        if self._count == 0:
   659|         0|            0|            0|  0.00%|            if self._state in (-1, 1):
   660|         0|            0|            0|  0.00%|                #resetting or draining
   661|         0|            0|            0|  0.00%|                self._state = 0
   662|         0|            0|            0|  0.00%|                self._cond.notify_all()
   663|         0|            0|            0|  0.00%|
   664|         0|            0|            0|  0.00%|    def reset(self):
   665|         0|            0|            0|  0.00%|        """Reset the barrier to the initial state.
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|        Any threads currently waiting will get the BrokenBarrier exception
   668|         0|            0|            0|  0.00%|        raised.
   669|         0|            0|            0|  0.00%|
   670|         0|            0|            0|  0.00%|        """
   671|         0|            0|            0|  0.00%|        with self._cond:
   672|         0|            0|            0|  0.00%|            if self._count > 0:
   673|         0|            0|            0|  0.00%|                if self._state == 0:
   674|         0|            0|            0|  0.00%|                    #reset the barrier, waking up threads
   675|         0|            0|            0|  0.00%|                    self._state = -1
   676|         0|            0|            0|  0.00%|                elif self._state == -2:
   677|         0|            0|            0|  0.00%|                    #was broken, set it to reset state
   678|         0|            0|            0|  0.00%|                    #which clears when the last thread exits
   679|         0|            0|            0|  0.00%|                    self._state = -1
   680|         0|            0|            0|  0.00%|            else:
   681|         0|            0|            0|  0.00%|                self._state = 0
   682|         0|            0|            0|  0.00%|            self._cond.notify_all()
   683|         0|            0|            0|  0.00%|
   684|         0|            0|            0|  0.00%|    def abort(self):
   685|         0|            0|            0|  0.00%|        """Place the barrier into a 'broken' state.
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|        Useful in case of error.  Any currently waiting threads and threads
   688|         0|            0|            0|  0.00%|        attempting to 'wait()' will have BrokenBarrierError raised.
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|        """
   691|         0|            0|            0|  0.00%|        with self._cond:
   692|         0|            0|            0|  0.00%|            self._break()
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|    def _break(self):
   695|         0|            0|            0|  0.00%|        # An internal error was detected.  The barrier is set to
   696|         0|            0|            0|  0.00%|        # a broken state all parties awakened.
   697|         0|            0|            0|  0.00%|        self._state = -2
   698|         0|            0|            0|  0.00%|        self._cond.notify_all()
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|    @property
   701|         0|            0|            0|  0.00%|    def parties(self):
   702|         0|            0|            0|  0.00%|        """Return the number of threads required to trip the barrier."""
   703|         0|            0|            0|  0.00%|        return self._parties
   704|         0|            0|            0|  0.00%|
   705|         0|            0|            0|  0.00%|    @property
   706|         0|            0|            0|  0.00%|    def n_waiting(self):
   707|         0|            0|            0|  0.00%|        """Return the number of threads currently waiting at the barrier."""
   708|         0|            0|            0|  0.00%|        # We don't need synchronization here since this is an ephemeral result
   709|         0|            0|            0|  0.00%|        # anyway.  It returns the correct value in the steady state.
   710|         0|            0|            0|  0.00%|        if self._state == 0:
   711|         0|            0|            0|  0.00%|            return self._count
   712|         0|            0|            0|  0.00%|        return 0
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|    @property
   715|         0|            0|            0|  0.00%|    def broken(self):
   716|         0|            0|            0|  0.00%|        """Return True if the barrier is in a broken state."""
   717|         0|            0|            0|  0.00%|        return self._state == -2
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|# exception raised by the Barrier class
   720|         0|            0|            0|  0.00%|class BrokenBarrierError(RuntimeError):
   721|         0|            0|            0|  0.00%|    pass
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|# Helper to generate new thread names
   725|         0|            0|            0|  0.00%|_counter = _count().__next__
   726|         0|            0|            0|  0.00%|_counter() # Consume 0 so first non-main thread has id 1.
   727|         0|            0|            0|  0.00%|def _newname(template="Thread-%d"):
   728|         0|            0|            0|  0.00%|    return template % _counter()
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|# Active thread administration
   731|         0|            0|            0|  0.00%|_active_limbo_lock = _allocate_lock()
   732|         0|            0|            0|  0.00%|_active = {}    # maps thread id to Thread object
   733|         0|            0|            0|  0.00%|_limbo = {}
   734|         0|            0|            0|  0.00%|_dangling = WeakSet()
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|# Main class for threads
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|class Thread:
   739|         0|            0|            0|  0.00%|    """A class that represents a thread of control.
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|    This class can be safely subclassed in a limited fashion. There are two ways
   742|         0|            0|            0|  0.00%|    to specify the activity: by passing a callable object to the constructor, or
   743|         0|            0|            0|  0.00%|    by overriding the run() method in a subclass.
   744|         0|            0|            0|  0.00%|
   745|         0|            0|            0|  0.00%|    """
   746|         0|            0|            0|  0.00%|
   747|         0|            0|            0|  0.00%|    _initialized = False
   748|         0|            0|            0|  0.00%|    # Need to store a reference to sys.exc_info for printing
   749|         0|            0|            0|  0.00%|    # out exceptions when a thread tries to use a global var. during interp.
   750|         0|            0|            0|  0.00%|    # shutdown and thus raises an exception about trying to perform some
   751|         0|            0|            0|  0.00%|    # operation on/with a NoneType
   752|         0|            0|            0|  0.00%|    _exc_info = _sys.exc_info
   753|         0|            0|            0|  0.00%|    # Keep sys.exc_clear too to clear the exception just before
   754|         0|            0|            0|  0.00%|    # allowing .join() to return.
   755|         0|            0|            0|  0.00%|    #XXX __exc_clear = _sys.exc_clear
   756|         0|            0|            0|  0.00%|
   757|         0|            0|            0|  0.00%|    def __init__(self, group=None, target=None, name=None,
   758|         0|            0|            0|  0.00%|                 args=(), kwargs=None, *, daemon=None):
   759|         0|            0|            0|  0.00%|        """This constructor should always be called with keyword arguments. Arguments are:
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|        *group* should be None; reserved for future extension when a ThreadGroup
   762|         0|            0|            0|  0.00%|        class is implemented.
   763|         0|            0|            0|  0.00%|
   764|         0|            0|            0|  0.00%|        *target* is the callable object to be invoked by the run()
   765|         0|            0|            0|  0.00%|        method. Defaults to None, meaning nothing is called.
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|        *name* is the thread name. By default, a unique name is constructed of
   768|         0|            0|            0|  0.00%|        the form "Thread-N" where N is a small decimal number.
   769|         0|            0|            0|  0.00%|
   770|         0|            0|            0|  0.00%|        *args* is the argument tuple for the target invocation. Defaults to ().
   771|         0|            0|            0|  0.00%|
   772|         0|            0|            0|  0.00%|        *kwargs* is a dictionary of keyword arguments for the target
   773|         0|            0|            0|  0.00%|        invocation. Defaults to {}.
   774|         0|            0|            0|  0.00%|
   775|         0|            0|            0|  0.00%|        If a subclass overrides the constructor, it must make sure to invoke
   776|         0|            0|            0|  0.00%|        the base class constructor (Thread.__init__()) before doing anything
   777|         0|            0|            0|  0.00%|        else to the thread.
   778|         0|            0|            0|  0.00%|
   779|         0|            0|            0|  0.00%|        """
   780|         0|            0|            0|  0.00%|        assert group is None, "group argument must be None for now"
   781|         0|            0|            0|  0.00%|        if kwargs is None:
   782|         0|            0|            0|  0.00%|            kwargs = {}
   783|         0|            0|            0|  0.00%|        self._target = target
   784|         0|            0|            0|  0.00%|        self._name = str(name or _newname())
   785|         0|            0|            0|  0.00%|        self._args = args
   786|         0|            0|            0|  0.00%|        self._kwargs = kwargs
   787|         0|            0|            0|  0.00%|        if daemon is not None:
   788|         0|            0|            0|  0.00%|            self._daemonic = daemon
   789|         0|            0|            0|  0.00%|        else:
   790|         0|            0|            0|  0.00%|            self._daemonic = current_thread().daemon
   791|         0|            0|            0|  0.00%|        self._ident = None
   792|         0|            0|            0|  0.00%|        self._tstate_lock = None
   793|         0|            0|            0|  0.00%|        self._started = Event()
   794|         0|            0|            0|  0.00%|        self._is_stopped = False
   795|         0|            0|            0|  0.00%|        self._initialized = True
   796|         0|            0|            0|  0.00%|        # sys.stderr is not stored in the class like
   797|         0|            0|            0|  0.00%|        # sys.exc_info since it can be changed between instances
   798|         0|            0|            0|  0.00%|        self._stderr = _sys.stderr
   799|         0|            0|            0|  0.00%|        # For debugging and _after_fork()
   800|         0|            0|            0|  0.00%|        _dangling.add(self)
   801|         0|            0|            0|  0.00%|
   802|         0|            0|            0|  0.00%|    def _reset_internal_locks(self, is_alive):
   803|         0|            0|            0|  0.00%|        # private!  Called by _after_fork() to reset our internal locks as
   804|         0|            0|            0|  0.00%|        # they may be in an invalid state leading to a deadlock or crash.
   805|         0|            0|            0|  0.00%|        self._started._reset_internal_locks()
   806|         0|            0|            0|  0.00%|        if is_alive:
   807|         0|            0|            0|  0.00%|            self._set_tstate_lock()
   808|         0|            0|            0|  0.00%|        else:
   809|         0|            0|            0|  0.00%|            # The thread isn't alive after fork: it doesn't have a tstate
   810|         0|            0|            0|  0.00%|            # anymore.
   811|         0|            0|            0|  0.00%|            self._is_stopped = True
   812|         0|            0|            0|  0.00%|            self._tstate_lock = None
   813|         0|            0|            0|  0.00%|
   814|         0|            0|            0|  0.00%|    def __repr__(self):
   815|         0|            0|            0|  0.00%|        assert self._initialized, "Thread.__init__() was not called"
   816|         0|            0|            0|  0.00%|        status = "initial"
   817|         0|            0|            0|  0.00%|        if self._started.is_set():
   818|         0|            0|            0|  0.00%|            status = "started"
   819|         0|            0|            0|  0.00%|        self.is_alive() # easy way to get ._is_stopped set when appropriate
   820|         0|            0|            0|  0.00%|        if self._is_stopped:
   821|         0|            0|            0|  0.00%|            status = "stopped"
   822|         0|            0|            0|  0.00%|        if self._daemonic:
   823|         0|            0|            0|  0.00%|            status += " daemon"
   824|         0|            0|            0|  0.00%|        if self._ident is not None:
   825|         0|            0|            0|  0.00%|            status += " %s" % self._ident
   826|         0|            0|            0|  0.00%|        return "<%s(%s, %s)>" % (self.__class__.__name__, self._name, status)
   827|         0|            0|            0|  0.00%|
   828|         0|            0|            0|  0.00%|    def start(self):
   829|         0|            0|            0|  0.00%|        """Start the thread's activity.
   830|         0|            0|            0|  0.00%|
   831|         0|            0|            0|  0.00%|        It must be called at most once per thread object. It arranges for the
   832|         0|            0|            0|  0.00%|        object's run() method to be invoked in a separate thread of control.
   833|         0|            0|            0|  0.00%|
   834|         0|            0|            0|  0.00%|        This method will raise a RuntimeError if called more than once on the
   835|         0|            0|            0|  0.00%|        same thread object.
   836|         0|            0|            0|  0.00%|
   837|         0|            0|            0|  0.00%|        """
   838|         0|            0|            0|  0.00%|        if not self._initialized:
   839|         0|            0|            0|  0.00%|            raise RuntimeError("thread.__init__() not called")
   840|         0|            0|            0|  0.00%|
   841|         0|            0|            0|  0.00%|        if self._started.is_set():
   842|         0|            0|            0|  0.00%|            raise RuntimeError("threads can only be started once")
   843|         0|            0|            0|  0.00%|        with _active_limbo_lock:
   844|         0|            0|            0|  0.00%|            _limbo[self] = self
   845|         0|            0|            0|  0.00%|        try:
   846|         0|            0|            0|  0.00%|            _start_new_thread(self._bootstrap, ())
   847|         0|            0|            0|  0.00%|        except Exception:
   848|         0|            0|            0|  0.00%|            with _active_limbo_lock:
   849|         0|            0|            0|  0.00%|                del _limbo[self]
   850|         0|            0|            0|  0.00%|            raise
   851|         0|            0|            0|  0.00%|        self._started.wait()
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\threading.py:533 wait
   852|         0|            0|            0|  0.00%|
   853|         0|            0|            0|  0.00%|    def run(self):
   854|         0|            0|            0|  0.00%|        """Method representing the thread's activity.
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|        You may override this method in a subclass. The standard run() method
   857|         0|            0|            0|  0.00%|        invokes the callable object passed to the object's constructor as the
   858|         0|            0|            0|  0.00%|        target argument, if any, with sequential and keyword arguments taken
   859|         0|            0|            0|  0.00%|        from the args and kwargs arguments, respectively.
   860|         0|            0|            0|  0.00%|
   861|         0|            0|            0|  0.00%|        """
   862|         0|            0|            0|  0.00%|        try:
   863|         0|            0|            0|  0.00%|            if self._target:
   864|         0|            0|            0|  0.00%|                self._target(*self._args, **self._kwargs)
   865|         0|            0|            0|  0.00%|        finally:
   866|         0|            0|            0|  0.00%|            # Avoid a refcycle if the thread is running a function with
   867|         0|            0|            0|  0.00%|            # an argument that has a member that points to the thread.
   868|         0|            0|            0|  0.00%|            del self._target, self._args, self._kwargs
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|    def _bootstrap(self):
   871|         0|            0|            0|  0.00%|        # Wrapper around the real bootstrap code that ignores
   872|         0|            0|            0|  0.00%|        # exceptions during interpreter cleanup.  Those typically
   873|         0|            0|            0|  0.00%|        # happen when a daemon thread wakes up at an unfortunate
   874|         0|            0|            0|  0.00%|        # moment, finds the world around it destroyed, and raises some
   875|         0|            0|            0|  0.00%|        # random exception *** while trying to report the exception in
   876|         0|            0|            0|  0.00%|        # _bootstrap_inner() below ***.  Those random exceptions
   877|         0|            0|            0|  0.00%|        # don't help anybody, and they confuse users, so we suppress
   878|         0|            0|            0|  0.00%|        # them.  We suppress them only when it appears that the world
   879|         0|            0|            0|  0.00%|        # indeed has already been destroyed, so that exceptions in
   880|         0|            0|            0|  0.00%|        # _bootstrap_inner() during normal business hours are properly
   881|         0|            0|            0|  0.00%|        # reported.  Also, we only suppress them for daemonic threads;
   882|         0|            0|            0|  0.00%|        # if a non-daemonic encounters this, something else is wrong.
   883|         0|            0|            0|  0.00%|        try:
   884|         0|            0|            0|  0.00%|            self._bootstrap_inner()
   885|         0|            0|            0|  0.00%|        except:
   886|         0|            0|            0|  0.00%|            if self._daemonic and _sys is None:
   887|         0|            0|            0|  0.00%|                return
   888|         0|            0|            0|  0.00%|            raise
   889|         0|            0|            0|  0.00%|
   890|         0|            0|            0|  0.00%|    def _set_ident(self):
   891|         0|            0|            0|  0.00%|        self._ident = get_ident()
   892|         0|            0|            0|  0.00%|
   893|         0|            0|            0|  0.00%|    def _set_tstate_lock(self):
   894|         0|            0|            0|  0.00%|        """
   895|         0|            0|            0|  0.00%|        Set a lock object which will be released by the interpreter when
   896|         0|            0|            0|  0.00%|        the underlying thread state (see pystate.h) gets deleted.
   897|         0|            0|            0|  0.00%|        """
   898|         0|            0|            0|  0.00%|        self._tstate_lock = _set_sentinel()
   899|         0|            0|            0|  0.00%|        self._tstate_lock.acquire()
   900|         0|            0|            0|  0.00%|
   901|         0|            0|            0|  0.00%|    def _bootstrap_inner(self):
   902|         0|            0|            0|  0.00%|        try:
   903|         0|            0|            0|  0.00%|            self._set_ident()
   904|         0|            0|            0|  0.00%|            self._set_tstate_lock()
   905|         0|            0|            0|  0.00%|            self._started.set()
   906|         0|            0|            0|  0.00%|            with _active_limbo_lock:
   907|         0|            0|            0|  0.00%|                _active[self._ident] = self
   908|         0|            0|            0|  0.00%|                del _limbo[self]
   909|         0|            0|            0|  0.00%|
   910|         0|            0|            0|  0.00%|            if _trace_hook:
   911|         0|            0|            0|  0.00%|                _sys.settrace(_trace_hook)
   912|         0|            0|            0|  0.00%|            if _profile_hook:
   913|         0|            0|            0|  0.00%|                _sys.setprofile(_profile_hook)
   914|         0|            0|            0|  0.00%|
   915|         0|            0|            0|  0.00%|            try:
   916|         0|            0|            0|  0.00%|                self.run()
   917|         0|            0|            0|  0.00%|            except SystemExit:
   918|         0|            0|            0|  0.00%|                pass
   919|         0|            0|            0|  0.00%|            except:
   920|         0|            0|            0|  0.00%|                # If sys.stderr is no more (most likely from interpreter
   921|         0|            0|            0|  0.00%|                # shutdown) use self._stderr.  Otherwise still use sys (as in
   922|         0|            0|            0|  0.00%|                # _sys) in case sys.stderr was redefined since the creation of
   923|         0|            0|            0|  0.00%|                # self.
   924|         0|            0|            0|  0.00%|                if _sys and _sys.stderr is not None:
   925|         0|            0|            0|  0.00%|                    print("Exception in thread %s:\n%s" %
   926|         0|            0|            0|  0.00%|                          (self.name, _format_exc()), file=_sys.stderr)
   927|         0|            0|            0|  0.00%|                elif self._stderr is not None:
   928|         0|            0|            0|  0.00%|                    # Do the best job possible w/o a huge amt. of code to
   929|         0|            0|            0|  0.00%|                    # approximate a traceback (code ideas from
   930|         0|            0|            0|  0.00%|                    # Lib/traceback.py)
   931|         0|            0|            0|  0.00%|                    exc_type, exc_value, exc_tb = self._exc_info()
   932|         0|            0|            0|  0.00%|                    try:
   933|         0|            0|            0|  0.00%|                        print((
   934|         0|            0|            0|  0.00%|                            "Exception in thread " + self.name +
   935|         0|            0|            0|  0.00%|                            " (most likely raised during interpreter shutdown):"), file=self._stderr)
   936|         0|            0|            0|  0.00%|                        print((
   937|         0|            0|            0|  0.00%|                            "Traceback (most recent call last):"), file=self._stderr)
   938|         0|            0|            0|  0.00%|                        while exc_tb:
   939|         0|            0|            0|  0.00%|                            print((
   940|         0|            0|            0|  0.00%|                                '  File "%s", line %s, in %s' %
   941|         0|            0|            0|  0.00%|                                (exc_tb.tb_frame.f_code.co_filename,
   942|         0|            0|            0|  0.00%|                                    exc_tb.tb_lineno,
   943|         0|            0|            0|  0.00%|                                    exc_tb.tb_frame.f_code.co_name)), file=self._stderr)
   944|         0|            0|            0|  0.00%|                            exc_tb = exc_tb.tb_next
   945|         0|            0|            0|  0.00%|                        print(("%s: %s" % (exc_type, exc_value)), file=self._stderr)
   946|         0|            0|            0|  0.00%|                    # Make sure that exc_tb gets deleted since it is a memory
   947|         0|            0|            0|  0.00%|                    # hog; deleting everything else is just for thoroughness
   948|         0|            0|            0|  0.00%|                    finally:
   949|         0|            0|            0|  0.00%|                        del exc_type, exc_value, exc_tb
   950|         0|            0|            0|  0.00%|            finally:
   951|         0|            0|            0|  0.00%|                # Prevent a race in
   952|         0|            0|            0|  0.00%|                # test_threading.test_no_refcycle_through_target when
   953|         0|            0|            0|  0.00%|                # the exception keeps the target alive past when we
   954|         0|            0|            0|  0.00%|                # assert that it's dead.
   955|         0|            0|            0|  0.00%|                #XXX self._exc_clear()
   956|         0|            0|            0|  0.00%|                pass
   957|         0|            0|            0|  0.00%|        finally:
   958|         0|            0|            0|  0.00%|            with _active_limbo_lock:
   959|         0|            0|            0|  0.00%|                try:
   960|         0|            0|            0|  0.00%|                    # We don't call self._delete() because it also
   961|         0|            0|            0|  0.00%|                    # grabs _active_limbo_lock.
   962|         0|            0|            0|  0.00%|                    del _active[get_ident()]
   963|         0|            0|            0|  0.00%|                except:
   964|         0|            0|            0|  0.00%|                    pass
   965|         0|            0|            0|  0.00%|
   966|         0|            0|            0|  0.00%|    def _stop(self):
   967|         0|            0|            0|  0.00%|        # After calling ._stop(), .is_alive() returns False and .join() returns
   968|         0|            0|            0|  0.00%|        # immediately.  ._tstate_lock must be released before calling ._stop().
   969|         0|            0|            0|  0.00%|        #
   970|         0|            0|            0|  0.00%|        # Normal case:  C code at the end of the thread's life
   971|         0|            0|            0|  0.00%|        # (release_sentinel in _threadmodule.c) releases ._tstate_lock, and
   972|         0|            0|            0|  0.00%|        # that's detected by our ._wait_for_tstate_lock(), called by .join()
   973|         0|            0|            0|  0.00%|        # and .is_alive().  Any number of threads _may_ call ._stop()
   974|         0|            0|            0|  0.00%|        # simultaneously (for example, if multiple threads are blocked in
   975|         0|            0|            0|  0.00%|        # .join() calls), and they're not serialized.  That's harmless -
   976|         0|            0|            0|  0.00%|        # they'll just make redundant rebindings of ._is_stopped and
   977|         0|            0|            0|  0.00%|        # ._tstate_lock.  Obscure:  we rebind ._tstate_lock last so that the
   978|         0|            0|            0|  0.00%|        # "assert self._is_stopped" in ._wait_for_tstate_lock() always works
   979|         0|            0|            0|  0.00%|        # (the assert is executed only if ._tstate_lock is None).
   980|         0|            0|            0|  0.00%|        #
   981|         0|            0|            0|  0.00%|        # Special case:  _main_thread releases ._tstate_lock via this
   982|         0|            0|            0|  0.00%|        # module's _shutdown() function.
   983|         0|            0|            0|  0.00%|        lock = self._tstate_lock
   984|         0|            0|            0|  0.00%|        if lock is not None:
   985|         0|            0|            0|  0.00%|            assert not lock.locked()
   986|         0|            0|            0|  0.00%|        self._is_stopped = True
   987|         0|            0|            0|  0.00%|        self._tstate_lock = None
   988|         0|            0|            0|  0.00%|
   989|         0|            0|            0|  0.00%|    def _delete(self):
   990|         0|            0|            0|  0.00%|        "Remove current thread from the dict of currently running threads."
   991|         0|            0|            0|  0.00%|
   992|         0|            0|            0|  0.00%|        # Notes about running with _dummy_thread:
   993|         0|            0|            0|  0.00%|        #
   994|         0|            0|            0|  0.00%|        # Must take care to not raise an exception if _dummy_thread is being
   995|         0|            0|            0|  0.00%|        # used (and thus this module is being used as an instance of
   996|         0|            0|            0|  0.00%|        # dummy_threading).  _dummy_thread.get_ident() always returns -1 since
   997|         0|            0|            0|  0.00%|        # there is only one thread if _dummy_thread is being used.  Thus
   998|         0|            0|            0|  0.00%|        # len(_active) is always <= 1 here, and any Thread instance created
   999|         0|            0|            0|  0.00%|        # overwrites the (if any) thread currently registered in _active.
  1000|         0|            0|            0|  0.00%|        #
  1001|         0|            0|            0|  0.00%|        # An instance of _MainThread is always created by 'threading'.  This
  1002|         0|            0|            0|  0.00%|        # gets overwritten the instant an instance of Thread is created; both
  1003|         0|            0|            0|  0.00%|        # threads return -1 from _dummy_thread.get_ident() and thus have the
  1004|         0|            0|            0|  0.00%|        # same key in the dict.  So when the _MainThread instance created by
  1005|         0|            0|            0|  0.00%|        # 'threading' tries to clean itself up when atexit calls this method
  1006|         0|            0|            0|  0.00%|        # it gets a KeyError if another Thread instance was created.
  1007|         0|            0|            0|  0.00%|        #
  1008|         0|            0|            0|  0.00%|        # This all means that KeyError from trying to delete something from
  1009|         0|            0|            0|  0.00%|        # _active if dummy_threading is being used is a red herring.  But
  1010|         0|            0|            0|  0.00%|        # since it isn't if dummy_threading is *not* being used then don't
  1011|         0|            0|            0|  0.00%|        # hide the exception.
  1012|         0|            0|            0|  0.00%|
  1013|         0|            0|            0|  0.00%|        try:
  1014|         0|            0|            0|  0.00%|            with _active_limbo_lock:
  1015|         0|            0|            0|  0.00%|                del _active[get_ident()]
  1016|         0|            0|            0|  0.00%|                # There must not be any python code between the previous line
  1017|         0|            0|            0|  0.00%|                # and after the lock is released.  Otherwise a tracing function
  1018|         0|            0|            0|  0.00%|                # could try to acquire the lock again in the same thread, (in
  1019|         0|            0|            0|  0.00%|                # current_thread()), and would block.
  1020|         0|            0|            0|  0.00%|        except KeyError:
  1021|         0|            0|            0|  0.00%|            if 'dummy_threading' not in _sys.modules:
  1022|         0|            0|            0|  0.00%|                raise
  1023|         0|            0|            0|  0.00%|
  1024|         0|            0|            0|  0.00%|    def join(self, timeout=None):
  1025|         0|            0|            0|  0.00%|        """Wait until the thread terminates.
  1026|         0|            0|            0|  0.00%|
  1027|         0|            0|            0|  0.00%|        This blocks the calling thread until the thread whose join() method is
  1028|         0|            0|            0|  0.00%|        called terminates -- either normally or through an unhandled exception
  1029|         0|            0|            0|  0.00%|        or until the optional timeout occurs.
  1030|         0|            0|            0|  0.00%|
  1031|         0|            0|            0|  0.00%|        When the timeout argument is present and not None, it should be a
  1032|         0|            0|            0|  0.00%|        floating point number specifying a timeout for the operation in seconds
  1033|         0|            0|            0|  0.00%|        (or fractions thereof). As join() always returns None, you must call
  1034|         0|            0|            0|  0.00%|        isAlive() after join() to decide whether a timeout happened -- if the
  1035|         0|            0|            0|  0.00%|        thread is still alive, the join() call timed out.
  1036|         0|            0|            0|  0.00%|
  1037|         0|            0|            0|  0.00%|        When the timeout argument is not present or None, the operation will
  1038|         0|            0|            0|  0.00%|        block until the thread terminates.
  1039|         0|            0|            0|  0.00%|
  1040|         0|            0|            0|  0.00%|        A thread can be join()ed many times.
  1041|         0|            0|            0|  0.00%|
  1042|         0|            0|            0|  0.00%|        join() raises a RuntimeError if an attempt is made to join the current
  1043|         0|            0|            0|  0.00%|        thread as that would cause a deadlock. It is also an error to join() a
  1044|         0|            0|            0|  0.00%|        thread before it has been started and attempts to do so raises the same
  1045|         0|            0|            0|  0.00%|        exception.
  1046|         0|            0|            0|  0.00%|
  1047|         0|            0|            0|  0.00%|        """
  1048|         0|            0|            0|  0.00%|        if not self._initialized:
  1049|         0|            0|            0|  0.00%|            raise RuntimeError("Thread.__init__() not called")
  1050|         0|            0|            0|  0.00%|        if not self._started.is_set():
  1051|         0|            0|            0|  0.00%|            raise RuntimeError("cannot join thread before it is started")
  1052|         0|            0|            0|  0.00%|        if self is current_thread():
  1053|         0|            0|            0|  0.00%|            raise RuntimeError("cannot join current thread")
  1054|         0|            0|            0|  0.00%|
  1055|         0|            0|            0|  0.00%|        if timeout is None:
  1056|         0|            0|            0|  0.00%|            self._wait_for_tstate_lock()
  1057|         0|            0|            0|  0.00%|        else:
  1058|         0|            0|            0|  0.00%|            # the behavior of a negative timeout isn't documented, but
  1059|         0|            0|            0|  0.00%|            # historically .join(timeout=x) for x<0 has acted as if timeout=0
  1060|         0|            0|            0|  0.00%|            self._wait_for_tstate_lock(timeout=max(timeout, 0))
  1061|         0|            0|            0|  0.00%|
  1062|         0|            0|            0|  0.00%|    def _wait_for_tstate_lock(self, block=True, timeout=-1):
  1063|         0|            0|            0|  0.00%|        # Issue #18808: wait for the thread state to be gone.
  1064|         0|            0|            0|  0.00%|        # At the end of the thread's life, after all knowledge of the thread
  1065|         0|            0|            0|  0.00%|        # is removed from C data structures, C code releases our _tstate_lock.
  1066|         0|            0|            0|  0.00%|        # This method passes its arguments to _tstate_lock.acquire().
  1067|         0|            0|            0|  0.00%|        # If the lock is acquired, the C code is done, and self._stop() is
  1068|         0|            0|            0|  0.00%|        # called.  That sets ._is_stopped to True, and ._tstate_lock to None.
  1069|         0|            0|            0|  0.00%|        lock = self._tstate_lock
  1070|         0|            0|            0|  0.00%|        if lock is None:  # already determined that the C code is done
  1071|         0|            0|            0|  0.00%|            assert self._is_stopped
  1072|         0|            0|            0|  0.00%|        elif lock.acquire(block, timeout):
  1073|         0|            0|            0|  0.00%|            lock.release()
  1074|         0|            0|            0|  0.00%|            self._stop()
  1075|         0|            0|            0|  0.00%|
  1076|         0|            0|            0|  0.00%|    @property
  1077|         0|            0|            0|  0.00%|    def name(self):
  1078|         0|            0|            0|  0.00%|        """A string used for identification purposes only.
  1079|         0|            0|            0|  0.00%|
  1080|         0|            0|            0|  0.00%|        It has no semantics. Multiple threads may be given the same name. The
  1081|         0|            0|            0|  0.00%|        initial name is set by the constructor.
  1082|         0|            0|            0|  0.00%|
  1083|         0|            0|            0|  0.00%|        """
  1084|         0|            0|            0|  0.00%|        assert self._initialized, "Thread.__init__() not called"
  1085|         0|            0|            0|  0.00%|        return self._name
  1086|         0|            0|            0|  0.00%|
  1087|         0|            0|            0|  0.00%|    @name.setter
  1088|         0|            0|            0|  0.00%|    def name(self, name):
  1089|         0|            0|            0|  0.00%|        assert self._initialized, "Thread.__init__() not called"
  1090|         0|            0|            0|  0.00%|        self._name = str(name)
  1091|         0|            0|            0|  0.00%|
  1092|         0|            0|            0|  0.00%|    @property
  1093|         0|            0|            0|  0.00%|    def ident(self):
  1094|         0|            0|            0|  0.00%|        """Thread identifier of this thread or None if it has not been started.
  1095|         0|            0|            0|  0.00%|
  1096|         0|            0|            0|  0.00%|        This is a nonzero integer. See the thread.get_ident() function. Thread
  1097|         0|            0|            0|  0.00%|        identifiers may be recycled when a thread exits and another thread is
  1098|         0|            0|            0|  0.00%|        created. The identifier is available even after the thread has exited.
  1099|         0|            0|            0|  0.00%|
  1100|         0|            0|            0|  0.00%|        """
  1101|         0|            0|            0|  0.00%|        assert self._initialized, "Thread.__init__() not called"
  1102|         0|            0|            0|  0.00%|        return self._ident
  1103|         0|            0|            0|  0.00%|
  1104|         0|            0|            0|  0.00%|    def is_alive(self):
  1105|         0|            0|            0|  0.00%|        """Return whether the thread is alive.
  1106|         0|            0|            0|  0.00%|
  1107|         0|            0|            0|  0.00%|        This method returns True just before the run() method starts until just
  1108|         0|            0|            0|  0.00%|        after the run() method terminates. The module function enumerate()
  1109|         0|            0|            0|  0.00%|        returns a list of all alive threads.
  1110|         0|            0|            0|  0.00%|
  1111|         0|            0|            0|  0.00%|        """
  1112|         0|            0|            0|  0.00%|        assert self._initialized, "Thread.__init__() not called"
  1113|         0|            0|            0|  0.00%|        if self._is_stopped or not self._started.is_set():
  1114|         0|            0|            0|  0.00%|            return False
  1115|         0|            0|            0|  0.00%|        self._wait_for_tstate_lock(False)
  1116|         0|            0|            0|  0.00%|        return not self._is_stopped
  1117|         0|            0|            0|  0.00%|
  1118|         0|            0|            0|  0.00%|    isAlive = is_alive
  1119|         0|            0|            0|  0.00%|
  1120|         0|            0|            0|  0.00%|    @property
  1121|         0|            0|            0|  0.00%|    def daemon(self):
  1122|         0|            0|            0|  0.00%|        """A boolean value indicating whether this thread is a daemon thread.
  1123|         0|            0|            0|  0.00%|
  1124|         0|            0|            0|  0.00%|        This must be set before start() is called, otherwise RuntimeError is
  1125|         0|            0|            0|  0.00%|        raised. Its initial value is inherited from the creating thread; the
  1126|         0|            0|            0|  0.00%|        main thread is not a daemon thread and therefore all threads created in
  1127|         0|            0|            0|  0.00%|        the main thread default to daemon = False.
  1128|         0|            0|            0|  0.00%|
  1129|         0|            0|            0|  0.00%|        The entire Python program exits when no alive non-daemon threads are
  1130|         0|            0|            0|  0.00%|        left.
  1131|         0|            0|            0|  0.00%|
  1132|         0|            0|            0|  0.00%|        """
  1133|         0|            0|            0|  0.00%|        assert self._initialized, "Thread.__init__() not called"
  1134|         0|            0|            0|  0.00%|        return self._daemonic
  1135|         0|            0|            0|  0.00%|
  1136|         0|            0|            0|  0.00%|    @daemon.setter
  1137|         0|            0|            0|  0.00%|    def daemon(self, daemonic):
  1138|         0|            0|            0|  0.00%|        if not self._initialized:
  1139|         0|            0|            0|  0.00%|            raise RuntimeError("Thread.__init__() not called")
  1140|         0|            0|            0|  0.00%|        if self._started.is_set():
  1141|         0|            0|            0|  0.00%|            raise RuntimeError("cannot set daemon status of active thread")
  1142|         0|            0|            0|  0.00%|        self._daemonic = daemonic
  1143|         0|            0|            0|  0.00%|
  1144|         0|            0|            0|  0.00%|    def isDaemon(self):
  1145|         0|            0|            0|  0.00%|        return self.daemon
  1146|         0|            0|            0|  0.00%|
  1147|         0|            0|            0|  0.00%|    def setDaemon(self, daemonic):
  1148|         0|            0|            0|  0.00%|        self.daemon = daemonic
  1149|         0|            0|            0|  0.00%|
  1150|         0|            0|            0|  0.00%|    def getName(self):
  1151|         0|            0|            0|  0.00%|        return self.name
  1152|         0|            0|            0|  0.00%|
  1153|         0|            0|            0|  0.00%|    def setName(self, name):
  1154|         0|            0|            0|  0.00%|        self.name = name
  1155|         0|            0|            0|  0.00%|
  1156|         0|            0|            0|  0.00%|# The timer class was contributed by Itamar Shtull-Trauring
  1157|         0|            0|            0|  0.00%|
  1158|         0|            0|            0|  0.00%|class Timer(Thread):
  1159|         0|            0|            0|  0.00%|    """Call a function after a specified number of seconds:
  1160|         0|            0|            0|  0.00%|
  1161|         0|            0|            0|  0.00%|            t = Timer(30.0, f, args=None, kwargs=None)
  1162|         0|            0|            0|  0.00%|            t.start()
  1163|         0|            0|            0|  0.00%|            t.cancel()     # stop the timer's action if it's still waiting
  1164|         0|            0|            0|  0.00%|
  1165|         0|            0|            0|  0.00%|    """
  1166|         0|            0|            0|  0.00%|
  1167|         0|            0|            0|  0.00%|    def __init__(self, interval, function, args=None, kwargs=None):
  1168|         0|            0|            0|  0.00%|        Thread.__init__(self)
  1169|         0|            0|            0|  0.00%|        self.interval = interval
  1170|         0|            0|            0|  0.00%|        self.function = function
  1171|         0|            0|            0|  0.00%|        self.args = args if args is not None else []
  1172|         0|            0|            0|  0.00%|        self.kwargs = kwargs if kwargs is not None else {}
  1173|         0|            0|            0|  0.00%|        self.finished = Event()
  1174|         0|            0|            0|  0.00%|
  1175|         0|            0|            0|  0.00%|    def cancel(self):
  1176|         0|            0|            0|  0.00%|        """Stop the timer if it hasn't finished yet."""
  1177|         0|            0|            0|  0.00%|        self.finished.set()
  1178|         0|            0|            0|  0.00%|
  1179|         0|            0|            0|  0.00%|    def run(self):
  1180|         0|            0|            0|  0.00%|        self.finished.wait(self.interval)
  1181|         0|            0|            0|  0.00%|        if not self.finished.is_set():
  1182|         0|            0|            0|  0.00%|            self.function(*self.args, **self.kwargs)
  1183|         0|            0|            0|  0.00%|        self.finished.set()
  1184|         0|            0|            0|  0.00%|
  1185|         0|            0|            0|  0.00%|# Special thread class to represent the main thread
  1186|         0|            0|            0|  0.00%|# This is garbage collected through an exit handler
  1187|         0|            0|            0|  0.00%|
  1188|         0|            0|            0|  0.00%|class _MainThread(Thread):
  1189|         0|            0|            0|  0.00%|
  1190|         0|            0|            0|  0.00%|    def __init__(self):
  1191|         0|            0|            0|  0.00%|        Thread.__init__(self, name="MainThread", daemon=False)
  1192|         0|            0|            0|  0.00%|        self._set_tstate_lock()
  1193|         0|            0|            0|  0.00%|        self._started.set()
  1194|         0|            0|            0|  0.00%|        self._set_ident()
  1195|         0|            0|            0|  0.00%|        with _active_limbo_lock:
  1196|         0|            0|            0|  0.00%|            _active[self._ident] = self
  1197|         0|            0|            0|  0.00%|
  1198|         0|            0|            0|  0.00%|
  1199|         0|            0|            0|  0.00%|# Dummy thread class to represent threads not started here.
  1200|         0|            0|            0|  0.00%|# These aren't garbage collected when they die, nor can they be waited for.
  1201|         0|            0|            0|  0.00%|# If they invoke anything in threading.py that calls current_thread(), they
  1202|         0|            0|            0|  0.00%|# leave an entry in the _active dict forever after.
  1203|         0|            0|            0|  0.00%|# Their purpose is to return *something* from current_thread().
  1204|         0|            0|            0|  0.00%|# They are marked as daemon threads so we won't wait for them
  1205|         0|            0|            0|  0.00%|# when we exit (conform previous semantics).
  1206|         0|            0|            0|  0.00%|
  1207|         0|            0|            0|  0.00%|class _DummyThread(Thread):
  1208|         0|            0|            0|  0.00%|
  1209|         0|            0|            0|  0.00%|    def __init__(self):
  1210|         0|            0|            0|  0.00%|        Thread.__init__(self, name=_newname("Dummy-%d"), daemon=True)
  1211|         0|            0|            0|  0.00%|
  1212|         0|            0|            0|  0.00%|        self._started.set()
  1213|         0|            0|            0|  0.00%|        self._set_ident()
  1214|         0|            0|            0|  0.00%|        with _active_limbo_lock:
  1215|         0|            0|            0|  0.00%|            _active[self._ident] = self
  1216|         0|            0|            0|  0.00%|
  1217|         0|            0|            0|  0.00%|    def _stop(self):
  1218|         0|            0|            0|  0.00%|        pass
  1219|         0|            0|            0|  0.00%|
  1220|         0|            0|            0|  0.00%|    def is_alive(self):
  1221|         0|            0|            0|  0.00%|        assert not self._is_stopped and self._started.is_set()
  1222|         0|            0|            0|  0.00%|        return True
  1223|         0|            0|            0|  0.00%|
  1224|         0|            0|            0|  0.00%|    def join(self, timeout=None):
  1225|         0|            0|            0|  0.00%|        assert False, "cannot join a dummy thread"
  1226|         0|            0|            0|  0.00%|
  1227|         0|            0|            0|  0.00%|
  1228|         0|            0|            0|  0.00%|# Global API functions
  1229|         0|            0|            0|  0.00%|
  1230|         0|            0|            0|  0.00%|def current_thread():
  1231|         0|            0|            0|  0.00%|    """Return the current Thread object, corresponding to the caller's thread of control.
  1232|         0|            0|            0|  0.00%|
  1233|         0|            0|            0|  0.00%|    If the caller's thread of control was not created through the threading
  1234|         0|            0|            0|  0.00%|    module, a dummy thread object with limited functionality is returned.
  1235|         0|            0|            0|  0.00%|
  1236|         0|            0|            0|  0.00%|    """
  1237|         0|            0|            0|  0.00%|    try:
  1238|         0|            0|            0|  0.00%|        return _active[get_ident()]
  1239|         0|            0|            0|  0.00%|    except KeyError:
  1240|         0|            0|            0|  0.00%|        return _DummyThread()
  1241|         0|            0|            0|  0.00%|
  1242|         0|            0|            0|  0.00%|currentThread = current_thread
  1243|         0|            0|            0|  0.00%|
  1244|         0|            0|            0|  0.00%|def active_count():
  1245|         0|            0|            0|  0.00%|    """Return the number of Thread objects currently alive.
  1246|         0|            0|            0|  0.00%|
  1247|         0|            0|            0|  0.00%|    The returned count is equal to the length of the list returned by
  1248|         0|            0|            0|  0.00%|    enumerate().
  1249|         0|            0|            0|  0.00%|
  1250|         0|            0|            0|  0.00%|    """
  1251|         0|            0|            0|  0.00%|    with _active_limbo_lock:
  1252|         0|            0|            0|  0.00%|        return len(_active) + len(_limbo)
  1253|         0|            0|            0|  0.00%|
  1254|         0|            0|            0|  0.00%|activeCount = active_count
  1255|         0|            0|            0|  0.00%|
  1256|         0|            0|            0|  0.00%|def _enumerate():
  1257|         0|            0|            0|  0.00%|    # Same as enumerate(), but without the lock. Internal use only.
  1258|         0|            0|            0|  0.00%|    return list(_active.values()) + list(_limbo.values())
  1259|         0|            0|            0|  0.00%|
  1260|         0|            0|            0|  0.00%|def enumerate():
  1261|         0|            0|            0|  0.00%|    """Return a list of all Thread objects currently alive.
  1262|         0|            0|            0|  0.00%|
  1263|         0|            0|            0|  0.00%|    The list includes daemonic threads, dummy thread objects created by
  1264|         0|            0|            0|  0.00%|    current_thread(), and the main thread. It excludes terminated threads and
  1265|         0|            0|            0|  0.00%|    threads that have not yet been started.
  1266|         0|            0|            0|  0.00%|
  1267|         0|            0|            0|  0.00%|    """
  1268|         0|            0|            0|  0.00%|    with _active_limbo_lock:
  1269|         0|            0|            0|  0.00%|        return list(_active.values()) + list(_limbo.values())
  1270|         0|            0|            0|  0.00%|
  1271|         0|            0|            0|  0.00%|from _thread import stack_size
  1272|         0|            0|            0|  0.00%|
  1273|         0|            0|            0|  0.00%|# Create the main thread object,
  1274|         0|            0|            0|  0.00%|# and make it available for the interpreter
  1275|         0|            0|            0|  0.00%|# (Py_Main) as threading._shutdown.
  1276|         0|            0|            0|  0.00%|
  1277|         0|            0|            0|  0.00%|_main_thread = _MainThread()
  1278|         0|            0|            0|  0.00%|
  1279|         0|            0|            0|  0.00%|def _shutdown():
  1280|         0|            0|            0|  0.00%|    # Obscure:  other threads may be waiting to join _main_thread.  That's
  1281|         0|            0|            0|  0.00%|    # dubious, but some code does it.  We can't wait for C code to release
  1282|         0|            0|            0|  0.00%|    # the main thread's tstate_lock - that won't happen until the interpreter
  1283|         0|            0|            0|  0.00%|    # is nearly dead.  So we release it here.  Note that just calling _stop()
  1284|         0|            0|            0|  0.00%|    # isn't enough:  other threads may already be waiting on _tstate_lock.
  1285|         0|            0|            0|  0.00%|    tlock = _main_thread._tstate_lock
  1286|         0|            0|            0|  0.00%|    # The main thread isn't finished yet, so its thread state lock can't have
  1287|         0|            0|            0|  0.00%|    # been released.
  1288|         0|            0|            0|  0.00%|    assert tlock is not None
  1289|         0|            0|            0|  0.00%|    assert tlock.locked()
  1290|         0|            0|            0|  0.00%|    tlock.release()
  1291|         0|            0|            0|  0.00%|    _main_thread._stop()
  1292|         0|            0|            0|  0.00%|    t = _pickSomeNonDaemonThread()
  1293|         0|            0|            0|  0.00%|    while t:
  1294|         0|            0|            0|  0.00%|        t.join()
  1295|         0|            0|            0|  0.00%|        t = _pickSomeNonDaemonThread()
  1296|         0|            0|            0|  0.00%|    _main_thread._delete()
  1297|         0|            0|            0|  0.00%|
  1298|         0|            0|            0|  0.00%|def _pickSomeNonDaemonThread():
  1299|         0|            0|            0|  0.00%|    for t in enumerate():
  1300|         0|            0|            0|  0.00%|        if not t.daemon and t.is_alive():
  1301|         0|            0|            0|  0.00%|            return t
  1302|         0|            0|            0|  0.00%|    return None
  1303|         0|            0|            0|  0.00%|
  1304|         0|            0|            0|  0.00%|def main_thread():
  1305|         0|            0|            0|  0.00%|    """Return the main thread object.
  1306|         0|            0|            0|  0.00%|
  1307|         0|            0|            0|  0.00%|    In normal conditions, the main thread is the thread from which the
  1308|         0|            0|            0|  0.00%|    Python interpreter was started.
  1309|         0|            0|            0|  0.00%|    """
  1310|         0|            0|            0|  0.00%|    return _main_thread
  1311|         0|            0|            0|  0.00%|
  1312|         0|            0|            0|  0.00%|# get thread-local implementation, either from the thread
  1313|         0|            0|            0|  0.00%|# module, or from the python fallback
  1314|         0|            0|            0|  0.00%|
  1315|         0|            0|            0|  0.00%|try:
  1316|         0|            0|            0|  0.00%|    from _thread import _local as local
  1317|         0|            0|            0|  0.00%|except ImportError:
  1318|         0|            0|            0|  0.00%|    from _threading_local import local
  1319|         0|            0|            0|  0.00%|
  1320|         0|            0|            0|  0.00%|
  1321|         0|            0|            0|  0.00%|def _after_fork():
  1322|         0|            0|            0|  0.00%|    # This function is called by Python/ceval.c:PyEval_ReInitThreads which
  1323|         0|            0|            0|  0.00%|    # is called from PyOS_AfterFork.  Here we cleanup threading module state
  1324|         0|            0|            0|  0.00%|    # that should not exist after a fork.
  1325|         0|            0|            0|  0.00%|
  1326|         0|            0|            0|  0.00%|    # Reset _active_limbo_lock, in case we forked while the lock was held
  1327|         0|            0|            0|  0.00%|    # by another (non-forked) thread.  http://bugs.python.org/issue874900
  1328|         0|            0|            0|  0.00%|    global _active_limbo_lock, _main_thread
  1329|         0|            0|            0|  0.00%|    _active_limbo_lock = _allocate_lock()
  1330|         0|            0|            0|  0.00%|
  1331|         0|            0|            0|  0.00%|    # fork() only copied the current thread; clear references to others.
  1332|         0|            0|            0|  0.00%|    new_active = {}
  1333|         0|            0|            0|  0.00%|    current = current_thread()
  1334|         0|            0|            0|  0.00%|    _main_thread = current
  1335|         0|            0|            0|  0.00%|    with _active_limbo_lock:
  1336|         0|            0|            0|  0.00%|        # Dangling thread instances must still have their locks reset,
  1337|         0|            0|            0|  0.00%|        # because someone may join() them.
  1338|         0|            0|            0|  0.00%|        threads = set(_enumerate())
  1339|         0|            0|            0|  0.00%|        threads.update(_dangling)
  1340|         0|            0|            0|  0.00%|        for thread in threads:
  1341|         0|            0|            0|  0.00%|            # Any lock/condition variable may be currently locked or in an
  1342|         0|            0|            0|  0.00%|            # invalid state, so we reinitialize them.
  1343|         0|            0|            0|  0.00%|            if thread is current:
  1344|         0|            0|            0|  0.00%|                # There is only one active thread. We reset the ident to
  1345|         0|            0|            0|  0.00%|                # its new value since it can have changed.
  1346|         0|            0|            0|  0.00%|                thread._reset_internal_locks(True)
  1347|         0|            0|            0|  0.00%|                ident = get_ident()
  1348|         0|            0|            0|  0.00%|                thread._ident = ident
  1349|         0|            0|            0|  0.00%|                new_active[ident] = thread
  1350|         0|            0|            0|  0.00%|            else:
  1351|         0|            0|            0|  0.00%|                # All the others are already stopped.
  1352|         0|            0|            0|  0.00%|                thread._reset_internal_locks(False)
  1353|         0|            0|            0|  0.00%|                thread._stop()
  1354|         0|            0|            0|  0.00%|
  1355|         0|            0|            0|  0.00%|        _limbo.clear()
  1356|         0|            0|            0|  0.00%|        _active.clear()
  1357|         0|            0|            0|  0.00%|        _active.update(new_active)
  1358|         0|            0|            0|  0.00%|        assert len(_active) == 1
File: D:\Application\Anaconda\lib\socket.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# Wrapper module for _socket, providing some additional facilities
     2|         0|            0|            0|  0.00%|# implemented in Python.
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|"""\
     5|         0|            0|            0|  0.00%|This module provides socket operations and some related functions.
     6|         0|            0|            0|  0.00%|On Unix, it supports IP (Internet Protocol) and Unix domain sockets.
     7|         0|            0|            0|  0.00%|On other systems, it only supports IP. Functions specific for a
     8|         0|            0|            0|  0.00%|socket are available as methods of the socket object.
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|Functions:
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|socket() -- create a new socket object
    13|         0|            0|            0|  0.00%|socketpair() -- create a pair of new socket objects [*]
    14|         0|            0|            0|  0.00%|fromfd() -- create a socket object from an open file descriptor [*]
    15|         0|            0|            0|  0.00%|fromshare() -- create a socket object from data received from socket.share() [*]
    16|         0|            0|            0|  0.00%|gethostname() -- return the current hostname
    17|         0|            0|            0|  0.00%|gethostbyname() -- map a hostname to its IP number
    18|         0|            0|            0|  0.00%|gethostbyaddr() -- map an IP number or hostname to DNS info
    19|         0|            0|            0|  0.00%|getservbyname() -- map a service name and a protocol name to a port number
    20|         0|            0|            0|  0.00%|getprotobyname() -- map a protocol name (e.g. 'tcp') to a number
    21|         0|            0|            0|  0.00%|ntohs(), ntohl() -- convert 16, 32 bit int from network to host byte order
    22|         0|            0|            0|  0.00%|htons(), htonl() -- convert 16, 32 bit int from host to network byte order
    23|         0|            0|            0|  0.00%|inet_aton() -- convert IP addr string (123.45.67.89) to 32-bit packed format
    24|         0|            0|            0|  0.00%|inet_ntoa() -- convert 32-bit packed format IP to string (123.45.67.89)
    25|         0|            0|            0|  0.00%|socket.getdefaulttimeout() -- get the default timeout value
    26|         0|            0|            0|  0.00%|socket.setdefaulttimeout() -- set the default timeout value
    27|         0|            0|            0|  0.00%|create_connection() -- connects to an address, with an optional timeout and
    28|         0|            0|            0|  0.00%|                       optional source address.
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%| [*] not available on all platforms!
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|Special objects:
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|SocketType -- type object for socket objects
    35|         0|            0|            0|  0.00%|error -- exception raised for I/O errors
    36|         0|            0|            0|  0.00%|has_ipv6 -- boolean value indicating if IPv6 is supported
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|IntEnum constants:
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|AF_INET, AF_UNIX -- socket domains (first argument to socket() call)
    41|         0|            0|            0|  0.00%|SOCK_STREAM, SOCK_DGRAM, SOCK_RAW -- socket types (second argument)
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|Integer constants:
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|Many other constants may be defined; these may be used in calls to
    46|         0|            0|            0|  0.00%|the setsockopt() and getsockopt() methods.
    47|         0|            0|            0|  0.00%|"""
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|import _socket
    50|         0|            0|            0|  0.00%|from _socket import *
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|import os, sys, io, selectors
    53|         0|            0|            0|  0.00%|from enum import IntEnum, IntFlag
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|try:
    56|         0|            0|            0|  0.00%|    import errno
    57|         0|            0|            0|  0.00%|except ImportError:
    58|         0|            0|            0|  0.00%|    errno = None
    59|         0|            0|            0|  0.00%|EBADF = getattr(errno, 'EBADF', 9)
    60|         0|            0|            0|  0.00%|EAGAIN = getattr(errno, 'EAGAIN', 11)
    61|         0|            0|            0|  0.00%|EWOULDBLOCK = getattr(errno, 'EWOULDBLOCK', 11)
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|__all__ = ["fromfd", "getfqdn", "create_connection",
    64|         0|            0|            0|  0.00%|        "AddressFamily", "SocketKind"]
    65|         0|            0|            0|  0.00%|__all__.extend(os._get_exports_list(_socket))
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|# Set up the socket.AF_* socket.SOCK_* constants as members of IntEnums for
    68|         0|            0|            0|  0.00%|# nicer string representations.
    69|         0|            0|            0|  0.00%|# Note that _socket only knows about the integer values. The public interface
    70|         0|            0|            0|  0.00%|# in this module understands the enums and translates them back from integers
    71|         0|            0|            0|  0.00%|# where needed (e.g. .family property of a socket object).
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|IntEnum._convert(
    74|         0|            0|            0|  0.00%|        'AddressFamily',
    75|         0|            0|            0|  0.00%|        __name__,
    76|         0|            0|            0|  0.00%|        lambda C: C.isupper() and C.startswith('AF_'))
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|IntEnum._convert(
    79|         0|            0|            0|  0.00%|        'SocketKind',
    80|         0|            0|            0|  0.00%|        __name__,
    81|         0|            0|            0|  0.00%|        lambda C: C.isupper() and C.startswith('SOCK_'))
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|IntFlag._convert(
    84|         0|            0|            0|  0.00%|        'MsgFlag',
    85|         0|            0|            0|  0.00%|        __name__,
    86|         0|            0|            0|  0.00%|        lambda C: C.isupper() and C.startswith('MSG_'))
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|IntFlag._convert(
    89|         0|            0|            0|  0.00%|        'AddressInfo',
    90|         0|            0|            0|  0.00%|        __name__,
    91|         0|            0|            0|  0.00%|        lambda C: C.isupper() and C.startswith('AI_'))
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|_LOCALHOST    = '127.0.0.1'
    94|         0|            0|            0|  0.00%|_LOCALHOST_V6 = '::1'
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|def _intenum_converter(value, enum_klass):
    98|         0|            0|            0|  0.00%|    """Convert a numeric family value to an IntEnum member.
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|    If it's not a known member, return the numeric value itself.
   101|         0|            0|            0|  0.00%|    """
   102|         0|            0|            0|  0.00%|    try:
   103|         0|            0|            0|  0.00%|        return enum_klass(value)
   104|         0|            0|            0|  0.00%|    except ValueError:
   105|         0|            0|            0|  0.00%|        return value
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|_realsocket = socket
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|# WSA error codes
   110|         0|            0|            0|  0.00%|if sys.platform.lower().startswith("win"):
   111|         0|            0|            0|  0.00%|    errorTab = {}
   112|         0|            0|            0|  0.00%|    errorTab[10004] = "The operation was interrupted."
   113|         0|            0|            0|  0.00%|    errorTab[10009] = "A bad file handle was passed."
   114|         0|            0|            0|  0.00%|    errorTab[10013] = "Permission denied."
   115|         0|            0|            0|  0.00%|    errorTab[10014] = "A fault occurred on the network??" # WSAEFAULT
   116|         0|            0|            0|  0.00%|    errorTab[10022] = "An invalid operation was attempted."
   117|         0|            0|            0|  0.00%|    errorTab[10035] = "The socket operation would block"
   118|         0|            0|            0|  0.00%|    errorTab[10036] = "A blocking operation is already in progress."
   119|         0|            0|            0|  0.00%|    errorTab[10048] = "The network address is in use."
   120|         0|            0|            0|  0.00%|    errorTab[10054] = "The connection has been reset."
   121|         0|            0|            0|  0.00%|    errorTab[10058] = "The network has been shut down."
   122|         0|            0|            0|  0.00%|    errorTab[10060] = "The operation timed out."
   123|         0|            0|            0|  0.00%|    errorTab[10061] = "Connection refused."
   124|         0|            0|            0|  0.00%|    errorTab[10063] = "The name is too long."
   125|         0|            0|            0|  0.00%|    errorTab[10064] = "The host is down."
   126|         0|            0|            0|  0.00%|    errorTab[10065] = "The host is unreachable."
   127|         0|            0|            0|  0.00%|    __all__.append("errorTab")
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|class _GiveupOnSendfile(Exception): pass
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|class socket(_socket.socket):
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|    """A subclass of _socket.socket adding the makefile() method."""
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|    __slots__ = ["__weakref__", "_io_refs", "_closed"]
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|    def __init__(self, family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None):
   140|         0|            0|            0|  0.00%|        # For user code address family and type values are IntEnum members, but
   141|         0|            0|            0|  0.00%|        # for the underlying _socket.socket they're just integers. The
   142|         0|            0|            0|  0.00%|        # constructor of _socket.socket converts the given argument to an
   143|         0|            0|            0|  0.00%|        # integer automatically.
   144|         0|            0|            0|  0.00%|        _socket.socket.__init__(self, family, type, proto, fileno)
   145|         0|            0|            0|  0.00%|        self._io_refs = 0
   146|         0|            0|            0|  0.00%|        self._closed = False
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|    def __enter__(self):
   149|         0|            0|            0|  0.00%|        return self
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|    def __exit__(self, *args):
   152|         0|            0|            0|  0.00%|        if not self._closed:
   153|         0|            0|            0|  0.00%|            self.close()
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|    def __repr__(self):
   156|         0|            0|            0|  0.00%|        """Wrap __repr__() to reveal the real class name and socket
   157|         0|            0|            0|  0.00%|        address(es).
   158|         0|            0|            0|  0.00%|        """
   159|         0|            0|            0|  0.00%|        closed = getattr(self, '_closed', False)
   160|         0|            0|            0|  0.00%|        s = "<%s.%s%s fd=%i, family=%s, type=%s, proto=%i" \
   161|         0|            0|            0|  0.00%|            % (self.__class__.__module__,
   162|         0|            0|            0|  0.00%|               self.__class__.__qualname__,
   163|         0|            0|            0|  0.00%|               " [closed]" if closed else "",
   164|         0|            0|            0|  0.00%|               self.fileno(),
   165|         0|            0|            0|  0.00%|               self.family,
   166|         0|            0|            0|  0.00%|               self.type,
   167|         0|            0|            0|  0.00%|               self.proto)
   168|         0|            0|            0|  0.00%|        if not closed:
   169|         0|            0|            0|  0.00%|            try:
   170|         0|            0|            0|  0.00%|                laddr = self.getsockname()
   171|         0|            0|            0|  0.00%|                if laddr:
   172|         0|            0|            0|  0.00%|                    s += ", laddr=%s" % str(laddr)
   173|         0|            0|            0|  0.00%|            except error:
   174|         0|            0|            0|  0.00%|                pass
   175|         0|            0|            0|  0.00%|            try:
   176|         0|            0|            0|  0.00%|                raddr = self.getpeername()
   177|         0|            0|            0|  0.00%|                if raddr:
   178|         0|            0|            0|  0.00%|                    s += ", raddr=%s" % str(raddr)
   179|         0|            0|            0|  0.00%|            except error:
   180|         0|            0|            0|  0.00%|                pass
   181|         0|            0|            0|  0.00%|        s += '>'
   182|         0|            0|            0|  0.00%|        return s
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|    def __getstate__(self):
   185|         0|            0|            0|  0.00%|        raise TypeError("Cannot serialize socket object")
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|    def dup(self):
   188|         0|            0|            0|  0.00%|        """dup() -> socket object
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|        Duplicate the socket. Return a new socket object connected to the same
   191|         0|            0|            0|  0.00%|        system resource. The new socket is non-inheritable.
   192|         0|            0|            0|  0.00%|        """
   193|         0|            0|            0|  0.00%|        fd = dup(self.fileno())
   194|         0|            0|            0|  0.00%|        sock = self.__class__(self.family, self.type, self.proto, fileno=fd)
   195|         0|            0|            0|  0.00%|        sock.settimeout(self.gettimeout())
   196|         0|            0|            0|  0.00%|        return sock
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    def accept(self):
   199|         0|            0|            0|  0.00%|        """accept() -> (socket object, address info)
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|        Wait for an incoming connection.  Return a new socket
   202|         0|            0|            0|  0.00%|        representing the connection, and the address of the client.
   203|         0|            0|            0|  0.00%|        For IP sockets, the address info is a pair (hostaddr, port).
   204|         0|            0|            0|  0.00%|        """
   205|         0|            0|            0|  0.00%|        fd, addr = self._accept()
   206|         0|            0|            0|  0.00%|        # If our type has the SOCK_NONBLOCK flag, we shouldn't pass it onto the
   207|         0|            0|            0|  0.00%|        # new socket. We do not currently allow passing SOCK_NONBLOCK to
   208|         0|            0|            0|  0.00%|        # accept4, so the returned socket is always blocking.
   209|         0|            0|            0|  0.00%|        type = self.type & ~globals().get("SOCK_NONBLOCK", 0)
   210|         0|            0|            0|  0.00%|        sock = socket(self.family, type, self.proto, fileno=fd)
   211|         0|            0|            0|  0.00%|        # Issue #7995: if no default timeout is set and the listening
   212|         0|            0|            0|  0.00%|        # socket had a (non-zero) timeout, force the new socket in blocking
   213|         0|            0|            0|  0.00%|        # mode to override platform-specific socket flags inheritance.
   214|         0|            0|            0|  0.00%|        if getdefaulttimeout() is None and self.gettimeout():
   215|         0|            0|            0|  0.00%|            sock.setblocking(True)
   216|         0|            0|            0|  0.00%|        return sock, addr
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|    def makefile(self, mode="r", buffering=None, *,
   219|         0|            0|            0|  0.00%|                 encoding=None, errors=None, newline=None):
   220|         0|            0|            0|  0.00%|        """makefile(...) -> an I/O stream connected to the socket
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|        The arguments are as for io.open() after the filename, except the only
   223|         0|            0|            0|  0.00%|        supported mode values are 'r' (default), 'w' and 'b'.
   224|         0|            0|            0|  0.00%|        """
   225|         0|            0|            0|  0.00%|        # XXX refactor to share code?
   226|         0|            0|            0|  0.00%|        if not set(mode) <= {"r", "w", "b"}:
   227|         0|            0|            0|  0.00%|            raise ValueError("invalid mode %r (only r, w, b allowed)" % (mode,))
   228|         0|            0|            0|  0.00%|        writing = "w" in mode
   229|         0|            0|            0|  0.00%|        reading = "r" in mode or not writing
   230|         0|            0|            0|  0.00%|        assert reading or writing
   231|         0|            0|            0|  0.00%|        binary = "b" in mode
   232|         0|            0|            0|  0.00%|        rawmode = ""
   233|         0|            0|            0|  0.00%|        if reading:
   234|         0|            0|            0|  0.00%|            rawmode += "r"
   235|         0|            0|            0|  0.00%|        if writing:
   236|         0|            0|            0|  0.00%|            rawmode += "w"
   237|         0|            0|            0|  0.00%|        raw = SocketIO(self, rawmode)
   238|         0|            0|            0|  0.00%|        self._io_refs += 1
   239|         0|            0|            0|  0.00%|        if buffering is None:
   240|         0|            0|            0|  0.00%|            buffering = -1
   241|         0|            0|            0|  0.00%|        if buffering < 0:
   242|         0|            0|            0|  0.00%|            buffering = io.DEFAULT_BUFFER_SIZE
   243|         0|            0|            0|  0.00%|        if buffering == 0:
   244|         0|            0|            0|  0.00%|            if not binary:
   245|         0|            0|            0|  0.00%|                raise ValueError("unbuffered streams must be binary")
   246|         0|            0|            0|  0.00%|            return raw
   247|         0|            0|            0|  0.00%|        if reading and writing:
   248|         0|            0|            0|  0.00%|            buffer = io.BufferedRWPair(raw, raw, buffering)
   249|         0|            0|            0|  0.00%|        elif reading:
   250|         0|            0|            0|  0.00%|            buffer = io.BufferedReader(raw, buffering)
   251|         0|            0|            0|  0.00%|        else:
   252|         0|            0|            0|  0.00%|            assert writing
   253|         0|            0|            0|  0.00%|            buffer = io.BufferedWriter(raw, buffering)
   254|         0|            0|            0|  0.00%|        if binary:
   255|         0|            0|            0|  0.00%|            return buffer
   256|         0|            0|            0|  0.00%|        text = io.TextIOWrapper(buffer, encoding, errors, newline)
   257|         0|            0|            0|  0.00%|        text.mode = mode
   258|         0|            0|            0|  0.00%|        return text
   259|         0|            0|            0|  0.00%|
   260|         0|            0|            0|  0.00%|    if hasattr(os, 'sendfile'):
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|        def _sendfile_use_sendfile(self, file, offset=0, count=None):
   263|         0|            0|            0|  0.00%|            self._check_sendfile_params(file, offset, count)
   264|         0|            0|            0|  0.00%|            sockno = self.fileno()
   265|         0|            0|            0|  0.00%|            try:
   266|         0|            0|            0|  0.00%|                fileno = file.fileno()
   267|         0|            0|            0|  0.00%|            except (AttributeError, io.UnsupportedOperation) as err:
   268|         0|            0|            0|  0.00%|                raise _GiveupOnSendfile(err)  # not a regular file
   269|         0|            0|            0|  0.00%|            try:
   270|         0|            0|            0|  0.00%|                fsize = os.fstat(fileno).st_size
   271|         0|            0|            0|  0.00%|            except OSError as err:
   272|         0|            0|            0|  0.00%|                raise _GiveupOnSendfile(err)  # not a regular file
   273|         0|            0|            0|  0.00%|            if not fsize:
   274|         0|            0|            0|  0.00%|                return 0  # empty file
   275|         0|            0|            0|  0.00%|            blocksize = fsize if not count else count
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|            timeout = self.gettimeout()
   278|         0|            0|            0|  0.00%|            if timeout == 0:
   279|         0|            0|            0|  0.00%|                raise ValueError("non-blocking sockets are not supported")
   280|         0|            0|            0|  0.00%|            # poll/select have the advantage of not requiring any
   281|         0|            0|            0|  0.00%|            # extra file descriptor, contrarily to epoll/kqueue
   282|         0|            0|            0|  0.00%|            # (also, they require a single syscall).
   283|         0|            0|            0|  0.00%|            if hasattr(selectors, 'PollSelector'):
   284|         0|            0|            0|  0.00%|                selector = selectors.PollSelector()
   285|         0|            0|            0|  0.00%|            else:
   286|         0|            0|            0|  0.00%|                selector = selectors.SelectSelector()
   287|         0|            0|            0|  0.00%|            selector.register(sockno, selectors.EVENT_WRITE)
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|            total_sent = 0
   290|         0|            0|            0|  0.00%|            # localize variable access to minimize overhead
   291|         0|            0|            0|  0.00%|            selector_select = selector.select
   292|         0|            0|            0|  0.00%|            os_sendfile = os.sendfile
   293|         0|            0|            0|  0.00%|            try:
   294|         0|            0|            0|  0.00%|                while True:
   295|         0|            0|            0|  0.00%|                    if timeout and not selector_select(timeout):
   296|         0|            0|            0|  0.00%|                        raise _socket.timeout('timed out')
   297|         0|            0|            0|  0.00%|                    if count:
   298|         0|            0|            0|  0.00%|                        blocksize = count - total_sent
   299|         0|            0|            0|  0.00%|                        if blocksize <= 0:
   300|         0|            0|            0|  0.00%|                            break
   301|         0|            0|            0|  0.00%|                    try:
   302|         0|            0|            0|  0.00%|                        sent = os_sendfile(sockno, fileno, offset, blocksize)
   303|         0|            0|            0|  0.00%|                    except BlockingIOError:
   304|         0|            0|            0|  0.00%|                        if not timeout:
   305|         0|            0|            0|  0.00%|                            # Block until the socket is ready to send some
   306|         0|            0|            0|  0.00%|                            # data; avoids hogging CPU resources.
   307|         0|            0|            0|  0.00%|                            selector_select()
   308|         0|            0|            0|  0.00%|                        continue
   309|         0|            0|            0|  0.00%|                    except OSError as err:
   310|         0|            0|            0|  0.00%|                        if total_sent == 0:
   311|         0|            0|            0|  0.00%|                            # We can get here for different reasons, the main
   312|         0|            0|            0|  0.00%|                            # one being 'file' is not a regular mmap(2)-like
   313|         0|            0|            0|  0.00%|                            # file, in which case we'll fall back on using
   314|         0|            0|            0|  0.00%|                            # plain send().
   315|         0|            0|            0|  0.00%|                            raise _GiveupOnSendfile(err)
   316|         0|            0|            0|  0.00%|                        raise err from None
   317|         0|            0|            0|  0.00%|                    else:
   318|         0|            0|            0|  0.00%|                        if sent == 0:
   319|         0|            0|            0|  0.00%|                            break  # EOF
   320|         0|            0|            0|  0.00%|                        offset += sent
   321|         0|            0|            0|  0.00%|                        total_sent += sent
   322|         0|            0|            0|  0.00%|                return total_sent
   323|         0|            0|            0|  0.00%|            finally:
   324|         0|            0|            0|  0.00%|                if total_sent > 0 and hasattr(file, 'seek'):
   325|         0|            0|            0|  0.00%|                    file.seek(offset)
   326|         0|            0|            0|  0.00%|    else:
   327|         0|            0|            0|  0.00%|        def _sendfile_use_sendfile(self, file, offset=0, count=None):
   328|         0|            0|            0|  0.00%|            raise _GiveupOnSendfile(
   329|         0|            0|            0|  0.00%|                "os.sendfile() not available on this platform")
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|    def _sendfile_use_send(self, file, offset=0, count=None):
   332|         0|            0|            0|  0.00%|        self._check_sendfile_params(file, offset, count)
   333|         0|            0|            0|  0.00%|        if self.gettimeout() == 0:
   334|         0|            0|            0|  0.00%|            raise ValueError("non-blocking sockets are not supported")
   335|         0|            0|            0|  0.00%|        if offset:
   336|         0|            0|            0|  0.00%|            file.seek(offset)
   337|         0|            0|            0|  0.00%|        blocksize = min(count, 8192) if count else 8192
   338|         0|            0|            0|  0.00%|        total_sent = 0
   339|         0|            0|            0|  0.00%|        # localize variable access to minimize overhead
   340|         0|            0|            0|  0.00%|        file_read = file.read
   341|         0|            0|            0|  0.00%|        sock_send = self.send
   342|         0|            0|            0|  0.00%|        try:
   343|         0|            0|            0|  0.00%|            while True:
   344|         0|            0|            0|  0.00%|                if count:
   345|         0|            0|            0|  0.00%|                    blocksize = min(count - total_sent, blocksize)
   346|         0|            0|            0|  0.00%|                    if blocksize <= 0:
   347|         0|            0|            0|  0.00%|                        break
   348|         0|            0|            0|  0.00%|                data = memoryview(file_read(blocksize))
   349|         0|            0|            0|  0.00%|                if not data:
   350|         0|            0|            0|  0.00%|                    break  # EOF
   351|         0|            0|            0|  0.00%|                while True:
   352|         0|            0|            0|  0.00%|                    try:
   353|         0|            0|            0|  0.00%|                        sent = sock_send(data)
   354|         0|            0|            0|  0.00%|                    except BlockingIOError:
   355|         0|            0|            0|  0.00%|                        continue
   356|         0|            0|            0|  0.00%|                    else:
   357|         0|            0|            0|  0.00%|                        total_sent += sent
   358|         0|            0|            0|  0.00%|                        if sent < len(data):
   359|         0|            0|            0|  0.00%|                            data = data[sent:]
   360|         0|            0|            0|  0.00%|                        else:
   361|         0|            0|            0|  0.00%|                            break
   362|         0|            0|            0|  0.00%|            return total_sent
   363|         0|            0|            0|  0.00%|        finally:
   364|         0|            0|            0|  0.00%|            if total_sent > 0 and hasattr(file, 'seek'):
   365|         0|            0|            0|  0.00%|                file.seek(offset + total_sent)
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|    def _check_sendfile_params(self, file, offset, count):
   368|         0|            0|            0|  0.00%|        if 'b' not in getattr(file, 'mode', 'b'):
   369|         0|            0|            0|  0.00%|            raise ValueError("file should be opened in binary mode")
   370|         0|            0|            0|  0.00%|        if not self.type & SOCK_STREAM:
   371|         0|            0|            0|  0.00%|            raise ValueError("only SOCK_STREAM type sockets are supported")
   372|         0|            0|            0|  0.00%|        if count is not None:
   373|         0|            0|            0|  0.00%|            if not isinstance(count, int):
   374|         0|            0|            0|  0.00%|                raise TypeError(
   375|         0|            0|            0|  0.00%|                    "count must be a positive integer (got {!r})".format(count))
   376|         0|            0|            0|  0.00%|            if count <= 0:
   377|         0|            0|            0|  0.00%|                raise ValueError(
   378|         0|            0|            0|  0.00%|                    "count must be a positive integer (got {!r})".format(count))
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|    def sendfile(self, file, offset=0, count=None):
   381|         0|            0|            0|  0.00%|        """sendfile(file[, offset[, count]]) -> sent
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|        Send a file until EOF is reached by using high-performance
   384|         0|            0|            0|  0.00%|        os.sendfile() and return the total number of bytes which
   385|         0|            0|            0|  0.00%|        were sent.
   386|         0|            0|            0|  0.00%|        *file* must be a regular file object opened in binary mode.
   387|         0|            0|            0|  0.00%|        If os.sendfile() is not available (e.g. Windows) or file is
   388|         0|            0|            0|  0.00%|        not a regular file socket.send() will be used instead.
   389|         0|            0|            0|  0.00%|        *offset* tells from where to start reading the file.
   390|         0|            0|            0|  0.00%|        If specified, *count* is the total number of bytes to transmit
   391|         0|            0|            0|  0.00%|        as opposed to sending the file until EOF is reached.
   392|         0|            0|            0|  0.00%|        File position is updated on return or also in case of error in
   393|         0|            0|            0|  0.00%|        which case file.tell() can be used to figure out the number of
   394|         0|            0|            0|  0.00%|        bytes which were sent.
   395|         0|            0|            0|  0.00%|        The socket must be of SOCK_STREAM type.
   396|         0|            0|            0|  0.00%|        Non-blocking sockets are not supported.
   397|         0|            0|            0|  0.00%|        """
   398|         0|            0|            0|  0.00%|        try:
   399|         0|            0|            0|  0.00%|            return self._sendfile_use_sendfile(file, offset, count)
   400|         0|            0|            0|  0.00%|        except _GiveupOnSendfile:
   401|         0|            0|            0|  0.00%|            return self._sendfile_use_send(file, offset, count)
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|    def _decref_socketios(self):
   404|         0|            0|            0|  0.00%|        if self._io_refs > 0:
   405|         0|            0|            0|  0.00%|            self._io_refs -= 1
   406|         0|            0|            0|  0.00%|        if self._closed:
   407|         0|            0|            0|  0.00%|            self.close()
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|    def _real_close(self, _ss=_socket.socket):
   410|         0|            0|            0|  0.00%|        # This function should not reference any globals. See issue #808164.
   411|         0|            0|            0|  0.00%|        _ss.close(self)
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|    def close(self):
   414|         0|            0|            0|  0.00%|        # This function should not reference any globals. See issue #808164.
   415|         0|            0|            0|  0.00%|        self._closed = True
   416|         0|            0|            0|  0.00%|        if self._io_refs <= 0:
   417|         0|            0|            0|  0.00%|            self._real_close()
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|    def detach(self):
   420|         0|            0|            0|  0.00%|        """detach() -> file descriptor
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|        Close the socket object without closing the underlying file descriptor.
   423|         0|            0|            0|  0.00%|        The object cannot be used after this call, but the file descriptor
   424|         0|            0|            0|  0.00%|        can be reused for other purposes.  The file descriptor is returned.
   425|         0|            0|            0|  0.00%|        """
   426|         0|            0|            0|  0.00%|        self._closed = True
   427|         0|            0|            0|  0.00%|        return super().detach()
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|    @property
   430|         0|            0|            0|  0.00%|    def family(self):
   431|         0|            0|            0|  0.00%|        """Read-only access to the address family for this socket.
   432|         0|            0|            0|  0.00%|        """
   433|         0|            0|            0|  0.00%|        return _intenum_converter(super().family, AddressFamily)
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|    @property
   436|         0|            0|            0|  0.00%|    def type(self):
   437|         0|            0|            0|  0.00%|        """Read-only access to the socket type.
   438|         0|            0|            0|  0.00%|        """
   439|         0|            0|            0|  0.00%|        return _intenum_converter(super().type, SocketKind)
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|    if os.name == 'nt':
   442|         0|            0|            0|  0.00%|        def get_inheritable(self):
   443|         0|            0|            0|  0.00%|            return os.get_handle_inheritable(self.fileno())
   444|         0|            0|            0|  0.00%|        def set_inheritable(self, inheritable):
   445|         0|            0|            0|  0.00%|            os.set_handle_inheritable(self.fileno(), inheritable)
   446|         0|            0|            0|  0.00%|    else:
   447|         0|            0|            0|  0.00%|        def get_inheritable(self):
   448|         0|            0|            0|  0.00%|            return os.get_inheritable(self.fileno())
   449|         0|            0|            0|  0.00%|        def set_inheritable(self, inheritable):
   450|         0|            0|            0|  0.00%|            os.set_inheritable(self.fileno(), inheritable)
   451|         0|            0|            0|  0.00%|    get_inheritable.__doc__ = "Get the inheritable flag of the socket"
   452|         0|            0|            0|  0.00%|    set_inheritable.__doc__ = "Set the inheritable flag of the socket"
   453|         0|            0|            0|  0.00%|
   454|         0|            0|            0|  0.00%|def fromfd(fd, family, type, proto=0):
   455|         0|            0|            0|  0.00%|    """ fromfd(fd, family, type[, proto]) -> socket object
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|    Create a socket object from a duplicate of the given file
   458|         0|            0|            0|  0.00%|    descriptor.  The remaining arguments are the same as for socket().
   459|         0|            0|            0|  0.00%|    """
   460|         0|            0|            0|  0.00%|    nfd = dup(fd)
   461|         0|            0|            0|  0.00%|    return socket(family, type, proto, nfd)
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|if hasattr(_socket.socket, "share"):
   464|         0|            0|            0|  0.00%|    def fromshare(info):
   465|         0|            0|            0|  0.00%|        """ fromshare(info) -> socket object
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|        Create a socket object from the bytes object returned by
   468|         0|            0|            0|  0.00%|        socket.share(pid).
   469|         0|            0|            0|  0.00%|        """
   470|         0|            0|            0|  0.00%|        return socket(0, 0, 0, info)
   471|         0|            0|            0|  0.00%|    __all__.append("fromshare")
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|if hasattr(_socket, "socketpair"):
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|    def socketpair(family=None, type=SOCK_STREAM, proto=0):
   476|         0|            0|            0|  0.00%|        """socketpair([family[, type[, proto]]]) -> (socket object, socket object)
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|        Create a pair of socket objects from the sockets returned by the platform
   479|         0|            0|            0|  0.00%|        socketpair() function.
   480|         0|            0|            0|  0.00%|        The arguments are the same as for socket() except the default family is
   481|         0|            0|            0|  0.00%|        AF_UNIX if defined on the platform; otherwise, the default is AF_INET.
   482|         0|            0|            0|  0.00%|        """
   483|         0|            0|            0|  0.00%|        if family is None:
   484|         0|            0|            0|  0.00%|            try:
   485|         0|            0|            0|  0.00%|                family = AF_UNIX
   486|         0|            0|            0|  0.00%|            except NameError:
   487|         0|            0|            0|  0.00%|                family = AF_INET
   488|         0|            0|            0|  0.00%|        a, b = _socket.socketpair(family, type, proto)
   489|         0|            0|            0|  0.00%|        a = socket(family, type, proto, a.detach())
   490|         0|            0|            0|  0.00%|        b = socket(family, type, proto, b.detach())
   491|         0|            0|            0|  0.00%|        return a, b
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|else:
   494|         0|            0|            0|  0.00%|
   495|         0|            0|            0|  0.00%|    # Origin: https://gist.github.com/4325783, by Geert Jansen.  Public domain.
   496|         0|            0|            0|  0.00%|    def socketpair(family=AF_INET, type=SOCK_STREAM, proto=0):
   497|         0|            0|            0|  0.00%|        if family == AF_INET:
   498|         0|            0|            0|  0.00%|            host = _LOCALHOST
   499|         0|            0|            0|  0.00%|        elif family == AF_INET6:
   500|         0|            0|            0|  0.00%|            host = _LOCALHOST_V6
   501|         0|            0|            0|  0.00%|        else:
   502|         0|            0|            0|  0.00%|            raise ValueError("Only AF_INET and AF_INET6 socket address families "
   503|         0|            0|            0|  0.00%|                             "are supported")
   504|         0|            0|            0|  0.00%|        if type != SOCK_STREAM:
   505|         0|            0|            0|  0.00%|            raise ValueError("Only SOCK_STREAM socket type is supported")
   506|         0|            0|            0|  0.00%|        if proto != 0:
   507|         0|            0|            0|  0.00%|            raise ValueError("Only protocol zero is supported")
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|        # We create a connected TCP socket. Note the trick with
   510|         0|            0|            0|  0.00%|        # setblocking(False) that prevents us from having to create a thread.
   511|         0|            0|            0|  0.00%|        lsock = socket(family, type, proto)
   512|         0|            0|            0|  0.00%|        try:
   513|         0|            0|            0|  0.00%|            lsock.bind((host, 0))
   514|         0|            0|            0|  0.00%|            lsock.listen()
   515|         0|            0|            0|  0.00%|            # On IPv6, ignore flow_info and scope_id
   516|         0|            0|            0|  0.00%|            addr, port = lsock.getsockname()[:2]
   517|         0|            0|            0|  0.00%|            csock = socket(family, type, proto)
   518|         0|            0|            0|  0.00%|            try:
   519|         0|            0|            0|  0.00%|                csock.setblocking(False)
   520|         0|            0|            0|  0.00%|                try:
   521|         0|            0|            0|  0.00%|                    csock.connect((addr, port))
   522|         0|            0|            0|  0.00%|                except (BlockingIOError, InterruptedError):
   523|         0|            0|            0|  0.00%|                    pass
   524|         0|            0|            0|  0.00%|                csock.setblocking(True)
   525|         0|            0|            0|  0.00%|                ssock, _ = lsock.accept()
   526|         0|            0|            0|  0.00%|            except:
   527|         0|            0|            0|  0.00%|                csock.close()
   528|         0|            0|            0|  0.00%|                raise
   529|         0|            0|            0|  0.00%|        finally:
   530|         0|            0|            0|  0.00%|            lsock.close()
   531|         0|            0|            0|  0.00%|        return (ssock, csock)
   532|         0|            0|            0|  0.00%|    __all__.append("socketpair")
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|socketpair.__doc__ = """socketpair([family[, type[, proto]]]) -> (socket object, socket object)
   535|         0|            0|            0|  0.00%|Create a pair of socket objects from the sockets returned by the platform
   536|         0|            0|            0|  0.00%|socketpair() function.
   537|         0|            0|            0|  0.00%|The arguments are the same as for socket() except the default family is AF_UNIX
   538|         0|            0|            0|  0.00%|if defined on the platform; otherwise, the default is AF_INET.
   539|         0|            0|            0|  0.00%|"""
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|_blocking_errnos = { EAGAIN, EWOULDBLOCK }
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|class SocketIO(io.RawIOBase):
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|    """Raw I/O implementation for stream sockets.
   546|         0|            0|            0|  0.00%|
   547|         0|            0|            0|  0.00%|    This class supports the makefile() method on sockets.  It provides
   548|         0|            0|            0|  0.00%|    the raw I/O interface on top of a socket object.
   549|         0|            0|            0|  0.00%|    """
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|    # One might wonder why not let FileIO do the job instead.  There are two
   552|         0|            0|            0|  0.00%|    # main reasons why FileIO is not adapted:
   553|         0|            0|            0|  0.00%|    # - it wouldn't work under Windows (where you can't used read() and
   554|         0|            0|            0|  0.00%|    #   write() on a socket handle)
   555|         0|            0|            0|  0.00%|    # - it wouldn't work with socket timeouts (FileIO would ignore the
   556|         0|            0|            0|  0.00%|    #   timeout and consider the socket non-blocking)
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|    # XXX More docs
   559|         0|            0|            0|  0.00%|
   560|         0|            0|            0|  0.00%|    def __init__(self, sock, mode):
   561|         0|            0|            0|  0.00%|        if mode not in ("r", "w", "rw", "rb", "wb", "rwb"):
   562|         0|            0|            0|  0.00%|            raise ValueError("invalid mode: %r" % mode)
   563|         0|            0|            0|  0.00%|        io.RawIOBase.__init__(self)
   564|         0|            0|            0|  0.00%|        self._sock = sock
   565|         0|            0|            0|  0.00%|        if "b" not in mode:
   566|         0|            0|            0|  0.00%|            mode += "b"
   567|         0|            0|            0|  0.00%|        self._mode = mode
   568|         0|            0|            0|  0.00%|        self._reading = "r" in mode
   569|         0|            0|            0|  0.00%|        self._writing = "w" in mode
   570|         0|            0|            0|  0.00%|        self._timeout_occurred = False
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|    def readinto(self, b):
   573|         0|            0|            0|  0.00%|        """Read up to len(b) bytes into the writable buffer *b* and return
   574|         0|            0|            0|  0.00%|        the number of bytes read.  If the socket is non-blocking and no bytes
   575|         0|            0|            0|  0.00%|        are available, None is returned.
   576|         0|            0|            0|  0.00%|
   577|         0|            0|            0|  0.00%|        If *b* is non-empty, a 0 return value indicates that the connection
   578|         0|            0|            0|  0.00%|        was shutdown at the other end.
   579|         0|            0|            0|  0.00%|        """
   580|         0|            0|            0|  0.00%|        self._checkClosed()
   581|         0|            0|            0|  0.00%|        self._checkReadable()
   582|         0|            0|            0|  0.00%|        if self._timeout_occurred:
   583|         0|            0|            0|  0.00%|            raise OSError("cannot read from timed out object")
   584|         0|            0|            0|  0.00%|        while True:
   585|         0|            0|            0|  0.00%|            try:
   586|         2|            0|            0|  0.00%|                return self._sock.recv_into(b)
   587|         0|            0|            0|  0.00%|            except timeout:
   588|         0|            0|            0|  0.00%|                self._timeout_occurred = True
   589|         0|            0|            0|  0.00%|                raise
   590|         0|            0|            0|  0.00%|            except error as e:
   591|         0|            0|            0|  0.00%|                if e.args[0] in _blocking_errnos:
   592|         0|            0|            0|  0.00%|                    return None
   593|         0|            0|            0|  0.00%|                raise
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|    def write(self, b):
   596|         0|            0|            0|  0.00%|        """Write the given bytes or bytearray object *b* to the socket
   597|         0|            0|            0|  0.00%|        and return the number of bytes written.  This can be less than
   598|         0|            0|            0|  0.00%|        len(b) if not all data could be written.  If the socket is
   599|         0|            0|            0|  0.00%|        non-blocking and no bytes could be written None is returned.
   600|         0|            0|            0|  0.00%|        """
   601|         0|            0|            0|  0.00%|        self._checkClosed()
   602|         0|            0|            0|  0.00%|        self._checkWritable()
   603|         0|            0|            0|  0.00%|        try:
   604|         0|            0|            0|  0.00%|            return self._sock.send(b)
   605|         0|            0|            0|  0.00%|        except error as e:
   606|         0|            0|            0|  0.00%|            # XXX what about EINTR?
   607|         0|            0|            0|  0.00%|            if e.args[0] in _blocking_errnos:
   608|         0|            0|            0|  0.00%|                return None
   609|         0|            0|            0|  0.00%|            raise
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|    def readable(self):
   612|         0|            0|            0|  0.00%|        """True if the SocketIO is open for reading.
   613|         0|            0|            0|  0.00%|        """
   614|         0|            0|            0|  0.00%|        if self.closed:
   615|         0|            0|            0|  0.00%|            raise ValueError("I/O operation on closed socket.")
   616|         0|            0|            0|  0.00%|        return self._reading
   617|         0|            0|            0|  0.00%|
   618|         0|            0|            0|  0.00%|    def writable(self):
   619|         0|            0|            0|  0.00%|        """True if the SocketIO is open for writing.
   620|         0|            0|            0|  0.00%|        """
   621|         0|            0|            0|  0.00%|        if self.closed:
   622|         0|            0|            0|  0.00%|            raise ValueError("I/O operation on closed socket.")
   623|         0|            0|            0|  0.00%|        return self._writing
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|    def seekable(self):
   626|         0|            0|            0|  0.00%|        """True if the SocketIO is open for seeking.
   627|         0|            0|            0|  0.00%|        """
   628|         0|            0|            0|  0.00%|        if self.closed:
   629|         0|            0|            0|  0.00%|            raise ValueError("I/O operation on closed socket.")
   630|         0|            0|            0|  0.00%|        return super().seekable()
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|    def fileno(self):
   633|         0|            0|            0|  0.00%|        """Return the file descriptor of the underlying socket.
   634|         0|            0|            0|  0.00%|        """
   635|         0|            0|            0|  0.00%|        self._checkClosed()
   636|         0|            0|            0|  0.00%|        return self._sock.fileno()
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|    @property
   639|         0|            0|            0|  0.00%|    def name(self):
   640|         0|            0|            0|  0.00%|        if not self.closed:
   641|         0|            0|            0|  0.00%|            return self.fileno()
   642|         0|            0|            0|  0.00%|        else:
   643|         0|            0|            0|  0.00%|            return -1
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|    @property
   646|         0|            0|            0|  0.00%|    def mode(self):
   647|         0|            0|            0|  0.00%|        return self._mode
   648|         0|            0|            0|  0.00%|
   649|         0|            0|            0|  0.00%|    def close(self):
   650|         0|            0|            0|  0.00%|        """Close the SocketIO object.  This doesn't close the underlying
   651|         0|            0|            0|  0.00%|        socket, except if all references to it have disappeared.
   652|         0|            0|            0|  0.00%|        """
   653|         0|            0|            0|  0.00%|        if self.closed:
   654|         0|            0|            0|  0.00%|            return
   655|         0|            0|            0|  0.00%|        io.RawIOBase.close(self)
   656|         0|            0|            0|  0.00%|        self._sock._decref_socketios()
   657|         0|            0|            0|  0.00%|        self._sock = None
   658|         0|            0|            0|  0.00%|
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|def getfqdn(name=''):
   661|         0|            0|            0|  0.00%|    """Get fully qualified domain name from name.
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|    An empty argument is interpreted as meaning the local host.
   664|         0|            0|            0|  0.00%|
   665|         0|            0|            0|  0.00%|    First the hostname returned by gethostbyaddr() is checked, then
   666|         0|            0|            0|  0.00%|    possibly existing aliases. In case no FQDN is available, hostname
   667|         0|            0|            0|  0.00%|    from gethostname() is returned.
   668|         0|            0|            0|  0.00%|    """
   669|         0|            0|            0|  0.00%|    name = name.strip()
   670|         0|            0|            0|  0.00%|    if not name or name == '0.0.0.0':
   671|         0|            0|            0|  0.00%|        name = gethostname()
   672|         0|            0|            0|  0.00%|    try:
   673|         0|            0|            0|  0.00%|        hostname, aliases, ipaddrs = gethostbyaddr(name)
   674|         0|            0|            0|  0.00%|    except error:
   675|         0|            0|            0|  0.00%|        pass
   676|         0|            0|            0|  0.00%|    else:
   677|         0|            0|            0|  0.00%|        aliases.insert(0, hostname)
   678|         0|            0|            0|  0.00%|        for name in aliases:
   679|         0|            0|            0|  0.00%|            if '.' in name:
   680|         0|            0|            0|  0.00%|                break
   681|         0|            0|            0|  0.00%|        else:
   682|         0|            0|            0|  0.00%|            name = hostname
   683|         0|            0|            0|  0.00%|    return name
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|
   686|         0|            0|            0|  0.00%|_GLOBAL_DEFAULT_TIMEOUT = object()
   687|         0|            0|            0|  0.00%|
   688|         0|            0|            0|  0.00%|def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,
   689|         0|            0|            0|  0.00%|                      source_address=None):
   690|         0|            0|            0|  0.00%|    """Connect to *address* and return the socket object.
   691|         0|            0|            0|  0.00%|
   692|         0|            0|            0|  0.00%|    Convenience function.  Connect to *address* (a 2-tuple ``(host,
   693|         0|            0|            0|  0.00%|    port)``) and return the socket object.  Passing the optional
   694|         0|            0|            0|  0.00%|    *timeout* parameter will set the timeout on the socket instance
   695|         0|            0|            0|  0.00%|    before attempting to connect.  If no *timeout* is supplied, the
   696|         0|            0|            0|  0.00%|    global default timeout setting returned by :func:`getdefaulttimeout`
   697|         0|            0|            0|  0.00%|    is used.  If *source_address* is set it must be a tuple of (host, port)
   698|         0|            0|            0|  0.00%|    for the socket to bind as a source address before making the connection.
   699|         0|            0|            0|  0.00%|    A host of '' or port 0 tells the OS to use the default.
   700|         0|            0|            0|  0.00%|    """
   701|         0|            0|            0|  0.00%|
   702|         0|            0|            0|  0.00%|    host, port = address
   703|         0|            0|            0|  0.00%|    err = None
   704|         0|            0|            0|  0.00%|    for res in getaddrinfo(host, port, 0, SOCK_STREAM):
   705|         0|            0|            0|  0.00%|        af, socktype, proto, canonname, sa = res
   706|         0|            0|            0|  0.00%|        sock = None
   707|         0|            0|            0|  0.00%|        try:
   708|         0|            0|            0|  0.00%|            sock = socket(af, socktype, proto)
   709|         0|            0|            0|  0.00%|            if timeout is not _GLOBAL_DEFAULT_TIMEOUT:
   710|         0|            0|            0|  0.00%|                sock.settimeout(timeout)
   711|         0|            0|            0|  0.00%|            if source_address:
   712|         0|            0|            0|  0.00%|                sock.bind(source_address)
   713|         0|            0|            0|  0.00%|            sock.connect(sa)
   714|         0|            0|            0|  0.00%|            return sock
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|        except error as _:
   717|         0|            0|            0|  0.00%|            err = _
   718|         0|            0|            0|  0.00%|            if sock is not None:
   719|         0|            0|            0|  0.00%|                sock.close()
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|    if err is not None:
   722|         0|            0|            0|  0.00%|        raise err
   723|         0|            0|            0|  0.00%|    else:
   724|         0|            0|            0|  0.00%|        raise error("getaddrinfo returns an empty list")
   725|         0|            0|            0|  0.00%|
   726|         0|            0|            0|  0.00%|def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
   727|         0|            0|            0|  0.00%|    """Resolve host and port into list of address info entries.
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|    Translate the host/port argument into a sequence of 5-tuples that contain
   730|         0|            0|            0|  0.00%|    all the necessary arguments for creating a socket connected to that service.
   731|         0|            0|            0|  0.00%|    host is a domain name, a string representation of an IPv4/v6 address or
   732|         0|            0|            0|  0.00%|    None. port is a string service name such as 'http', a numeric port number or
   733|         0|            0|            0|  0.00%|    None. By passing None as the value of host and port, you can pass NULL to
   734|         0|            0|            0|  0.00%|    the underlying C API.
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|    The family, type and proto arguments can be optionally specified in order to
   737|         0|            0|            0|  0.00%|    narrow the list of addresses returned. Passing zero as a value for each of
   738|         0|            0|            0|  0.00%|    these arguments selects the full range of results.
   739|         0|            0|            0|  0.00%|    """
   740|         0|            0|            0|  0.00%|    # We override this function since we want to translate the numeric family
   741|         0|            0|            0|  0.00%|    # and socket type values to enum constants.
   742|         0|            0|            0|  0.00%|    addrlist = []
   743|         0|            0|            0|  0.00%|    for res in _socket.getaddrinfo(host, port, family, type, proto, flags):
   744|         0|            0|            0|  0.00%|        af, socktype, proto, canonname, sa = res
   745|         0|            0|            0|  0.00%|        addrlist.append((_intenum_converter(af, AddressFamily),
   746|         0|            0|            0|  0.00%|                         _intenum_converter(socktype, SocketKind),
   747|         0|            0|            0|  0.00%|                         proto, canonname, sa))
   748|         0|            0|            0|  0.00%|    return addrlist
File: D:\Application\Anaconda\lib\genericpath.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|Path operations common to more than one OS
     3|         0|            0|            0|  0.00%|Do not use directly.  The OS specific modules import the appropriate
     4|         0|            0|            0|  0.00%|functions from this module themselves.
     5|         0|            0|            0|  0.00%|"""
     6|         0|            0|            0|  0.00%|import os
     7|         0|            0|            0|  0.00%|import stat
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|__all__ = ['commonprefix', 'exists', 'getatime', 'getctime', 'getmtime',
    10|         0|            0|            0|  0.00%|           'getsize', 'isdir', 'isfile', 'samefile', 'sameopenfile',
    11|         0|            0|            0|  0.00%|           'samestat']
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|# Does a path exist?
    15|         0|            0|            0|  0.00%|# This is false for dangling symbolic links on systems that support them.
    16|         0|            0|            0|  0.00%|def exists(path):
    17|         0|            0|            0|  0.00%|    """Test whether a path exists.  Returns False for broken symbolic links"""
    18|         0|            0|            0|  0.00%|    try:
    19|         1|            0|            0|  0.00%|        os.stat(path)
    20|         0|            0|            0|  0.00%|    except OSError:
    21|         0|            0|            0|  0.00%|        return False
    22|         0|            0|            0|  0.00%|    return True
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|# This follows symbolic links, so both islink() and isdir() can be true
    26|         0|            0|            0|  0.00%|# for the same path on systems that support symlinks
    27|         0|            0|            0|  0.00%|def isfile(path):
    28|         0|            0|            0|  0.00%|    """Test whether a path is a regular file"""
    29|         0|            0|            0|  0.00%|    try:
    30|         0|            0|            0|  0.00%|        st = os.stat(path)
    31|         0|            0|            0|  0.00%|    except OSError:
    32|         0|            0|            0|  0.00%|        return False
    33|         0|            0|            0|  0.00%|    return stat.S_ISREG(st.st_mode)
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|# Is a path a directory?
    37|         0|            0|            0|  0.00%|# This follows symbolic links, so both islink() and isdir()
    38|         0|            0|            0|  0.00%|# can be true for the same path on systems that support symlinks
    39|         0|            0|            0|  0.00%|def isdir(s):
    40|         0|            0|            0|  0.00%|    """Return true if the pathname refers to an existing directory."""
    41|         0|            0|            0|  0.00%|    try:
    42|         0|            0|            0|  0.00%|        st = os.stat(s)
    43|         0|            0|            0|  0.00%|    except OSError:
    44|         0|            0|            0|  0.00%|        return False
    45|         0|            0|            0|  0.00%|    return stat.S_ISDIR(st.st_mode)
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|def getsize(filename):
    49|         0|            0|            0|  0.00%|    """Return the size of a file, reported by os.stat()."""
    50|         0|            0|            0|  0.00%|    return os.stat(filename).st_size
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|def getmtime(filename):
    54|         0|            0|            0|  0.00%|    """Return the last modification time of a file, reported by os.stat()."""
    55|         0|            0|            0|  0.00%|    return os.stat(filename).st_mtime
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|def getatime(filename):
    59|         0|            0|            0|  0.00%|    """Return the last access time of a file, reported by os.stat()."""
    60|         0|            0|            0|  0.00%|    return os.stat(filename).st_atime
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|def getctime(filename):
    64|         0|            0|            0|  0.00%|    """Return the metadata change time of a file, reported by os.stat()."""
    65|         0|            0|            0|  0.00%|    return os.stat(filename).st_ctime
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|# Return the longest prefix of all list elements.
    69|         0|            0|            0|  0.00%|def commonprefix(m):
    70|         0|            0|            0|  0.00%|    "Given a list of pathnames, returns the longest common leading component"
    71|         0|            0|            0|  0.00%|    if not m: return ''
    72|         0|            0|            0|  0.00%|    # Some people pass in a list of pathname parts to operate in an OS-agnostic
    73|         0|            0|            0|  0.00%|    # fashion; don't try to translate in that case as that's an abuse of the
    74|         0|            0|            0|  0.00%|    # API and they are already doing what they need to be OS-agnostic and so
    75|         0|            0|            0|  0.00%|    # they most likely won't be using an os.PathLike object in the sublists.
    76|         0|            0|            0|  0.00%|    if not isinstance(m[0], (list, tuple)):
    77|         0|            0|            0|  0.00%|        m = tuple(map(os.fspath, m))
    78|         0|            0|            0|  0.00%|    s1 = min(m)
    79|         0|            0|            0|  0.00%|    s2 = max(m)
    80|         0|            0|            0|  0.00%|    for i, c in enumerate(s1):
    81|         0|            0|            0|  0.00%|        if c != s2[i]:
    82|         0|            0|            0|  0.00%|            return s1[:i]
    83|         0|            0|            0|  0.00%|    return s1
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|# Are two stat buffers (obtained from stat, fstat or lstat)
    86|         0|            0|            0|  0.00%|# describing the same file?
    87|         0|            0|            0|  0.00%|def samestat(s1, s2):
    88|         0|            0|            0|  0.00%|    """Test whether two stat buffers reference the same file"""
    89|         0|            0|            0|  0.00%|    return (s1.st_ino == s2.st_ino and
    90|         0|            0|            0|  0.00%|            s1.st_dev == s2.st_dev)
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|# Are two filenames really pointing to the same file?
    94|         0|            0|            0|  0.00%|def samefile(f1, f2):
    95|         0|            0|            0|  0.00%|    """Test whether two pathnames reference the same actual file"""
    96|         0|            0|            0|  0.00%|    s1 = os.stat(f1)
    97|         0|            0|            0|  0.00%|    s2 = os.stat(f2)
    98|         0|            0|            0|  0.00%|    return samestat(s1, s2)
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|# Are two open files really referencing the same file?
   102|         0|            0|            0|  0.00%|# (Not necessarily the same file descriptor!)
   103|         0|            0|            0|  0.00%|def sameopenfile(fp1, fp2):
   104|         0|            0|            0|  0.00%|    """Test whether two open file objects reference the same file"""
   105|         0|            0|            0|  0.00%|    s1 = os.fstat(fp1)
   106|         0|            0|            0|  0.00%|    s2 = os.fstat(fp2)
   107|         0|            0|            0|  0.00%|    return samestat(s1, s2)
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|# Split a path in root and extension.
   111|         0|            0|            0|  0.00%|# The extension is everything starting at the last dot in the last
   112|         0|            0|            0|  0.00%|# pathname component; the root is everything before that.
   113|         0|            0|            0|  0.00%|# It is always true that root + ext == p.
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|# Generic implementation of splitext, to be parametrized with
   116|         0|            0|            0|  0.00%|# the separators
   117|         0|            0|            0|  0.00%|def _splitext(p, sep, altsep, extsep):
   118|         0|            0|            0|  0.00%|    """Split the extension from a pathname.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|    Extension is everything from the last dot to the end, ignoring
   121|         0|            0|            0|  0.00%|    leading dots.  Returns "(root, ext)"; ext may be empty."""
   122|         0|            0|            0|  0.00%|    # NOTE: This code must work for text and bytes strings.
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|    sepIndex = p.rfind(sep)
   125|         0|            0|            0|  0.00%|    if altsep:
   126|         0|            0|            0|  0.00%|        altsepIndex = p.rfind(altsep)
   127|         0|            0|            0|  0.00%|        sepIndex = max(sepIndex, altsepIndex)
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|    dotIndex = p.rfind(extsep)
   130|         0|            0|            0|  0.00%|    if dotIndex > sepIndex:
   131|         0|            0|            0|  0.00%|        # skip all leading dots
   132|         0|            0|            0|  0.00%|        filenameIndex = sepIndex + 1
   133|         0|            0|            0|  0.00%|        while filenameIndex < dotIndex:
   134|         0|            0|            0|  0.00%|            if p[filenameIndex:filenameIndex+1] != extsep:
   135|         0|            0|            0|  0.00%|                return p[:dotIndex], p[dotIndex:]
   136|         0|            0|            0|  0.00%|            filenameIndex += 1
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|    return p, p[:0]
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|def _check_arg_types(funcname, *args):
   141|         0|            0|            0|  0.00%|    hasstr = hasbytes = False
   142|         0|            0|            0|  0.00%|    for s in args:
   143|         0|            0|            0|  0.00%|        if isinstance(s, str):
   144|         0|            0|            0|  0.00%|            hasstr = True
   145|         0|            0|            0|  0.00%|        elif isinstance(s, bytes):
   146|         0|            0|            0|  0.00%|            hasbytes = True
   147|         0|            0|            0|  0.00%|        else:
   148|         0|            0|            0|  0.00%|            raise TypeError('%s() argument must be str or bytes, not %r' %
   149|         0|            0|            0|  0.00%|                            (funcname, s.__class__.__name__)) from None
   150|         0|            0|            0|  0.00%|    if hasstr and hasbytes:
   151|         0|            0|            0|  0.00%|        raise TypeError("Can't mix strings and bytes in path components") from None
File: D:\Application\Anaconda\lib\site-packages\ipykernel\ipkernel.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""The IPython kernel implementation"""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import asyncio
     4|         0|            0|            0|  0.00%|from contextlib import contextmanager
     5|         0|            0|            0|  0.00%|from functools import partial
     6|         0|            0|            0|  0.00%|import getpass
     7|         0|            0|            0|  0.00%|import signal
     8|         0|            0|            0|  0.00%|import sys
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|from IPython.core import release
    11|         0|            0|            0|  0.00%|from ipython_genutils.py3compat import builtin_mod, PY3, unicode_type, safe_unicode
    12|         0|            0|            0|  0.00%|from IPython.utils.tokenutil import token_at_cursor, line_at_cursor
    13|         0|            0|            0|  0.00%|from tornado import gen
    14|         0|            0|            0|  0.00%|from traitlets import Instance, Type, Any, List, Bool
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|from .comm import CommManager
    17|         0|            0|            0|  0.00%|from .kernelbase import Kernel as KernelBase
    18|         0|            0|            0|  0.00%|from .zmqshell import ZMQInteractiveShell
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|try:
    21|         0|            0|            0|  0.00%|    from IPython.core.interactiveshell import _asyncio_runner
    22|         0|            0|            0|  0.00%|except ImportError:
    23|         0|            0|            0|  0.00%|    _asyncio_runner = None
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|try:
    26|         0|            0|            0|  0.00%|    from IPython.core.completer import rectify_completions as _rectify_completions, provisionalcompleter as _provisionalcompleter
    27|         0|            0|            0|  0.00%|    _use_experimental_60_completion = True
    28|         0|            0|            0|  0.00%|except ImportError:
    29|         0|            0|            0|  0.00%|    _use_experimental_60_completion = False
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|_EXPERIMENTAL_KEY_NAME = '_jupyter_types_experimental'
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|class IPythonKernel(KernelBase):
    35|         0|            0|            0|  0.00%|    shell = Instance('IPython.core.interactiveshell.InteractiveShellABC',
    36|         0|            0|            0|  0.00%|                     allow_none=True)
    37|         0|            0|            0|  0.00%|    shell_class = Type(ZMQInteractiveShell)
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|    use_experimental_completions = Bool(True,
    40|         0|            0|            0|  0.00%|        help="Set this flag to False to deactivate the use of experimental IPython completion APIs.",
    41|         0|            0|            0|  0.00%|    ).tag(config=True)
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|    user_module = Any()
    44|         0|            0|            0|  0.00%|    def _user_module_changed(self, name, old, new):
    45|         0|            0|            0|  0.00%|        if self.shell is not None:
    46|         0|            0|            0|  0.00%|            self.shell.user_module = new
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|    user_ns = Instance(dict, args=None, allow_none=True)
    49|         0|            0|            0|  0.00%|    def _user_ns_changed(self, name, old, new):
    50|         0|            0|            0|  0.00%|        if self.shell is not None:
    51|         0|            0|            0|  0.00%|            self.shell.user_ns = new
    52|         0|            0|            0|  0.00%|            self.shell.init_user_ns()
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|    # A reference to the Python builtin 'raw_input' function.
    55|         0|            0|            0|  0.00%|    # (i.e., __builtin__.raw_input for Python 2.7, builtins.input for Python 3)
    56|         0|            0|            0|  0.00%|    _sys_raw_input = Any()
    57|         0|            0|            0|  0.00%|    _sys_eval_input = Any()
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|    def __init__(self, **kwargs):
    60|         0|            0|            0|  0.00%|        super(IPythonKernel, self).__init__(**kwargs)
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|        # Initialize the InteractiveShell subclass
    63|         0|            0|            0|  0.00%|        self.shell = self.shell_class.instance(parent=self,
    64|         0|            0|            0|  0.00%|            profile_dir = self.profile_dir,
    65|         0|            0|            0|  0.00%|            user_module = self.user_module,
    66|         0|            0|            0|  0.00%|            user_ns     = self.user_ns,
    67|         0|            0|            0|  0.00%|            kernel      = self,
    68|         0|            0|            0|  0.00%|        )
    69|         0|            0|            0|  0.00%|        self.shell.displayhook.session = self.session
    70|         0|            0|            0|  0.00%|        self.shell.displayhook.pub_socket = self.iopub_socket
    71|         0|            0|            0|  0.00%|        self.shell.displayhook.topic = self._topic('execute_result')
    72|         0|            0|            0|  0.00%|        self.shell.display_pub.session = self.session
    73|         0|            0|            0|  0.00%|        self.shell.display_pub.pub_socket = self.iopub_socket
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|        self.comm_manager = CommManager(parent=self, kernel=self)
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|        self.shell.configurables.append(self.comm_manager)
    78|         0|            0|            0|  0.00%|        comm_msg_types = [ 'comm_open', 'comm_msg', 'comm_close' ]
    79|         0|            0|            0|  0.00%|        for msg_type in comm_msg_types:
    80|         0|            0|            0|  0.00%|            self.shell_handlers[msg_type] = getattr(self.comm_manager, msg_type)
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|    help_links = List([
    83|         0|            0|            0|  0.00%|        {
    84|         0|            0|            0|  0.00%|            'text': "Python Reference",
    85|         0|            0|            0|  0.00%|            'url': "https://docs.python.org/%i.%i" % sys.version_info[:2],
    86|         0|            0|            0|  0.00%|        },
    87|         0|            0|            0|  0.00%|        {
    88|         0|            0|            0|  0.00%|            'text': "IPython Reference",
    89|         0|            0|            0|  0.00%|            'url': "https://ipython.org/documentation.html",
    90|         0|            0|            0|  0.00%|        },
    91|         0|            0|            0|  0.00%|        {
    92|         0|            0|            0|  0.00%|            'text': "NumPy Reference",
    93|         0|            0|            0|  0.00%|            'url': "https://docs.scipy.org/doc/numpy/reference/",
    94|         0|            0|            0|  0.00%|        },
    95|         0|            0|            0|  0.00%|        {
    96|         0|            0|            0|  0.00%|            'text': "SciPy Reference",
    97|         0|            0|            0|  0.00%|            'url': "https://docs.scipy.org/doc/scipy/reference/",
    98|         0|            0|            0|  0.00%|        },
    99|         0|            0|            0|  0.00%|        {
   100|         0|            0|            0|  0.00%|            'text': "Matplotlib Reference",
   101|         0|            0|            0|  0.00%|            'url': "https://matplotlib.org/contents.html",
   102|         0|            0|            0|  0.00%|        },
   103|         0|            0|            0|  0.00%|        {
   104|         0|            0|            0|  0.00%|            'text': "SymPy Reference",
   105|         0|            0|            0|  0.00%|            'url': "http://docs.sympy.org/latest/index.html",
   106|         0|            0|            0|  0.00%|        },
   107|         0|            0|            0|  0.00%|        {
   108|         0|            0|            0|  0.00%|            'text': "pandas Reference",
   109|         0|            0|            0|  0.00%|            'url': "https://pandas.pydata.org/pandas-docs/stable/",
   110|         0|            0|            0|  0.00%|        },
   111|         0|            0|            0|  0.00%|    ]).tag(config=True)
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|    # Kernel info fields
   114|         0|            0|            0|  0.00%|    implementation = 'ipython'
   115|         0|            0|            0|  0.00%|    implementation_version = release.version
   116|         0|            0|            0|  0.00%|    language_info = {
   117|         0|            0|            0|  0.00%|        'name': 'python',
   118|         0|            0|            0|  0.00%|        'version': sys.version.split()[0],
   119|         0|            0|            0|  0.00%|        'mimetype': 'text/x-python',
   120|         0|            0|            0|  0.00%|        'codemirror_mode': {
   121|         0|            0|            0|  0.00%|            'name': 'ipython',
   122|         0|            0|            0|  0.00%|            'version': sys.version_info[0]
   123|         0|            0|            0|  0.00%|        },
   124|         0|            0|            0|  0.00%|        'pygments_lexer': 'ipython%d' % (3 if PY3 else 2),
   125|         0|            0|            0|  0.00%|        'nbconvert_exporter': 'python',
   126|         0|            0|            0|  0.00%|        'file_extension': '.py'
   127|         0|            0|            0|  0.00%|    }
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|    @property
   130|         0|            0|            0|  0.00%|    def banner(self):
   131|         0|            0|            0|  0.00%|        return self.shell.banner
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|    def start(self):
   134|         0|            0|            0|  0.00%|        self.shell.exit_now = False
   135|         0|            0|            0|  0.00%|        super(IPythonKernel, self).start()
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|    def set_parent(self, ident, parent):
   138|         0|            0|            0|  0.00%|        """Overridden from parent to tell the display hook and output streams
   139|         0|            0|            0|  0.00%|        about the parent message.
   140|         0|            0|            0|  0.00%|        """
   141|         0|            0|            0|  0.00%|        super(IPythonKernel, self).set_parent(ident, parent)
   142|         0|            0|            0|  0.00%|        self.shell.set_parent(parent)
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    def init_metadata(self, parent):
   145|         0|            0|            0|  0.00%|        """Initialize metadata.
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|        Run at the beginning of each execution request.
   148|         0|            0|            0|  0.00%|        """
   149|         0|            0|            0|  0.00%|        md = super(IPythonKernel, self).init_metadata(parent)
   150|         0|            0|            0|  0.00%|        # FIXME: remove deprecated ipyparallel-specific code
   151|         0|            0|            0|  0.00%|        # This is required for ipyparallel < 5.0
   152|         0|            0|            0|  0.00%|        md.update({
   153|         0|            0|            0|  0.00%|            'dependencies_met' : True,
   154|         0|            0|            0|  0.00%|            'engine' : self.ident,
   155|         0|            0|            0|  0.00%|        })
   156|         0|            0|            0|  0.00%|        return md
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|    def finish_metadata(self, parent, metadata, reply_content):
   159|         0|            0|            0|  0.00%|        """Finish populating metadata.
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|        Run after completing an execution request.
   162|         0|            0|            0|  0.00%|        """
   163|         0|            0|            0|  0.00%|        # FIXME: remove deprecated ipyparallel-specific code
   164|         0|            0|            0|  0.00%|        # This is required by ipyparallel < 5.0
   165|         0|            0|            0|  0.00%|        metadata['status'] = reply_content['status']
   166|         0|            0|            0|  0.00%|        if reply_content['status'] == 'error' and reply_content['ename'] == 'UnmetDependency':
   167|         0|            0|            0|  0.00%|                metadata['dependencies_met'] = False
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|        return metadata
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|    def _forward_input(self, allow_stdin=False):
   172|         0|            0|            0|  0.00%|        """Forward raw_input and getpass to the current frontend.
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|        via input_request
   175|         0|            0|            0|  0.00%|        """
   176|         0|            0|            0|  0.00%|        self._allow_stdin = allow_stdin
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|        if PY3:
   179|         0|            0|            0|  0.00%|            self._sys_raw_input = builtin_mod.input
   180|         0|            0|            0|  0.00%|            builtin_mod.input = self.raw_input
   181|         0|            0|            0|  0.00%|        else:
   182|         0|            0|            0|  0.00%|            self._sys_raw_input = builtin_mod.raw_input
   183|         0|            0|            0|  0.00%|            self._sys_eval_input = builtin_mod.input
   184|         0|            0|            0|  0.00%|            builtin_mod.raw_input = self.raw_input
   185|         0|            0|            0|  0.00%|            builtin_mod.input = lambda prompt='': eval(self.raw_input(prompt))
   186|         0|            0|            0|  0.00%|        self._save_getpass = getpass.getpass
   187|         0|            0|            0|  0.00%|        getpass.getpass = self.getpass
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|    def _restore_input(self):
   190|         0|            0|            0|  0.00%|        """Restore raw_input, getpass"""
   191|         0|            0|            0|  0.00%|        if PY3:
   192|         0|            0|            0|  0.00%|            builtin_mod.input = self._sys_raw_input
   193|         0|            0|            0|  0.00%|        else:
   194|         0|            0|            0|  0.00%|            builtin_mod.raw_input = self._sys_raw_input
   195|         0|            0|            0|  0.00%|            builtin_mod.input = self._sys_eval_input
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|        getpass.getpass = self._save_getpass
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|    @property
   200|         0|            0|            0|  0.00%|    def execution_count(self):
   201|         0|            0|            0|  0.00%|        return self.shell.execution_count
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|    @execution_count.setter
   204|         0|            0|            0|  0.00%|    def execution_count(self, value):
   205|         0|            0|            0|  0.00%|        # Ignore the incrementing done by KernelBase, in favour of our shell's
   206|         0|            0|            0|  0.00%|        # execution counter.
   207|         0|            0|            0|  0.00%|        pass
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|    @contextmanager
   210|         0|            0|            0|  0.00%|    def _cancel_on_sigint(self, future):
   211|         0|            0|            0|  0.00%|        """ContextManager for capturing SIGINT and cancelling a future
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|        SIGINT raises in the event loop when running async code,
   214|         0|            0|            0|  0.00%|        but we want it to halt a coroutine.
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|        Ideally, it would raise KeyboardInterrupt,
   217|         0|            0|            0|  0.00%|        but this turns it into a CancelledError.
   218|         0|            0|            0|  0.00%|        At least it gets a decent traceback to the user.
   219|         0|            0|            0|  0.00%|        """
   220|         0|            0|            0|  0.00%|        sigint_future = asyncio.Future()
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|        # whichever future finishes first,
   223|         0|            0|            0|  0.00%|        # cancel the other one
   224|         0|            0|            0|  0.00%|        def cancel_unless_done(f, _ignored):
   225|         0|            0|            0|  0.00%|            if f.cancelled() or f.done():
   226|         0|            0|            0|  0.00%|                return
   227|         0|            0|            0|  0.00%|            f.cancel()
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|        # when sigint finishes,
   230|         0|            0|            0|  0.00%|        # abort the coroutine with CancelledError
   231|         0|            0|            0|  0.00%|        sigint_future.add_done_callback(
   232|         0|            0|            0|  0.00%|            partial(cancel_unless_done, future)
   233|         0|            0|            0|  0.00%|        )
   234|         0|            0|            0|  0.00%|        # when the main future finishes,
   235|         0|            0|            0|  0.00%|        # stop watching for SIGINT events
   236|         0|            0|            0|  0.00%|        future.add_done_callback(
   237|         0|            0|            0|  0.00%|            partial(cancel_unless_done, sigint_future)
   238|         0|            0|            0|  0.00%|        )
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|        def handle_sigint(*args):
   241|         0|            0|            0|  0.00%|            def set_sigint_result():
   242|         0|            0|            0|  0.00%|                if sigint_future.cancelled() or sigint_future.done():
   243|         0|            0|            0|  0.00%|                    return
   244|         0|            0|            0|  0.00%|                sigint_future.set_result(1)
   245|         0|            0|            0|  0.00%|            # use add_callback for thread safety
   246|         0|            0|            0|  0.00%|            self.io_loop.add_callback(set_sigint_result)
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|        # set the custom sigint hander during this context
   249|         0|            0|            0|  0.00%|        save_sigint = signal.signal(signal.SIGINT, handle_sigint)
   250|         0|            0|            0|  0.00%|        try:
   251|         0|            0|            0|  0.00%|            yield
   252|         0|            0|            0|  0.00%|        finally:
   253|         0|            0|            0|  0.00%|            # restore the previous sigint handler
   254|         0|            0|            0|  0.00%|            signal.signal(signal.SIGINT, save_sigint)
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|    @gen.coroutine
   257|         0|            0|            0|  0.00%|    def do_execute(self, code, silent, store_history=True,
   258|         0|            0|            0|  0.00%|                   user_expressions=None, allow_stdin=False):
   259|         0|            0|            0|  0.00%|        shell = self.shell # we'll need this a lot here
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|        self._forward_input(allow_stdin)
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|        reply_content = {}
   264|         0|            0|            0|  0.00%|        if hasattr(shell, 'run_cell_async') and hasattr(shell, 'should_run_async'):
   265|         0|            0|            0|  0.00%|            run_cell = shell.run_cell_async
   266|         0|            0|            0|  0.00%|            should_run_async = shell.should_run_async
   267|         0|            0|            0|  0.00%|        else:
   268|         0|            0|            0|  0.00%|            should_run_async = lambda cell: False
   269|         0|            0|            0|  0.00%|            # older IPython,
   270|         0|            0|            0|  0.00%|            # use blocking run_cell and wrap it in coroutine
   271|         0|            0|            0|  0.00%|            @gen.coroutine
   272|         0|            0|            0|  0.00%|            def run_cell(*args, **kwargs):
   273|         0|            0|            0|  0.00%|                return shell.run_cell(*args, **kwargs)
   274|         0|            0|            0|  0.00%|        try:
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|            # default case: runner is asyncio and asyncio is already running
   277|         0|            0|            0|  0.00%|            # TODO: this should check every case for "are we inside the runner",
   278|         0|            0|            0|  0.00%|            # not just asyncio
   279|         0|            0|            0|  0.00%|            if (
   280|         0|            0|            0|  0.00%|                _asyncio_runner
   281|         0|            0|            0|  0.00%|                and should_run_async(code)
   282|         0|            0|            0|  0.00%|                and shell.loop_runner is _asyncio_runner
   283|         0|            0|            0|  0.00%|                and asyncio.get_event_loop().is_running()
   284|         0|            0|            0|  0.00%|            ):
   285|         0|            0|            0|  0.00%|                coro = run_cell(code, store_history=store_history, silent=silent)
   286|         0|            0|            0|  0.00%|                coro_future = asyncio.ensure_future(coro)
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|                with self._cancel_on_sigint(coro_future):
   289|         0|            0|            0|  0.00%|                    res = yield coro_future
   290|         0|            0|            0|  0.00%|            else:
   291|         0|            0|            0|  0.00%|                # runner isn't already running,
   292|         0|            0|            0|  0.00%|                # make synchronous call,
   293|         0|            0|            0|  0.00%|                # letting shell dispatch to loop runners
   294|         0|            0|            0|  0.00%|                res = shell.run_cell(code, store_history=store_history, silent=silent)
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\ipykernel\zmqshell.py:534 run_cell
   295|         0|            0|            0|  0.00%|        finally:
   296|         0|            0|            0|  0.00%|            self._restore_input()
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|        if res.error_before_exec is not None:
   299|         0|            0|            0|  0.00%|            err = res.error_before_exec
   300|         0|            0|            0|  0.00%|        else:
   301|         0|            0|            0|  0.00%|            err = res.error_in_exec
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|        if res.success:
   304|         0|            0|            0|  0.00%|            reply_content[u'status'] = u'ok'
   305|         0|            0|            0|  0.00%|        else:
   306|         0|            0|            0|  0.00%|            reply_content[u'status'] = u'error'
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|            reply_content.update({
   309|         0|            0|            0|  0.00%|                u'traceback': shell._last_traceback or [],
   310|         0|            0|            0|  0.00%|                u'ename': unicode_type(type(err).__name__),
   311|         0|            0|            0|  0.00%|                u'evalue': safe_unicode(err),
   312|         0|            0|            0|  0.00%|            })
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|            # FIXME: deprecated piece for ipyparallel (remove in 5.0):
   315|         0|            0|            0|  0.00%|            e_info = dict(engine_uuid=self.ident, engine_id=self.int_id,
   316|         0|            0|            0|  0.00%|                          method='execute')
   317|         0|            0|            0|  0.00%|            reply_content['engine_info'] = e_info
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|        # Return the execution counter so clients can display prompts
   321|         0|            0|            0|  0.00%|        reply_content['execution_count'] = shell.execution_count - 1
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|        if 'traceback' in reply_content:
   324|         0|            0|            0|  0.00%|            self.log.info("Exception in execute request:\n%s", '\n'.join(reply_content['traceback']))
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|        # At this point, we can tell whether the main code execution succeeded
   328|         0|            0|            0|  0.00%|        # or not.  If it did, we proceed to evaluate user_expressions
   329|         0|            0|            0|  0.00%|        if reply_content['status'] == 'ok':
   330|         0|            0|            0|  0.00%|            reply_content[u'user_expressions'] = \
   331|         0|            0|            0|  0.00%|                         shell.user_expressions(user_expressions or {})
   332|         0|            0|            0|  0.00%|        else:
   333|         0|            0|            0|  0.00%|            # If there was an error, don't even try to compute expressions
   334|         0|            0|            0|  0.00%|            reply_content[u'user_expressions'] = {}
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|        # Payloads should be retrieved regardless of outcome, so we can both
   337|         0|            0|            0|  0.00%|        # recover partial output (that could have been generated early in a
   338|         0|            0|            0|  0.00%|        # block, before an error) and always clear the payload system.
   339|         0|            0|            0|  0.00%|        reply_content[u'payload'] = shell.payload_manager.read_payload()
   340|         0|            0|            0|  0.00%|        # Be aggressive about clearing the payload because we don't want
   341|         0|            0|            0|  0.00%|        # it to sit in memory until the next execute_request comes in.
   342|         0|            0|            0|  0.00%|        shell.payload_manager.clear_payload()
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|        return reply_content
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|    def do_complete(self, code, cursor_pos):
   347|         0|            0|            0|  0.00%|        if _use_experimental_60_completion and self.use_experimental_completions:
   348|         0|            0|            0|  0.00%|            return self._experimental_do_complete(code, cursor_pos)
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|        # FIXME: IPython completers currently assume single line,
   351|         0|            0|            0|  0.00%|        # but completion messages give multi-line context
   352|         0|            0|            0|  0.00%|        # For now, extract line from cell, based on cursor_pos:
   353|         0|            0|            0|  0.00%|        if cursor_pos is None:
   354|         0|            0|            0|  0.00%|            cursor_pos = len(code)
   355|         0|            0|            0|  0.00%|        line, offset = line_at_cursor(code, cursor_pos)
   356|         0|            0|            0|  0.00%|        line_cursor = cursor_pos - offset
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|        txt, matches = self.shell.complete('', line, line_cursor)
   359|         0|            0|            0|  0.00%|        return {'matches' : matches,
   360|         0|            0|            0|  0.00%|                'cursor_end' : cursor_pos,
   361|         0|            0|            0|  0.00%|                'cursor_start' : cursor_pos - len(txt),
   362|         0|            0|            0|  0.00%|                'metadata' : {},
   363|         0|            0|            0|  0.00%|                'status' : 'ok'}
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|    def _experimental_do_complete(self, code, cursor_pos):
   366|         0|            0|            0|  0.00%|        """
   367|         0|            0|            0|  0.00%|        Experimental completions from IPython, using Jedi.
   368|         0|            0|            0|  0.00%|        """
   369|         0|            0|            0|  0.00%|        if cursor_pos is None:
   370|         0|            0|            0|  0.00%|            cursor_pos = len(code)
   371|         0|            0|            0|  0.00%|        with _provisionalcompleter():
   372|         0|            0|            0|  0.00%|            raw_completions = self.shell.Completer.completions(code, cursor_pos)
   373|         0|            0|            0|  0.00%|            completions = list(_rectify_completions(code, raw_completions))
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|            comps = []
   376|         0|            0|            0|  0.00%|            for comp in completions:
   377|         0|            0|            0|  0.00%|                comps.append(dict(
   378|         0|            0|            0|  0.00%|                            start=comp.start,
   379|         0|            0|            0|  0.00%|                            end=comp.end,
   380|         0|            0|            0|  0.00%|                            text=comp.text,
   381|         0|            0|            0|  0.00%|                            type=comp.type,
   382|         0|            0|            0|  0.00%|                ))
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|        if completions:
   385|         0|            0|            0|  0.00%|            s = completions[0].start
   386|         0|            0|            0|  0.00%|            e = completions[0].end
   387|         0|            0|            0|  0.00%|            matches = [c.text for c in completions]
   388|         0|            0|            0|  0.00%|        else:
   389|         0|            0|            0|  0.00%|            s = cursor_pos
   390|         0|            0|            0|  0.00%|            e = cursor_pos
   391|         0|            0|            0|  0.00%|            matches = []
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|        return {'matches': matches,
   394|         0|            0|            0|  0.00%|                'cursor_end': e,
   395|         0|            0|            0|  0.00%|                'cursor_start': s,
   396|         0|            0|            0|  0.00%|                'metadata': {_EXPERIMENTAL_KEY_NAME: comps},
   397|         0|            0|            0|  0.00%|                'status': 'ok'}
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|    def do_inspect(self, code, cursor_pos, detail_level=0):
   402|         0|            0|            0|  0.00%|        name = token_at_cursor(code, cursor_pos)
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|        reply_content = {'status' : 'ok'}
   405|         0|            0|            0|  0.00%|        reply_content['data'] = {}
   406|         0|            0|            0|  0.00%|        reply_content['metadata'] = {}
   407|         0|            0|            0|  0.00%|        try:
   408|         0|            0|            0|  0.00%|            reply_content['data'].update(
   409|         0|            0|            0|  0.00%|                self.shell.object_inspect_mime(
   410|         0|            0|            0|  0.00%|                    name,
   411|         0|            0|            0|  0.00%|                    detail_level=detail_level
   412|         0|            0|            0|  0.00%|                )
   413|         0|            0|            0|  0.00%|            )
   414|         0|            0|            0|  0.00%|            if not self.shell.enable_html_pager:
   415|         0|            0|            0|  0.00%|                reply_content['data'].pop('text/html')
   416|         0|            0|            0|  0.00%|            reply_content['found'] = True
   417|         0|            0|            0|  0.00%|        except KeyError:
   418|         0|            0|            0|  0.00%|            reply_content['found'] = False
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|        return reply_content
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|    def do_history(self, hist_access_type, output, raw, session=0, start=0,
   423|         0|            0|            0|  0.00%|                   stop=None, n=None, pattern=None, unique=False):
   424|         0|            0|            0|  0.00%|        if hist_access_type == 'tail':
   425|         0|            0|            0|  0.00%|            hist = self.shell.history_manager.get_tail(n, raw=raw, output=output,
   426|         0|            0|            0|  0.00%|                                                            include_latest=True)
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|        elif hist_access_type == 'range':
   429|         0|            0|            0|  0.00%|            hist = self.shell.history_manager.get_range(session, start, stop,
   430|         0|            0|            0|  0.00%|                                                        raw=raw, output=output)
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|        elif hist_access_type == 'search':
   433|         0|            0|            0|  0.00%|            hist = self.shell.history_manager.search(
   434|         0|            0|            0|  0.00%|                pattern, raw=raw, output=output, n=n, unique=unique)
   435|         0|            0|            0|  0.00%|        else:
   436|         0|            0|            0|  0.00%|            hist = []
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|        return {
   439|         0|            0|            0|  0.00%|            'status': 'ok',
   440|         0|            0|            0|  0.00%|            'history' : list(hist),
   441|         0|            0|            0|  0.00%|        }
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|    def do_shutdown(self, restart):
   444|         0|            0|            0|  0.00%|        self.shell.exit_now = True
   445|         0|            0|            0|  0.00%|        return dict(status='ok', restart=restart)
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|    def do_is_complete(self, code):
   448|         0|            0|            0|  0.00%|        status, indent_spaces = self.shell.input_splitter.check_complete(code)
   449|         0|            0|            0|  0.00%|        r = {'status': status}
   450|         0|            0|            0|  0.00%|        if status == 'incomplete':
   451|         0|            0|            0|  0.00%|            r['indent'] = ' ' * indent_spaces
   452|         0|            0|            0|  0.00%|        return r
   453|         0|            0|            0|  0.00%|
   454|         0|            0|            0|  0.00%|    def do_apply(self, content, bufs, msg_id, reply_metadata):
   455|         0|            0|            0|  0.00%|        from .serialize import serialize_object, unpack_apply_message
   456|         0|            0|            0|  0.00%|        shell = self.shell
   457|         0|            0|            0|  0.00%|        try:
   458|         0|            0|            0|  0.00%|            working = shell.user_ns
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|            prefix = "_"+str(msg_id).replace("-","")+"_"
   461|         0|            0|            0|  0.00%|
   462|         0|            0|            0|  0.00%|            f,args,kwargs = unpack_apply_message(bufs, working, copy=False)
   463|         0|            0|            0|  0.00%|
   464|         0|            0|            0|  0.00%|            fname = getattr(f, '__name__', 'f')
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|            fname = prefix+"f"
   467|         0|            0|            0|  0.00%|            argname = prefix+"args"
   468|         0|            0|            0|  0.00%|            kwargname = prefix+"kwargs"
   469|         0|            0|            0|  0.00%|            resultname = prefix+"result"
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|            ns = { fname : f, argname : args, kwargname : kwargs , resultname : None }
   472|         0|            0|            0|  0.00%|            # print ns
   473|         0|            0|            0|  0.00%|            working.update(ns)
   474|         0|            0|            0|  0.00%|            code = "%s = %s(*%s,**%s)" % (resultname, fname, argname, kwargname)
   475|         0|            0|            0|  0.00%|            try:
   476|         0|            0|            0|  0.00%|                exec(code, shell.user_global_ns, shell.user_ns)
   477|         0|            0|            0|  0.00%|                result = working.get(resultname)
   478|         0|            0|            0|  0.00%|            finally:
   479|         0|            0|            0|  0.00%|                for key in ns:
   480|         0|            0|            0|  0.00%|                    working.pop(key)
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|            result_buf = serialize_object(result,
   483|         0|            0|            0|  0.00%|                buffer_threshold=self.session.buffer_threshold,
   484|         0|            0|            0|  0.00%|                item_threshold=self.session.item_threshold,
   485|         0|            0|            0|  0.00%|            )
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|        except BaseException as e:
   488|         0|            0|            0|  0.00%|            # invoke IPython traceback formatting
   489|         0|            0|            0|  0.00%|            shell.showtraceback()
   490|         0|            0|            0|  0.00%|            reply_content = {
   491|         0|            0|            0|  0.00%|                u'traceback': shell._last_traceback or [],
   492|         0|            0|            0|  0.00%|                u'ename': unicode_type(type(e).__name__),
   493|         0|            0|            0|  0.00%|                u'evalue': safe_unicode(e),
   494|         0|            0|            0|  0.00%|            }
   495|         0|            0|            0|  0.00%|            # FIXME: deprecated piece for ipyparallel (remove in 5.0):
   496|         0|            0|            0|  0.00%|            e_info = dict(engine_uuid=self.ident, engine_id=self.int_id, method='apply')
   497|         0|            0|            0|  0.00%|            reply_content['engine_info'] = e_info
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|            self.send_response(self.iopub_socket, u'error', reply_content,
   500|         0|            0|            0|  0.00%|                                ident=self._topic('error'))
   501|         0|            0|            0|  0.00%|            self.log.info("Exception in apply request:\n%s", '\n'.join(reply_content['traceback']))
   502|         0|            0|            0|  0.00%|            result_buf = []
   503|         0|            0|            0|  0.00%|            reply_content['status'] = 'error'
   504|         0|            0|            0|  0.00%|        else:
   505|         0|            0|            0|  0.00%|            reply_content = {'status' : 'ok'}
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|        return reply_content, result_buf
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|    def do_clear(self):
   510|         0|            0|            0|  0.00%|        self.shell.reset(False)
   511|         0|            0|            0|  0.00%|        return dict(status='ok')
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|# This exists only for backwards compatibility - use IPythonKernel instead
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|class Kernel(IPythonKernel):
   517|         0|            0|            0|  0.00%|    def __init__(self, *args, **kwargs):
   518|         0|            0|            0|  0.00%|        import warnings
   519|         0|            0|            0|  0.00%|        warnings.warn('Kernel is a deprecated alias of ipykernel.ipkernel.IPythonKernel',
   520|         0|            0|            0|  0.00%|                      DeprecationWarning)
   521|         0|            0|            0|  0.00%|        super(Kernel, self).__init__(*args, **kwargs)
File: D:\Application\Anaconda\lib\site-packages\ipykernel\kernelapp.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""An Application for launching a kernel"""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|# Copyright (c) IPython Development Team.
     4|         0|            0|            0|  0.00%|# Distributed under the terms of the Modified BSD License.
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|from __future__ import print_function
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|import atexit
     9|         0|            0|            0|  0.00%|import os
    10|         0|            0|            0|  0.00%|import sys
    11|         0|            0|            0|  0.00%|import errno
    12|         0|            0|            0|  0.00%|import signal
    13|         0|            0|            0|  0.00%|import traceback
    14|         0|            0|            0|  0.00%|import logging
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|from tornado import ioloop
    17|         0|            0|            0|  0.00%|import zmq
    18|         0|            0|            0|  0.00%|from zmq.eventloop import ioloop as zmq_ioloop
    19|         0|            0|            0|  0.00%|from zmq.eventloop.zmqstream import ZMQStream
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|from IPython.core.application import (
    22|         0|            0|            0|  0.00%|    BaseIPythonApplication, base_flags, base_aliases, catch_config_error
    23|         0|            0|            0|  0.00%|)
    24|         0|            0|            0|  0.00%|from IPython.core.profiledir import ProfileDir
    25|         0|            0|            0|  0.00%|from IPython.core.shellapp import (
    26|         0|            0|            0|  0.00%|    InteractiveShellApp, shell_flags, shell_aliases
    27|         0|            0|            0|  0.00%|)
    28|         0|            0|            0|  0.00%|from ipython_genutils.path import filefind, ensure_dir_exists
    29|         0|            0|            0|  0.00%|from traitlets import (
    30|         0|            0|            0|  0.00%|    Any, Instance, Dict, Unicode, Integer, Bool, DottedObjectName, Type, default
    31|         0|            0|            0|  0.00%|)
    32|         0|            0|            0|  0.00%|from ipython_genutils.importstring import import_item
    33|         0|            0|            0|  0.00%|from jupyter_core.paths import jupyter_runtime_dir
    34|         0|            0|            0|  0.00%|from jupyter_client import write_connection_file
    35|         0|            0|            0|  0.00%|from jupyter_client.connect import ConnectionFileMixin
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|# local imports
    38|         0|            0|            0|  0.00%|from .iostream import IOPubThread
    39|         0|            0|            0|  0.00%|from .heartbeat import Heartbeat
    40|         0|            0|            0|  0.00%|from .ipkernel import IPythonKernel
    41|         0|            0|            0|  0.00%|from .parentpoller import ParentPollerUnix, ParentPollerWindows
    42|         0|            0|            0|  0.00%|from jupyter_client.session import (
    43|         0|            0|            0|  0.00%|    Session, session_flags, session_aliases,
    44|         0|            0|            0|  0.00%|)
    45|         0|            0|            0|  0.00%|from .zmqshell import ZMQInteractiveShell
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
    48|         0|            0|            0|  0.00%|# Flags and Aliases
    49|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|kernel_aliases = dict(base_aliases)
    52|         0|            0|            0|  0.00%|kernel_aliases.update({
    53|         0|            0|            0|  0.00%|    'ip' : 'IPKernelApp.ip',
    54|         0|            0|            0|  0.00%|    'hb' : 'IPKernelApp.hb_port',
    55|         0|            0|            0|  0.00%|    'shell' : 'IPKernelApp.shell_port',
    56|         0|            0|            0|  0.00%|    'iopub' : 'IPKernelApp.iopub_port',
    57|         0|            0|            0|  0.00%|    'stdin' : 'IPKernelApp.stdin_port',
    58|         0|            0|            0|  0.00%|    'control' : 'IPKernelApp.control_port',
    59|         0|            0|            0|  0.00%|    'f' : 'IPKernelApp.connection_file',
    60|         0|            0|            0|  0.00%|    'transport': 'IPKernelApp.transport',
    61|         0|            0|            0|  0.00%|})
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|kernel_flags = dict(base_flags)
    64|         0|            0|            0|  0.00%|kernel_flags.update({
    65|         0|            0|            0|  0.00%|    'no-stdout' : (
    66|         0|            0|            0|  0.00%|            {'IPKernelApp' : {'no_stdout' : True}},
    67|         0|            0|            0|  0.00%|            "redirect stdout to the null device"),
    68|         0|            0|            0|  0.00%|    'no-stderr' : (
    69|         0|            0|            0|  0.00%|            {'IPKernelApp' : {'no_stderr' : True}},
    70|         0|            0|            0|  0.00%|            "redirect stderr to the null device"),
    71|         0|            0|            0|  0.00%|    'pylab' : (
    72|         0|            0|            0|  0.00%|        {'IPKernelApp' : {'pylab' : 'auto'}},
    73|         0|            0|            0|  0.00%|        """Pre-load matplotlib and numpy for interactive use with
    74|         0|            0|            0|  0.00%|        the default matplotlib backend."""),
    75|         0|            0|            0|  0.00%|})
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|# inherit flags&aliases for any IPython shell apps
    78|         0|            0|            0|  0.00%|kernel_aliases.update(shell_aliases)
    79|         0|            0|            0|  0.00%|kernel_flags.update(shell_flags)
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|# inherit flags&aliases for Sessions
    82|         0|            0|            0|  0.00%|kernel_aliases.update(session_aliases)
    83|         0|            0|            0|  0.00%|kernel_flags.update(session_flags)
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|_ctrl_c_message = """\
    86|         0|            0|            0|  0.00%|NOTE: When using the `ipython kernel` entry point, Ctrl-C will not work.
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|To exit, you will have to explicitly quit this process, by either sending
    89|         0|            0|            0|  0.00%|"quit" from a client, or using Ctrl-\\ in UNIX-like environments.
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|To read more about this, see https://github.com/ipython/ipython/issues/2049
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|"""
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
    96|         0|            0|            0|  0.00%|# Application class for starting an IPython Kernel
    97|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|class IPKernelApp(BaseIPythonApplication, InteractiveShellApp,
   100|         0|            0|            0|  0.00%|        ConnectionFileMixin):
   101|         0|            0|            0|  0.00%|    name='ipython-kernel'
   102|         0|            0|            0|  0.00%|    aliases = Dict(kernel_aliases)
   103|         0|            0|            0|  0.00%|    flags = Dict(kernel_flags)
   104|         0|            0|            0|  0.00%|    classes = [IPythonKernel, ZMQInteractiveShell, ProfileDir, Session]
   105|         0|            0|            0|  0.00%|    # the kernel class, as an importstring
   106|         0|            0|            0|  0.00%|    kernel_class = Type('ipykernel.ipkernel.IPythonKernel',
   107|         0|            0|            0|  0.00%|                        klass='ipykernel.kernelbase.Kernel',
   108|         0|            0|            0|  0.00%|    help="""The Kernel subclass to be used.
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|    This should allow easy re-use of the IPKernelApp entry point
   111|         0|            0|            0|  0.00%|    to configure and launch kernels other than IPython's own.
   112|         0|            0|            0|  0.00%|    """).tag(config=True)
   113|         0|            0|            0|  0.00%|    kernel = Any()
   114|         0|            0|            0|  0.00%|    poller = Any() # don't restrict this even though current pollers are all Threads
   115|         0|            0|            0|  0.00%|    heartbeat = Instance(Heartbeat, allow_none=True)
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|    context = Any()
   118|         0|            0|            0|  0.00%|    shell_socket = Any()
   119|         0|            0|            0|  0.00%|    control_socket = Any()
   120|         0|            0|            0|  0.00%|    stdin_socket = Any()
   121|         0|            0|            0|  0.00%|    iopub_socket = Any()
   122|         0|            0|            0|  0.00%|    iopub_thread = Any()
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|    ports = Dict()
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|    subcommands = {
   127|         0|            0|            0|  0.00%|        'install': (
   128|         0|            0|            0|  0.00%|            'ipykernel.kernelspec.InstallIPythonKernelSpecApp',
   129|         0|            0|            0|  0.00%|            'Install the IPython kernel'
   130|         0|            0|            0|  0.00%|        ),
   131|         0|            0|            0|  0.00%|    }
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|    # connection info:
   134|         0|            0|            0|  0.00%|    connection_dir = Unicode()
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|    @default('connection_dir')
   137|         0|            0|            0|  0.00%|    def _default_connection_dir(self):
   138|         0|            0|            0|  0.00%|        return jupyter_runtime_dir()
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|    @property
   141|         0|            0|            0|  0.00%|    def abs_connection_file(self):
   142|         0|            0|            0|  0.00%|        if os.path.basename(self.connection_file) == self.connection_file:
   143|         0|            0|            0|  0.00%|            return os.path.join(self.connection_dir, self.connection_file)
   144|         0|            0|            0|  0.00%|        else:
   145|         0|            0|            0|  0.00%|            return self.connection_file
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|    # streams, etc.
   148|         0|            0|            0|  0.00%|    no_stdout = Bool(False, help="redirect stdout to the null device").tag(config=True)
   149|         0|            0|            0|  0.00%|    no_stderr = Bool(False, help="redirect stderr to the null device").tag(config=True)
   150|         0|            0|            0|  0.00%|    quiet = Bool(True, help="Only send stdout/stderr to output stream").tag(config=True)
   151|         0|            0|            0|  0.00%|    outstream_class = DottedObjectName('ipykernel.iostream.OutStream',
   152|         0|            0|            0|  0.00%|        help="The importstring for the OutStream factory").tag(config=True)
   153|         0|            0|            0|  0.00%|    displayhook_class = DottedObjectName('ipykernel.displayhook.ZMQDisplayHook',
   154|         0|            0|            0|  0.00%|        help="The importstring for the DisplayHook factory").tag(config=True)
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|    # polling
   157|         0|            0|            0|  0.00%|    parent_handle = Integer(int(os.environ.get('JPY_PARENT_PID') or 0),
   158|         0|            0|            0|  0.00%|        help="""kill this process if its parent dies.  On Windows, the argument
   159|         0|            0|            0|  0.00%|        specifies the HANDLE of the parent process, otherwise it is simply boolean.
   160|         0|            0|            0|  0.00%|        """).tag(config=True)
   161|         0|            0|            0|  0.00%|    interrupt = Integer(int(os.environ.get('JPY_INTERRUPT_EVENT') or 0),
   162|         0|            0|            0|  0.00%|        help="""ONLY USED ON WINDOWS
   163|         0|            0|            0|  0.00%|        Interrupt this process when the parent is signaled.
   164|         0|            0|            0|  0.00%|        """).tag(config=True)
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|    def init_crash_handler(self):
   167|         0|            0|            0|  0.00%|        sys.excepthook = self.excepthook
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|    def excepthook(self, etype, evalue, tb):
   170|         0|            0|            0|  0.00%|        # write uncaught traceback to 'real' stderr, not zmq-forwarder
   171|         0|            0|            0|  0.00%|        traceback.print_exception(etype, evalue, tb, file=sys.__stderr__)
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|    def init_poller(self):
   174|         0|            0|            0|  0.00%|        if sys.platform == 'win32':
   175|         0|            0|            0|  0.00%|            if self.interrupt or self.parent_handle:
   176|         0|            0|            0|  0.00%|                self.poller = ParentPollerWindows(self.interrupt, self.parent_handle)
   177|         0|            0|            0|  0.00%|        elif self.parent_handle and self.parent_handle != 1:
   178|         0|            0|            0|  0.00%|            # PID 1 (init) is special and will never go away,
   179|         0|            0|            0|  0.00%|            # only be reassigned.
   180|         0|            0|            0|  0.00%|            # Parent polling doesn't work if ppid == 1 to start with.
   181|         0|            0|            0|  0.00%|            self.poller = ParentPollerUnix()
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    def _try_bind_socket(self, s, port):
   184|         0|            0|            0|  0.00%|        iface = '%s://%s' % (self.transport, self.ip)
   185|         0|            0|            0|  0.00%|        if self.transport == 'tcp':
   186|         0|            0|            0|  0.00%|            if port <= 0:
   187|         0|            0|            0|  0.00%|                port = s.bind_to_random_port(iface)
   188|         0|            0|            0|  0.00%|            else:
   189|         0|            0|            0|  0.00%|                s.bind("tcp://%s:%i" % (self.ip, port))
   190|         0|            0|            0|  0.00%|        elif self.transport == 'ipc':
   191|         0|            0|            0|  0.00%|            if port <= 0:
   192|         0|            0|            0|  0.00%|                port = 1
   193|         0|            0|            0|  0.00%|                path = "%s-%i" % (self.ip, port)
   194|         0|            0|            0|  0.00%|                while os.path.exists(path):
   195|         0|            0|            0|  0.00%|                    port = port + 1
   196|         0|            0|            0|  0.00%|                    path = "%s-%i" % (self.ip, port)
   197|         0|            0|            0|  0.00%|            else:
   198|         0|            0|            0|  0.00%|                path = "%s-%i" % (self.ip, port)
   199|         0|            0|            0|  0.00%|            s.bind("ipc://%s" % path)
   200|         0|            0|            0|  0.00%|        return port
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|    def _bind_socket(self, s, port):
   203|         0|            0|            0|  0.00%|        try:
   204|         0|            0|            0|  0.00%|            win_in_use = errno.WSAEADDRINUSE
   205|         0|            0|            0|  0.00%|        except AttributeError:
   206|         0|            0|            0|  0.00%|            win_in_use = None
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|        # Try up to 100 times to bind a port when in conflict to avoid
   209|         0|            0|            0|  0.00%|        # infinite attempts in bad setups
   210|         0|            0|            0|  0.00%|        max_attempts = 1 if port else 100
   211|         0|            0|            0|  0.00%|        for attempt in range(max_attempts):
   212|         0|            0|            0|  0.00%|            try:
   213|         0|            0|            0|  0.00%|                return self._try_bind_socket(s, port)
   214|         0|            0|            0|  0.00%|            except zmq.ZMQError as ze:
   215|         0|            0|            0|  0.00%|                # Raise if we have any error not related to socket binding
   216|         0|            0|            0|  0.00%|                if ze.errno != errno.EADDRINUSE and ze.errno != win_in_use:
   217|         0|            0|            0|  0.00%|                    raise
   218|         0|            0|            0|  0.00%|                if attempt == max_attempts - 1:
   219|         0|            0|            0|  0.00%|                    raise
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|    def write_connection_file(self):
   222|         0|            0|            0|  0.00%|        """write connection info to JSON file"""
   223|         0|            0|            0|  0.00%|        cf = self.abs_connection_file
   224|         0|            0|            0|  0.00%|        self.log.debug("Writing connection file: %s", cf)
   225|         0|            0|            0|  0.00%|        write_connection_file(cf, ip=self.ip, key=self.session.key, transport=self.transport,
   226|         0|            0|            0|  0.00%|        shell_port=self.shell_port, stdin_port=self.stdin_port, hb_port=self.hb_port,
   227|         0|            0|            0|  0.00%|        iopub_port=self.iopub_port, control_port=self.control_port)
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|    def cleanup_connection_file(self):
   230|         0|            0|            0|  0.00%|        cf = self.abs_connection_file
   231|         0|            0|            0|  0.00%|        self.log.debug("Cleaning up connection file: %s", cf)
   232|         0|            0|            0|  0.00%|        try:
   233|         0|            0|            0|  0.00%|            os.remove(cf)
   234|         0|            0|            0|  0.00%|        except (IOError, OSError):
   235|         0|            0|            0|  0.00%|            pass
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|        self.cleanup_ipc_files()
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|    def init_connection_file(self):
   240|         0|            0|            0|  0.00%|        if not self.connection_file:
   241|         0|            0|            0|  0.00%|            self.connection_file = "kernel-%s.json"%os.getpid()
   242|         0|            0|            0|  0.00%|        try:
   243|         0|            0|            0|  0.00%|            self.connection_file = filefind(self.connection_file, ['.', self.connection_dir])
   244|         0|            0|            0|  0.00%|        except IOError:
   245|         0|            0|            0|  0.00%|            self.log.debug("Connection file not found: %s", self.connection_file)
   246|         0|            0|            0|  0.00%|            # This means I own it, and I'll create it in this directory:
   247|         0|            0|            0|  0.00%|            ensure_dir_exists(os.path.dirname(self.abs_connection_file), 0o700)
   248|         0|            0|            0|  0.00%|            # Also, I will clean it up:
   249|         0|            0|            0|  0.00%|            atexit.register(self.cleanup_connection_file)
   250|         0|            0|            0|  0.00%|            return
   251|         0|            0|            0|  0.00%|        try:
   252|         0|            0|            0|  0.00%|            self.load_connection_file()
   253|         0|            0|            0|  0.00%|        except Exception:
   254|         0|            0|            0|  0.00%|            self.log.error("Failed to load connection file: %r", self.connection_file, exc_info=True)
   255|         0|            0|            0|  0.00%|            self.exit(1)
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|    def init_sockets(self):
   258|         0|            0|            0|  0.00%|        # Create a context, a session, and the kernel sockets.
   259|         0|            0|            0|  0.00%|        self.log.info("Starting the kernel at pid: %i", os.getpid())
   260|         0|            0|            0|  0.00%|        assert self.context is None, "init_sockets cannot be called twice!"
   261|         0|            0|            0|  0.00%|        self.context = context = zmq.Context()
   262|         0|            0|            0|  0.00%|        atexit.register(self.close)
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|        self.shell_socket = context.socket(zmq.ROUTER)
   265|         0|            0|            0|  0.00%|        self.shell_socket.linger = 1000
   266|         0|            0|            0|  0.00%|        self.shell_port = self._bind_socket(self.shell_socket, self.shell_port)
   267|         0|            0|            0|  0.00%|        self.log.debug("shell ROUTER Channel on port: %i" % self.shell_port)
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|        self.stdin_socket = context.socket(zmq.ROUTER)
   270|         0|            0|            0|  0.00%|        self.stdin_socket.linger = 1000
   271|         0|            0|            0|  0.00%|        self.stdin_port = self._bind_socket(self.stdin_socket, self.stdin_port)
   272|         0|            0|            0|  0.00%|        self.log.debug("stdin ROUTER Channel on port: %i" % self.stdin_port)
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|        self.control_socket = context.socket(zmq.ROUTER)
   275|         0|            0|            0|  0.00%|        self.control_socket.linger = 1000
   276|         0|            0|            0|  0.00%|        self.control_port = self._bind_socket(self.control_socket, self.control_port)
   277|         0|            0|            0|  0.00%|        self.log.debug("control ROUTER Channel on port: %i" % self.control_port)
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|        if hasattr(zmq, 'ROUTER_HANDOVER'):
   280|         0|            0|            0|  0.00%|            # set router-handover to workaround zeromq reconnect problems
   281|         0|            0|            0|  0.00%|            # in certain rare circumstances
   282|         0|            0|            0|  0.00%|            # see ipython/ipykernel#270 and zeromq/libzmq#2892
   283|         0|            0|            0|  0.00%|            self.shell_socket.router_handover = \
   284|         0|            0|            0|  0.00%|                self.control_socket.router_handover = \
   285|         0|            0|            0|  0.00%|                self.stdin_socket.router_handover = 1
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|        self.init_iopub(context)
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|    def init_iopub(self, context):
   290|         0|            0|            0|  0.00%|        self.iopub_socket = context.socket(zmq.PUB)
   291|         0|            0|            0|  0.00%|        self.iopub_socket.linger = 1000
   292|         0|            0|            0|  0.00%|        self.iopub_port = self._bind_socket(self.iopub_socket, self.iopub_port)
   293|         0|            0|            0|  0.00%|        self.log.debug("iopub PUB Channel on port: %i" % self.iopub_port)
   294|         0|            0|            0|  0.00%|        self.configure_tornado_logger()
   295|         0|            0|            0|  0.00%|        self.iopub_thread = IOPubThread(self.iopub_socket, pipe=True)
   296|         0|            0|            0|  0.00%|        self.iopub_thread.start()
   297|         0|            0|            0|  0.00%|        # backward-compat: wrap iopub socket API in background thread
   298|         0|            0|            0|  0.00%|        self.iopub_socket = self.iopub_thread.background_socket
   299|         0|            0|            0|  0.00%|
   300|         0|            0|            0|  0.00%|    def init_heartbeat(self):
   301|         0|            0|            0|  0.00%|        """start the heart beating"""
   302|         0|            0|            0|  0.00%|        # heartbeat doesn't share context, because it mustn't be blocked
   303|         0|            0|            0|  0.00%|        # by the GIL, which is accessed by libzmq when freeing zero-copy messages
   304|         0|            0|            0|  0.00%|        hb_ctx = zmq.Context()
   305|         0|            0|            0|  0.00%|        self.heartbeat = Heartbeat(hb_ctx, (self.transport, self.ip, self.hb_port))
   306|         0|            0|            0|  0.00%|        self.hb_port = self.heartbeat.port
   307|         0|            0|            0|  0.00%|        self.log.debug("Heartbeat REP Channel on port: %i" % self.hb_port)
   308|         0|            0|            0|  0.00%|        self.heartbeat.start()
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|    def close(self):
   311|         0|            0|            0|  0.00%|        """Close zmq sockets in an orderly fashion"""
   312|         0|            0|            0|  0.00%|        # un-capture IO before we start closing channels
   313|         0|            0|            0|  0.00%|        self.reset_io()
   314|         0|            0|            0|  0.00%|        self.log.info("Cleaning up sockets")
   315|         0|            0|            0|  0.00%|        if self.heartbeat:
   316|         0|            0|            0|  0.00%|            self.log.debug("Closing heartbeat channel")
   317|         0|            0|            0|  0.00%|            self.heartbeat.context.term()
   318|         0|            0|            0|  0.00%|        if self.iopub_thread:
   319|         0|            0|            0|  0.00%|            self.log.debug("Closing iopub channel")
   320|         0|            0|            0|  0.00%|            self.iopub_thread.stop()
   321|         0|            0|            0|  0.00%|            self.iopub_thread.close()
   322|         0|            0|            0|  0.00%|        for channel in ('shell', 'control', 'stdin'):
   323|         0|            0|            0|  0.00%|            self.log.debug("Closing %s channel", channel)
   324|         0|            0|            0|  0.00%|            socket = getattr(self, channel + "_socket", None)
   325|         0|            0|            0|  0.00%|            if socket and not socket.closed:
   326|         0|            0|            0|  0.00%|                socket.close()
   327|         0|            0|            0|  0.00%|        self.log.debug("Terminating zmq context")
   328|         0|            0|            0|  0.00%|        self.context.term()
   329|         0|            0|            0|  0.00%|        self.log.debug("Terminated zmq context")
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|    def log_connection_info(self):
   332|         0|            0|            0|  0.00%|        """display connection info, and store ports"""
   333|         0|            0|            0|  0.00%|        basename = os.path.basename(self.connection_file)
   334|         0|            0|            0|  0.00%|        if basename == self.connection_file or \
   335|         0|            0|            0|  0.00%|            os.path.dirname(self.connection_file) == self.connection_dir:
   336|         0|            0|            0|  0.00%|            # use shortname
   337|         0|            0|            0|  0.00%|            tail = basename
   338|         0|            0|            0|  0.00%|        else:
   339|         0|            0|            0|  0.00%|            tail = self.connection_file
   340|         0|            0|            0|  0.00%|        lines = [
   341|         0|            0|            0|  0.00%|            "To connect another client to this kernel, use:",
   342|         0|            0|            0|  0.00%|            "    --existing %s" % tail,
   343|         0|            0|            0|  0.00%|        ]
   344|         0|            0|            0|  0.00%|        # log connection info
   345|         0|            0|            0|  0.00%|        # info-level, so often not shown.
   346|         0|            0|            0|  0.00%|        # frontends should use the %connect_info magic
   347|         0|            0|            0|  0.00%|        # to see the connection info
   348|         0|            0|            0|  0.00%|        for line in lines:
   349|         0|            0|            0|  0.00%|            self.log.info(line)
   350|         0|            0|            0|  0.00%|        # also raw print to the terminal if no parent_handle (`ipython kernel`)
   351|         0|            0|            0|  0.00%|        # unless log-level is CRITICAL (--quiet)
   352|         0|            0|            0|  0.00%|        if not self.parent_handle and self.log_level < logging.CRITICAL:
   353|         0|            0|            0|  0.00%|            print(_ctrl_c_message, file=sys.__stdout__)
   354|         0|            0|            0|  0.00%|            for line in lines:
   355|         0|            0|            0|  0.00%|                print(line, file=sys.__stdout__)
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|        self.ports = dict(shell=self.shell_port, iopub=self.iopub_port,
   358|         0|            0|            0|  0.00%|                                stdin=self.stdin_port, hb=self.hb_port,
   359|         0|            0|            0|  0.00%|                                control=self.control_port)
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|    def init_blackhole(self):
   362|         0|            0|            0|  0.00%|        """redirects stdout/stderr to devnull if necessary"""
   363|         0|            0|            0|  0.00%|        if self.no_stdout or self.no_stderr:
   364|         0|            0|            0|  0.00%|            blackhole = open(os.devnull, 'w')
   365|         0|            0|            0|  0.00%|            if self.no_stdout:
   366|         0|            0|            0|  0.00%|                sys.stdout = sys.__stdout__ = blackhole
   367|         0|            0|            0|  0.00%|            if self.no_stderr:
   368|         0|            0|            0|  0.00%|                sys.stderr = sys.__stderr__ = blackhole
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|    def init_io(self):
   371|         0|            0|            0|  0.00%|        """Redirect input streams and set a display hook."""
   372|         0|            0|            0|  0.00%|        if self.outstream_class:
   373|         0|            0|            0|  0.00%|            outstream_factory = import_item(str(self.outstream_class))
   374|         0|            0|            0|  0.00%|            if sys.stdout is not None:
   375|         0|            0|            0|  0.00%|                sys.stdout.flush()
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|            e_stdout = None if self.quiet else sys.__stdout__
   378|         0|            0|            0|  0.00%|            e_stderr = None if self.quiet else sys.__stderr__
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|            sys.stdout = outstream_factory(self.session, self.iopub_thread,
   381|         0|            0|            0|  0.00%|                                           u'stdout',
   382|         0|            0|            0|  0.00%|                                           echo=e_stdout)
   383|         0|            0|            0|  0.00%|            if sys.stderr is not None:
   384|         0|            0|            0|  0.00%|                sys.stderr.flush()
   385|         0|            0|            0|  0.00%|            sys.stderr = outstream_factory(self.session, self.iopub_thread,
   386|         0|            0|            0|  0.00%|                                           u'stderr',
   387|         0|            0|            0|  0.00%|                                           echo=e_stderr)
   388|         0|            0|            0|  0.00%|        if self.displayhook_class:
   389|         0|            0|            0|  0.00%|            displayhook_factory = import_item(str(self.displayhook_class))
   390|         0|            0|            0|  0.00%|            self.displayhook = displayhook_factory(self.session, self.iopub_socket)
   391|         0|            0|            0|  0.00%|            sys.displayhook = self.displayhook
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|        self.patch_io()
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|    def reset_io(self):
   396|         0|            0|            0|  0.00%|        """restore original io
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|        restores state after init_io
   399|         0|            0|            0|  0.00%|        """
   400|         0|            0|            0|  0.00%|        sys.stdout = sys.__stdout__
   401|         0|            0|            0|  0.00%|        sys.stderr = sys.__stderr__
   402|         0|            0|            0|  0.00%|        sys.displayhook = sys.__displayhook__
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|    def patch_io(self):
   405|         0|            0|            0|  0.00%|        """Patch important libraries that can't handle sys.stdout forwarding"""
   406|         0|            0|            0|  0.00%|        try:
   407|         0|            0|            0|  0.00%|            import faulthandler
   408|         0|            0|            0|  0.00%|        except ImportError:
   409|         0|            0|            0|  0.00%|            pass
   410|         0|            0|            0|  0.00%|        else:
   411|         0|            0|            0|  0.00%|            # Warning: this is a monkeypatch of `faulthandler.enable`, watch for possible
   412|         0|            0|            0|  0.00%|            # updates to the upstream API and update accordingly (up-to-date as of Python 3.5):
   413|         0|            0|            0|  0.00%|            # https://docs.python.org/3/library/faulthandler.html#faulthandler.enable
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|            # change default file to __stderr__ from forwarded stderr
   416|         0|            0|            0|  0.00%|            faulthandler_enable = faulthandler.enable
   417|         0|            0|            0|  0.00%|            def enable(file=sys.__stderr__, all_threads=True, **kwargs):
   418|         0|            0|            0|  0.00%|                return faulthandler_enable(file=file, all_threads=all_threads, **kwargs)
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|            faulthandler.enable = enable
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|            if hasattr(faulthandler, 'register'):
   423|         0|            0|            0|  0.00%|                faulthandler_register = faulthandler.register
   424|         0|            0|            0|  0.00%|                def register(signum, file=sys.__stderr__, all_threads=True, chain=False, **kwargs):
   425|         0|            0|            0|  0.00%|                    return faulthandler_register(signum, file=file, all_threads=all_threads,
   426|         0|            0|            0|  0.00%|                                                 chain=chain, **kwargs)
   427|         0|            0|            0|  0.00%|                faulthandler.register = register
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|    def init_signal(self):
   430|         0|            0|            0|  0.00%|        signal.signal(signal.SIGINT, signal.SIG_IGN)
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|    def init_kernel(self):
   433|         0|            0|            0|  0.00%|        """Create the Kernel object itself"""
   434|         0|            0|            0|  0.00%|        shell_stream = ZMQStream(self.shell_socket)
   435|         0|            0|            0|  0.00%|        control_stream = ZMQStream(self.control_socket)
   436|         0|            0|            0|  0.00%|
   437|         0|            0|            0|  0.00%|        kernel_factory = self.kernel_class.instance
   438|         0|            0|            0|  0.00%|
   439|         0|            0|            0|  0.00%|        kernel = kernel_factory(parent=self, session=self.session,
   440|         0|            0|            0|  0.00%|                                control_stream=control_stream,
   441|         0|            0|            0|  0.00%|                                shell_streams=[shell_stream, control_stream],
   442|         0|            0|            0|  0.00%|                                iopub_thread=self.iopub_thread,
   443|         0|            0|            0|  0.00%|                                iopub_socket=self.iopub_socket,
   444|         0|            0|            0|  0.00%|                                stdin_socket=self.stdin_socket,
   445|         0|            0|            0|  0.00%|                                log=self.log,
   446|         0|            0|            0|  0.00%|                                profile_dir=self.profile_dir,
   447|         0|            0|            0|  0.00%|                                user_ns=self.user_ns,
   448|         0|            0|            0|  0.00%|        )
   449|         0|            0|            0|  0.00%|        kernel.record_ports({
   450|         0|            0|            0|  0.00%|            name + '_port': port for name, port in self.ports.items()
   451|         0|            0|            0|  0.00%|        })
   452|         0|            0|            0|  0.00%|        self.kernel = kernel
   453|         0|            0|            0|  0.00%|
   454|         0|            0|            0|  0.00%|        # Allow the displayhook to get the execution count
   455|         0|            0|            0|  0.00%|        self.displayhook.get_execution_count = lambda: kernel.execution_count
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|    def init_gui_pylab(self):
   458|         0|            0|            0|  0.00%|        """Enable GUI event loop integration, taking pylab into account."""
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|        # Register inline backend as default
   461|         0|            0|            0|  0.00%|        # this is higher priority than matplotlibrc,
   462|         0|            0|            0|  0.00%|        # but lower priority than anything else (mpl.use() for instance).
   463|         0|            0|            0|  0.00%|        # This only affects matplotlib >= 1.5
   464|         0|            0|            0|  0.00%|        if not os.environ.get('MPLBACKEND'):
   465|         0|            0|            0|  0.00%|            os.environ['MPLBACKEND'] = 'module://ipykernel.pylab.backend_inline'
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|        # Provide a wrapper for :meth:`InteractiveShellApp.init_gui_pylab`
   468|         0|            0|            0|  0.00%|        # to ensure that any exception is printed straight to stderr.
   469|         0|            0|            0|  0.00%|        # Normally _showtraceback associates the reply with an execution,
   470|         0|            0|            0|  0.00%|        # which means frontends will never draw it, as this exception
   471|         0|            0|            0|  0.00%|        # is not associated with any execute request.
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|        shell = self.shell
   474|         0|            0|            0|  0.00%|        _showtraceback = shell._showtraceback
   475|         0|            0|            0|  0.00%|        try:
   476|         0|            0|            0|  0.00%|            # replace error-sending traceback with stderr
   477|         0|            0|            0|  0.00%|            def print_tb(etype, evalue, stb):
   478|         0|            0|            0|  0.00%|                print ("GUI event loop or pylab initialization failed",
   479|         0|            0|            0|  0.00%|                       file=sys.stderr)
   480|         0|            0|            0|  0.00%|                print (shell.InteractiveTB.stb2text(stb), file=sys.stderr)
   481|         0|            0|            0|  0.00%|            shell._showtraceback = print_tb
   482|         0|            0|            0|  0.00%|            InteractiveShellApp.init_gui_pylab(self)
   483|         0|            0|            0|  0.00%|        finally:
   484|         0|            0|            0|  0.00%|            shell._showtraceback = _showtraceback
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|    def init_shell(self):
   487|         0|            0|            0|  0.00%|        self.shell = getattr(self.kernel, 'shell', None)
   488|         0|            0|            0|  0.00%|        if self.shell:
   489|         0|            0|            0|  0.00%|            self.shell.configurables.append(self)
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|    def init_extensions(self):
   492|         0|            0|            0|  0.00%|        super(IPKernelApp, self).init_extensions()
   493|         0|            0|            0|  0.00%|        # BEGIN HARDCODED WIDGETS HACK
   494|         0|            0|            0|  0.00%|        # Ensure ipywidgets extension is loaded if available
   495|         0|            0|            0|  0.00%|        extension_man = self.shell.extension_manager
   496|         0|            0|            0|  0.00%|        if 'ipywidgets' not in extension_man.loaded:
   497|         0|            0|            0|  0.00%|            try:
   498|         0|            0|            0|  0.00%|                extension_man.load_extension('ipywidgets')
   499|         0|            0|            0|  0.00%|            except ImportError as e:
   500|         0|            0|            0|  0.00%|                self.log.debug('ipywidgets package not installed.  Widgets will not be available.')
   501|         0|            0|            0|  0.00%|        # END HARDCODED WIDGETS HACK
   502|         0|            0|            0|  0.00%|
   503|         0|            0|            0|  0.00%|    def configure_tornado_logger(self):
   504|         0|            0|            0|  0.00%|        """ Configure the tornado logging.Logger.
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|            Must set up the tornado logger or else tornado will call
   507|         0|            0|            0|  0.00%|            basicConfig for the root logger which makes the root logger
   508|         0|            0|            0|  0.00%|            go to the real sys.stderr instead of the capture streams.
   509|         0|            0|            0|  0.00%|            This function mimics the setup of logging.basicConfig.
   510|         0|            0|            0|  0.00%|        """
   511|         0|            0|            0|  0.00%|        logger = logging.getLogger('tornado')
   512|         0|            0|            0|  0.00%|        handler = logging.StreamHandler()
   513|         0|            0|            0|  0.00%|        formatter = logging.Formatter(logging.BASIC_FORMAT)
   514|         0|            0|            0|  0.00%|        handler.setFormatter(formatter)
   515|         0|            0|            0|  0.00%|        logger.addHandler(handler)
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|    @catch_config_error
   518|         0|            0|            0|  0.00%|    def initialize(self, argv=None):
   519|         0|            0|            0|  0.00%|        super(IPKernelApp, self).initialize(argv)
   520|         0|            0|            0|  0.00%|        if self.subapp is not None:
   521|         0|            0|            0|  0.00%|            return
   522|         0|            0|            0|  0.00%|        # register zmq IOLoop with tornado
   523|         0|            0|            0|  0.00%|        zmq_ioloop.install()
   524|         0|            0|            0|  0.00%|        self.init_blackhole()
   525|         0|            0|            0|  0.00%|        self.init_connection_file()
   526|         0|            0|            0|  0.00%|        self.init_poller()
   527|         0|            0|            0|  0.00%|        self.init_sockets()
   528|         0|            0|            0|  0.00%|        self.init_heartbeat()
   529|         0|            0|            0|  0.00%|        # writing/displaying connection info must be *after* init_sockets/heartbeat
   530|         0|            0|            0|  0.00%|        self.write_connection_file()
   531|         0|            0|            0|  0.00%|        # Log connection info after writing connection file, so that the connection
   532|         0|            0|            0|  0.00%|        # file is definitely available at the time someone reads the log.
   533|         0|            0|            0|  0.00%|        self.log_connection_info()
   534|         0|            0|            0|  0.00%|        self.init_io()
   535|         0|            0|            0|  0.00%|        try:
   536|         0|            0|            0|  0.00%|            self.init_signal()
   537|         0|            0|            0|  0.00%|        except:
   538|         0|            0|            0|  0.00%|            # Catch exception when initializing signal fails, eg when running the
   539|         0|            0|            0|  0.00%|            # kernel on a separate thread
   540|         0|            0|            0|  0.00%|            if self.log_level < logging.CRITICAL:
   541|         0|            0|            0|  0.00%|                self.log.error("Unable to initialize signal:", exc_info=True)
   542|         0|            0|            0|  0.00%|        self.init_kernel()
   543|         0|            0|            0|  0.00%|        # shell init steps
   544|         0|            0|            0|  0.00%|        self.init_path()
   545|         0|            0|            0|  0.00%|        self.init_shell()
   546|         0|            0|            0|  0.00%|        if self.shell:
   547|         0|            0|            0|  0.00%|            self.init_gui_pylab()
   548|         0|            0|            0|  0.00%|            self.init_extensions()
   549|         0|            0|            0|  0.00%|            self.init_code()
   550|         0|            0|            0|  0.00%|        # flush stdout/stderr, so that anything written to these streams during
   551|         0|            0|            0|  0.00%|        # initialization do not get associated with the first execution request
   552|         0|            0|            0|  0.00%|        sys.stdout.flush()
   553|         0|            0|            0|  0.00%|        sys.stderr.flush()
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|    def start(self):
   556|         0|            0|            0|  0.00%|        if self.subapp is not None:
   557|         0|            0|            0|  0.00%|            return self.subapp.start()
   558|         0|            0|            0|  0.00%|        if self.poller is not None:
   559|         0|            0|            0|  0.00%|            self.poller.start()
   560|         0|            0|            0|  0.00%|        self.kernel.start()
   561|         0|            0|            0|  0.00%|        self.io_loop = ioloop.IOLoop.current()
   562|         0|            0|            0|  0.00%|        try:
   563|         0|            0|            0|  0.00%|            self.io_loop.start()
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\tornado\ioloop.py:753 start
   564|         0|            0|            0|  0.00%|        except KeyboardInterrupt:
   565|         0|            0|            0|  0.00%|            pass
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|launch_new_instance = IPKernelApp.launch_instance
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|
   571|         0|            0|            0|  0.00%|def main():
   572|         0|            0|            0|  0.00%|    """Run an IPKernel as an application"""
   573|         0|            0|            0|  0.00%|    app = IPKernelApp.instance()
   574|         0|            0|            0|  0.00%|    app.initialize()
   575|         0|            0|            0|  0.00%|    app.start()
   576|         0|            0|            0|  0.00%|
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|if __name__ == '__main__':
   579|         0|            0|            0|  0.00%|    main()
File: D:\Application\Anaconda\lib\site-packages\spyder_kernels\console\start.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# -*- coding: utf-8 -*-
     2|         0|            0|            0|  0.00%|# -----------------------------------------------------------------------------
     3|         0|            0|            0|  0.00%|# Copyright (c) 2009- Spyder Kernels Contributors
     4|         0|            0|            0|  0.00%|#
     5|         0|            0|            0|  0.00%|# Licensed under the terms of the MIT License
     6|         0|            0|            0|  0.00%|# (see spyder_kernels/__init__.py for details)
     7|         0|            0|            0|  0.00%|# -----------------------------------------------------------------------------
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|"""
    10|         0|            0|            0|  0.00%|File used to start kernels for the IPython Console
    11|         0|            0|            0|  0.00%|"""
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|# Standard library imports
    14|         0|            0|            0|  0.00%|from distutils.version import LooseVersion
    15|         0|            0|            0|  0.00%|import os
    16|         0|            0|            0|  0.00%|import os.path as osp
    17|         0|            0|            0|  0.00%|import sys
    18|         0|            0|            0|  0.00%|import site
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|PY2 = sys.version[0] == '2'
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|def import_spydercustomize():
    25|         0|            0|            0|  0.00%|    """Import our customizations into the kernel."""
    26|         0|            0|            0|  0.00%|    here = osp.dirname(__file__)
    27|         0|            0|            0|  0.00%|    parent = osp.dirname(here)
    28|         0|            0|            0|  0.00%|    customize_dir = osp.join(parent, 'customize')
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|    # Remove current directory from sys.path to prevent kernel
    31|         0|            0|            0|  0.00%|    # crashes when people name Python files or modules with
    32|         0|            0|            0|  0.00%|    # the same name as standard library modules.
    33|         0|            0|            0|  0.00%|    # See spyder-ide/spyder#8007
    34|         0|            0|            0|  0.00%|    while '' in sys.path:
    35|         0|            0|            0|  0.00%|        sys.path.remove('')
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|    # Import our customizations
    38|         0|            0|            0|  0.00%|    site.addsitedir(customize_dir)
    39|         0|            0|            0|  0.00%|    import spydercustomize
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|    # Remove our customize path from sys.path
    42|         0|            0|            0|  0.00%|    try:
    43|         0|            0|            0|  0.00%|        sys.path.remove(customize_dir)
    44|         0|            0|            0|  0.00%|    except ValueError:
    45|         0|            0|            0|  0.00%|        pass
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|def is_module_installed(module_name):
    49|         0|            0|            0|  0.00%|    """
    50|         0|            0|            0|  0.00%|    Simpler version of spyder.utils.programs.is_module_installed
    51|         0|            0|            0|  0.00%|    to improve startup time.
    52|         0|            0|            0|  0.00%|    """
    53|         0|            0|            0|  0.00%|    try:
    54|         0|            0|            0|  0.00%|        __import__(module_name)
    55|         0|            0|            0|  0.00%|        return True
    56|         0|            0|            0|  0.00%|    except:
    57|         0|            0|            0|  0.00%|        # Module is not installed
    58|         0|            0|            0|  0.00%|        return False
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|def sympy_config(mpl_backend):
    62|         0|            0|            0|  0.00%|    """Sympy configuration"""
    63|         0|            0|            0|  0.00%|    if mpl_backend is not None:
    64|         0|            0|            0|  0.00%|        lines = """
    65|         0|            0|            0|  0.00%|from sympy.interactive import init_session
    66|         0|            0|            0|  0.00%|init_session()
    67|         0|            0|            0|  0.00%|%matplotlib {0}
    68|         0|            0|            0|  0.00%|""".format(mpl_backend)
    69|         0|            0|            0|  0.00%|    else:
    70|         0|            0|            0|  0.00%|        lines = """
    71|         0|            0|            0|  0.00%|from sympy.interactive import init_session
    72|         0|            0|            0|  0.00%|init_session()
    73|         0|            0|            0|  0.00%|"""
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|    return lines
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|def kernel_config():
    79|         0|            0|            0|  0.00%|    """Create a config object with IPython kernel options."""
    80|         0|            0|            0|  0.00%|    import ipykernel
    81|         0|            0|            0|  0.00%|    from IPython.core.application import get_ipython_dir
    82|         0|            0|            0|  0.00%|    from traitlets.config.loader import Config, load_pyconfig_files
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|    # ---- IPython config ----
    85|         0|            0|            0|  0.00%|    try:
    86|         0|            0|            0|  0.00%|        profile_path = osp.join(get_ipython_dir(), 'profile_default')
    87|         0|            0|            0|  0.00%|        cfg = load_pyconfig_files(['ipython_config.py',
    88|         0|            0|            0|  0.00%|                                   'ipython_kernel_config.py'],
    89|         0|            0|            0|  0.00%|                                  profile_path)
    90|         0|            0|            0|  0.00%|    except:
    91|         0|            0|            0|  0.00%|        cfg = Config()
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|    # ---- Spyder config ----
    94|         0|            0|            0|  0.00%|    spy_cfg = Config()
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|    # Enable/disable certain features for testing
    97|         0|            0|            0|  0.00%|    testing = os.environ.get('SPY_TESTING') == 'True'
    98|         0|            0|            0|  0.00%|    if testing:
    99|         0|            0|            0|  0.00%|        # Don't load nor save history in our IPython consoles.
   100|         0|            0|            0|  0.00%|        spy_cfg.HistoryAccessor.enabled = False
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|    # Until we implement Issue 1052
   103|         0|            0|            0|  0.00%|    spy_cfg.InteractiveShell.xmode = 'Plain'
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|    # Jedi completer. It's only available in Python 3
   106|         0|            0|            0|  0.00%|    jedi_o = os.environ.get('SPY_JEDI_O') == 'True'
   107|         0|            0|            0|  0.00%|    if not PY2:
   108|         0|            0|            0|  0.00%|        spy_cfg.IPCompleter.use_jedi = jedi_o
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|    # Run lines of code at startup
   111|         0|            0|            0|  0.00%|    run_lines_o = os.environ.get('SPY_RUN_LINES_O')
   112|         0|            0|            0|  0.00%|    if run_lines_o is not None:
   113|         0|            0|            0|  0.00%|        spy_cfg.IPKernelApp.exec_lines = [x.strip() for x in run_lines_o.split(',')]
   114|         0|            0|            0|  0.00%|    else:
   115|         0|            0|            0|  0.00%|        spy_cfg.IPKernelApp.exec_lines = []
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|    # Clean terminal arguments input
   118|         0|            0|            0|  0.00%|    clear_argv = "import sys;sys.argv = [''];del sys"
   119|         0|            0|            0|  0.00%|    spy_cfg.IPKernelApp.exec_lines.append(clear_argv)
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|    # Load %autoreload magic
   122|         0|            0|            0|  0.00%|    spy_cfg.IPKernelApp.exec_lines.append(
   123|         0|            0|            0|  0.00%|        "get_ipython().kernel._load_autoreload_magic()")
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|    # Load wurlitzer extension
   126|         0|            0|            0|  0.00%|    spy_cfg.IPKernelApp.exec_lines.append(
   127|         0|            0|            0|  0.00%|        "get_ipython().kernel._load_wurlitzer()")
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|    # Default inline backend configuration
   130|         0|            0|            0|  0.00%|    # This is useful to have when people doesn't
   131|         0|            0|            0|  0.00%|    # use our config system to configure the
   132|         0|            0|            0|  0.00%|    # inline backend but want to use
   133|         0|            0|            0|  0.00%|    # '%matplotlib inline' at runtime
   134|         0|            0|            0|  0.00%|    if LooseVersion(ipykernel.__version__) < LooseVersion('4.5'):
   135|         0|            0|            0|  0.00%|        dpi_option = 'savefig.dpi'
   136|         0|            0|            0|  0.00%|    else:
   137|         0|            0|            0|  0.00%|        dpi_option = 'figure.dpi'
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|    spy_cfg.InlineBackend.rc = {'figure.figsize': (6.0, 4.0),
   140|         0|            0|            0|  0.00%|                                dpi_option: 72,
   141|         0|            0|            0|  0.00%|                                'font.size': 10,
   142|         0|            0|            0|  0.00%|                                'figure.subplot.bottom': .125,
   143|         0|            0|            0|  0.00%|                                'figure.facecolor': 'white',
   144|         0|            0|            0|  0.00%|                                'figure.edgecolor': 'white'}
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|    # Pylab configuration
   147|         0|            0|            0|  0.00%|    mpl_backend = None
   148|         0|            0|            0|  0.00%|    if is_module_installed('matplotlib'):
   149|         0|            0|            0|  0.00%|        # Set Matplotlib backend with Spyder options
   150|         0|            0|            0|  0.00%|        pylab_o = os.environ.get('SPY_PYLAB_O')
   151|         0|            0|            0|  0.00%|        backend_o = os.environ.get('SPY_BACKEND_O')
   152|         0|            0|            0|  0.00%|        if pylab_o == 'True' and backend_o is not None:
   153|         0|            0|            0|  0.00%|            # Select the automatic backend
   154|         0|            0|            0|  0.00%|            if backend_o == '1':
   155|         0|            0|            0|  0.00%|                if is_module_installed('PyQt5'):
   156|         0|            0|            0|  0.00%|                    auto_backend = 'qt5'
   157|         0|            0|            0|  0.00%|                elif is_module_installed('PyQt4'):
   158|         0|            0|            0|  0.00%|                    auto_backend = 'qt4'
   159|         0|            0|            0|  0.00%|                elif is_module_installed('_tkinter'):
   160|         0|            0|            0|  0.00%|                    auto_backend = 'tk'
   161|         0|            0|            0|  0.00%|                else:
   162|         0|            0|            0|  0.00%|                    auto_backend = 'inline'
   163|         0|            0|            0|  0.00%|            else:
   164|         0|            0|            0|  0.00%|                auto_backend = ''
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|            # Mapping of Spyder options to backends
   167|         0|            0|            0|  0.00%|            backends = {'0': 'inline',
   168|         0|            0|            0|  0.00%|                        '1': auto_backend,
   169|         0|            0|            0|  0.00%|                        '2': 'qt5',
   170|         0|            0|            0|  0.00%|                        '3': 'qt4',
   171|         0|            0|            0|  0.00%|                        '4': 'osx',
   172|         0|            0|            0|  0.00%|                        '5': 'gtk3',
   173|         0|            0|            0|  0.00%|                        '6': 'gtk',
   174|         0|            0|            0|  0.00%|                        '7': 'wx',
   175|         0|            0|            0|  0.00%|                        '8': 'tk'}
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|            # Select backend
   178|         0|            0|            0|  0.00%|            mpl_backend = backends[backend_o]
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|            # Inline backend configuration
   181|         0|            0|            0|  0.00%|            if mpl_backend == 'inline':
   182|         0|            0|            0|  0.00%|                # Figure format
   183|         0|            0|            0|  0.00%|                format_o = os.environ.get('SPY_FORMAT_O')
   184|         0|            0|            0|  0.00%|                formats = {'0': 'png',
   185|         0|            0|            0|  0.00%|                           '1': 'svg'}
   186|         0|            0|            0|  0.00%|                if format_o is not None:
   187|         0|            0|            0|  0.00%|                    spy_cfg.InlineBackend.figure_format = formats[format_o]
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|                # Resolution
   190|         0|            0|            0|  0.00%|                resolution_o = os.environ.get('SPY_RESOLUTION_O')
   191|         0|            0|            0|  0.00%|                if resolution_o is not None:
   192|         0|            0|            0|  0.00%|                    spy_cfg.InlineBackend.rc[dpi_option] = float(resolution_o)
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|                # Figure size
   195|         0|            0|            0|  0.00%|                width_o = float(os.environ.get('SPY_WIDTH_O'))
   196|         0|            0|            0|  0.00%|                height_o = float(os.environ.get('SPY_HEIGHT_O'))
   197|         0|            0|            0|  0.00%|                if width_o is not None and height_o is not None:
   198|         0|            0|            0|  0.00%|                    spy_cfg.InlineBackend.rc['figure.figsize'] = (width_o,
   199|         0|            0|            0|  0.00%|                                                                  height_o)
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|                # Print figure kwargs
   202|         0|            0|            0|  0.00%|                bbox_inches_o = os.environ.get('SPY_BBOX_INCHES_O')
   203|         0|            0|            0|  0.00%|                bbox_inches = 'tight' if bbox_inches_o == 'True' else None
   204|         0|            0|            0|  0.00%|                spy_cfg.InlineBackend.print_figure_kwargs.update(
   205|         0|            0|            0|  0.00%|                    {'bbox_inches': bbox_inches})
   206|         0|            0|            0|  0.00%|        else:
   207|         0|            0|            0|  0.00%|            # Set Matplotlib backend to inline for external kernels.
   208|         0|            0|            0|  0.00%|            # Fixes issue 108
   209|         0|            0|            0|  0.00%|            mpl_backend = 'inline'
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|        # Automatically load Pylab and Numpy, or only set Matplotlib
   212|         0|            0|            0|  0.00%|        # backend
   213|         0|            0|            0|  0.00%|        autoload_pylab_o = os.environ.get('SPY_AUTOLOAD_PYLAB_O') == 'True'
   214|         0|            0|            0|  0.00%|        command = "get_ipython().kernel._set_mpl_backend('{0}', {1})"
   215|         0|            0|            0|  0.00%|        spy_cfg.IPKernelApp.exec_lines.append(
   216|         0|            0|            0|  0.00%|            command.format(mpl_backend, autoload_pylab_o))
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|    # Enable Cython magic
   219|         0|            0|            0|  0.00%|    run_cython = os.environ.get('SPY_RUN_CYTHON') == 'True'
   220|         0|            0|            0|  0.00%|    if run_cython and is_module_installed('Cython'):
   221|         0|            0|            0|  0.00%|        spy_cfg.IPKernelApp.exec_lines.append('%reload_ext Cython')
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|    # Run a file at startup
   224|         0|            0|            0|  0.00%|    use_file_o = os.environ.get('SPY_USE_FILE_O')
   225|         0|            0|            0|  0.00%|    run_file_o = os.environ.get('SPY_RUN_FILE_O')
   226|         0|            0|            0|  0.00%|    if use_file_o == 'True' and run_file_o is not None:
   227|         0|            0|            0|  0.00%|        spy_cfg.IPKernelApp.file_to_run = run_file_o
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|    # Autocall
   230|         0|            0|            0|  0.00%|    autocall_o = os.environ.get('SPY_AUTOCALL_O')
   231|         0|            0|            0|  0.00%|    if autocall_o is not None:
   232|         0|            0|            0|  0.00%|        spy_cfg.ZMQInteractiveShell.autocall = int(autocall_o)
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|    # To handle the banner by ourselves in IPython 3+
   235|         0|            0|            0|  0.00%|    spy_cfg.ZMQInteractiveShell.banner1 = ''
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|    # Greedy completer
   238|         0|            0|            0|  0.00%|    greedy_o = os.environ.get('SPY_GREEDY_O') == 'True'
   239|         0|            0|            0|  0.00%|    spy_cfg.IPCompleter.greedy = greedy_o
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|    # Sympy loading
   242|         0|            0|            0|  0.00%|    sympy_o = os.environ.get('SPY_SYMPY_O') == 'True'
   243|         0|            0|            0|  0.00%|    if sympy_o and is_module_installed('sympy'):
   244|         0|            0|            0|  0.00%|        lines = sympy_config(mpl_backend)
   245|         0|            0|            0|  0.00%|        spy_cfg.IPKernelApp.exec_lines.append(lines)
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|    # Merge IPython and Spyder configs. Spyder prefs will have prevalence
   248|         0|            0|            0|  0.00%|    # over IPython ones
   249|         0|            0|            0|  0.00%|    cfg._merge(spy_cfg)
   250|         0|            0|            0|  0.00%|    return cfg
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|def varexp(line):
   254|         0|            0|            0|  0.00%|    """
   255|         0|            0|            0|  0.00%|    Spyder's variable explorer magic
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|    Used to generate plots, histograms and images of the variables displayed
   258|         0|            0|            0|  0.00%|    on it.
   259|         0|            0|            0|  0.00%|    """
   260|         0|            0|            0|  0.00%|    ip = get_ipython()       #analysis:ignore
   261|         0|            0|            0|  0.00%|    funcname, name = line.split()
   262|         0|            0|            0|  0.00%|    try:
   263|         0|            0|            0|  0.00%|        import guiqwt.pyplot as pyplot
   264|         0|            0|            0|  0.00%|    except:
   265|         0|            0|            0|  0.00%|        import matplotlib.pyplot as pyplot
   266|         0|            0|            0|  0.00%|    __fig__ = pyplot.figure();
   267|         0|            0|            0|  0.00%|    __items__ = getattr(pyplot, funcname[2:])(ip.user_ns[name])
   268|         0|            0|            0|  0.00%|    pyplot.show()
   269|         0|            0|            0|  0.00%|    del __fig__, __items__
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|def main():
   273|         0|            0|            0|  0.00%|    # Remove this module's path from sys.path:
   274|         0|            0|            0|  0.00%|    try:
   275|         0|            0|            0|  0.00%|        sys.path.remove(osp.dirname(__file__))
   276|         0|            0|            0|  0.00%|    except ValueError:
   277|         0|            0|            0|  0.00%|        pass
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|    try:
   280|         0|            0|            0|  0.00%|        locals().pop('__file__')
   281|         0|            0|            0|  0.00%|    except KeyError:
   282|         0|            0|            0|  0.00%|        pass
   283|         0|            0|            0|  0.00%|    __doc__ = ''
   284|         0|            0|            0|  0.00%|    __name__ = '__main__'
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|    # Import our customizations into the kernel
   287|         0|            0|            0|  0.00%|    import_spydercustomize()
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|    # Remove current directory from sys.path to prevent kernel
   290|         0|            0|            0|  0.00%|    # crashes when people name Python files or modules with
   291|         0|            0|            0|  0.00%|    # the same name as standard library modules.
   292|         0|            0|            0|  0.00%|    # See spyder-ide/spyder#8007
   293|         0|            0|            0|  0.00%|    while '' in sys.path:
   294|         0|            0|            0|  0.00%|        sys.path.remove('')
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|    # Fire up the kernel instance.
   297|         0|            0|            0|  0.00%|    from ipykernel.kernelapp import IPKernelApp
   298|         0|            0|            0|  0.00%|    from spyder_kernels.console.kernel import SpyderKernel
   299|         0|            0|            0|  0.00%|
   300|         0|            0|            0|  0.00%|    kernel = IPKernelApp.instance()
   301|         0|            0|            0|  0.00%|    kernel.kernel_class = SpyderKernel
   302|         0|            0|            0|  0.00%|    try:
   303|         0|            0|            0|  0.00%|        kernel.config = kernel_config()
   304|         0|            0|            0|  0.00%|    except:
   305|         0|            0|            0|  0.00%|        pass
   306|         0|            0|            0|  0.00%|    kernel.initialize()
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    # Set our own magics
   309|         0|            0|            0|  0.00%|    kernel.shell.register_magic_function(varexp)
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|    # Set Pdb class to be used by %debug and %pdb.
   312|         0|            0|            0|  0.00%|    # This makes IPython consoles to use the class defined in our
   313|         0|            0|            0|  0.00%|    # sitecustomize instead of their default one.
   314|         0|            0|            0|  0.00%|    import pdb
   315|         0|            0|            0|  0.00%|    kernel.shell.InteractiveTB.debugger_cls = pdb.Pdb
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|    # Start the (infinite) kernel event loop.
   318|         0|            0|            0|  0.00%|    kernel.start()
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\ipykernel\kernelapp.py:555 start
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|if __name__ == '__main__':
   322|         0|            0|            0|  0.00%|    main()
File: D:\Application\Anaconda\lib\site-packages\ipykernel\zmqshell.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# -*- coding: utf-8 -*-
     2|         0|            0|            0|  0.00%|"""A ZMQ-based subclass of InteractiveShell.
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|This code is meant to ease the refactoring of the base InteractiveShell into
     5|         0|            0|            0|  0.00%|something with a cleaner architecture for 2-process use, without actually
     6|         0|            0|            0|  0.00%|breaking InteractiveShell itself.  So we're doing something a bit ugly, where
     7|         0|            0|            0|  0.00%|we subclass and override what we want to fix.  Once this is working well, we
     8|         0|            0|            0|  0.00%|can go back to the base class and refactor the code for a cleaner inheritance
     9|         0|            0|            0|  0.00%|implementation that doesn't rely on so much monkeypatching.
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|But this lets us maintain a fully working IPython as we develop the new
    12|         0|            0|            0|  0.00%|machinery.  This should thus be thought of as scaffolding.
    13|         0|            0|            0|  0.00%|"""
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|# Copyright (c) IPython Development Team.
    16|         0|            0|            0|  0.00%|# Distributed under the terms of the Modified BSD License.
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|from __future__ import print_function
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|import os
    21|         0|            0|            0|  0.00%|import sys
    22|         0|            0|            0|  0.00%|import time
    23|         0|            0|            0|  0.00%|import warnings
    24|         0|            0|            0|  0.00%|from threading import local
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|from tornado import ioloop
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|from IPython.core.interactiveshell import (
    29|         0|            0|            0|  0.00%|    InteractiveShell, InteractiveShellABC
    30|         0|            0|            0|  0.00%|)
    31|         0|            0|            0|  0.00%|from IPython.core import page
    32|         0|            0|            0|  0.00%|from IPython.core.autocall import ZMQExitAutocall
    33|         0|            0|            0|  0.00%|from IPython.core.displaypub import DisplayPublisher
    34|         0|            0|            0|  0.00%|from IPython.core.error import UsageError
    35|         0|            0|            0|  0.00%|from IPython.core.magics import MacroToEdit, CodeMagics
    36|         0|            0|            0|  0.00%|from IPython.core.magic import magics_class, line_magic, Magics
    37|         0|            0|            0|  0.00%|from IPython.core import payloadpage
    38|         0|            0|            0|  0.00%|from IPython.core.usage import default_banner
    39|         0|            0|            0|  0.00%|from IPython.display import display, Javascript
    40|         0|            0|            0|  0.00%|from ipykernel import (
    41|         0|            0|            0|  0.00%|    get_connection_file, get_connection_info, connect_qtconsole
    42|         0|            0|            0|  0.00%|)
    43|         0|            0|            0|  0.00%|from IPython.utils import openpy
    44|         0|            0|            0|  0.00%|from ipykernel.jsonutil import json_clean, encode_images
    45|         0|            0|            0|  0.00%|from IPython.utils.process import arg_split
    46|         0|            0|            0|  0.00%|from ipython_genutils import py3compat
    47|         0|            0|            0|  0.00%|from ipython_genutils.py3compat import unicode_type
    48|         0|            0|            0|  0.00%|from traitlets import (
    49|         0|            0|            0|  0.00%|    Instance, Type, Dict, CBool, CBytes, Any, default, observe
    50|         0|            0|            0|  0.00%|)
    51|         0|            0|            0|  0.00%|from ipykernel.displayhook import ZMQShellDisplayHook
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|from jupyter_core.paths import jupyter_runtime_dir
    54|         0|            0|            0|  0.00%|from jupyter_client.session import extract_header, Session
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
    57|         0|            0|            0|  0.00%|# Functions and classes
    58|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|class ZMQDisplayPublisher(DisplayPublisher):
    61|         0|            0|            0|  0.00%|    """A display publisher that publishes data using a ZeroMQ PUB socket."""
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|    session = Instance(Session, allow_none=True)
    64|         0|            0|            0|  0.00%|    pub_socket = Any(allow_none=True)
    65|         0|            0|            0|  0.00%|    parent_header = Dict({})
    66|         0|            0|            0|  0.00%|    topic = CBytes(b'display_data')
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    # thread_local:
    69|         0|            0|            0|  0.00%|    # An attribute used to ensure the correct output message
    70|         0|            0|            0|  0.00%|    #?is processed. See ipykernel Issue 113 for a discussion.
    71|         0|            0|            0|  0.00%|    _thread_local = Any()
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|    def set_parent(self, parent):
    74|         0|            0|            0|  0.00%|        """Set the parent for outbound messages."""
    75|         0|            0|            0|  0.00%|        self.parent_header = extract_header(parent)
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|    def _flush_streams(self):
    78|         0|            0|            0|  0.00%|        """flush IO Streams prior to display"""
    79|         0|            0|            0|  0.00%|        sys.stdout.flush()
    80|         0|            0|            0|  0.00%|        sys.stderr.flush()
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|    @default('_thread_local')
    83|         0|            0|            0|  0.00%|    def _default_thread_local(self):
    84|         0|            0|            0|  0.00%|        """Initialize our thread local storage"""
    85|         0|            0|            0|  0.00%|        return local()
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|    @property
    88|         0|            0|            0|  0.00%|    def _hooks(self):
    89|         0|            0|            0|  0.00%|        if not hasattr(self._thread_local, 'hooks'):
    90|         0|            0|            0|  0.00%|            # create new list for a new thread
    91|         0|            0|            0|  0.00%|            self._thread_local.hooks = []
    92|         0|            0|            0|  0.00%|        return self._thread_local.hooks
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|    def publish(self, data, metadata=None, source=None, transient=None,
    95|         0|            0|            0|  0.00%|        update=False,
    96|         0|            0|            0|  0.00%|    ):
    97|         0|            0|            0|  0.00%|        """Publish a display-data message
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|        Parameters
   100|         0|            0|            0|  0.00%|        ----------
   101|         0|            0|            0|  0.00%|        data: dict
   102|         0|            0|            0|  0.00%|            A mime-bundle dict, keyed by mime-type.
   103|         0|            0|            0|  0.00%|        metadata: dict, optional
   104|         0|            0|            0|  0.00%|            Metadata associated with the data.
   105|         0|            0|            0|  0.00%|        transient: dict, optional, keyword-only
   106|         0|            0|            0|  0.00%|            Transient data that may only be relevant during a live display,
   107|         0|            0|            0|  0.00%|            such as display_id.
   108|         0|            0|            0|  0.00%|            Transient data should not be persisted to documents.
   109|         0|            0|            0|  0.00%|        update: bool, optional, keyword-only
   110|         0|            0|            0|  0.00%|            If True, send an update_display_data message instead of display_data.
   111|         0|            0|            0|  0.00%|        """
   112|         0|            0|            0|  0.00%|        self._flush_streams()
   113|         0|            0|            0|  0.00%|        if metadata is None:
   114|         0|            0|            0|  0.00%|            metadata = {}
   115|         0|            0|            0|  0.00%|        if transient is None:
   116|         0|            0|            0|  0.00%|            transient = {}
   117|         0|            0|            0|  0.00%|        self._validate_data(data, metadata)
   118|         0|            0|            0|  0.00%|        content = {}
   119|         0|            0|            0|  0.00%|        content['data'] = encode_images(data)
   120|         0|            0|            0|  0.00%|        content['metadata'] = metadata
   121|         0|            0|            0|  0.00%|        content['transient'] = transient
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|        msg_type = 'update_display_data' if update else 'display_data'
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|        # Use 2-stage process to send a message,
   126|         0|            0|            0|  0.00%|        # in order to put it through the transform
   127|         0|            0|            0|  0.00%|        # hooks before potentially sending.
   128|         0|            0|            0|  0.00%|        msg = self.session.msg(
   129|         0|            0|            0|  0.00%|            msg_type, json_clean(content),
   130|         0|            0|            0|  0.00%|            parent=self.parent_header
   131|         0|            0|            0|  0.00%|        )
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|        # Each transform either returns a new
   134|         0|            0|            0|  0.00%|        # message or None. If None is returned,
   135|         0|            0|            0|  0.00%|        # the message has been 'used' and we return.
   136|         0|            0|            0|  0.00%|        for hook in self._hooks:
   137|         0|            0|            0|  0.00%|            msg = hook(msg)
   138|         0|            0|            0|  0.00%|            if msg is None:
   139|         0|            0|            0|  0.00%|                return
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|        self.session.send(
   142|         0|            0|            0|  0.00%|            self.pub_socket, msg, ident=self.topic,
   143|         0|            0|            0|  0.00%|        )
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|    def clear_output(self, wait=False):
   146|         0|            0|            0|  0.00%|        """Clear output associated with the current execution (cell).
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|        Parameters
   149|         0|            0|            0|  0.00%|        ----------
   150|         0|            0|            0|  0.00%|        wait: bool (default: False)
   151|         0|            0|            0|  0.00%|            If True, the output will not be cleared immediately,
   152|         0|            0|            0|  0.00%|            instead waiting for the next display before clearing.
   153|         0|            0|            0|  0.00%|            This reduces bounce during repeated clear & display loops.
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|        """
   156|         0|            0|            0|  0.00%|        content = dict(wait=wait)
   157|         0|            0|            0|  0.00%|        self._flush_streams()
   158|         0|            0|            0|  0.00%|        self.session.send(
   159|         0|            0|            0|  0.00%|            self.pub_socket, u'clear_output', content,
   160|         0|            0|            0|  0.00%|            parent=self.parent_header, ident=self.topic,
   161|         0|            0|            0|  0.00%|        )
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|    def register_hook(self, hook):
   164|         0|            0|            0|  0.00%|        """
   165|         0|            0|            0|  0.00%|        Registers a hook with the thread-local storage.
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|        Parameters
   168|         0|            0|            0|  0.00%|        ----------
   169|         0|            0|            0|  0.00%|        hook : Any callable object
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|        Returns
   172|         0|            0|            0|  0.00%|        -------
   173|         0|            0|            0|  0.00%|        Either a publishable message, or `None`.
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|        The DisplayHook objects must return a message from
   176|         0|            0|            0|  0.00%|        the __call__ method if they still require the
   177|         0|            0|            0|  0.00%|        `session.send` method to be called after transformation.
   178|         0|            0|            0|  0.00%|        Returning `None` will halt that execution path, and
   179|         0|            0|            0|  0.00%|        session.send will not be called.
   180|         0|            0|            0|  0.00%|        """
   181|         0|            0|            0|  0.00%|        self._hooks.append(hook)
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    def unregister_hook(self, hook):
   184|         0|            0|            0|  0.00%|        """
   185|         0|            0|            0|  0.00%|        Un-registers a hook with the thread-local storage.
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|        Parameters
   188|         0|            0|            0|  0.00%|        ----------
   189|         0|            0|            0|  0.00%|        hook: Any callable object which has previously been
   190|         0|            0|            0|  0.00%|              registered as a hook.
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|        Returns
   193|         0|            0|            0|  0.00%|        -------
   194|         0|            0|            0|  0.00%|        bool - `True` if the hook was removed, `False` if it wasn't
   195|         0|            0|            0|  0.00%|               found.
   196|         0|            0|            0|  0.00%|        """
   197|         0|            0|            0|  0.00%|        try:
   198|         0|            0|            0|  0.00%|            self._hooks.remove(hook)
   199|         0|            0|            0|  0.00%|            return True
   200|         0|            0|            0|  0.00%|        except ValueError:
   201|         0|            0|            0|  0.00%|            return False
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|@magics_class
   205|         0|            0|            0|  0.00%|class KernelMagics(Magics):
   206|         0|            0|            0|  0.00%|    #------------------------------------------------------------------------
   207|         0|            0|            0|  0.00%|    # Magic overrides
   208|         0|            0|            0|  0.00%|    #------------------------------------------------------------------------
   209|         0|            0|            0|  0.00%|    # Once the base class stops inheriting from magic, this code needs to be
   210|         0|            0|            0|  0.00%|    # moved into a separate machinery as well.  For now, at least isolate here
   211|         0|            0|            0|  0.00%|    # the magics which this class needs to implement differently from the base
   212|         0|            0|            0|  0.00%|    # class, or that are unique to it.
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|    _find_edit_target = CodeMagics._find_edit_target
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|    @line_magic
   217|         0|            0|            0|  0.00%|    def edit(self, parameter_s='', last_call=['','']):
   218|         0|            0|            0|  0.00%|        """Bring up an editor and execute the resulting code.
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|        Usage:
   221|         0|            0|            0|  0.00%|          %edit [options] [args]
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|        %edit runs an external text editor. You will need to set the command for
   224|         0|            0|            0|  0.00%|        this editor via the ``TerminalInteractiveShell.editor`` option in your
   225|         0|            0|            0|  0.00%|        configuration file before it will work.
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|        This command allows you to conveniently edit multi-line code right in
   228|         0|            0|            0|  0.00%|        your IPython session.
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|        If called without arguments, %edit opens up an empty editor with a
   231|         0|            0|            0|  0.00%|        temporary file and will execute the contents of this file when you
   232|         0|            0|            0|  0.00%|        close it (don't forget to save it!).
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|        Options:
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|        -n <number>
   237|         0|            0|            0|  0.00%|          Open the editor at a specified line number. By default, the IPython
   238|         0|            0|            0|  0.00%|          editor hook uses the unix syntax 'editor +N filename', but you can
   239|         0|            0|            0|  0.00%|          configure this by providing your own modified hook if your favorite
   240|         0|            0|            0|  0.00%|          editor supports line-number specifications with a different syntax.
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|        -p
   243|         0|            0|            0|  0.00%|          Call the editor with the same data as the previous time it was used,
   244|         0|            0|            0|  0.00%|          regardless of how long ago (in your current session) it was.
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|        -r
   247|         0|            0|            0|  0.00%|          Use 'raw' input. This option only applies to input taken from the
   248|         0|            0|            0|  0.00%|          user's history.  By default, the 'processed' history is used, so that
   249|         0|            0|            0|  0.00%|          magics are loaded in their transformed version to valid Python.  If
   250|         0|            0|            0|  0.00%|          this option is given, the raw input as typed as the command line is
   251|         0|            0|            0|  0.00%|          used instead.  When you exit the editor, it will be executed by
   252|         0|            0|            0|  0.00%|          IPython's own processor.
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|        Arguments:
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|        If arguments are given, the following possibilities exist:
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|        - The arguments are numbers or pairs of colon-separated numbers (like
   259|         0|            0|            0|  0.00%|          1 4:8 9). These are interpreted as lines of previous input to be
   260|         0|            0|            0|  0.00%|          loaded into the editor. The syntax is the same of the %macro command.
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|        - If the argument doesn't start with a number, it is evaluated as a
   263|         0|            0|            0|  0.00%|          variable and its contents loaded into the editor. You can thus edit
   264|         0|            0|            0|  0.00%|          any string which contains python code (including the result of
   265|         0|            0|            0|  0.00%|          previous edits).
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|        - If the argument is the name of an object (other than a string),
   268|         0|            0|            0|  0.00%|          IPython will try to locate the file where it was defined and open the
   269|         0|            0|            0|  0.00%|          editor at the point where it is defined. You can use ``%edit function``
   270|         0|            0|            0|  0.00%|          to load an editor exactly at the point where 'function' is defined,
   271|         0|            0|            0|  0.00%|          edit it and have the file be executed automatically.
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|          If the object is a macro (see %macro for details), this opens up your
   274|         0|            0|            0|  0.00%|          specified editor with a temporary file containing the macro's data.
   275|         0|            0|            0|  0.00%|          Upon exit, the macro is reloaded with the contents of the file.
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|          Note: opening at an exact line is only supported under Unix, and some
   278|         0|            0|            0|  0.00%|          editors (like kedit and gedit up to Gnome 2.8) do not understand the
   279|         0|            0|            0|  0.00%|          '+NUMBER' parameter necessary for this feature. Good editors like
   280|         0|            0|            0|  0.00%|          (X)Emacs, vi, jed, pico and joe all do.
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|        - If the argument is not found as a variable, IPython will look for a
   283|         0|            0|            0|  0.00%|          file with that name (adding .py if necessary) and load it into the
   284|         0|            0|            0|  0.00%|          editor. It will execute its contents with execfile() when you exit,
   285|         0|            0|            0|  0.00%|          loading any code in the file into your interactive namespace.
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|        Unlike in the terminal, this is designed to use a GUI editor, and we do
   288|         0|            0|            0|  0.00%|        not know when it has closed. So the file you edit will not be
   289|         0|            0|            0|  0.00%|        automatically executed or printed.
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|        Note that %edit is also available through the alias %ed.
   292|         0|            0|            0|  0.00%|        """
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|        opts,args = self.parse_options(parameter_s, 'prn:')
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|        try:
   297|         0|            0|            0|  0.00%|            filename, lineno, _ = CodeMagics._find_edit_target(self.shell, args, opts, last_call)
   298|         0|            0|            0|  0.00%|        except MacroToEdit:
   299|         0|            0|            0|  0.00%|            # TODO: Implement macro editing over 2 processes.
   300|         0|            0|            0|  0.00%|            print("Macro editing not yet implemented in 2-process model.")
   301|         0|            0|            0|  0.00%|            return
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|        # Make sure we send to the client an absolute path, in case the working
   304|         0|            0|            0|  0.00%|        # directory of client and kernel don't match
   305|         0|            0|            0|  0.00%|        filename = os.path.abspath(filename)
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|        payload = {
   308|         0|            0|            0|  0.00%|            'source' : 'edit_magic',
   309|         0|            0|            0|  0.00%|            'filename' : filename,
   310|         0|            0|            0|  0.00%|            'line_number' : lineno
   311|         0|            0|            0|  0.00%|        }
   312|         0|            0|            0|  0.00%|        self.shell.payload_manager.write_payload(payload)
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|    # A few magics that are adapted to the specifics of using pexpect and a
   315|         0|            0|            0|  0.00%|    # remote terminal
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|    @line_magic
   318|         0|            0|            0|  0.00%|    def clear(self, arg_s):
   319|         0|            0|            0|  0.00%|        """Clear the terminal."""
   320|         0|            0|            0|  0.00%|        if os.name == 'posix':
   321|         0|            0|            0|  0.00%|            self.shell.system("clear")
   322|         0|            0|            0|  0.00%|        else:
   323|         0|            0|            0|  0.00%|            self.shell.system("cls")
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|    if os.name == 'nt':
   326|         0|            0|            0|  0.00%|        # This is the usual name in windows
   327|         0|            0|            0|  0.00%|        cls = line_magic('cls')(clear)
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|    # Terminal pagers won't work over pexpect, but we do have our own pager
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|    @line_magic
   332|         0|            0|            0|  0.00%|    def less(self, arg_s):
   333|         0|            0|            0|  0.00%|        """Show a file through the pager.
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|        Files ending in .py are syntax-highlighted."""
   336|         0|            0|            0|  0.00%|        if not arg_s:
   337|         0|            0|            0|  0.00%|            raise UsageError('Missing filename.')
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|        if arg_s.endswith('.py'):
   340|         0|            0|            0|  0.00%|            cont = self.shell.pycolorize(openpy.read_py_file(arg_s, skip_encoding_cookie=False))
   341|         0|            0|            0|  0.00%|        else:
   342|         0|            0|            0|  0.00%|            cont = open(arg_s).read()
   343|         0|            0|            0|  0.00%|        page.page(cont)
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|    more = line_magic('more')(less)
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|    # Man calls a pager, so we also need to redefine it
   348|         0|            0|            0|  0.00%|    if os.name == 'posix':
   349|         0|            0|            0|  0.00%|        @line_magic
   350|         0|            0|            0|  0.00%|        def man(self, arg_s):
   351|         0|            0|            0|  0.00%|            """Find the man page for the given command and display in pager."""
   352|         0|            0|            0|  0.00%|            page.page(self.shell.getoutput('man %s | col -b' % arg_s,
   353|         0|            0|            0|  0.00%|                                           split=False))
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|    @line_magic
   356|         0|            0|            0|  0.00%|    def connect_info(self, arg_s):
   357|         0|            0|            0|  0.00%|        """Print information for connecting other clients to this kernel
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|        It will print the contents of this session's connection file, as well as
   360|         0|            0|            0|  0.00%|        shortcuts for local clients.
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|        In the simplest case, when called from the most recently launched kernel,
   363|         0|            0|            0|  0.00%|        secondary clients can be connected, simply with:
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|        $> jupyter <app> --existing
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|        """
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|        try:
   370|         0|            0|            0|  0.00%|            connection_file = get_connection_file()
   371|         0|            0|            0|  0.00%|            info = get_connection_info(unpack=False)
   372|         0|            0|            0|  0.00%|        except Exception as e:
   373|         0|            0|            0|  0.00%|            warnings.warn("Could not get connection info: %r" % e)
   374|         0|            0|            0|  0.00%|            return
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|        # if it's in the default dir, truncate to basename
   377|         0|            0|            0|  0.00%|        if jupyter_runtime_dir() == os.path.dirname(connection_file):
   378|         0|            0|            0|  0.00%|            connection_file = os.path.basename(connection_file)
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|        print (info + '\n')
   382|         0|            0|            0|  0.00%|        print ("Paste the above JSON into a file, and connect with:\n"
   383|         0|            0|            0|  0.00%|            "    $> jupyter <app> --existing <file>\n"
   384|         0|            0|            0|  0.00%|            "or, if you are local, you can connect with just:\n"
   385|         0|            0|            0|  0.00%|            "    $> jupyter <app> --existing {0}\n"
   386|         0|            0|            0|  0.00%|            "or even just:\n"
   387|         0|            0|            0|  0.00%|            "    $> jupyter <app> --existing\n"
   388|         0|            0|            0|  0.00%|            "if this is the most recent Jupyter kernel you have started.".format(
   389|         0|            0|            0|  0.00%|            connection_file
   390|         0|            0|            0|  0.00%|            )
   391|         0|            0|            0|  0.00%|        )
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|    @line_magic
   394|         0|            0|            0|  0.00%|    def qtconsole(self, arg_s):
   395|         0|            0|            0|  0.00%|        """Open a qtconsole connected to this kernel.
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|        Useful for connecting a qtconsole to running notebooks, for better
   398|         0|            0|            0|  0.00%|        debugging.
   399|         0|            0|            0|  0.00%|        """
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|        # %qtconsole should imply bind_kernel for engines:
   402|         0|            0|            0|  0.00%|        # FIXME: move to ipyparallel Kernel subclass
   403|         0|            0|            0|  0.00%|        if 'ipyparallel' in sys.modules:
   404|         0|            0|            0|  0.00%|            from ipyparallel import bind_kernel
   405|         0|            0|            0|  0.00%|            bind_kernel()
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|        try:
   408|         0|            0|            0|  0.00%|            connect_qtconsole(argv=arg_split(arg_s, os.name=='posix'))
   409|         0|            0|            0|  0.00%|        except Exception as e:
   410|         0|            0|            0|  0.00%|            warnings.warn("Could not start qtconsole: %r" % e)
   411|         0|            0|            0|  0.00%|            return
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|    @line_magic
   414|         0|            0|            0|  0.00%|    def autosave(self, arg_s):
   415|         0|            0|            0|  0.00%|        """Set the autosave interval in the notebook (in seconds).
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|        The default value is 120, or two minutes.
   418|         0|            0|            0|  0.00%|        ``%autosave 0`` will disable autosave.
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|        This magic only has an effect when called from the notebook interface.
   421|         0|            0|            0|  0.00%|        It has no effect when called in a startup file.
   422|         0|            0|            0|  0.00%|        """
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|        try:
   425|         0|            0|            0|  0.00%|            interval = int(arg_s)
   426|         0|            0|            0|  0.00%|        except ValueError:
   427|         0|            0|            0|  0.00%|            raise UsageError("%%autosave requires an integer, got %r" % arg_s)
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|        # javascript wants milliseconds
   430|         0|            0|            0|  0.00%|        milliseconds = 1000 * interval
   431|         0|            0|            0|  0.00%|        display(Javascript("IPython.notebook.set_autosave_interval(%i)" % milliseconds),
   432|         0|            0|            0|  0.00%|            include=['application/javascript']
   433|         0|            0|            0|  0.00%|        )
   434|         0|            0|            0|  0.00%|        if interval:
   435|         0|            0|            0|  0.00%|            print("Autosaving every %i seconds" % interval)
   436|         0|            0|            0|  0.00%|        else:
   437|         0|            0|            0|  0.00%|            print("Autosave disabled")
   438|         0|            0|            0|  0.00%|
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|class ZMQInteractiveShell(InteractiveShell):
   441|         0|            0|            0|  0.00%|    """A subclass of InteractiveShell for ZMQ."""
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|    displayhook_class = Type(ZMQShellDisplayHook)
   444|         0|            0|            0|  0.00%|    display_pub_class = Type(ZMQDisplayPublisher)
   445|         0|            0|            0|  0.00%|    data_pub_class = Type('ipykernel.datapub.ZMQDataPublisher')
   446|         0|            0|            0|  0.00%|    kernel = Any()
   447|         0|            0|            0|  0.00%|    parent_header = Any()
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|    @default('banner1')
   450|         0|            0|            0|  0.00%|    def _default_banner1(self):
   451|         0|            0|            0|  0.00%|        return default_banner
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|    # Override the traitlet in the parent class, because there's no point using
   454|         0|            0|            0|  0.00%|    # readline for the kernel. Can be removed when the readline code is moved
   455|         0|            0|            0|  0.00%|    # to the terminal frontend.
   456|         0|            0|            0|  0.00%|    readline_use = CBool(False)
   457|         0|            0|            0|  0.00%|    # autoindent has no meaning in a zmqshell, and attempting to enable it
   458|         0|            0|            0|  0.00%|    # will print a warning in the absence of readline.
   459|         0|            0|            0|  0.00%|    autoindent = CBool(False)
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|    exiter = Instance(ZMQExitAutocall)
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|    @default('exiter')
   464|         0|            0|            0|  0.00%|    def _default_exiter(self):
   465|         0|            0|            0|  0.00%|        return ZMQExitAutocall(self)
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|    @observe('exit_now')
   468|         0|            0|            0|  0.00%|    def _update_exit_now(self, change):
   469|         0|            0|            0|  0.00%|        """stop eventloop when exit_now fires"""
   470|         0|            0|            0|  0.00%|        if change['new']:
   471|         0|            0|            0|  0.00%|            loop = self.kernel.io_loop
   472|         0|            0|            0|  0.00%|            loop.call_later(0.1, loop.stop)
   473|         0|            0|            0|  0.00%|            if self.kernel.eventloop:
   474|         0|            0|            0|  0.00%|                exit_hook = getattr(self.kernel.eventloop, 'exit_hook', None)
   475|         0|            0|            0|  0.00%|                if exit_hook:
   476|         0|            0|            0|  0.00%|                    exit_hook(self.kernel)
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|    keepkernel_on_exit = None
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|    # Over ZeroMQ, GUI control isn't done with PyOS_InputHook as there is no
   481|         0|            0|            0|  0.00%|    # interactive input being read; we provide event loop support in ipkernel
   482|         0|            0|            0|  0.00%|    def enable_gui(self, gui):
   483|         0|            0|            0|  0.00%|        from .eventloops import enable_gui as real_enable_gui
   484|         0|            0|            0|  0.00%|        try:
   485|         0|            0|            0|  0.00%|            real_enable_gui(gui)
   486|         0|            0|            0|  0.00%|            self.active_eventloop = gui
   487|         0|            0|            0|  0.00%|        except ValueError as e:
   488|         0|            0|            0|  0.00%|            raise UsageError("%s" % e)
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|    def init_environment(self):
   491|         0|            0|            0|  0.00%|        """Configure the user's environment."""
   492|         0|            0|            0|  0.00%|        env = os.environ
   493|         0|            0|            0|  0.00%|        # These two ensure 'ls' produces nice coloring on BSD-derived systems
   494|         0|            0|            0|  0.00%|        env['TERM'] = 'xterm-color'
   495|         0|            0|            0|  0.00%|        env['CLICOLOR'] = '1'
   496|         0|            0|            0|  0.00%|        # Since normal pagers don't work at all (over pexpect we don't have
   497|         0|            0|            0|  0.00%|        # single-key control of the subprocess), try to disable paging in
   498|         0|            0|            0|  0.00%|        # subprocesses as much as possible.
   499|         0|            0|            0|  0.00%|        env['PAGER'] = 'cat'
   500|         0|            0|            0|  0.00%|        env['GIT_PAGER'] = 'cat'
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|    def init_hooks(self):
   503|         0|            0|            0|  0.00%|        super(ZMQInteractiveShell, self).init_hooks()
   504|         0|            0|            0|  0.00%|        self.set_hook('show_in_pager', page.as_hook(payloadpage.page), 99)
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|    def init_data_pub(self):
   507|         0|            0|            0|  0.00%|        """Delay datapub init until request, for deprecation warnings"""
   508|         0|            0|            0|  0.00%|        pass
   509|         0|            0|            0|  0.00%|
   510|         0|            0|            0|  0.00%|    @property
   511|         0|            0|            0|  0.00%|    def data_pub(self):
   512|         0|            0|            0|  0.00%|        if not hasattr(self, '_data_pub'):
   513|         0|            0|            0|  0.00%|            warnings.warn("InteractiveShell.data_pub is deprecated outside IPython parallel.",
   514|         0|            0|            0|  0.00%|                DeprecationWarning, stacklevel=2)
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|            self._data_pub = self.data_pub_class(parent=self)
   517|         0|            0|            0|  0.00%|            self._data_pub.session = self.display_pub.session
   518|         0|            0|            0|  0.00%|            self._data_pub.pub_socket = self.display_pub.pub_socket
   519|         0|            0|            0|  0.00%|        return self._data_pub
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|    @data_pub.setter
   522|         0|            0|            0|  0.00%|    def data_pub(self, pub):
   523|         0|            0|            0|  0.00%|        self._data_pub = pub
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|    def ask_exit(self):
   526|         0|            0|            0|  0.00%|        """Engage the exit actions."""
   527|         0|            0|            0|  0.00%|        self.exit_now = (not self.keepkernel_on_exit)
   528|         0|            0|            0|  0.00%|        payload = dict(
   529|         0|            0|            0|  0.00%|            source='ask_exit',
   530|         0|            0|            0|  0.00%|            keepkernel=self.keepkernel_on_exit,
   531|         0|            0|            0|  0.00%|            )
   532|         0|            0|            0|  0.00%|        self.payload_manager.write_payload(payload)
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|    def run_cell(self, *args, **kwargs):
   535|         0|            0|            0|  0.00%|        self._last_traceback = None
   536|         0|            0|            0|  0.00%|        return super(ZMQInteractiveShell, self).run_cell(*args, **kwargs)
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\IPython\core\interactiveshell.py:2591 run_cell
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|    def _showtraceback(self, etype, evalue, stb):
   539|         0|            0|            0|  0.00%|        # try to preserve ordering of tracebacks and print statements
   540|         0|            0|            0|  0.00%|        sys.stdout.flush()
   541|         0|            0|            0|  0.00%|        sys.stderr.flush()
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|        exc_content = {
   544|         0|            0|            0|  0.00%|            u'traceback' : stb,
   545|         0|            0|            0|  0.00%|            u'ename' : unicode_type(etype.__name__),
   546|         0|            0|            0|  0.00%|            u'evalue' : py3compat.safe_unicode(evalue),
   547|         0|            0|            0|  0.00%|        }
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|        dh = self.displayhook
   550|         0|            0|            0|  0.00%|        # Send exception info over pub socket for other clients than the caller
   551|         0|            0|            0|  0.00%|        # to pick up
   552|         0|            0|            0|  0.00%|        topic = None
   553|         0|            0|            0|  0.00%|        if dh.topic:
   554|         0|            0|            0|  0.00%|            topic = dh.topic.replace(b'execute_result', b'error')
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|        exc_msg = dh.session.send(dh.pub_socket, u'error', json_clean(exc_content),
   557|         0|            0|            0|  0.00%|                                  dh.parent_header, ident=topic)
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|        # FIXME - Once we rely on Python 3, the traceback is stored on the
   560|         0|            0|            0|  0.00%|        # exception object, so we shouldn't need to store it here.
   561|         0|            0|            0|  0.00%|        self._last_traceback = stb
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|    def set_next_input(self, text, replace=False):
   564|         0|            0|            0|  0.00%|        """Send the specified text to the frontend to be presented at the next
   565|         0|            0|            0|  0.00%|        input cell."""
   566|         0|            0|            0|  0.00%|        payload = dict(
   567|         0|            0|            0|  0.00%|            source='set_next_input',
   568|         0|            0|            0|  0.00%|            text=text,
   569|         0|            0|            0|  0.00%|            replace=replace,
   570|         0|            0|            0|  0.00%|        )
   571|         0|            0|            0|  0.00%|        self.payload_manager.write_payload(payload)
   572|         0|            0|            0|  0.00%|
   573|         0|            0|            0|  0.00%|    def set_parent(self, parent):
   574|         0|            0|            0|  0.00%|        """Set the parent header for associating output with its triggering input"""
   575|         0|            0|            0|  0.00%|        self.parent_header = parent
   576|         0|            0|            0|  0.00%|        self.displayhook.set_parent(parent)
   577|         0|            0|            0|  0.00%|        self.display_pub.set_parent(parent)
   578|         0|            0|            0|  0.00%|        if hasattr(self, '_data_pub'):
   579|         0|            0|            0|  0.00%|            self.data_pub.set_parent(parent)
   580|         0|            0|            0|  0.00%|        try:
   581|         0|            0|            0|  0.00%|            sys.stdout.set_parent(parent)
   582|         0|            0|            0|  0.00%|        except AttributeError:
   583|         0|            0|            0|  0.00%|            pass
   584|         0|            0|            0|  0.00%|        try:
   585|         0|            0|            0|  0.00%|            sys.stderr.set_parent(parent)
   586|         0|            0|            0|  0.00%|        except AttributeError:
   587|         0|            0|            0|  0.00%|            pass
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|    def get_parent(self):
   590|         0|            0|            0|  0.00%|        return self.parent_header
   591|         0|            0|            0|  0.00%|
   592|         0|            0|            0|  0.00%|    def init_magics(self):
   593|         0|            0|            0|  0.00%|        super(ZMQInteractiveShell, self).init_magics()
   594|         0|            0|            0|  0.00%|        self.register_magics(KernelMagics)
   595|         0|            0|            0|  0.00%|        self.magics_manager.register_alias('ed', 'edit')
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|    def init_virtualenv(self):
   598|         0|            0|            0|  0.00%|        # Overridden not to do virtualenv detection, because it's probably
   599|         0|            0|            0|  0.00%|        # not appropriate in a kernel. To use a kernel in a virtualenv, install
   600|         0|            0|            0|  0.00%|        # it inside the virtualenv.
   601|         0|            0|            0|  0.00%|        # https://ipython.readthedocs.io/en/latest/install/kernel_install.html
   602|         0|            0|            0|  0.00%|        pass
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|InteractiveShellABC.register(ZMQInteractiveShell)
File: D:\Application\Anaconda\lib\site-packages\spyder_kernels\console\__main__.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# -*- coding: utf-8 -*-
     2|         0|            0|            0|  0.00%|# -----------------------------------------------------------------------------
     3|         0|            0|            0|  0.00%|# Copyright (c) 2009- Spyder Kernels Contributors
     4|         0|            0|            0|  0.00%|#
     5|         0|            0|            0|  0.00%|# Licensed under the terms of the MIT License
     6|         0|            0|            0|  0.00%|# (see spyder_kernels/__init__.py for details)
     7|         0|            0|            0|  0.00%|# -----------------------------------------------------------------------------
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|if __name__ == '__main__':
    10|         0|            0|            0|  0.00%|    from spyder_kernels.console import start
    11|         0|            0|            0|  0.00%|    start.main()
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\spyder_kernels\console\start.py:272 main
File: D:\Application\Anaconda\lib\site-packages\tornado\stack_context.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|#!/usr/bin/env python
     2|         0|            0|            0|  0.00%|#
     3|         0|            0|            0|  0.00%|# Copyright 2010 Facebook
     4|         0|            0|            0|  0.00%|#
     5|         0|            0|            0|  0.00%|# Licensed under the Apache License, Version 2.0 (the "License"); you may
     6|         0|            0|            0|  0.00%|# not use this file except in compliance with the License. You may obtain
     7|         0|            0|            0|  0.00%|# a copy of the License at
     8|         0|            0|            0|  0.00%|#
     9|         0|            0|            0|  0.00%|#     http://www.apache.org/licenses/LICENSE-2.0
    10|         0|            0|            0|  0.00%|#
    11|         0|            0|            0|  0.00%|# Unless required by applicable law or agreed to in writing, software
    12|         0|            0|            0|  0.00%|# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
    13|         0|            0|            0|  0.00%|# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
    14|         0|            0|            0|  0.00%|# License for the specific language governing permissions and limitations
    15|         0|            0|            0|  0.00%|# under the License.
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|"""`StackContext` allows applications to maintain threadlocal-like state
    18|         0|            0|            0|  0.00%|that follows execution as it moves to other execution contexts.
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|The motivating examples are to eliminate the need for explicit
    21|         0|            0|            0|  0.00%|``async_callback`` wrappers (as in `tornado.web.RequestHandler`), and to
    22|         0|            0|            0|  0.00%|allow some additional context to be kept for logging.
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|This is slightly magic, but it's an extension of the idea that an
    25|         0|            0|            0|  0.00%|exception handler is a kind of stack-local state and when that stack
    26|         0|            0|            0|  0.00%|is suspended and resumed in a new context that state needs to be
    27|         0|            0|            0|  0.00%|preserved.  `StackContext` shifts the burden of restoring that state
    28|         0|            0|            0|  0.00%|from each call site (e.g.  wrapping each `.AsyncHTTPClient` callback
    29|         0|            0|            0|  0.00%|in ``async_callback``) to the mechanisms that transfer control from
    30|         0|            0|            0|  0.00%|one context to another (e.g. `.AsyncHTTPClient` itself, `.IOLoop`,
    31|         0|            0|            0|  0.00%|thread pools, etc).
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|Example usage::
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|    @contextlib.contextmanager
    36|         0|            0|            0|  0.00%|    def die_on_error():
    37|         0|            0|            0|  0.00%|        try:
    38|         0|            0|            0|  0.00%|            yield
    39|         0|            0|            0|  0.00%|        except Exception:
    40|         0|            0|            0|  0.00%|            logging.error("exception in asynchronous operation",exc_info=True)
    41|         0|            0|            0|  0.00%|            sys.exit(1)
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|    with StackContext(die_on_error):
    44|         0|            0|            0|  0.00%|        # Any exception thrown here *or in callback and its descendants*
    45|         0|            0|            0|  0.00%|        # will cause the process to exit instead of spinning endlessly
    46|         0|            0|            0|  0.00%|        # in the ioloop.
    47|         0|            0|            0|  0.00%|        http_client.fetch(url, callback)
    48|         0|            0|            0|  0.00%|    ioloop.start()
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|Most applications shouldn't have to work with `StackContext` directly.
    51|         0|            0|            0|  0.00%|Here are a few rules of thumb for when it's necessary:
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|* If you're writing an asynchronous library that doesn't rely on a
    54|         0|            0|            0|  0.00%|  stack_context-aware library like `tornado.ioloop` or `tornado.iostream`
    55|         0|            0|            0|  0.00%|  (for example, if you're writing a thread pool), use
    56|         0|            0|            0|  0.00%|  `.stack_context.wrap()` before any asynchronous operations to capture the
    57|         0|            0|            0|  0.00%|  stack context from where the operation was started.
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|* If you're writing an asynchronous library that has some shared
    60|         0|            0|            0|  0.00%|  resources (such as a connection pool), create those shared resources
    61|         0|            0|            0|  0.00%|  within a ``with stack_context.NullContext():`` block.  This will prevent
    62|         0|            0|            0|  0.00%|  ``StackContexts`` from leaking from one request to another.
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|* If you want to write something like an exception handler that will
    65|         0|            0|            0|  0.00%|  persist across asynchronous calls, create a new `StackContext` (or
    66|         0|            0|            0|  0.00%|  `ExceptionStackContext`), and make your asynchronous calls in a ``with``
    67|         0|            0|            0|  0.00%|  block that references your `StackContext`.
    68|         0|            0|            0|  0.00%|"""
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|from __future__ import absolute_import, division, print_function
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|import sys
    73|         0|            0|            0|  0.00%|import threading
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|from tornado.util import raise_exc_info
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|class StackContextInconsistentError(Exception):
    79|         0|            0|            0|  0.00%|    pass
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|class _State(threading.local):
    83|         0|            0|            0|  0.00%|    def __init__(self):
    84|         0|            0|            0|  0.00%|        self.contexts = (tuple(), None)
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|_state = _State()
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|class StackContext(object):
    91|         0|            0|            0|  0.00%|    """Establishes the given context as a StackContext that will be transferred.
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|    Note that the parameter is a callable that returns a context
    94|         0|            0|            0|  0.00%|    manager, not the context itself.  That is, where for a
    95|         0|            0|            0|  0.00%|    non-transferable context manager you would say::
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|      with my_context():
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|    StackContext takes the function itself rather than its result::
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|      with StackContext(my_context):
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|    The result of ``with StackContext() as cb:`` is a deactivation
   104|         0|            0|            0|  0.00%|    callback.  Run this callback when the StackContext is no longer
   105|         0|            0|            0|  0.00%|    needed to ensure that it is not propagated any further (note that
   106|         0|            0|            0|  0.00%|    deactivating a context does not affect any instances of that
   107|         0|            0|            0|  0.00%|    context that are currently pending).  This is an advanced feature
   108|         0|            0|            0|  0.00%|    and not necessary in most applications.
   109|         0|            0|            0|  0.00%|    """
   110|         0|            0|            0|  0.00%|    def __init__(self, context_factory):
   111|         0|            0|            0|  0.00%|        self.context_factory = context_factory
   112|         0|            0|            0|  0.00%|        self.contexts = []
   113|         0|            0|            0|  0.00%|        self.active = True
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|    def _deactivate(self):
   116|         0|            0|            0|  0.00%|        self.active = False
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|    # StackContext protocol
   119|         0|            0|            0|  0.00%|    def enter(self):
   120|         0|            0|            0|  0.00%|        context = self.context_factory()
   121|         0|            0|            0|  0.00%|        self.contexts.append(context)
   122|         0|            0|            0|  0.00%|        context.__enter__()
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|    def exit(self, type, value, traceback):
   125|         0|            0|            0|  0.00%|        context = self.contexts.pop()
   126|         0|            0|            0|  0.00%|        context.__exit__(type, value, traceback)
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|    # Note that some of this code is duplicated in ExceptionStackContext
   129|         0|            0|            0|  0.00%|    # below.  ExceptionStackContext is more common and doesn't need
   130|         0|            0|            0|  0.00%|    # the full generality of this class.
   131|         0|            0|            0|  0.00%|    def __enter__(self):
   132|         0|            0|            0|  0.00%|        self.old_contexts = _state.contexts
   133|         0|            0|            0|  0.00%|        self.new_contexts = (self.old_contexts[0] + (self,), self)
   134|         0|            0|            0|  0.00%|        _state.contexts = self.new_contexts
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|        try:
   137|         0|            0|            0|  0.00%|            self.enter()
   138|         0|            0|            0|  0.00%|        except:
   139|         0|            0|            0|  0.00%|            _state.contexts = self.old_contexts
   140|         0|            0|            0|  0.00%|            raise
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|        return self._deactivate
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    def __exit__(self, type, value, traceback):
   145|         0|            0|            0|  0.00%|        try:
   146|         0|            0|            0|  0.00%|            self.exit(type, value, traceback)
   147|         0|            0|            0|  0.00%|        finally:
   148|         0|            0|            0|  0.00%|            final_contexts = _state.contexts
   149|         0|            0|            0|  0.00%|            _state.contexts = self.old_contexts
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|            # Generator coroutines and with-statements with non-local
   152|         0|            0|            0|  0.00%|            # effects interact badly.  Check here for signs of
   153|         0|            0|            0|  0.00%|            # the stack getting out of sync.
   154|         0|            0|            0|  0.00%|            # Note that this check comes after restoring _state.context
   155|         0|            0|            0|  0.00%|            # so that if it fails things are left in a (relatively)
   156|         0|            0|            0|  0.00%|            # consistent state.
   157|         0|            0|            0|  0.00%|            if final_contexts is not self.new_contexts:
   158|         0|            0|            0|  0.00%|                raise StackContextInconsistentError(
   159|         0|            0|            0|  0.00%|                    'stack_context inconsistency (may be caused by yield '
   160|         0|            0|            0|  0.00%|                    'within a "with StackContext" block)')
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|            # Break up a reference to itself to allow for faster GC on CPython.
   163|         0|            0|            0|  0.00%|            self.new_contexts = None
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|class ExceptionStackContext(object):
   167|         0|            0|            0|  0.00%|    """Specialization of StackContext for exception handling.
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|    The supplied ``exception_handler`` function will be called in the
   170|         0|            0|            0|  0.00%|    event of an uncaught exception in this context.  The semantics are
   171|         0|            0|            0|  0.00%|    similar to a try/finally clause, and intended use cases are to log
   172|         0|            0|            0|  0.00%|    an error, close a socket, or similar cleanup actions.  The
   173|         0|            0|            0|  0.00%|    ``exc_info`` triple ``(type, value, traceback)`` will be passed to the
   174|         0|            0|            0|  0.00%|    exception_handler function.
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|    If the exception handler returns true, the exception will be
   177|         0|            0|            0|  0.00%|    consumed and will not be propagated to other exception handlers.
   178|         0|            0|            0|  0.00%|    """
   179|         0|            0|            0|  0.00%|    def __init__(self, exception_handler):
   180|         0|            0|            0|  0.00%|        self.exception_handler = exception_handler
   181|         0|            0|            0|  0.00%|        self.active = True
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    def _deactivate(self):
   184|         0|            0|            0|  0.00%|        self.active = False
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|    def exit(self, type, value, traceback):
   187|         0|            0|            0|  0.00%|        if type is not None:
   188|         0|            0|            0|  0.00%|            return self.exception_handler(type, value, traceback)
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|    def __enter__(self):
   191|         0|            0|            0|  0.00%|        self.old_contexts = _state.contexts
   192|         0|            0|            0|  0.00%|        self.new_contexts = (self.old_contexts[0], self)
   193|         0|            0|            0|  0.00%|        _state.contexts = self.new_contexts
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|        return self._deactivate
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|    def __exit__(self, type, value, traceback):
   198|         0|            0|            0|  0.00%|        try:
   199|         0|            0|            0|  0.00%|            if type is not None:
   200|         0|            0|            0|  0.00%|                return self.exception_handler(type, value, traceback)
   201|         0|            0|            0|  0.00%|        finally:
   202|         0|            0|            0|  0.00%|            final_contexts = _state.contexts
   203|         0|            0|            0|  0.00%|            _state.contexts = self.old_contexts
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|            if final_contexts is not self.new_contexts:
   206|         0|            0|            0|  0.00%|                raise StackContextInconsistentError(
   207|         0|            0|            0|  0.00%|                    'stack_context inconsistency (may be caused by yield '
   208|         0|            0|            0|  0.00%|                    'within a "with StackContext" block)')
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|            # Break up a reference to itself to allow for faster GC on CPython.
   211|         0|            0|            0|  0.00%|            self.new_contexts = None
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|class NullContext(object):
   215|         0|            0|            0|  0.00%|    """Resets the `StackContext`.
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|    Useful when creating a shared resource on demand (e.g. an
   218|         0|            0|            0|  0.00%|    `.AsyncHTTPClient`) where the stack that caused the creating is
   219|         0|            0|            0|  0.00%|    not relevant to future operations.
   220|         0|            0|            0|  0.00%|    """
   221|         0|            0|            0|  0.00%|    def __enter__(self):
   222|         0|            0|            0|  0.00%|        self.old_contexts = _state.contexts
   223|         0|            0|            0|  0.00%|        _state.contexts = (tuple(), None)
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|    def __exit__(self, type, value, traceback):
   226|         0|            0|            0|  0.00%|        _state.contexts = self.old_contexts
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|def _remove_deactivated(contexts):
   230|         0|            0|            0|  0.00%|    """Remove deactivated handlers from the chain"""
   231|         0|            0|            0|  0.00%|    # Clean ctx handlers
   232|         0|            0|            0|  0.00%|    stack_contexts = tuple([h for h in contexts[0] if h.active])
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|    # Find new head
   235|         0|            0|            0|  0.00%|    head = contexts[1]
   236|         0|            0|            0|  0.00%|    while head is not None and not head.active:
   237|         0|            0|            0|  0.00%|        head = head.old_contexts[1]
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|    # Process chain
   240|         0|            0|            0|  0.00%|    ctx = head
   241|         0|            0|            0|  0.00%|    while ctx is not None:
   242|         0|            0|            0|  0.00%|        parent = ctx.old_contexts[1]
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|        while parent is not None:
   245|         0|            0|            0|  0.00%|            if parent.active:
   246|         0|            0|            0|  0.00%|                break
   247|         0|            0|            0|  0.00%|            ctx.old_contexts = parent.old_contexts
   248|         0|            0|            0|  0.00%|            parent = parent.old_contexts[1]
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|        ctx = parent
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|    return (stack_contexts, head)
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|def wrap(fn):
   256|         0|            0|            0|  0.00%|    """Returns a callable object that will restore the current `StackContext`
   257|         0|            0|            0|  0.00%|    when executed.
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|    Use this whenever saving a callback to be executed later in a
   260|         0|            0|            0|  0.00%|    different execution context (either in a different thread or
   261|         0|            0|            0|  0.00%|    asynchronously in the same thread).
   262|         0|            0|            0|  0.00%|    """
   263|         0|            0|            0|  0.00%|    # Check if function is already wrapped
   264|         0|            0|            0|  0.00%|    if fn is None or hasattr(fn, '_wrapped'):
   265|         0|            0|            0|  0.00%|        return fn
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|    # Capture current stack head
   268|         0|            0|            0|  0.00%|    # TODO: Any other better way to store contexts and update them in wrapped function?
   269|         0|            0|            0|  0.00%|    cap_contexts = [_state.contexts]
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|    if not cap_contexts[0][0] and not cap_contexts[0][1]:
   272|         0|            0|            0|  0.00%|        # Fast path when there are no active contexts.
   273|         0|            0|            0|  0.00%|        def null_wrapper(*args, **kwargs):
   274|         0|            0|            0|  0.00%|            try:
   275|         0|            0|            0|  0.00%|                current_state = _state.contexts
   276|         0|            0|            0|  0.00%|                _state.contexts = cap_contexts[0]
   277|         0|            0|            0|  0.00%|                return fn(*args, **kwargs)
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\tornado\gen.py:1149 inner
   278|         0|            0|            0|  0.00%|            finally:
   279|         0|            0|            0|  0.00%|                _state.contexts = current_state
   280|         0|            0|            0|  0.00%|        null_wrapper._wrapped = True
   281|         0|            0|            0|  0.00%|        return null_wrapper
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|    def wrapped(*args, **kwargs):
   284|         0|            0|            0|  0.00%|        ret = None
   285|         0|            0|            0|  0.00%|        try:
   286|         0|            0|            0|  0.00%|            # Capture old state
   287|         0|            0|            0|  0.00%|            current_state = _state.contexts
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|            # Remove deactivated items
   290|         0|            0|            0|  0.00%|            cap_contexts[0] = contexts = _remove_deactivated(cap_contexts[0])
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|            # Force new state
   293|         0|            0|            0|  0.00%|            _state.contexts = contexts
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|            # Current exception
   296|         0|            0|            0|  0.00%|            exc = (None, None, None)
   297|         0|            0|            0|  0.00%|            top = None
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|            # Apply stack contexts
   300|         0|            0|            0|  0.00%|            last_ctx = 0
   301|         0|            0|            0|  0.00%|            stack = contexts[0]
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|            # Apply state
   304|         0|            0|            0|  0.00%|            for n in stack:
   305|         0|            0|            0|  0.00%|                try:
   306|         0|            0|            0|  0.00%|                    n.enter()
   307|         0|            0|            0|  0.00%|                    last_ctx += 1
   308|         0|            0|            0|  0.00%|                except:
   309|         0|            0|            0|  0.00%|                    # Exception happened. Record exception info and store top-most handler
   310|         0|            0|            0|  0.00%|                    exc = sys.exc_info()
   311|         0|            0|            0|  0.00%|                    top = n.old_contexts[1]
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|            # Execute callback if no exception happened while restoring state
   314|         0|            0|            0|  0.00%|            if top is None:
   315|         0|            0|            0|  0.00%|                try:
   316|         0|            0|            0|  0.00%|                    ret = fn(*args, **kwargs)
   317|         0|            0|            0|  0.00%|                except:
   318|         0|            0|            0|  0.00%|                    exc = sys.exc_info()
   319|         0|            0|            0|  0.00%|                    top = contexts[1]
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|            # If there was exception, try to handle it by going through the exception chain
   322|         0|            0|            0|  0.00%|            if top is not None:
   323|         0|            0|            0|  0.00%|                exc = _handle_exception(top, exc)
   324|         0|            0|            0|  0.00%|            else:
   325|         0|            0|            0|  0.00%|                # Otherwise take shorter path and run stack contexts in reverse order
   326|         0|            0|            0|  0.00%|                while last_ctx > 0:
   327|         0|            0|            0|  0.00%|                    last_ctx -= 1
   328|         0|            0|            0|  0.00%|                    c = stack[last_ctx]
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|                    try:
   331|         0|            0|            0|  0.00%|                        c.exit(*exc)
   332|         0|            0|            0|  0.00%|                    except:
   333|         0|            0|            0|  0.00%|                        exc = sys.exc_info()
   334|         0|            0|            0|  0.00%|                        top = c.old_contexts[1]
   335|         0|            0|            0|  0.00%|                        break
   336|         0|            0|            0|  0.00%|                else:
   337|         0|            0|            0|  0.00%|                    top = None
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|                # If if exception happened while unrolling, take longer exception handler path
   340|         0|            0|            0|  0.00%|                if top is not None:
   341|         0|            0|            0|  0.00%|                    exc = _handle_exception(top, exc)
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|            # If exception was not handled, raise it
   344|         0|            0|            0|  0.00%|            if exc != (None, None, None):
   345|         0|            0|            0|  0.00%|                raise_exc_info(exc)
   346|         0|            0|            0|  0.00%|        finally:
   347|         0|            0|            0|  0.00%|            _state.contexts = current_state
   348|         0|            0|            0|  0.00%|        return ret
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|    wrapped._wrapped = True
   351|         0|            0|            0|  0.00%|    return wrapped
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|def _handle_exception(tail, exc):
   355|         0|            0|            0|  0.00%|    while tail is not None:
   356|         0|            0|            0|  0.00%|        try:
   357|         0|            0|            0|  0.00%|            if tail.exit(*exc):
   358|         0|            0|            0|  0.00%|                exc = (None, None, None)
   359|         0|            0|            0|  0.00%|        except:
   360|         0|            0|            0|  0.00%|            exc = sys.exc_info()
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|        tail = tail.old_contexts[1]
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|    return exc
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|def run_with_stack_context(context, func):
   368|         0|            0|            0|  0.00%|    """Run a coroutine ``func`` in the given `StackContext`.
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|    It is not safe to have a ``yield`` statement within a ``with StackContext``
   371|         0|            0|            0|  0.00%|    block, so it is difficult to use stack context with `.gen.coroutine`.
   372|         0|            0|            0|  0.00%|    This helper function runs the function in the correct context while
   373|         0|            0|            0|  0.00%|    keeping the ``yield`` and ``with`` statements syntactically separate.
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|    Example::
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|        @gen.coroutine
   378|         0|            0|            0|  0.00%|        def incorrect():
   379|         0|            0|            0|  0.00%|            with StackContext(ctx):
   380|         0|            0|            0|  0.00%|                # ERROR: this will raise StackContextInconsistentError
   381|         0|            0|            0|  0.00%|                yield other_coroutine()
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|        @gen.coroutine
   384|         0|            0|            0|  0.00%|        def correct():
   385|         0|            0|            0|  0.00%|            yield run_with_stack_context(StackContext(ctx), other_coroutine)
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|    .. versionadded:: 3.1
   388|         0|            0|            0|  0.00%|    """
   389|         0|            0|            0|  0.00%|    with context:
   390|         0|            0|            0|  0.00%|        return func()
File: D:\Application\Anaconda\lib\site-packages\ipykernel\kernelbase.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Base class for a kernel that talks to frontends over 0MQ."""
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|# Copyright (c) IPython Development Team.
     4|         0|            0|            0|  0.00%|# Distributed under the terms of the Modified BSD License.
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|from __future__ import print_function
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|from datetime import datetime
     9|         0|            0|            0|  0.00%|from functools import partial
    10|         0|            0|            0|  0.00%|import itertools
    11|         0|            0|            0|  0.00%|import logging
    12|         0|            0|            0|  0.00%|from signal import signal, default_int_handler, SIGINT
    13|         0|            0|            0|  0.00%|import sys
    14|         0|            0|            0|  0.00%|import time
    15|         0|            0|            0|  0.00%|import uuid
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|try:
    18|         0|            0|            0|  0.00%|    # jupyter_client >= 5, use tz-aware now
    19|         0|            0|            0|  0.00%|    from jupyter_client.session import utcnow as now
    20|         0|            0|            0|  0.00%|except ImportError:
    21|         0|            0|            0|  0.00%|    # jupyter_client < 5, use local now()
    22|         0|            0|            0|  0.00%|    now = datetime.now
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|from tornado import ioloop
    25|         0|            0|            0|  0.00%|from tornado import gen
    26|         0|            0|            0|  0.00%|from tornado.queues import PriorityQueue, QueueEmpty
    27|         0|            0|            0|  0.00%|import zmq
    28|         0|            0|            0|  0.00%|from zmq.eventloop.zmqstream import ZMQStream
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|from traitlets.config.configurable import SingletonConfigurable
    31|         0|            0|            0|  0.00%|from IPython.core.error import StdinNotImplementedError
    32|         0|            0|            0|  0.00%|from ipython_genutils import py3compat
    33|         0|            0|            0|  0.00%|from ipython_genutils.py3compat import unicode_type, string_types
    34|         0|            0|            0|  0.00%|from ipykernel.jsonutil import json_clean
    35|         0|            0|            0|  0.00%|from traitlets import (
    36|         0|            0|            0|  0.00%|    Any, Instance, Float, Dict, List, Set, Integer, Unicode, Bool,
    37|         0|            0|            0|  0.00%|    observe, default
    38|         0|            0|            0|  0.00%|)
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|from jupyter_client.session import Session
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|from ._version import kernel_protocol_version
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|CONTROL_PRIORITY = 1
    45|         0|            0|            0|  0.00%|SHELL_PRIORITY = 10
    46|         0|            0|            0|  0.00%|ABORT_PRIORITY = 20
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|class Kernel(SingletonConfigurable):
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    #---------------------------------------------------------------------------
    52|         0|            0|            0|  0.00%|    # Kernel interface
    53|         0|            0|            0|  0.00%|    #---------------------------------------------------------------------------
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|    # attribute to override with a GUI
    56|         0|            0|            0|  0.00%|    eventloop = Any(None)
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|    @observe('eventloop')
    59|         0|            0|            0|  0.00%|    def _update_eventloop(self, change):
    60|         0|            0|            0|  0.00%|        """schedule call to eventloop from IOLoop"""
    61|         0|            0|            0|  0.00%|        loop = ioloop.IOLoop.current()
    62|         0|            0|            0|  0.00%|        if change.new is not None:
    63|         0|            0|            0|  0.00%|            loop.add_callback(self.enter_eventloop)
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    session = Instance(Session, allow_none=True)
    66|         0|            0|            0|  0.00%|    profile_dir = Instance('IPython.core.profiledir.ProfileDir', allow_none=True)
    67|         0|            0|            0|  0.00%|    shell_streams = List()
    68|         0|            0|            0|  0.00%|    control_stream = Instance(ZMQStream, allow_none=True)
    69|         0|            0|            0|  0.00%|    iopub_socket = Any()
    70|         0|            0|            0|  0.00%|    iopub_thread = Any()
    71|         0|            0|            0|  0.00%|    stdin_socket = Any()
    72|         0|            0|            0|  0.00%|    log = Instance(logging.Logger, allow_none=True)
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|    # identities:
    75|         0|            0|            0|  0.00%|    int_id = Integer(-1)
    76|         0|            0|            0|  0.00%|    ident = Unicode()
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|    @default('ident')
    79|         0|            0|            0|  0.00%|    def _default_ident(self):
    80|         0|            0|            0|  0.00%|        return unicode_type(uuid.uuid4())
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|    # This should be overridden by wrapper kernels that implement any real
    83|         0|            0|            0|  0.00%|    # language.
    84|         0|            0|            0|  0.00%|    language_info = {}
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    # any links that should go in the help menu
    87|         0|            0|            0|  0.00%|    help_links = List()
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|    # Private interface
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|    _darwin_app_nap = Bool(True,
    92|         0|            0|            0|  0.00%|        help="""Whether to use appnope for compatibility with OS X App Nap.
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|        Only affects OS X >= 10.9.
    95|         0|            0|            0|  0.00%|        """
    96|         0|            0|            0|  0.00%|    ).tag(config=True)
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|    # track associations with current request
    99|         0|            0|            0|  0.00%|    _allow_stdin = Bool(False)
   100|         0|            0|            0|  0.00%|    _parent_header = Dict()
   101|         0|            0|            0|  0.00%|    _parent_ident = Any(b'')
   102|         0|            0|            0|  0.00%|    # Time to sleep after flushing the stdout/err buffers in each execute
   103|         0|            0|            0|  0.00%|    # cycle.  While this introduces a hard limit on the minimal latency of the
   104|         0|            0|            0|  0.00%|    # execute cycle, it helps prevent output synchronization problems for
   105|         0|            0|            0|  0.00%|    # clients.
   106|         0|            0|            0|  0.00%|    # Units are in seconds.  The minimum zmq latency on local host is probably
   107|         0|            0|            0|  0.00%|    # ~150 microseconds, set this to 500us for now.  We may need to increase it
   108|         0|            0|            0|  0.00%|    # a little if it's not enough after more interactive testing.
   109|         0|            0|            0|  0.00%|    _execute_sleep = Float(0.0005).tag(config=True)
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|    # Frequency of the kernel's event loop.
   112|         0|            0|            0|  0.00%|    # Units are in seconds, kernel subclasses for GUI toolkits may need to
   113|         0|            0|            0|  0.00%|    # adapt to milliseconds.
   114|         0|            0|            0|  0.00%|    _poll_interval = Float(0.01).tag(config=True)
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|    stop_on_error_timeout = Float(
   117|         0|            0|            0|  0.00%|        0.1,
   118|         0|            0|            0|  0.00%|        config=True,
   119|         0|            0|            0|  0.00%|        help="""time (in seconds) to wait for messages to arrive
   120|         0|            0|            0|  0.00%|        when aborting queued requests after an error.
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|        Requests that arrive within this window after an error
   123|         0|            0|            0|  0.00%|        will be cancelled.
   124|         0|            0|            0|  0.00%|
   125|         0|            0|            0|  0.00%|        Increase in the event of unusually slow network
   126|         0|            0|            0|  0.00%|        causing significant delays,
   127|         0|            0|            0|  0.00%|        which can manifest as e.g. "Run all" in a notebook
   128|         0|            0|            0|  0.00%|        aborting some, but not all, messages after an error.
   129|         0|            0|            0|  0.00%|        """
   130|         0|            0|            0|  0.00%|    )
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|    # If the shutdown was requested over the network, we leave here the
   133|         0|            0|            0|  0.00%|    # necessary reply message so it can be sent by our registered atexit
   134|         0|            0|            0|  0.00%|    # handler.  This ensures that the reply is only sent to clients truly at
   135|         0|            0|            0|  0.00%|    # the end of our shutdown process (which happens after the underlying
   136|         0|            0|            0|  0.00%|    # IPython shell's own shutdown).
   137|         0|            0|            0|  0.00%|    _shutdown_message = None
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|    # This is a dict of port number that the kernel is listening on. It is set
   140|         0|            0|            0|  0.00%|    # by record_ports and used by connect_request.
   141|         0|            0|            0|  0.00%|    _recorded_ports = Dict()
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|    # set of aborted msg_ids
   144|         0|            0|            0|  0.00%|    aborted = Set()
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|    # Track execution count here. For IPython, we override this to use the
   147|         0|            0|            0|  0.00%|    # execution count we store in the shell.
   148|         0|            0|            0|  0.00%|    execution_count = 0
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|    msg_types = [
   151|         0|            0|            0|  0.00%|        'execute_request', 'complete_request',
   152|         0|            0|            0|  0.00%|        'inspect_request', 'history_request',
   153|         0|            0|            0|  0.00%|        'comm_info_request', 'kernel_info_request',
   154|         0|            0|            0|  0.00%|        'connect_request', 'shutdown_request',
   155|         0|            0|            0|  0.00%|        'is_complete_request',
   156|         0|            0|            0|  0.00%|        # deprecated:
   157|         0|            0|            0|  0.00%|        'apply_request',
   158|         0|            0|            0|  0.00%|    ]
   159|         0|            0|            0|  0.00%|    # add deprecated ipyparallel control messages
   160|         0|            0|            0|  0.00%|    control_msg_types = msg_types + ['clear_request', 'abort_request']
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|    def __init__(self, **kwargs):
   163|         0|            0|            0|  0.00%|        super(Kernel, self).__init__(**kwargs)
   164|         0|            0|            0|  0.00%|        # Build dict of handlers for message types
   165|         0|            0|            0|  0.00%|        self.shell_handlers = {}
   166|         0|            0|            0|  0.00%|        for msg_type in self.msg_types:
   167|         0|            0|            0|  0.00%|            self.shell_handlers[msg_type] = getattr(self, msg_type)
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|        self.control_handlers = {}
   170|         0|            0|            0|  0.00%|        for msg_type in self.control_msg_types:
   171|         0|            0|            0|  0.00%|            self.control_handlers[msg_type] = getattr(self, msg_type)
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|    @gen.coroutine
   174|         0|            0|            0|  0.00%|    def dispatch_control(self, msg):
   175|         0|            0|            0|  0.00%|        """dispatch control requests"""
   176|         0|            0|            0|  0.00%|        idents, msg = self.session.feed_identities(msg, copy=False)
   177|         0|            0|            0|  0.00%|        try:
   178|         0|            0|            0|  0.00%|            msg = self.session.deserialize(msg, content=True, copy=False)
   179|         0|            0|            0|  0.00%|        except:
   180|         0|            0|            0|  0.00%|            self.log.error("Invalid Control Message", exc_info=True)
   181|         0|            0|            0|  0.00%|            return
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|        self.log.debug("Control received: %s", msg)
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|        # Set the parent message for side effects.
   186|         0|            0|            0|  0.00%|        self.set_parent(idents, msg)
   187|         0|            0|            0|  0.00%|        self._publish_status(u'busy')
   188|         0|            0|            0|  0.00%|        if self._aborting:
   189|         0|            0|            0|  0.00%|            self._send_abort_reply(self.control_stream, msg, idents)
   190|         0|            0|            0|  0.00%|            self._publish_status(u'idle')
   191|         0|            0|            0|  0.00%|            return
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|        header = msg['header']
   194|         0|            0|            0|  0.00%|        msg_type = header['msg_type']
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|        handler = self.control_handlers.get(msg_type, None)
   197|         0|            0|            0|  0.00%|        if handler is None:
   198|         0|            0|            0|  0.00%|            self.log.error("UNKNOWN CONTROL MESSAGE TYPE: %r", msg_type)
   199|         0|            0|            0|  0.00%|        else:
   200|         0|            0|            0|  0.00%|            try:
   201|         0|            0|            0|  0.00%|                yield gen.maybe_future(handler(self.control_stream, idents, msg))
   202|         0|            0|            0|  0.00%|            except Exception:
   203|         0|            0|            0|  0.00%|                self.log.error("Exception in control handler:", exc_info=True)
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|        sys.stdout.flush()
   206|         0|            0|            0|  0.00%|        sys.stderr.flush()
   207|         0|            0|            0|  0.00%|        self._publish_status(u'idle')
   208|         0|            0|            0|  0.00%|        # flush to ensure reply is sent
   209|         0|            0|            0|  0.00%|        self.control_stream.flush(zmq.POLLOUT)
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|    def should_handle(self, stream, msg, idents):
   212|         0|            0|            0|  0.00%|        """Check whether a shell-channel message should be handled
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|        Allows subclasses to prevent handling of certain messages (e.g. aborted requests).
   215|         0|            0|            0|  0.00%|        """
   216|         0|            0|            0|  0.00%|        msg_id = msg['header']['msg_id']
   217|         0|            0|            0|  0.00%|        if msg_id in self.aborted:
   218|         0|            0|            0|  0.00%|            msg_type = msg['header']['msg_type']
   219|         0|            0|            0|  0.00%|            # is it safe to assume a msg_id will not be resubmitted?
   220|         0|            0|            0|  0.00%|            self.aborted.remove(msg_id)
   221|         0|            0|            0|  0.00%|            self._send_abort_reply(stream, msg, idents)
   222|         0|            0|            0|  0.00%|            return False
   223|         0|            0|            0|  0.00%|        return True
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|    @gen.coroutine
   226|         0|            0|            0|  0.00%|    def dispatch_shell(self, stream, msg):
   227|         0|            0|            0|  0.00%|        """dispatch shell requests"""
   228|         0|            0|            0|  0.00%|        # flush control requests first
   229|         0|            0|            0|  0.00%|        if self.control_stream:
   230|         0|            0|            0|  0.00%|            self.control_stream.flush()
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|        idents, msg = self.session.feed_identities(msg, copy=False)
   233|         0|            0|            0|  0.00%|        try:
   234|         0|            0|            0|  0.00%|            msg = self.session.deserialize(msg, content=True, copy=False)
   235|         0|            0|            0|  0.00%|        except:
   236|         0|            0|            0|  0.00%|            self.log.error("Invalid Message", exc_info=True)
   237|         0|            0|            0|  0.00%|            return
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|        # Set the parent message for side effects.
   240|         0|            0|            0|  0.00%|        self.set_parent(idents, msg)
   241|         0|            0|            0|  0.00%|        self._publish_status(u'busy')
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|        if self._aborting:
   244|         0|            0|            0|  0.00%|            self._send_abort_reply(stream, msg, idents)
   245|         0|            0|            0|  0.00%|            self._publish_status(u'idle')
   246|         0|            0|            0|  0.00%|            # flush to ensure reply is sent before
   247|         0|            0|            0|  0.00%|            # handling the next request
   248|         0|            0|            0|  0.00%|            stream.flush(zmq.POLLOUT)
   249|         0|            0|            0|  0.00%|            return
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|        msg_type = msg['header']['msg_type']
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|        # Print some info about this message and leave a '--->' marker, so it's
   254|         0|            0|            0|  0.00%|        # easier to trace visually the message chain when debugging.  Each
   255|         0|            0|            0|  0.00%|        # handler prints its message at the end.
   256|         0|            0|            0|  0.00%|        self.log.debug('\n*** MESSAGE TYPE:%s***', msg_type)
   257|         0|            0|            0|  0.00%|        self.log.debug('   Content: %s\n   --->\n   ', msg['content'])
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|        if not self.should_handle(stream, msg, idents):
   260|         0|            0|            0|  0.00%|            return
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|        handler = self.shell_handlers.get(msg_type, None)
   263|         0|            0|            0|  0.00%|        if handler is None:
   264|         0|            0|            0|  0.00%|            self.log.warning("Unknown message type: %r", msg_type)
   265|         0|            0|            0|  0.00%|        else:
   266|         0|            0|            0|  0.00%|            self.log.debug("%s: %s", msg_type, msg)
   267|         0|            0|            0|  0.00%|            try:
   268|         0|            0|            0|  0.00%|                self.pre_handler_hook()
   269|         0|            0|            0|  0.00%|            except Exception:
   270|         0|            0|            0|  0.00%|                self.log.debug("Unable to signal in pre_handler_hook:", exc_info=True)
   271|         0|            0|            0|  0.00%|            try:
   272|         0|            0|            0|  0.00%|                yield gen.maybe_future(handler(stream, idents, msg))
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\tornado\gen.py:282 wrapper
   273|         0|            0|            0|  0.00%|            except Exception:
   274|         0|            0|            0|  0.00%|                self.log.error("Exception in message handler:", exc_info=True)
   275|         0|            0|            0|  0.00%|            finally:
   276|         0|            0|            0|  0.00%|                try:
   277|         0|            0|            0|  0.00%|                    self.post_handler_hook()
   278|         0|            0|            0|  0.00%|                except Exception:
   279|         0|            0|            0|  0.00%|                    self.log.debug("Unable to signal in post_handler_hook:", exc_info=True)
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|        sys.stdout.flush()
   282|         0|            0|            0|  0.00%|        sys.stderr.flush()
   283|         0|            0|            0|  0.00%|        self._publish_status(u'idle')
   284|         0|            0|            0|  0.00%|        # flush to ensure reply is sent before
   285|         0|            0|            0|  0.00%|        # handling the next request
   286|         0|            0|            0|  0.00%|        stream.flush(zmq.POLLOUT)
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|    def pre_handler_hook(self):
   289|         0|            0|            0|  0.00%|        """Hook to execute before calling message handler"""
   290|         0|            0|            0|  0.00%|        # ensure default_int_handler during handler call
   291|         0|            0|            0|  0.00%|        self.saved_sigint_handler = signal(SIGINT, default_int_handler)
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|    def post_handler_hook(self):
   294|         0|            0|            0|  0.00%|        """Hook to execute after calling message handler"""
   295|         0|            0|            0|  0.00%|        signal(SIGINT, self.saved_sigint_handler)
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|    def enter_eventloop(self):
   298|         0|            0|            0|  0.00%|        """enter eventloop"""
   299|         0|            0|            0|  0.00%|        self.log.info("Entering eventloop %s", self.eventloop)
   300|         0|            0|            0|  0.00%|        # record handle, so we can check when this changes
   301|         0|            0|            0|  0.00%|        eventloop = self.eventloop
   302|         0|            0|            0|  0.00%|        def advance_eventloop():
   303|         0|            0|            0|  0.00%|            # check if eventloop changed:
   304|         0|            0|            0|  0.00%|            if self.eventloop is not eventloop:
   305|         0|            0|            0|  0.00%|                self.log.info("exiting eventloop %s", eventloop)
   306|         0|            0|            0|  0.00%|                return
   307|         0|            0|            0|  0.00%|            if self.msg_queue.qsize():
   308|         0|            0|            0|  0.00%|                self.log.debug("Delaying eventloop due to waiting messages")
   309|         0|            0|            0|  0.00%|                # still messages to process, make the eventloop wait
   310|         0|            0|            0|  0.00%|                schedule_next()
   311|         0|            0|            0|  0.00%|                return
   312|         0|            0|            0|  0.00%|            self.log.debug("Advancing eventloop %s", eventloop)
   313|         0|            0|            0|  0.00%|            try:
   314|         0|            0|            0|  0.00%|                eventloop(self)
   315|         0|            0|            0|  0.00%|            except KeyboardInterrupt:
   316|         0|            0|            0|  0.00%|                # Ctrl-C shouldn't crash the kernel
   317|         0|            0|            0|  0.00%|                self.log.error("KeyboardInterrupt caught in kernel")
   318|         0|            0|            0|  0.00%|                pass
   319|         0|            0|            0|  0.00%|            if self.eventloop is eventloop:
   320|         0|            0|            0|  0.00%|                # schedule advance again
   321|         0|            0|            0|  0.00%|                schedule_next()
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|        def schedule_next():
   324|         0|            0|            0|  0.00%|            """Schedule the next advance of the eventloop"""
   325|         0|            0|            0|  0.00%|            # flush the eventloop every so often,
   326|         0|            0|            0|  0.00%|            # giving us a chance to handle messages in the meantime
   327|         0|            0|            0|  0.00%|            self.log.debug("Scheduling eventloop advance")
   328|         0|            0|            0|  0.00%|            self.io_loop.call_later(1, advance_eventloop)
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|        # begin polling the eventloop
   331|         0|            0|            0|  0.00%|        schedule_next()
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|    @gen.coroutine
   334|         0|            0|            0|  0.00%|    def do_one_iteration(self):
   335|         0|            0|            0|  0.00%|        """Process a single shell message
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|        Any pending control messages will be flushed as well
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|        .. versionchanged:: 5
   340|         0|            0|            0|  0.00%|            This is now a coroutine
   341|         0|            0|            0|  0.00%|        """
   342|         0|            0|            0|  0.00%|        # flush messages off of shell streams into the message queue
   343|         0|            0|            0|  0.00%|        for stream in self.shell_streams:
   344|         0|            0|            0|  0.00%|            stream.flush()
   345|         0|            0|            0|  0.00%|        # process all messages higher priority than shell (control),
   346|         0|            0|            0|  0.00%|        # and at most one shell message per iteration
   347|         0|            0|            0|  0.00%|        priority = 0
   348|         0|            0|            0|  0.00%|        while priority is not None and priority < SHELL_PRIORITY:
   349|         0|            0|            0|  0.00%|            priority = yield self.process_one(wait=False)
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|    @gen.coroutine
   352|         0|            0|            0|  0.00%|    def process_one(self, wait=True):
   353|         0|            0|            0|  0.00%|        """Process one request
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|        Returns priority of the message handled.
   356|         0|            0|            0|  0.00%|        Returns None if no message was handled.
   357|         0|            0|            0|  0.00%|        """
   358|         0|            0|            0|  0.00%|        if wait:
   359|         0|            0|            0|  0.00%|            priority, t, dispatch, args = yield self.msg_queue.get()
   360|         0|            0|            0|  0.00%|        else:
   361|         0|            0|            0|  0.00%|            try:
   362|         0|            0|            0|  0.00%|                priority, t, dispatch, args = self.msg_queue.get_nowait()
   363|         0|            0|            0|  0.00%|            except QueueEmpty:
   364|         0|            0|            0|  0.00%|                return None
   365|         0|            0|            0|  0.00%|        yield gen.maybe_future(dispatch(*args))
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\tornado\gen.py:282 wrapper
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|    @gen.coroutine
   368|         0|            0|            0|  0.00%|    def dispatch_queue(self):
   369|         0|            0|            0|  0.00%|        """Coroutine to preserve order of message handling
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|        Ensures that only one message is processing at a time,
   372|         0|            0|            0|  0.00%|        even when the handler is async
   373|         0|            0|            0|  0.00%|        """
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|        while True:
   376|         0|            0|            0|  0.00%|            # receive the next message and handle it
   377|         0|            0|            0|  0.00%|            try:
   378|         0|            0|            0|  0.00%|                yield self.process_one()
   379|         0|            0|            0|  0.00%|            except Exception:
   380|         0|            0|            0|  0.00%|                self.log.exception("Error in message handler")
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|    _message_counter = Any(
   383|         0|            0|            0|  0.00%|        help="""Monotonic counter of messages
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|        Ensures messages of the same priority are handled in arrival order.
   386|         0|            0|            0|  0.00%|        """,
   387|         0|            0|            0|  0.00%|    )
   388|         0|            0|            0|  0.00%|    @default('_message_counter')
   389|         0|            0|            0|  0.00%|    def _message_counter_default(self):
   390|         0|            0|            0|  0.00%|        return itertools.count()
   391|         0|            0|            0|  0.00%|
   392|         0|            0|            0|  0.00%|    def schedule_dispatch(self, priority, dispatch, *args):
   393|         0|            0|            0|  0.00%|        """schedule a message for dispatch"""
   394|         0|            0|            0|  0.00%|        idx = next(self._message_counter)
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|        self.msg_queue.put_nowait(
   397|         0|            0|            0|  0.00%|            (
   398|         0|            0|            0|  0.00%|                priority,
   399|         0|            0|            0|  0.00%|                idx,
   400|         0|            0|            0|  0.00%|                dispatch,
   401|         0|            0|            0|  0.00%|                args,
   402|         0|            0|            0|  0.00%|            )
   403|         0|            0|            0|  0.00%|        )
   404|         0|            0|            0|  0.00%|        # ensure the eventloop wakes up
   405|         0|            0|            0|  0.00%|        self.io_loop.add_callback(lambda: None)
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|    def start(self):
   408|         0|            0|            0|  0.00%|        """register dispatchers for streams"""
   409|         0|            0|            0|  0.00%|        self.io_loop = ioloop.IOLoop.current()
   410|         0|            0|            0|  0.00%|        self.msg_queue = PriorityQueue()
   411|         0|            0|            0|  0.00%|        self.io_loop.add_callback(self.dispatch_queue)
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|        if self.control_stream:
   415|         0|            0|            0|  0.00%|            self.control_stream.on_recv(
   416|         0|            0|            0|  0.00%|                partial(
   417|         0|            0|            0|  0.00%|                    self.schedule_dispatch,
   418|         0|            0|            0|  0.00%|                    CONTROL_PRIORITY,
   419|         0|            0|            0|  0.00%|                    self.dispatch_control,
   420|         0|            0|            0|  0.00%|                ),
   421|         0|            0|            0|  0.00%|                copy=False,
   422|         0|            0|            0|  0.00%|            )
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|        for s in self.shell_streams:
   425|         0|            0|            0|  0.00%|            if s is self.control_stream:
   426|         0|            0|            0|  0.00%|                continue
   427|         0|            0|            0|  0.00%|            s.on_recv(
   428|         0|            0|            0|  0.00%|                partial(
   429|         0|            0|            0|  0.00%|                    self.schedule_dispatch,
   430|         0|            0|            0|  0.00%|                    SHELL_PRIORITY,
   431|         0|            0|            0|  0.00%|                    self.dispatch_shell,
   432|         0|            0|            0|  0.00%|                    s,
   433|         0|            0|            0|  0.00%|                ),
   434|         0|            0|            0|  0.00%|                copy=False,
   435|         0|            0|            0|  0.00%|            )
   436|         0|            0|            0|  0.00%|
   437|         0|            0|            0|  0.00%|        # publish idle status
   438|         0|            0|            0|  0.00%|        self._publish_status('starting')
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|    def record_ports(self, ports):
   442|         0|            0|            0|  0.00%|        """Record the ports that this kernel is using.
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|        The creator of the Kernel instance must call this methods if they
   445|         0|            0|            0|  0.00%|        want the :meth:`connect_request` method to return the port numbers.
   446|         0|            0|            0|  0.00%|        """
   447|         0|            0|            0|  0.00%|        self._recorded_ports = ports
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|    #---------------------------------------------------------------------------
   450|         0|            0|            0|  0.00%|    # Kernel request handlers
   451|         0|            0|            0|  0.00%|    #---------------------------------------------------------------------------
   452|         0|            0|            0|  0.00%|
   453|         0|            0|            0|  0.00%|    def _publish_execute_input(self, code, parent, execution_count):
   454|         0|            0|            0|  0.00%|        """Publish the code request on the iopub stream."""
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|        self.session.send(self.iopub_socket, u'execute_input',
   457|         0|            0|            0|  0.00%|                            {u'code':code, u'execution_count': execution_count},
   458|         0|            0|            0|  0.00%|                            parent=parent, ident=self._topic('execute_input')
   459|         0|            0|            0|  0.00%|        )
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|    def _publish_status(self, status, parent=None):
   462|         0|            0|            0|  0.00%|        """send status (busy/idle) on IOPub"""
   463|         0|            0|            0|  0.00%|        self.session.send(self.iopub_socket,
   464|         0|            0|            0|  0.00%|                          u'status',
   465|         0|            0|            0|  0.00%|                          {u'execution_state': status},
   466|         0|            0|            0|  0.00%|                          parent=parent or self._parent_header,
   467|         0|            0|            0|  0.00%|                          ident=self._topic('status'),
   468|         0|            0|            0|  0.00%|                          )
   469|         0|            0|            0|  0.00%|
   470|         0|            0|            0|  0.00%|    def set_parent(self, ident, parent):
   471|         0|            0|            0|  0.00%|        """Set the current parent_header
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|        Side effects (IOPub messages) and replies are associated with
   474|         0|            0|            0|  0.00%|        the request that caused them via the parent_header.
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|        The parent identity is used to route input_request messages
   477|         0|            0|            0|  0.00%|        on the stdin channel.
   478|         0|            0|            0|  0.00%|        """
   479|         0|            0|            0|  0.00%|        self._parent_ident = ident
   480|         0|            0|            0|  0.00%|        self._parent_header = parent
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|    def send_response(self, stream, msg_or_type, content=None, ident=None,
   483|         0|            0|            0|  0.00%|             buffers=None, track=False, header=None, metadata=None):
   484|         0|            0|            0|  0.00%|        """Send a response to the message we're currently processing.
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|        This accepts all the parameters of :meth:`jupyter_client.session.Session.send`
   487|         0|            0|            0|  0.00%|        except ``parent``.
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|        This relies on :meth:`set_parent` having been called for the current
   490|         0|            0|            0|  0.00%|        message.
   491|         0|            0|            0|  0.00%|        """
   492|         0|            0|            0|  0.00%|        return self.session.send(stream, msg_or_type, content, self._parent_header,
   493|         0|            0|            0|  0.00%|                                 ident, buffers, track, header, metadata)
   494|         0|            0|            0|  0.00%|
   495|         0|            0|            0|  0.00%|    def init_metadata(self, parent):
   496|         0|            0|            0|  0.00%|        """Initialize metadata.
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|        Run at the beginning of execution requests.
   499|         0|            0|            0|  0.00%|        """
   500|         0|            0|            0|  0.00%|        # FIXME: `started` is part of ipyparallel
   501|         0|            0|            0|  0.00%|        # Remove for ipykernel 5.0
   502|         0|            0|            0|  0.00%|        return {
   503|         0|            0|            0|  0.00%|            'started': now(),
   504|         0|            0|            0|  0.00%|        }
   505|         0|            0|            0|  0.00%|
   506|         0|            0|            0|  0.00%|    def finish_metadata(self, parent, metadata, reply_content):
   507|         0|            0|            0|  0.00%|        """Finish populating metadata.
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|        Run after completing an execution request.
   510|         0|            0|            0|  0.00%|        """
   511|         0|            0|            0|  0.00%|        return metadata
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|    @gen.coroutine
   514|         0|            0|            0|  0.00%|    def execute_request(self, stream, ident, parent):
   515|         0|            0|            0|  0.00%|        """handle an execute_request"""
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|        try:
   518|         0|            0|            0|  0.00%|            content = parent[u'content']
   519|         0|            0|            0|  0.00%|            code = py3compat.cast_unicode_py2(content[u'code'])
   520|         0|            0|            0|  0.00%|            silent = content[u'silent']
   521|         0|            0|            0|  0.00%|            store_history = content.get(u'store_history', not silent)
   522|         0|            0|            0|  0.00%|            user_expressions = content.get('user_expressions', {})
   523|         0|            0|            0|  0.00%|            allow_stdin = content.get('allow_stdin', False)
   524|         0|            0|            0|  0.00%|        except:
   525|         0|            0|            0|  0.00%|            self.log.error("Got bad msg: ")
   526|         0|            0|            0|  0.00%|            self.log.error("%s", parent)
   527|         0|            0|            0|  0.00%|            return
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|        stop_on_error = content.get('stop_on_error', True)
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|        metadata = self.init_metadata(parent)
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|        # Re-broadcast our input for the benefit of listening clients, and
   534|         0|            0|            0|  0.00%|        # start computing output
   535|         0|            0|            0|  0.00%|        if not silent:
   536|         0|            0|            0|  0.00%|            self.execution_count += 1
   537|         0|            0|            0|  0.00%|            self._publish_execute_input(code, parent, self.execution_count)
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|        reply_content = yield gen.maybe_future(
   540|         0|            0|            0|  0.00%|            self.do_execute(
   541|         0|            0|            0|  0.00%|                code, silent, store_history,
   542|         0|            0|            0|  0.00%|                user_expressions, allow_stdin,
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\tornado\gen.py:282 wrapper
   543|         0|            0|            0|  0.00%|            )
   544|         0|            0|            0|  0.00%|        )
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|        # Flush output before sending the reply.
   547|         0|            0|            0|  0.00%|        sys.stdout.flush()
   548|         0|            0|            0|  0.00%|        sys.stderr.flush()
   549|         0|            0|            0|  0.00%|        # FIXME: on rare occasions, the flush doesn't seem to make it to the
   550|         0|            0|            0|  0.00%|        # clients... This seems to mitigate the problem, but we definitely need
   551|         0|            0|            0|  0.00%|        # to better understand what's going on.
   552|         0|            0|            0|  0.00%|        if self._execute_sleep:
   553|         0|            0|            0|  0.00%|            time.sleep(self._execute_sleep)
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|        # Send the reply.
   556|         0|            0|            0|  0.00%|        reply_content = json_clean(reply_content)
   557|         0|            0|            0|  0.00%|        metadata = self.finish_metadata(parent, metadata, reply_content)
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|        reply_msg = self.session.send(stream, u'execute_reply',
   560|         0|            0|            0|  0.00%|                                      reply_content, parent, metadata=metadata,
   561|         0|            0|            0|  0.00%|                                      ident=ident)
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|        self.log.debug("%s", reply_msg)
   564|         0|            0|            0|  0.00%|
   565|         0|            0|            0|  0.00%|        if not silent and reply_msg['content']['status'] == u'error' and stop_on_error:
   566|         0|            0|            0|  0.00%|            yield self._abort_queues()
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|    def do_execute(self, code, silent, store_history=True,
   569|         0|            0|            0|  0.00%|                   user_expressions=None, allow_stdin=False):
   570|         0|            0|            0|  0.00%|        """Execute user code. Must be overridden by subclasses.
   571|         0|            0|            0|  0.00%|        """
   572|         0|            0|            0|  0.00%|        raise NotImplementedError
   573|         0|            0|            0|  0.00%|
   574|         0|            0|            0|  0.00%|    @gen.coroutine
   575|         0|            0|            0|  0.00%|    def complete_request(self, stream, ident, parent):
   576|         0|            0|            0|  0.00%|        content = parent['content']
   577|         0|            0|            0|  0.00%|        code = content['code']
   578|         0|            0|            0|  0.00%|        cursor_pos = content['cursor_pos']
   579|         0|            0|            0|  0.00%|
   580|         0|            0|            0|  0.00%|        matches = yield gen.maybe_future(self.do_complete(code, cursor_pos))
   581|         0|            0|            0|  0.00%|        matches = json_clean(matches)
   582|         0|            0|            0|  0.00%|        completion_msg = self.session.send(stream, 'complete_reply',
   583|         0|            0|            0|  0.00%|                                           matches, parent, ident)
   584|         0|            0|            0|  0.00%|
   585|         0|            0|            0|  0.00%|    def do_complete(self, code, cursor_pos):
   586|         0|            0|            0|  0.00%|        """Override in subclasses to find completions.
   587|         0|            0|            0|  0.00%|        """
   588|         0|            0|            0|  0.00%|        return {'matches' : [],
   589|         0|            0|            0|  0.00%|                'cursor_end' : cursor_pos,
   590|         0|            0|            0|  0.00%|                'cursor_start' : cursor_pos,
   591|         0|            0|            0|  0.00%|                'metadata' : {},
   592|         0|            0|            0|  0.00%|                'status' : 'ok'}
   593|         0|            0|            0|  0.00%|
   594|         0|            0|            0|  0.00%|    @gen.coroutine
   595|         0|            0|            0|  0.00%|    def inspect_request(self, stream, ident, parent):
   596|         0|            0|            0|  0.00%|        content = parent['content']
   597|         0|            0|            0|  0.00%|
   598|         0|            0|            0|  0.00%|        reply_content = yield gen.maybe_future(
   599|         0|            0|            0|  0.00%|            self.do_inspect(
   600|         0|            0|            0|  0.00%|                content['code'], content['cursor_pos'],
   601|         0|            0|            0|  0.00%|                content.get('detail_level', 0),
   602|         0|            0|            0|  0.00%|            )
   603|         0|            0|            0|  0.00%|        )
   604|         0|            0|            0|  0.00%|        # Before we send this object over, we scrub it for JSON usage
   605|         0|            0|            0|  0.00%|        reply_content = json_clean(reply_content)
   606|         0|            0|            0|  0.00%|        msg = self.session.send(stream, 'inspect_reply',
   607|         0|            0|            0|  0.00%|                                reply_content, parent, ident)
   608|         0|            0|            0|  0.00%|        self.log.debug("%s", msg)
   609|         0|            0|            0|  0.00%|
   610|         0|            0|            0|  0.00%|    def do_inspect(self, code, cursor_pos, detail_level=0):
   611|         0|            0|            0|  0.00%|        """Override in subclasses to allow introspection.
   612|         0|            0|            0|  0.00%|        """
   613|         0|            0|            0|  0.00%|        return {'status': 'ok', 'data': {}, 'metadata': {}, 'found': False}
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|    @gen.coroutine
   616|         0|            0|            0|  0.00%|    def history_request(self, stream, ident, parent):
   617|         0|            0|            0|  0.00%|        content = parent['content']
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|        reply_content = yield gen.maybe_future(self.do_history(**content))
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|        reply_content = json_clean(reply_content)
   622|         0|            0|            0|  0.00%|        msg = self.session.send(stream, 'history_reply',
   623|         0|            0|            0|  0.00%|                                reply_content, parent, ident)
   624|         0|            0|            0|  0.00%|        self.log.debug("%s", msg)
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|    def do_history(self, hist_access_type, output, raw, session=None, start=None,
   627|         0|            0|            0|  0.00%|                   stop=None, n=None, pattern=None, unique=False):
   628|         0|            0|            0|  0.00%|        """Override in subclasses to access history.
   629|         0|            0|            0|  0.00%|        """
   630|         0|            0|            0|  0.00%|        return {'status': 'ok', 'history': []}
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|    def connect_request(self, stream, ident, parent):
   633|         0|            0|            0|  0.00%|        if self._recorded_ports is not None:
   634|         0|            0|            0|  0.00%|            content = self._recorded_ports.copy()
   635|         0|            0|            0|  0.00%|        else:
   636|         0|            0|            0|  0.00%|            content = {}
   637|         0|            0|            0|  0.00%|        content['status'] = 'ok'
   638|         0|            0|            0|  0.00%|        msg = self.session.send(stream, 'connect_reply',
   639|         0|            0|            0|  0.00%|                                content, parent, ident)
   640|         0|            0|            0|  0.00%|        self.log.debug("%s", msg)
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|    @property
   643|         0|            0|            0|  0.00%|    def kernel_info(self):
   644|         0|            0|            0|  0.00%|        return {
   645|         0|            0|            0|  0.00%|            'protocol_version': kernel_protocol_version,
   646|         0|            0|            0|  0.00%|            'implementation': self.implementation,
   647|         0|            0|            0|  0.00%|            'implementation_version': self.implementation_version,
   648|         0|            0|            0|  0.00%|            'language_info': self.language_info,
   649|         0|            0|            0|  0.00%|            'banner': self.banner,
   650|         0|            0|            0|  0.00%|            'help_links': self.help_links,
   651|         0|            0|            0|  0.00%|        }
   652|         0|            0|            0|  0.00%|
   653|         0|            0|            0|  0.00%|    def kernel_info_request(self, stream, ident, parent):
   654|         0|            0|            0|  0.00%|        content = {'status': 'ok'}
   655|         0|            0|            0|  0.00%|        content.update(self.kernel_info)
   656|         0|            0|            0|  0.00%|        msg = self.session.send(stream, 'kernel_info_reply',
   657|         0|            0|            0|  0.00%|                                content, parent, ident)
   658|         0|            0|            0|  0.00%|        self.log.debug("%s", msg)
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|    def comm_info_request(self, stream, ident, parent):
   661|         0|            0|            0|  0.00%|        content = parent['content']
   662|         0|            0|            0|  0.00%|        target_name = content.get('target_name', None)
   663|         0|            0|            0|  0.00%|
   664|         0|            0|            0|  0.00%|        # Should this be moved to ipkernel?
   665|         0|            0|            0|  0.00%|        if hasattr(self, 'comm_manager'):
   666|         0|            0|            0|  0.00%|            comms = {
   667|         0|            0|            0|  0.00%|                k: dict(target_name=v.target_name)
   668|         0|            0|            0|  0.00%|                for (k, v) in self.comm_manager.comms.items()
   669|         0|            0|            0|  0.00%|                if v.target_name == target_name or target_name is None
   670|         0|            0|            0|  0.00%|            }
   671|         0|            0|            0|  0.00%|        else:
   672|         0|            0|            0|  0.00%|            comms = {}
   673|         0|            0|            0|  0.00%|        reply_content = dict(comms=comms, status='ok')
   674|         0|            0|            0|  0.00%|        msg = self.session.send(stream, 'comm_info_reply',
   675|         0|            0|            0|  0.00%|                                reply_content, parent, ident)
   676|         0|            0|            0|  0.00%|        self.log.debug("%s", msg)
   677|         0|            0|            0|  0.00%|
   678|         0|            0|            0|  0.00%|    @gen.coroutine
   679|         0|            0|            0|  0.00%|    def shutdown_request(self, stream, ident, parent):
   680|         0|            0|            0|  0.00%|        content = yield gen.maybe_future(self.do_shutdown(parent['content']['restart']))
   681|         0|            0|            0|  0.00%|        self.session.send(stream, u'shutdown_reply', content, parent, ident=ident)
   682|         0|            0|            0|  0.00%|        # same content, but different msg_id for broadcasting on IOPub
   683|         0|            0|            0|  0.00%|        self._shutdown_message = self.session.msg(u'shutdown_reply',
   684|         0|            0|            0|  0.00%|                                                  content, parent
   685|         0|            0|            0|  0.00%|        )
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|        self._at_shutdown()
   688|         0|            0|            0|  0.00%|        # call sys.exit after a short delay
   689|         0|            0|            0|  0.00%|        loop = ioloop.IOLoop.current()
   690|         0|            0|            0|  0.00%|        loop.add_timeout(time.time()+0.1, loop.stop)
   691|         0|            0|            0|  0.00%|
   692|         0|            0|            0|  0.00%|    def do_shutdown(self, restart):
   693|         0|            0|            0|  0.00%|        """Override in subclasses to do things when the frontend shuts down the
   694|         0|            0|            0|  0.00%|        kernel.
   695|         0|            0|            0|  0.00%|        """
   696|         0|            0|            0|  0.00%|        return {'status': 'ok', 'restart': restart}
   697|         0|            0|            0|  0.00%|
   698|         0|            0|            0|  0.00%|    @gen.coroutine
   699|         0|            0|            0|  0.00%|    def is_complete_request(self, stream, ident, parent):
   700|         0|            0|            0|  0.00%|        content = parent['content']
   701|         0|            0|            0|  0.00%|        code = content['code']
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|        reply_content = yield gen.maybe_future(self.do_is_complete(code))
   704|         0|            0|            0|  0.00%|        reply_content = json_clean(reply_content)
   705|         0|            0|            0|  0.00%|        reply_msg = self.session.send(stream, 'is_complete_reply',
   706|         0|            0|            0|  0.00%|                                      reply_content, parent, ident)
   707|         0|            0|            0|  0.00%|        self.log.debug("%s", reply_msg)
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|    def do_is_complete(self, code):
   710|         0|            0|            0|  0.00%|        """Override in subclasses to find completions.
   711|         0|            0|            0|  0.00%|        """
   712|         0|            0|            0|  0.00%|        return {'status' : 'unknown',
   713|         0|            0|            0|  0.00%|                }
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|    #---------------------------------------------------------------------------
   716|         0|            0|            0|  0.00%|    # Engine methods (DEPRECATED)
   717|         0|            0|            0|  0.00%|    #---------------------------------------------------------------------------
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|    def apply_request(self, stream, ident, parent):
   720|         0|            0|            0|  0.00%|        self.log.warning("apply_request is deprecated in kernel_base, moving to ipyparallel.")
   721|         0|            0|            0|  0.00%|        try:
   722|         0|            0|            0|  0.00%|            content = parent[u'content']
   723|         0|            0|            0|  0.00%|            bufs = parent[u'buffers']
   724|         0|            0|            0|  0.00%|            msg_id = parent['header']['msg_id']
   725|         0|            0|            0|  0.00%|        except:
   726|         0|            0|            0|  0.00%|            self.log.error("Got bad msg: %s", parent, exc_info=True)
   727|         0|            0|            0|  0.00%|            return
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|        md = self.init_metadata(parent)
   730|         0|            0|            0|  0.00%|
   731|         0|            0|            0|  0.00%|        reply_content, result_buf = self.do_apply(content, bufs, msg_id, md)
   732|         0|            0|            0|  0.00%|
   733|         0|            0|            0|  0.00%|        # flush i/o
   734|         0|            0|            0|  0.00%|        sys.stdout.flush()
   735|         0|            0|            0|  0.00%|        sys.stderr.flush()
   736|         0|            0|            0|  0.00%|
   737|         0|            0|            0|  0.00%|        md = self.finish_metadata(parent, md, reply_content)
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|        self.session.send(stream, u'apply_reply', reply_content,
   740|         0|            0|            0|  0.00%|                    parent=parent, ident=ident,buffers=result_buf, metadata=md)
   741|         0|            0|            0|  0.00%|
   742|         0|            0|            0|  0.00%|    def do_apply(self, content, bufs, msg_id, reply_metadata):
   743|         0|            0|            0|  0.00%|        """DEPRECATED"""
   744|         0|            0|            0|  0.00%|        raise NotImplementedError
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|    #---------------------------------------------------------------------------
   747|         0|            0|            0|  0.00%|    # Control messages (DEPRECATED)
   748|         0|            0|            0|  0.00%|    #---------------------------------------------------------------------------
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|    def abort_request(self, stream, ident, parent):
   751|         0|            0|            0|  0.00%|        """abort a specific msg by id"""
   752|         0|            0|            0|  0.00%|        self.log.warning("abort_request is deprecated in kernel_base. It is only part of IPython parallel")
   753|         0|            0|            0|  0.00%|        msg_ids = parent['content'].get('msg_ids', None)
   754|         0|            0|            0|  0.00%|        if isinstance(msg_ids, string_types):
   755|         0|            0|            0|  0.00%|            msg_ids = [msg_ids]
   756|         0|            0|            0|  0.00%|        if not msg_ids:
   757|         0|            0|            0|  0.00%|            self._abort_queues()
   758|         0|            0|            0|  0.00%|        for mid in msg_ids:
   759|         0|            0|            0|  0.00%|            self.aborted.add(str(mid))
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|        content = dict(status='ok')
   762|         0|            0|            0|  0.00%|        reply_msg = self.session.send(stream, 'abort_reply', content=content,
   763|         0|            0|            0|  0.00%|                parent=parent, ident=ident)
   764|         0|            0|            0|  0.00%|        self.log.debug("%s", reply_msg)
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|    def clear_request(self, stream, idents, parent):
   767|         0|            0|            0|  0.00%|        """Clear our namespace."""
   768|         0|            0|            0|  0.00%|        self.log.warning("clear_request is deprecated in kernel_base. It is only part of IPython parallel")
   769|         0|            0|            0|  0.00%|        content = self.do_clear()
   770|         0|            0|            0|  0.00%|        self.session.send(stream, 'clear_reply', ident=idents, parent=parent,
   771|         0|            0|            0|  0.00%|                content = content)
   772|         0|            0|            0|  0.00%|
   773|         0|            0|            0|  0.00%|    def do_clear(self):
   774|         0|            0|            0|  0.00%|        """DEPRECATED since 4.0.3"""
   775|         0|            0|            0|  0.00%|        raise NotImplementedError
   776|         0|            0|            0|  0.00%|
   777|         0|            0|            0|  0.00%|    #---------------------------------------------------------------------------
   778|         0|            0|            0|  0.00%|    # Protected interface
   779|         0|            0|            0|  0.00%|    #---------------------------------------------------------------------------
   780|         0|            0|            0|  0.00%|
   781|         0|            0|            0|  0.00%|    def _topic(self, topic):
   782|         0|            0|            0|  0.00%|        """prefixed topic for IOPub messages"""
   783|         0|            0|            0|  0.00%|        base = "kernel.%s" % self.ident
   784|         0|            0|            0|  0.00%|
   785|         0|            0|            0|  0.00%|        return py3compat.cast_bytes("%s.%s" % (base, topic))
   786|         0|            0|            0|  0.00%|
   787|         0|            0|            0|  0.00%|    _aborting = Bool(False)
   788|         0|            0|            0|  0.00%|
   789|         0|            0|            0|  0.00%|    @gen.coroutine
   790|         0|            0|            0|  0.00%|    def _abort_queues(self):
   791|         0|            0|            0|  0.00%|        for stream in self.shell_streams:
   792|         0|            0|            0|  0.00%|            stream.flush()
   793|         0|            0|            0|  0.00%|        self._aborting = True
   794|         0|            0|            0|  0.00%|
   795|         0|            0|            0|  0.00%|        self.schedule_dispatch(
   796|         0|            0|            0|  0.00%|            ABORT_PRIORITY,
   797|         0|            0|            0|  0.00%|            self._dispatch_abort,
   798|         0|            0|            0|  0.00%|        )
   799|         0|            0|            0|  0.00%|
   800|         0|            0|            0|  0.00%|    @gen.coroutine
   801|         0|            0|            0|  0.00%|    def _dispatch_abort(self):
   802|         0|            0|            0|  0.00%|        self.log.info("Finishing abort")
   803|         0|            0|            0|  0.00%|        yield gen.sleep(self.stop_on_error_timeout)
   804|         0|            0|            0|  0.00%|        self._aborting = False
   805|         0|            0|            0|  0.00%|
   806|         0|            0|            0|  0.00%|    def _send_abort_reply(self, stream, msg, idents):
   807|         0|            0|            0|  0.00%|        """Send a reply to an aborted request"""
   808|         0|            0|            0|  0.00%|        self.log.info("Aborting:")
   809|         0|            0|            0|  0.00%|        self.log.info("%s", msg)
   810|         0|            0|            0|  0.00%|        reply_type = msg['header']['msg_type'].rsplit('_', 1)[0] + '_reply'
   811|         0|            0|            0|  0.00%|        status = {'status': 'aborted'}
   812|         0|            0|            0|  0.00%|        md = {'engine': self.ident}
   813|         0|            0|            0|  0.00%|        md.update(status)
   814|         0|            0|            0|  0.00%|        self.session.send(
   815|         0|            0|            0|  0.00%|            stream, reply_type, metadata=md,
   816|         0|            0|            0|  0.00%|            content=status, parent=msg, ident=idents,
   817|         0|            0|            0|  0.00%|        )
   818|         0|            0|            0|  0.00%|
   819|         0|            0|            0|  0.00%|    def _no_raw_input(self):
   820|         0|            0|            0|  0.00%|        """Raise StdinNotImplentedError if active frontend doesn't support
   821|         0|            0|            0|  0.00%|        stdin."""
   822|         0|            0|            0|  0.00%|        raise StdinNotImplementedError("raw_input was called, but this "
   823|         0|            0|            0|  0.00%|                                       "frontend does not support stdin.")
   824|         0|            0|            0|  0.00%|
   825|         0|            0|            0|  0.00%|    def getpass(self, prompt='', stream=None):
   826|         0|            0|            0|  0.00%|        """Forward getpass to frontends
   827|         0|            0|            0|  0.00%|
   828|         0|            0|            0|  0.00%|        Raises
   829|         0|            0|            0|  0.00%|        ------
   830|         0|            0|            0|  0.00%|        StdinNotImplentedError if active frontend doesn't support stdin.
   831|         0|            0|            0|  0.00%|        """
   832|         0|            0|            0|  0.00%|        if not self._allow_stdin:
   833|         0|            0|            0|  0.00%|            raise StdinNotImplementedError(
   834|         0|            0|            0|  0.00%|                "getpass was called, but this frontend does not support input requests."
   835|         0|            0|            0|  0.00%|            )
   836|         0|            0|            0|  0.00%|        if stream is not None:
   837|         0|            0|            0|  0.00%|            import warnings
   838|         0|            0|            0|  0.00%|            warnings.warn("The `stream` parameter of `getpass.getpass` will have no effect when using ipykernel",
   839|         0|            0|            0|  0.00%|                    UserWarning, stacklevel=2)
   840|         0|            0|            0|  0.00%|        return self._input_request(prompt,
   841|         0|            0|            0|  0.00%|            self._parent_ident,
   842|         0|            0|            0|  0.00%|            self._parent_header,
   843|         0|            0|            0|  0.00%|            password=True,
   844|         0|            0|            0|  0.00%|        )
   845|         0|            0|            0|  0.00%|
   846|         0|            0|            0|  0.00%|    def raw_input(self, prompt=''):
   847|         0|            0|            0|  0.00%|        """Forward raw_input to frontends
   848|         0|            0|            0|  0.00%|
   849|         0|            0|            0|  0.00%|        Raises
   850|         0|            0|            0|  0.00%|        ------
   851|         0|            0|            0|  0.00%|        StdinNotImplentedError if active frontend doesn't support stdin.
   852|         0|            0|            0|  0.00%|        """
   853|         0|            0|            0|  0.00%|        if not self._allow_stdin:
   854|         0|            0|            0|  0.00%|            raise StdinNotImplementedError(
   855|         0|            0|            0|  0.00%|                "raw_input was called, but this frontend does not support input requests."
   856|         0|            0|            0|  0.00%|            )
   857|         0|            0|            0|  0.00%|        return self._input_request(str(prompt),
   858|         0|            0|            0|  0.00%|            self._parent_ident,
   859|         0|            0|            0|  0.00%|            self._parent_header,
   860|         0|            0|            0|  0.00%|            password=False,
   861|         0|            0|            0|  0.00%|        )
   862|         0|            0|            0|  0.00%|
   863|         0|            0|            0|  0.00%|    def _input_request(self, prompt, ident, parent, password=False):
   864|         0|            0|            0|  0.00%|        # Flush output before making the request.
   865|         0|            0|            0|  0.00%|        sys.stderr.flush()
   866|         0|            0|            0|  0.00%|        sys.stdout.flush()
   867|         0|            0|            0|  0.00%|        # flush the stdin socket, to purge stale replies
   868|         0|            0|            0|  0.00%|        while True:
   869|         0|            0|            0|  0.00%|            try:
   870|         0|            0|            0|  0.00%|                self.stdin_socket.recv_multipart(zmq.NOBLOCK)
   871|         0|            0|            0|  0.00%|            except zmq.ZMQError as e:
   872|         0|            0|            0|  0.00%|                if e.errno == zmq.EAGAIN:
   873|         0|            0|            0|  0.00%|                    break
   874|         0|            0|            0|  0.00%|                else:
   875|         0|            0|            0|  0.00%|                    raise
   876|         0|            0|            0|  0.00%|
   877|         0|            0|            0|  0.00%|        # Send the input request.
   878|         0|            0|            0|  0.00%|        content = json_clean(dict(prompt=prompt, password=password))
   879|         0|            0|            0|  0.00%|        self.session.send(self.stdin_socket, u'input_request', content, parent,
   880|         0|            0|            0|  0.00%|                          ident=ident)
   881|         0|            0|            0|  0.00%|
   882|         0|            0|            0|  0.00%|        # Await a response.
   883|         0|            0|            0|  0.00%|        while True:
   884|         0|            0|            0|  0.00%|            try:
   885|         0|            0|            0|  0.00%|                ident, reply = self.session.recv(self.stdin_socket, 0)
   886|         0|            0|            0|  0.00%|            except Exception:
   887|         0|            0|            0|  0.00%|                self.log.warning("Invalid Message:", exc_info=True)
   888|         0|            0|            0|  0.00%|            except KeyboardInterrupt:
   889|         0|            0|            0|  0.00%|                # re-raise KeyboardInterrupt, to truncate traceback
   890|         0|            0|            0|  0.00%|                raise KeyboardInterrupt
   891|         0|            0|            0|  0.00%|            else:
   892|         0|            0|            0|  0.00%|                break
   893|         0|            0|            0|  0.00%|        try:
   894|         0|            0|            0|  0.00%|            value = py3compat.unicode_to_str(reply['content']['value'])
   895|         0|            0|            0|  0.00%|        except:
   896|         0|            0|            0|  0.00%|            self.log.error("Bad input_reply: %s", parent)
   897|         0|            0|            0|  0.00%|            value = ''
   898|         0|            0|            0|  0.00%|        if value == '\x04':
   899|         0|            0|            0|  0.00%|            # EOF
   900|         0|            0|            0|  0.00%|            raise EOFError
   901|         0|            0|            0|  0.00%|        return value
   902|         0|            0|            0|  0.00%|
   903|         0|            0|            0|  0.00%|    def _at_shutdown(self):
   904|         0|            0|            0|  0.00%|        """Actions taken at shutdown by the kernel, called by python's atexit.
   905|         0|            0|            0|  0.00%|        """
   906|         0|            0|            0|  0.00%|        if self._shutdown_message is not None:
   907|         0|            0|            0|  0.00%|            self.session.send(self.iopub_socket, self._shutdown_message, ident=self._topic('shutdown'))
   908|         0|            0|            0|  0.00%|            self.log.debug("%s", self._shutdown_message)
   909|         0|            0|            0|  0.00%|        [ s.flush(zmq.POLLOUT) for s in self.shell_streams ]
File: D:\Application\Anaconda\lib\site-packages\pandas\core\series.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|Data structure for 1-dimensional cross-sectional and time series data
     3|         0|            0|            0|  0.00%|"""
     4|         0|            0|            0|  0.00%|from __future__ import division
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|# pylint: disable=E1101,E1103
     7|         0|            0|            0|  0.00%|# pylint: disable=W0703,W0622,W0613,W0201
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|import types
    10|         0|            0|            0|  0.00%|import warnings
    11|         0|            0|            0|  0.00%|from textwrap import dedent
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|from numpy import nan, ndarray
    14|         0|            0|            0|  0.00%|import numpy as np
    15|         0|            0|            0|  0.00%|import numpy.ma as ma
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|from pandas.core.dtypes.common import (
    18|         0|            0|            0|  0.00%|    is_categorical_dtype,
    19|         0|            0|            0|  0.00%|    is_bool,
    20|         0|            0|            0|  0.00%|    is_integer, is_integer_dtype,
    21|         0|            0|            0|  0.00%|    is_float_dtype,
    22|         0|            0|            0|  0.00%|    is_extension_type, is_datetimetz,
    23|         0|            0|            0|  0.00%|    is_datetimelike,
    24|         0|            0|            0|  0.00%|    is_datetime64tz_dtype,
    25|         0|            0|            0|  0.00%|    is_timedelta64_dtype,
    26|         0|            0|            0|  0.00%|    is_list_like,
    27|         0|            0|            0|  0.00%|    is_hashable,
    28|         0|            0|            0|  0.00%|    is_iterator,
    29|         0|            0|            0|  0.00%|    is_dict_like,
    30|         0|            0|            0|  0.00%|    is_scalar,
    31|         0|            0|            0|  0.00%|    _is_unorderable_exception,
    32|         0|            0|            0|  0.00%|    _ensure_platform_int,
    33|         0|            0|            0|  0.00%|    pandas_dtype)
    34|         0|            0|            0|  0.00%|from pandas.core.dtypes.generic import ABCSparseArray, ABCDataFrame
    35|         0|            0|            0|  0.00%|from pandas.core.dtypes.cast import (
    36|         0|            0|            0|  0.00%|    maybe_upcast, infer_dtype_from_scalar,
    37|         0|            0|            0|  0.00%|    maybe_convert_platform,
    38|         0|            0|            0|  0.00%|    maybe_cast_to_datetime, maybe_castable)
    39|         0|            0|            0|  0.00%|from pandas.core.dtypes.missing import isnull, notnull
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|from pandas.core.common import (is_bool_indexer,
    42|         0|            0|            0|  0.00%|                                _default_index,
    43|         0|            0|            0|  0.00%|                                _asarray_tuplesafe,
    44|         0|            0|            0|  0.00%|                                _values_from_object,
    45|         0|            0|            0|  0.00%|                                _try_sort,
    46|         0|            0|            0|  0.00%|                                _maybe_match_name,
    47|         0|            0|            0|  0.00%|                                SettingWithCopyError,
    48|         0|            0|            0|  0.00%|                                _maybe_box_datetimelike,
    49|         0|            0|            0|  0.00%|                                _dict_compat)
    50|         0|            0|            0|  0.00%|from pandas.core.index import (Index, MultiIndex, InvalidIndexError,
    51|         0|            0|            0|  0.00%|                               Float64Index, _ensure_index)
    52|         0|            0|            0|  0.00%|from pandas.core.indexing import check_bool_indexer, maybe_convert_indices
    53|         0|            0|            0|  0.00%|from pandas.core import generic, base
    54|         0|            0|            0|  0.00%|from pandas.core.internals import SingleBlockManager
    55|         0|            0|            0|  0.00%|from pandas.core.categorical import Categorical, CategoricalAccessor
    56|         0|            0|            0|  0.00%|import pandas.core.strings as strings
    57|         0|            0|            0|  0.00%|from pandas.core.indexes.accessors import (
    58|         0|            0|            0|  0.00%|    maybe_to_datetimelike, CombinedDatetimelikeProperties)
    59|         0|            0|            0|  0.00%|from pandas.core.indexes.datetimes import DatetimeIndex
    60|         0|            0|            0|  0.00%|from pandas.core.indexes.timedeltas import TimedeltaIndex
    61|         0|            0|            0|  0.00%|from pandas.core.indexes.period import PeriodIndex
    62|         0|            0|            0|  0.00%|from pandas import compat
    63|         0|            0|            0|  0.00%|from pandas.io.formats.terminal import get_terminal_size
    64|         0|            0|            0|  0.00%|from pandas.compat import zip, u, OrderedDict, StringIO
    65|         0|            0|            0|  0.00%|from pandas.compat.numpy import function as nv
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|import pandas.core.ops as ops
    68|         0|            0|            0|  0.00%|import pandas.core.algorithms as algorithms
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|import pandas.core.common as com
    71|         0|            0|            0|  0.00%|import pandas.core.nanops as nanops
    72|         0|            0|            0|  0.00%|import pandas.io.formats.format as fmt
    73|         0|            0|            0|  0.00%|from pandas.util._decorators import Appender, deprecate_kwarg, Substitution
    74|         0|            0|            0|  0.00%|from pandas.util._validators import validate_bool_kwarg
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|from pandas._libs import index as libindex, tslib as libts, lib, iNaT
    77|         0|            0|            0|  0.00%|from pandas.core.config import get_option
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|__all__ = ['Series']
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|_shared_doc_kwargs = dict(
    82|         0|            0|            0|  0.00%|    axes='index', klass='Series', axes_single_arg="{0, 'index'}",
    83|         0|            0|            0|  0.00%|    inplace="""inplace : boolean, default False
    84|         0|            0|            0|  0.00%|        If True, performs operation inplace and returns None.""",
    85|         0|            0|            0|  0.00%|    unique='np.ndarray', duplicated='Series',
    86|         0|            0|            0|  0.00%|    optional_by='',
    87|         0|            0|            0|  0.00%|    versionadded_to_excel='\n    .. versionadded:: 0.20.0\n')
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|def _coerce_method(converter):
    91|         0|            0|            0|  0.00%|    """ install the scalar coercion methods """
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|    def wrapper(self):
    94|         0|            0|            0|  0.00%|        if len(self) == 1:
    95|         0|            0|            0|  0.00%|            return converter(self.iloc[0])
    96|         0|            0|            0|  0.00%|        raise TypeError("cannot convert the series to "
    97|         0|            0|            0|  0.00%|                        "{0}".format(str(converter)))
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|    return wrapper
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|# ----------------------------------------------------------------------
   102|         0|            0|            0|  0.00%|# Series class
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|class Series(base.IndexOpsMixin, strings.StringAccessorMixin,
   106|         0|            0|            0|  0.00%|             generic.NDFrame,):
   107|         0|            0|            0|  0.00%|    """
   108|         0|            0|            0|  0.00%|    One-dimensional ndarray with axis labels (including time series).
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|    Labels need not be unique but must be a hashable type. The object
   111|         0|            0|            0|  0.00%|    supports both integer- and label-based indexing and provides a host of
   112|         0|            0|            0|  0.00%|    methods for performing operations involving the index. Statistical
   113|         0|            0|            0|  0.00%|    methods from ndarray have been overridden to automatically exclude
   114|         0|            0|            0|  0.00%|    missing data (currently represented as NaN).
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|    Operations between Series (+, -, /, *, **) align values based on their
   117|         0|            0|            0|  0.00%|    associated index values-- they need not be the same length. The result
   118|         0|            0|            0|  0.00%|    index will be the sorted union of the two indexes.
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|    Parameters
   121|         0|            0|            0|  0.00%|    ----------
   122|         0|            0|            0|  0.00%|    data : array-like, dict, or scalar value
   123|         0|            0|            0|  0.00%|        Contains data stored in Series
   124|         0|            0|            0|  0.00%|    index : array-like or Index (1d)
   125|         0|            0|            0|  0.00%|        Values must be hashable and have the same length as `data`.
   126|         0|            0|            0|  0.00%|        Non-unique index values are allowed. Will default to
   127|         0|            0|            0|  0.00%|        RangeIndex(len(data)) if not provided. If both a dict and index
   128|         0|            0|            0|  0.00%|        sequence are used, the index will override the keys found in the
   129|         0|            0|            0|  0.00%|        dict.
   130|         0|            0|            0|  0.00%|    dtype : numpy.dtype or None
   131|         0|            0|            0|  0.00%|        If None, dtype will be inferred
   132|         0|            0|            0|  0.00%|    copy : boolean, default False
   133|         0|            0|            0|  0.00%|        Copy input data
   134|         0|            0|            0|  0.00%|    """
   135|         0|            0|            0|  0.00%|    _metadata = ['name']
   136|         0|            0|            0|  0.00%|    _accessors = frozenset(['dt', 'cat', 'str'])
   137|         0|            0|            0|  0.00%|    _allow_index_ops = True
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|    def __init__(self, data=None, index=None, dtype=None, name=None,
   140|         0|            0|            0|  0.00%|                 copy=False, fastpath=False):
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|        # we are called internally, so short-circuit
   143|         0|            0|            0|  0.00%|        if fastpath:
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|            # data is an ndarray, index is defined
   146|         0|            0|            0|  0.00%|            if not isinstance(data, SingleBlockManager):
   147|         0|            0|            0|  0.00%|                data = SingleBlockManager(data, index, fastpath=True)
   148|         0|            0|            0|  0.00%|            if copy:
   149|         0|            0|            0|  0.00%|                data = data.copy()
   150|         0|            0|            0|  0.00%|            if index is None:
   151|         0|            0|            0|  0.00%|                index = data.index
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|        else:
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|            if index is not None:
   156|         0|            0|            0|  0.00%|                index = _ensure_index(index)
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|            if data is None:
   159|         0|            0|            0|  0.00%|                data = {}
   160|         0|            0|            0|  0.00%|            if dtype is not None:
   161|         0|            0|            0|  0.00%|                dtype = self._validate_dtype(dtype)
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|            if isinstance(data, MultiIndex):
   164|         0|            0|            0|  0.00%|                raise NotImplementedError("initializing a Series from a "
   165|         0|            0|            0|  0.00%|                                          "MultiIndex is not supported")
   166|         0|            0|            0|  0.00%|            elif isinstance(data, Index):
   167|         0|            0|            0|  0.00%|                # need to copy to avoid aliasing issues
   168|         0|            0|            0|  0.00%|                if name is None:
   169|         0|            0|            0|  0.00%|                    name = data.name
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|                data = data._to_embed(keep_tz=True)
   172|         0|            0|            0|  0.00%|                copy = True
   173|         0|            0|            0|  0.00%|            elif isinstance(data, np.ndarray):
   174|         0|            0|            0|  0.00%|                pass
   175|         0|            0|            0|  0.00%|            elif isinstance(data, Series):
   176|         0|            0|            0|  0.00%|                if name is None:
   177|         0|            0|            0|  0.00%|                    name = data.name
   178|         0|            0|            0|  0.00%|                if index is None:
   179|         0|            0|            0|  0.00%|                    index = data.index
   180|         0|            0|            0|  0.00%|                else:
   181|         0|            0|            0|  0.00%|                    data = data.reindex(index, copy=copy)
   182|         0|            0|            0|  0.00%|                data = data._data
   183|         0|            0|            0|  0.00%|            elif isinstance(data, dict):
   184|         0|            0|            0|  0.00%|                if index is None:
   185|         0|            0|            0|  0.00%|                    if isinstance(data, OrderedDict):
   186|         0|            0|            0|  0.00%|                        index = Index(data)
   187|         0|            0|            0|  0.00%|                    else:
   188|         0|            0|            0|  0.00%|                        index = Index(_try_sort(data))
   189|         0|            0|            0|  0.00%|                try:
   190|         0|            0|            0|  0.00%|                    if isinstance(index, DatetimeIndex):
   191|         0|            0|            0|  0.00%|                        if len(data):
   192|         0|            0|            0|  0.00%|                            # coerce back to datetime objects for lookup
   193|         0|            0|            0|  0.00%|                            data = _dict_compat(data)
   194|         0|            0|            0|  0.00%|                            data = lib.fast_multiget(data,
   195|         0|            0|            0|  0.00%|                                                     index.asobject.values,
   196|         0|            0|            0|  0.00%|                                                     default=np.nan)
   197|         0|            0|            0|  0.00%|                        else:
   198|         0|            0|            0|  0.00%|                            data = np.nan
   199|         0|            0|            0|  0.00%|                    # GH #12169
   200|         0|            0|            0|  0.00%|                    elif isinstance(index, (PeriodIndex, TimedeltaIndex)):
   201|         0|            0|            0|  0.00%|                        data = ([data.get(i, nan) for i in index]
   202|         0|            0|            0|  0.00%|                                if data else np.nan)
   203|         0|            0|            0|  0.00%|                    else:
   204|         0|            0|            0|  0.00%|                        data = lib.fast_multiget(data, index.values,
   205|         0|            0|            0|  0.00%|                                                 default=np.nan)
   206|         0|            0|            0|  0.00%|                except TypeError:
   207|         0|            0|            0|  0.00%|                    data = ([data.get(i, nan) for i in index]
   208|         0|            0|            0|  0.00%|                            if data else np.nan)
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|            elif isinstance(data, SingleBlockManager):
   211|         0|            0|            0|  0.00%|                if index is None:
   212|         0|            0|            0|  0.00%|                    index = data.index
   213|         0|            0|            0|  0.00%|                else:
   214|         0|            0|            0|  0.00%|                    data = data.reindex(index, copy=copy)
   215|         0|            0|            0|  0.00%|            elif isinstance(data, Categorical):
   216|         0|            0|            0|  0.00%|                # GH12574: Allow dtype=category only, otherwise error
   217|         0|            0|            0|  0.00%|                if ((dtype is not None) and
   218|         0|            0|            0|  0.00%|                        not is_categorical_dtype(dtype)):
   219|         0|            0|            0|  0.00%|                    raise ValueError("cannot specify a dtype with a "
   220|         0|            0|            0|  0.00%|                                     "Categorical unless "
   221|         0|            0|            0|  0.00%|                                     "dtype='category'")
   222|         0|            0|            0|  0.00%|            elif (isinstance(data, types.GeneratorType) or
   223|         0|            0|            0|  0.00%|                  (compat.PY3 and isinstance(data, map))):
   224|         0|            0|            0|  0.00%|                data = list(data)
   225|         0|            0|            0|  0.00%|            elif isinstance(data, (set, frozenset)):
   226|         0|            0|            0|  0.00%|                raise TypeError("{0!r} type is unordered"
   227|         0|            0|            0|  0.00%|                                "".format(data.__class__.__name__))
   228|         0|            0|            0|  0.00%|            else:
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|                # handle sparse passed here (and force conversion)
   231|         0|            0|            0|  0.00%|                if isinstance(data, ABCSparseArray):
   232|         0|            0|            0|  0.00%|                    data = data.to_dense()
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|            if index is None:
   235|         0|            0|            0|  0.00%|                if not is_list_like(data):
   236|         0|            0|            0|  0.00%|                    data = [data]
   237|         0|            0|            0|  0.00%|                index = _default_index(len(data))
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|            # create/copy the manager
   240|         0|            0|            0|  0.00%|            if isinstance(data, SingleBlockManager):
   241|         0|            0|            0|  0.00%|                if dtype is not None:
   242|         0|            0|            0|  0.00%|                    data = data.astype(dtype=dtype, raise_on_error=False,
   243|         0|            0|            0|  0.00%|                                       copy=copy)
   244|         0|            0|            0|  0.00%|                elif copy:
   245|         0|            0|            0|  0.00%|                    data = data.copy()
   246|         0|            0|            0|  0.00%|            else:
   247|         0|            0|            0|  0.00%|                data = _sanitize_array(data, index, dtype, copy,
   248|         0|            0|            0|  0.00%|                                       raise_cast_failure=True)
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|                data = SingleBlockManager(data, index, fastpath=True)
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|        generic.NDFrame.__init__(self, data, fastpath=True)
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|        self.name = name
   255|         0|            0|            0|  0.00%|        self._set_axis(0, index, fastpath=True)
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|    @classmethod
   258|         0|            0|            0|  0.00%|    def from_array(cls, arr, index=None, name=None, dtype=None, copy=False,
   259|         0|            0|            0|  0.00%|                   fastpath=False):
   260|         0|            0|            0|  0.00%|        # return a sparse series here
   261|         0|            0|            0|  0.00%|        if isinstance(arr, ABCSparseArray):
   262|         0|            0|            0|  0.00%|            from pandas.core.sparse.series import SparseSeries
   263|         0|            0|            0|  0.00%|            cls = SparseSeries
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|        return cls(arr, index=index, name=name, dtype=dtype, copy=copy,
   266|         0|            0|            0|  0.00%|                   fastpath=fastpath)
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|    @property
   269|         0|            0|            0|  0.00%|    def _constructor(self):
   270|         0|            0|            0|  0.00%|        return Series
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|    @property
   273|         0|            0|            0|  0.00%|    def _constructor_expanddim(self):
   274|         0|            0|            0|  0.00%|        from pandas.core.frame import DataFrame
   275|         0|            0|            0|  0.00%|        return DataFrame
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|    # types
   278|         0|            0|            0|  0.00%|    @property
   279|         0|            0|            0|  0.00%|    def _can_hold_na(self):
   280|         0|            0|            0|  0.00%|        return self._data._can_hold_na
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|    _index = None
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|    def _set_axis(self, axis, labels, fastpath=False):
   285|         0|            0|            0|  0.00%|        """ override generic, we want to set the _typ here """
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|        if not fastpath:
   288|         0|            0|            0|  0.00%|            labels = _ensure_index(labels)
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|        is_all_dates = labels.is_all_dates
   291|         0|            0|            0|  0.00%|        if is_all_dates:
   292|         0|            0|            0|  0.00%|            if not isinstance(labels,
   293|         0|            0|            0|  0.00%|                              (DatetimeIndex, PeriodIndex, TimedeltaIndex)):
   294|         0|            0|            0|  0.00%|                try:
   295|         0|            0|            0|  0.00%|                    labels = DatetimeIndex(labels)
   296|         0|            0|            0|  0.00%|                    # need to set here becuase we changed the index
   297|         0|            0|            0|  0.00%|                    if fastpath:
   298|         0|            0|            0|  0.00%|                        self._data.set_axis(axis, labels)
   299|         0|            0|            0|  0.00%|                except (libts.OutOfBoundsDatetime, ValueError):
   300|         0|            0|            0|  0.00%|                    # labels may exceeds datetime bounds,
   301|         0|            0|            0|  0.00%|                    # or not be a DatetimeIndex
   302|         0|            0|            0|  0.00%|                    pass
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|        self._set_subtyp(is_all_dates)
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|        object.__setattr__(self, '_index', labels)
   307|         0|            0|            0|  0.00%|        if not fastpath:
   308|         0|            0|            0|  0.00%|            self._data.set_axis(axis, labels)
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|    def _set_subtyp(self, is_all_dates):
   311|         0|            0|            0|  0.00%|        if is_all_dates:
   312|         0|            0|            0|  0.00%|            object.__setattr__(self, '_subtyp', 'time_series')
   313|         0|            0|            0|  0.00%|        else:
   314|         0|            0|            0|  0.00%|            object.__setattr__(self, '_subtyp', 'series')
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|    def _update_inplace(self, result, **kwargs):
   317|         0|            0|            0|  0.00%|        # we want to call the generic version and not the IndexOpsMixin
   318|         0|            0|            0|  0.00%|        return generic.NDFrame._update_inplace(self, result, **kwargs)
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|    @property
   321|         0|            0|            0|  0.00%|    def name(self):
   322|         0|            0|            0|  0.00%|        return self._name
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|    @name.setter
   325|         0|            0|            0|  0.00%|    def name(self, value):
   326|         0|            0|            0|  0.00%|        if value is not None and not is_hashable(value):
   327|         0|            0|            0|  0.00%|            raise TypeError('Series.name must be a hashable type')
   328|         0|            0|            0|  0.00%|        object.__setattr__(self, '_name', value)
   329|         0|            0|            0|  0.00%|
   330|         0|            0|            0|  0.00%|    # ndarray compatibility
   331|         0|            0|            0|  0.00%|    @property
   332|         0|            0|            0|  0.00%|    def dtype(self):
   333|         0|            0|            0|  0.00%|        """ return the dtype object of the underlying data """
   334|         0|            0|            0|  0.00%|        return self._data.dtype
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|    @property
   337|         0|            0|            0|  0.00%|    def dtypes(self):
   338|         0|            0|            0|  0.00%|        """ return the dtype object of the underlying data """
   339|         0|            0|            0|  0.00%|        return self._data.dtype
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|    @property
   342|         0|            0|            0|  0.00%|    def ftype(self):
   343|         0|            0|            0|  0.00%|        """ return if the data is sparse|dense """
   344|         0|            0|            0|  0.00%|        return self._data.ftype
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|    @property
   347|         0|            0|            0|  0.00%|    def ftypes(self):
   348|         0|            0|            0|  0.00%|        """ return if the data is sparse|dense """
   349|         0|            0|            0|  0.00%|        return self._data.ftype
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|    @property
   352|         0|            0|            0|  0.00%|    def values(self):
   353|         0|            0|            0|  0.00%|        """
   354|         0|            0|            0|  0.00%|        Return Series as ndarray or ndarray-like
   355|         0|            0|            0|  0.00%|        depending on the dtype
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|        Returns
   358|         0|            0|            0|  0.00%|        -------
   359|         0|            0|            0|  0.00%|        arr : numpy.ndarray or ndarray-like
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|        Examples
   362|         0|            0|            0|  0.00%|        --------
   363|         0|            0|            0|  0.00%|        >>> pd.Series([1, 2, 3]).values
   364|         0|            0|            0|  0.00%|        array([1, 2, 3])
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|        >>> pd.Series(list('aabc')).values
   367|         0|            0|            0|  0.00%|        array(['a', 'a', 'b', 'c'], dtype=object)
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|        >>> pd.Series(list('aabc')).astype('category').values
   370|         0|            0|            0|  0.00%|        [a, a, b, c]
   371|         0|            0|            0|  0.00%|        Categories (3, object): [a, b, c]
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|        Timezone aware datetime data is converted to UTC:
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|        >>> pd.Series(pd.date_range('20130101', periods=3,
   376|         0|            0|            0|  0.00%|        ...                         tz='US/Eastern')).values
   377|         0|            0|            0|  0.00%|        array(['2013-01-01T05:00:00.000000000',
   378|         0|            0|            0|  0.00%|               '2013-01-02T05:00:00.000000000',
   379|         0|            0|            0|  0.00%|               '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|        """
   382|         0|            0|            0|  0.00%|        return self._data.external_values()
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|    @property
   385|         0|            0|            0|  0.00%|    def _values(self):
   386|         0|            0|            0|  0.00%|        """ return the internal repr of this data """
   387|         0|            0|            0|  0.00%|        return self._data.internal_values()
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|    def get_values(self):
   390|         0|            0|            0|  0.00%|        """ same as values (but handles sparseness conversions); is a view """
   391|         0|            0|            0|  0.00%|        return self._data.get_values()
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|    @property
   394|         0|            0|            0|  0.00%|    def asobject(self):
   395|         0|            0|            0|  0.00%|        """
   396|         0|            0|            0|  0.00%|        return object Series which contains boxed values
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|        *this is an internal non-public method*
   399|         0|            0|            0|  0.00%|        """
   400|         0|            0|            0|  0.00%|        return self._data.asobject
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|    # ops
   403|         0|            0|            0|  0.00%|    def ravel(self, order='C'):
   404|         0|            0|            0|  0.00%|        """
   405|         0|            0|            0|  0.00%|        Return the flattened underlying data as an ndarray
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|        See also
   408|         0|            0|            0|  0.00%|        --------
   409|         0|            0|            0|  0.00%|        numpy.ndarray.ravel
   410|         0|            0|            0|  0.00%|        """
   411|         0|            0|            0|  0.00%|        return self._values.ravel(order=order)
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|    def compress(self, condition, *args, **kwargs):
   414|         0|            0|            0|  0.00%|        """
   415|         0|            0|            0|  0.00%|        Return selected slices of an array along given axis as a Series
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|        See also
   418|         0|            0|            0|  0.00%|        --------
   419|         0|            0|            0|  0.00%|        numpy.ndarray.compress
   420|         0|            0|            0|  0.00%|        """
   421|         0|            0|            0|  0.00%|        nv.validate_compress(args, kwargs)
   422|         0|            0|            0|  0.00%|        return self[condition]
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|    def nonzero(self):
   425|         0|            0|            0|  0.00%|        """
   426|         0|            0|            0|  0.00%|        Return the indices of the elements that are non-zero
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|        This method is equivalent to calling `numpy.nonzero` on the
   429|         0|            0|            0|  0.00%|        series data. For compatability with NumPy, the return value is
   430|         0|            0|            0|  0.00%|        the same (a tuple with an array of indices for each dimension),
   431|         0|            0|            0|  0.00%|        but it will always be a one-item tuple because series only have
   432|         0|            0|            0|  0.00%|        one dimension.
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|        Examples
   435|         0|            0|            0|  0.00%|        --------
   436|         0|            0|            0|  0.00%|        >>> s = pd.Series([0, 3, 0, 4])
   437|         0|            0|            0|  0.00%|        >>> s.nonzero()
   438|         0|            0|            0|  0.00%|        (array([1, 3]),)
   439|         0|            0|            0|  0.00%|        >>> s.iloc[s.nonzero()[0]]
   440|         0|            0|            0|  0.00%|        1    3
   441|         0|            0|            0|  0.00%|        3    4
   442|         0|            0|            0|  0.00%|        dtype: int64
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|        See Also
   445|         0|            0|            0|  0.00%|        --------
   446|         0|            0|            0|  0.00%|        numpy.nonzero
   447|         0|            0|            0|  0.00%|        """
   448|         0|            0|            0|  0.00%|        return self._values.nonzero()
   449|         0|            0|            0|  0.00%|
   450|         0|            0|            0|  0.00%|    def put(self, *args, **kwargs):
   451|         0|            0|            0|  0.00%|        """
   452|         0|            0|            0|  0.00%|        Applies the `put` method to its `values` attribute
   453|         0|            0|            0|  0.00%|        if it has one.
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|        See also
   456|         0|            0|            0|  0.00%|        --------
   457|         0|            0|            0|  0.00%|        numpy.ndarray.put
   458|         0|            0|            0|  0.00%|        """
   459|         0|            0|            0|  0.00%|        self._values.put(*args, **kwargs)
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|    def __len__(self):
   462|         0|            0|            0|  0.00%|        """
   463|         0|            0|            0|  0.00%|        return the length of the Series
   464|         0|            0|            0|  0.00%|        """
   465|         0|            0|            0|  0.00%|        return len(self._data)
   466|         0|            0|            0|  0.00%|
   467|         0|            0|            0|  0.00%|    def view(self, dtype=None):
   468|         0|            0|            0|  0.00%|        return self._constructor(self._values.view(dtype),
   469|         0|            0|            0|  0.00%|                                 index=self.index).__finalize__(self)
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|    def __array__(self, result=None):
   472|         0|            0|            0|  0.00%|        """
   473|         0|            0|            0|  0.00%|        the array interface, return my values
   474|         0|            0|            0|  0.00%|        """
   475|         0|            0|            0|  0.00%|        return self.get_values()
   476|         0|            0|            0|  0.00%|
   477|         0|            0|            0|  0.00%|    def __array_wrap__(self, result, context=None):
   478|         0|            0|            0|  0.00%|        """
   479|         0|            0|            0|  0.00%|        Gets called after a ufunc
   480|         0|            0|            0|  0.00%|        """
   481|         0|            0|            0|  0.00%|        return self._constructor(result, index=self.index,
   482|         0|            0|            0|  0.00%|                                 copy=False).__finalize__(self)
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|    def __array_prepare__(self, result, context=None):
   485|         0|            0|            0|  0.00%|        """
   486|         0|            0|            0|  0.00%|        Gets called prior to a ufunc
   487|         0|            0|            0|  0.00%|        """
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|        # nice error message for non-ufunc types
   490|         0|            0|            0|  0.00%|        if context is not None and not isinstance(self._values, np.ndarray):
   491|         0|            0|            0|  0.00%|            obj = context[1][0]
   492|         0|            0|            0|  0.00%|            raise TypeError("{obj} with dtype {dtype} cannot perform "
   493|         0|            0|            0|  0.00%|                            "the numpy op {op}".format(
   494|         0|            0|            0|  0.00%|                                obj=type(obj).__name__,
   495|         0|            0|            0|  0.00%|                                dtype=getattr(obj, 'dtype', None),
   496|         0|            0|            0|  0.00%|                                op=context[0].__name__))
   497|         0|            0|            0|  0.00%|        return result
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|    # complex
   500|         0|            0|            0|  0.00%|    @property
   501|         0|            0|            0|  0.00%|    def real(self):
   502|         0|            0|            0|  0.00%|        return self.values.real
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|    @real.setter
   505|         0|            0|            0|  0.00%|    def real(self, v):
   506|         0|            0|            0|  0.00%|        self.values.real = v
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|    @property
   509|         0|            0|            0|  0.00%|    def imag(self):
   510|         0|            0|            0|  0.00%|        return self.values.imag
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|    @imag.setter
   513|         0|            0|            0|  0.00%|    def imag(self, v):
   514|         0|            0|            0|  0.00%|        self.values.imag = v
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|    # coercion
   517|         0|            0|            0|  0.00%|    __float__ = _coerce_method(float)
   518|         0|            0|            0|  0.00%|    __long__ = _coerce_method(int)
   519|         0|            0|            0|  0.00%|    __int__ = _coerce_method(int)
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|    def _unpickle_series_compat(self, state):
   522|         0|            0|            0|  0.00%|        if isinstance(state, dict):
   523|         0|            0|            0|  0.00%|            self._data = state['_data']
   524|         0|            0|            0|  0.00%|            self.name = state['name']
   525|         0|            0|            0|  0.00%|            self.index = self._data.index
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|        elif isinstance(state, tuple):
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|            # < 0.12 series pickle
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|            nd_state, own_state = state
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|            # recreate the ndarray
   534|         0|            0|            0|  0.00%|            data = np.empty(nd_state[1], dtype=nd_state[2])
   535|         0|            0|            0|  0.00%|            np.ndarray.__setstate__(data, nd_state)
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|            # backwards compat
   538|         0|            0|            0|  0.00%|            index, name = own_state[0], None
   539|         0|            0|            0|  0.00%|            if len(own_state) > 1:
   540|         0|            0|            0|  0.00%|                name = own_state[1]
   541|         0|            0|            0|  0.00%|
   542|         0|            0|            0|  0.00%|            # recreate
   543|         0|            0|            0|  0.00%|            self._data = SingleBlockManager(data, index, fastpath=True)
   544|         0|            0|            0|  0.00%|            self._index = index
   545|         0|            0|            0|  0.00%|            self.name = name
   546|         0|            0|            0|  0.00%|
   547|         0|            0|            0|  0.00%|        else:
   548|         0|            0|            0|  0.00%|            raise Exception("cannot unpickle legacy formats -> [%s]" % state)
   549|         0|            0|            0|  0.00%|
   550|         0|            0|            0|  0.00%|    # indexers
   551|         0|            0|            0|  0.00%|    @property
   552|         0|            0|            0|  0.00%|    def axes(self):
   553|         0|            0|            0|  0.00%|        """Return a list of the row axis labels"""
   554|         0|            0|            0|  0.00%|        return [self.index]
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|    def _ixs(self, i, axis=0):
   557|         0|            0|            0|  0.00%|        """
   558|         0|            0|            0|  0.00%|        Return the i-th value or values in the Series by location
   559|         0|            0|            0|  0.00%|
   560|         0|            0|            0|  0.00%|        Parameters
   561|         0|            0|            0|  0.00%|        ----------
   562|         0|            0|            0|  0.00%|        i : int, slice, or sequence of integers
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|        Returns
   565|         0|            0|            0|  0.00%|        -------
   566|         0|            0|            0|  0.00%|        value : scalar (int) or Series (slice, sequence)
   567|         0|            0|            0|  0.00%|        """
   568|         0|            0|            0|  0.00%|        try:
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|            # dispatch to the values if we need
   571|         0|            0|            0|  0.00%|            values = self._values
   572|         0|            0|            0|  0.00%|            if isinstance(values, np.ndarray):
   573|         0|            0|            0|  0.00%|                return libindex.get_value_at(values, i)
   574|         0|            0|            0|  0.00%|            else:
   575|         0|            0|            0|  0.00%|                return values[i]
   576|         0|            0|            0|  0.00%|        except IndexError:
   577|         0|            0|            0|  0.00%|            raise
   578|         0|            0|            0|  0.00%|        except:
   579|         0|            0|            0|  0.00%|            if isinstance(i, slice):
   580|         0|            0|            0|  0.00%|                indexer = self.index._convert_slice_indexer(i, kind='iloc')
   581|         0|            0|            0|  0.00%|                return self._get_values(indexer)
   582|         0|            0|            0|  0.00%|            else:
   583|         0|            0|            0|  0.00%|                label = self.index[i]
   584|         0|            0|            0|  0.00%|                if isinstance(label, Index):
   585|         0|            0|            0|  0.00%|                    return self.take(i, axis=axis, convert=True)
   586|         0|            0|            0|  0.00%|                else:
   587|         0|            0|            0|  0.00%|                    return libindex.get_value_at(self, i)
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|    @property
   590|         0|            0|            0|  0.00%|    def _is_mixed_type(self):
   591|         0|            0|            0|  0.00%|        return False
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|    def _slice(self, slobj, axis=0, kind=None):
   594|         0|            0|            0|  0.00%|        slobj = self.index._convert_slice_indexer(slobj,
   595|         0|            0|            0|  0.00%|                                                  kind=kind or 'getitem')
   596|         0|            0|            0|  0.00%|        return self._get_values(slobj)
   597|         0|            0|            0|  0.00%|
   598|         0|            0|            0|  0.00%|    def __getitem__(self, key):
   599|         0|            0|            0|  0.00%|        key = com._apply_if_callable(key, self)
   600|         0|            0|            0|  0.00%|        try:
   601|         0|            0|            0|  0.00%|            result = self.index.get_value(self, key)
   602|         0|            0|            0|  0.00%|
   603|         0|            0|            0|  0.00%|            if not is_scalar(result):
   604|         0|            0|            0|  0.00%|                if is_list_like(result) and not isinstance(result, Series):
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|                    # we need to box if we have a non-unique index here
   607|         0|            0|            0|  0.00%|                    # otherwise have inline ndarray/lists
   608|         0|            0|            0|  0.00%|                    if not self.index.is_unique:
   609|         0|            0|            0|  0.00%|                        result = self._constructor(
   610|         0|            0|            0|  0.00%|                            result, index=[key] * len(result),
   611|         0|            0|            0|  0.00%|                            dtype=self.dtype).__finalize__(self)
   612|         0|            0|            0|  0.00%|
   613|         0|            0|            0|  0.00%|            return result
   614|         0|            0|            0|  0.00%|        except InvalidIndexError:
   615|         0|            0|            0|  0.00%|            pass
   616|         0|            0|            0|  0.00%|        except (KeyError, ValueError):
   617|         0|            0|            0|  0.00%|            if isinstance(key, tuple) and isinstance(self.index, MultiIndex):
   618|         0|            0|            0|  0.00%|                # kludge
   619|         0|            0|            0|  0.00%|                pass
   620|         0|            0|            0|  0.00%|            elif key is Ellipsis:
   621|         0|            0|            0|  0.00%|                return self
   622|         0|            0|            0|  0.00%|            elif is_bool_indexer(key):
   623|         0|            0|            0|  0.00%|                pass
   624|         0|            0|            0|  0.00%|            else:
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|                # we can try to coerce the indexer (or this will raise)
   627|         0|            0|            0|  0.00%|                new_key = self.index._convert_scalar_indexer(key,
   628|         0|            0|            0|  0.00%|                                                             kind='getitem')
   629|         0|            0|            0|  0.00%|                if type(new_key) != type(key):
   630|         0|            0|            0|  0.00%|                    return self.__getitem__(new_key)
   631|         0|            0|            0|  0.00%|                raise
   632|         0|            0|            0|  0.00%|
   633|         0|            0|            0|  0.00%|        except Exception:
   634|         0|            0|            0|  0.00%|            raise
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|        if is_iterator(key):
   637|         0|            0|            0|  0.00%|            key = list(key)
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|        if com.is_bool_indexer(key):
   640|         0|            0|            0|  0.00%|            key = check_bool_indexer(self.index, key)
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|        return self._get_with(key)
   643|         0|            0|            0|  0.00%|
   644|         0|            0|            0|  0.00%|    def _get_with(self, key):
   645|         0|            0|            0|  0.00%|        # other: fancy integer or otherwise
   646|         0|            0|            0|  0.00%|        if isinstance(key, slice):
   647|         0|            0|            0|  0.00%|            indexer = self.index._convert_slice_indexer(key, kind='getitem')
   648|         0|            0|            0|  0.00%|            return self._get_values(indexer)
   649|         0|            0|            0|  0.00%|        elif isinstance(key, ABCDataFrame):
   650|         0|            0|            0|  0.00%|            raise TypeError('Indexing a Series with DataFrame is not '
   651|         0|            0|            0|  0.00%|                            'supported, use the appropriate DataFrame column')
   652|         0|            0|            0|  0.00%|        else:
   653|         0|            0|            0|  0.00%|            if isinstance(key, tuple):
   654|         0|            0|            0|  0.00%|                try:
   655|         0|            0|            0|  0.00%|                    return self._get_values_tuple(key)
   656|         0|            0|            0|  0.00%|                except:
   657|         0|            0|            0|  0.00%|                    if len(key) == 1:
   658|         0|            0|            0|  0.00%|                        key = key[0]
   659|         0|            0|            0|  0.00%|                        if isinstance(key, slice):
   660|         0|            0|            0|  0.00%|                            return self._get_values(key)
   661|         0|            0|            0|  0.00%|                    raise
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|            # pragma: no cover
   664|         0|            0|            0|  0.00%|            if not isinstance(key, (list, np.ndarray, Series, Index)):
   665|         0|            0|            0|  0.00%|                key = list(key)
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|            if isinstance(key, Index):
   668|         0|            0|            0|  0.00%|                key_type = key.inferred_type
   669|         0|            0|            0|  0.00%|            else:
   670|         0|            0|            0|  0.00%|                key_type = lib.infer_dtype(key)
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|            if key_type == 'integer':
   673|         0|            0|            0|  0.00%|                if self.index.is_integer() or self.index.is_floating():
   674|         0|            0|            0|  0.00%|                    return self.reindex(key)
   675|         0|            0|            0|  0.00%|                else:
   676|         0|            0|            0|  0.00%|                    return self._get_values(key)
   677|         0|            0|            0|  0.00%|            elif key_type == 'boolean':
   678|         0|            0|            0|  0.00%|                return self._get_values(key)
   679|         0|            0|            0|  0.00%|            else:
   680|         0|            0|            0|  0.00%|                try:
   681|         0|            0|            0|  0.00%|                    # handle the dup indexing case (GH 4246)
   682|         0|            0|            0|  0.00%|                    if isinstance(key, (list, tuple)):
   683|         0|            0|            0|  0.00%|                        return self.loc[key]
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|                    return self.reindex(key)
   686|         0|            0|            0|  0.00%|                except Exception:
   687|         0|            0|            0|  0.00%|                    # [slice(0, 5, None)] will break if you convert to ndarray,
   688|         0|            0|            0|  0.00%|                    # e.g. as requested by np.median
   689|         0|            0|            0|  0.00%|                    # hack
   690|         0|            0|            0|  0.00%|                    if isinstance(key[0], slice):
   691|         0|            0|            0|  0.00%|                        return self._get_values(key)
   692|         0|            0|            0|  0.00%|                    raise
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|    def _get_values_tuple(self, key):
   695|         0|            0|            0|  0.00%|        # mpl hackaround
   696|         0|            0|            0|  0.00%|        if any(k is None for k in key):
   697|         0|            0|            0|  0.00%|            return self._get_values(key)
   698|         0|            0|            0|  0.00%|
   699|         0|            0|            0|  0.00%|        if not isinstance(self.index, MultiIndex):
   700|         0|            0|            0|  0.00%|            raise ValueError('Can only tuple-index with a MultiIndex')
   701|         0|            0|            0|  0.00%|
   702|         0|            0|            0|  0.00%|        # If key is contained, would have returned by now
   703|         0|            0|            0|  0.00%|        indexer, new_index = self.index.get_loc_level(key)
   704|         0|            0|            0|  0.00%|        return self._constructor(self._values[indexer],
   705|         0|            0|            0|  0.00%|                                 index=new_index).__finalize__(self)
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|    def _get_values(self, indexer):
   708|         0|            0|            0|  0.00%|        try:
   709|         0|            0|            0|  0.00%|            return self._constructor(self._data.get_slice(indexer),
   710|         0|            0|            0|  0.00%|                                     fastpath=True).__finalize__(self)
   711|         0|            0|            0|  0.00%|        except Exception:
   712|         0|            0|            0|  0.00%|            return self._values[indexer]
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|    def __setitem__(self, key, value):
   715|         0|            0|            0|  0.00%|        key = com._apply_if_callable(key, self)
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|        def setitem(key, value):
   718|         0|            0|            0|  0.00%|            try:
   719|         0|            0|            0|  0.00%|                self._set_with_engine(key, value)
   720|         0|            0|            0|  0.00%|                return
   721|         0|            0|            0|  0.00%|            except (SettingWithCopyError):
   722|         0|            0|            0|  0.00%|                raise
   723|         0|            0|            0|  0.00%|            except (KeyError, ValueError):
   724|         0|            0|            0|  0.00%|                values = self._values
   725|         0|            0|            0|  0.00%|                if (is_integer(key) and
   726|         0|            0|            0|  0.00%|                        not self.index.inferred_type == 'integer'):
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|                    values[key] = value
   729|         0|            0|            0|  0.00%|                    return
   730|         0|            0|            0|  0.00%|                elif key is Ellipsis:
   731|         0|            0|            0|  0.00%|                    self[:] = value
   732|         0|            0|            0|  0.00%|                    return
   733|         0|            0|            0|  0.00%|                elif com.is_bool_indexer(key):
   734|         0|            0|            0|  0.00%|                    pass
   735|         0|            0|            0|  0.00%|                elif is_timedelta64_dtype(self.dtype):
   736|         0|            0|            0|  0.00%|                    # reassign a null value to iNaT
   737|         0|            0|            0|  0.00%|                    if isnull(value):
   738|         0|            0|            0|  0.00%|                        value = iNaT
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|                        try:
   741|         0|            0|            0|  0.00%|                            self.index._engine.set_value(self._values, key,
   742|         0|            0|            0|  0.00%|                                                         value)
   743|         0|            0|            0|  0.00%|                            return
   744|         0|            0|            0|  0.00%|                        except TypeError:
   745|         0|            0|            0|  0.00%|                            pass
   746|         0|            0|            0|  0.00%|
   747|         0|            0|            0|  0.00%|                self.loc[key] = value
   748|         0|            0|            0|  0.00%|                return
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|            except TypeError as e:
   751|         0|            0|            0|  0.00%|                if (isinstance(key, tuple) and
   752|         0|            0|            0|  0.00%|                        not isinstance(self.index, MultiIndex)):
   753|         0|            0|            0|  0.00%|                    raise ValueError("Can only tuple-index with a MultiIndex")
   754|         0|            0|            0|  0.00%|
   755|         0|            0|            0|  0.00%|                # python 3 type errors should be raised
   756|         0|            0|            0|  0.00%|                if _is_unorderable_exception(e):
   757|         0|            0|            0|  0.00%|                    raise IndexError(key)
   758|         0|            0|            0|  0.00%|
   759|         0|            0|            0|  0.00%|            if com.is_bool_indexer(key):
   760|         0|            0|            0|  0.00%|                key = check_bool_indexer(self.index, key)
   761|         0|            0|            0|  0.00%|                try:
   762|         0|            0|            0|  0.00%|                    self._where(~key, value, inplace=True)
   763|         0|            0|            0|  0.00%|                    return
   764|         0|            0|            0|  0.00%|                except InvalidIndexError:
   765|         0|            0|            0|  0.00%|                    pass
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|            self._set_with(key, value)
   768|         0|            0|            0|  0.00%|
   769|         0|            0|            0|  0.00%|        # do the setitem
   770|         0|            0|            0|  0.00%|        cacher_needs_updating = self._check_is_chained_assignment_possible()
   771|         0|            0|            0|  0.00%|        setitem(key, value)
   772|         0|            0|            0|  0.00%|        if cacher_needs_updating:
   773|         0|            0|            0|  0.00%|            self._maybe_update_cacher()
   774|         0|            0|            0|  0.00%|
   775|         0|            0|            0|  0.00%|    def _set_with_engine(self, key, value):
   776|         0|            0|            0|  0.00%|        values = self._values
   777|         0|            0|            0|  0.00%|        try:
   778|         0|            0|            0|  0.00%|            self.index._engine.set_value(values, key, value)
   779|         0|            0|            0|  0.00%|            return
   780|         0|            0|            0|  0.00%|        except KeyError:
   781|         0|            0|            0|  0.00%|            values[self.index.get_loc(key)] = value
   782|         0|            0|            0|  0.00%|            return
   783|         0|            0|            0|  0.00%|
   784|         0|            0|            0|  0.00%|    def _set_with(self, key, value):
   785|         0|            0|            0|  0.00%|        # other: fancy integer or otherwise
   786|         0|            0|            0|  0.00%|        if isinstance(key, slice):
   787|         0|            0|            0|  0.00%|            indexer = self.index._convert_slice_indexer(key, kind='getitem')
   788|         0|            0|            0|  0.00%|            return self._set_values(indexer, value)
   789|         0|            0|            0|  0.00%|        else:
   790|         0|            0|            0|  0.00%|            if isinstance(key, tuple):
   791|         0|            0|            0|  0.00%|                try:
   792|         0|            0|            0|  0.00%|                    self._set_values(key, value)
   793|         0|            0|            0|  0.00%|                except Exception:
   794|         0|            0|            0|  0.00%|                    pass
   795|         0|            0|            0|  0.00%|
   796|         0|            0|            0|  0.00%|            if not isinstance(key, (list, Series, np.ndarray, Series)):
   797|         0|            0|            0|  0.00%|                try:
   798|         0|            0|            0|  0.00%|                    key = list(key)
   799|         0|            0|            0|  0.00%|                except:
   800|         0|            0|            0|  0.00%|                    key = [key]
   801|         0|            0|            0|  0.00%|
   802|         0|            0|            0|  0.00%|            if isinstance(key, Index):
   803|         0|            0|            0|  0.00%|                key_type = key.inferred_type
   804|         0|            0|            0|  0.00%|            else:
   805|         0|            0|            0|  0.00%|                key_type = lib.infer_dtype(key)
   806|         0|            0|            0|  0.00%|
   807|         0|            0|            0|  0.00%|            if key_type == 'integer':
   808|         0|            0|            0|  0.00%|                if self.index.inferred_type == 'integer':
   809|         0|            0|            0|  0.00%|                    self._set_labels(key, value)
   810|         0|            0|            0|  0.00%|                else:
   811|         0|            0|            0|  0.00%|                    return self._set_values(key, value)
   812|         0|            0|            0|  0.00%|            elif key_type == 'boolean':
   813|         0|            0|            0|  0.00%|                self._set_values(key.astype(np.bool_), value)
   814|         0|            0|            0|  0.00%|            else:
   815|         0|            0|            0|  0.00%|                self._set_labels(key, value)
   816|         0|            0|            0|  0.00%|
   817|         0|            0|            0|  0.00%|    def _set_labels(self, key, value):
   818|         0|            0|            0|  0.00%|        if isinstance(key, Index):
   819|         0|            0|            0|  0.00%|            key = key.values
   820|         0|            0|            0|  0.00%|        else:
   821|         0|            0|            0|  0.00%|            key = _asarray_tuplesafe(key)
   822|         0|            0|            0|  0.00%|        indexer = self.index.get_indexer(key)
   823|         0|            0|            0|  0.00%|        mask = indexer == -1
   824|         0|            0|            0|  0.00%|        if mask.any():
   825|         0|            0|            0|  0.00%|            raise ValueError('%s not contained in the index' % str(key[mask]))
   826|         0|            0|            0|  0.00%|        self._set_values(indexer, value)
   827|         0|            0|            0|  0.00%|
   828|         0|            0|            0|  0.00%|    def _set_values(self, key, value):
   829|         0|            0|            0|  0.00%|        if isinstance(key, Series):
   830|         0|            0|            0|  0.00%|            key = key._values
   831|         0|            0|            0|  0.00%|        self._data = self._data.setitem(indexer=key, value=value)
   832|         0|            0|            0|  0.00%|        self._maybe_update_cacher()
   833|         0|            0|            0|  0.00%|
   834|         0|            0|            0|  0.00%|    @deprecate_kwarg(old_arg_name='reps', new_arg_name='repeats')
   835|         0|            0|            0|  0.00%|    def repeat(self, repeats, *args, **kwargs):
   836|         0|            0|            0|  0.00%|        """
   837|         0|            0|            0|  0.00%|        Repeat elements of an Series. Refer to `numpy.ndarray.repeat`
   838|         0|            0|            0|  0.00%|        for more information about the `repeats` argument.
   839|         0|            0|            0|  0.00%|
   840|         0|            0|            0|  0.00%|        See also
   841|         0|            0|            0|  0.00%|        --------
   842|         0|            0|            0|  0.00%|        numpy.ndarray.repeat
   843|         0|            0|            0|  0.00%|        """
   844|         0|            0|            0|  0.00%|        nv.validate_repeat(args, kwargs)
   845|         0|            0|            0|  0.00%|        new_index = self.index.repeat(repeats)
   846|         0|            0|            0|  0.00%|        new_values = self._values.repeat(repeats)
   847|         0|            0|            0|  0.00%|        return self._constructor(new_values,
   848|         0|            0|            0|  0.00%|                                 index=new_index).__finalize__(self)
   849|         0|            0|            0|  0.00%|
   850|         0|            0|            0|  0.00%|    def reshape(self, *args, **kwargs):
   851|         0|            0|            0|  0.00%|        """
   852|         0|            0|            0|  0.00%|        DEPRECATED: calling this method will raise an error in a
   853|         0|            0|            0|  0.00%|        future release. Please call ``.values.reshape(...)`` instead.
   854|         0|            0|            0|  0.00%|
   855|         0|            0|            0|  0.00%|        return an ndarray with the values shape
   856|         0|            0|            0|  0.00%|        if the specified shape matches exactly the current shape, then
   857|         0|            0|            0|  0.00%|        return self (for compat)
   858|         0|            0|            0|  0.00%|
   859|         0|            0|            0|  0.00%|        See also
   860|         0|            0|            0|  0.00%|        --------
   861|         0|            0|            0|  0.00%|        numpy.ndarray.reshape
   862|         0|            0|            0|  0.00%|        """
   863|         0|            0|            0|  0.00%|        warnings.warn("reshape is deprecated and will raise "
   864|         0|            0|            0|  0.00%|                      "in a subsequent release. Please use "
   865|         0|            0|            0|  0.00%|                      ".values.reshape(...) instead", FutureWarning,
   866|         0|            0|            0|  0.00%|                      stacklevel=2)
   867|         0|            0|            0|  0.00%|
   868|         0|            0|            0|  0.00%|        if len(args) == 1 and hasattr(args[0], '__iter__'):
   869|         0|            0|            0|  0.00%|            shape = args[0]
   870|         0|            0|            0|  0.00%|        else:
   871|         0|            0|            0|  0.00%|            shape = args
   872|         0|            0|            0|  0.00%|
   873|         0|            0|            0|  0.00%|        if tuple(shape) == self.shape:
   874|         0|            0|            0|  0.00%|            # XXX ignoring the "order" keyword.
   875|         0|            0|            0|  0.00%|            nv.validate_reshape(tuple(), kwargs)
   876|         0|            0|            0|  0.00%|            return self
   877|         0|            0|            0|  0.00%|
   878|         0|            0|            0|  0.00%|        return self._values.reshape(shape, **kwargs)
   879|         0|            0|            0|  0.00%|
   880|         0|            0|            0|  0.00%|    def get_value(self, label, takeable=False):
   881|         0|            0|            0|  0.00%|        """
   882|         0|            0|            0|  0.00%|        Quickly retrieve single value at passed index label
   883|         0|            0|            0|  0.00%|
   884|         0|            0|            0|  0.00%|        Parameters
   885|         0|            0|            0|  0.00%|        ----------
   886|         0|            0|            0|  0.00%|        index : label
   887|         0|            0|            0|  0.00%|        takeable : interpret the index as indexers, default False
   888|         0|            0|            0|  0.00%|
   889|         0|            0|            0|  0.00%|        Returns
   890|         0|            0|            0|  0.00%|        -------
   891|         0|            0|            0|  0.00%|        value : scalar value
   892|         0|            0|            0|  0.00%|        """
   893|         0|            0|            0|  0.00%|        if takeable is True:
   894|         0|            0|            0|  0.00%|            return _maybe_box_datetimelike(self._values[label])
   895|         0|            0|            0|  0.00%|        return self.index.get_value(self._values, label)
   896|         0|            0|            0|  0.00%|
   897|         0|            0|            0|  0.00%|    def set_value(self, label, value, takeable=False):
   898|         0|            0|            0|  0.00%|        """
   899|         0|            0|            0|  0.00%|        Quickly set single value at passed label. If label is not contained, a
   900|         0|            0|            0|  0.00%|        new object is created with the label placed at the end of the result
   901|         0|            0|            0|  0.00%|        index
   902|         0|            0|            0|  0.00%|
   903|         0|            0|            0|  0.00%|        Parameters
   904|         0|            0|            0|  0.00%|        ----------
   905|         0|            0|            0|  0.00%|        label : object
   906|         0|            0|            0|  0.00%|            Partial indexing with MultiIndex not allowed
   907|         0|            0|            0|  0.00%|        value : object
   908|         0|            0|            0|  0.00%|            Scalar value
   909|         0|            0|            0|  0.00%|        takeable : interpret the index as indexers, default False
   910|         0|            0|            0|  0.00%|
   911|         0|            0|            0|  0.00%|        Returns
   912|         0|            0|            0|  0.00%|        -------
   913|         0|            0|            0|  0.00%|        series : Series
   914|         0|            0|            0|  0.00%|            If label is contained, will be reference to calling Series,
   915|         0|            0|            0|  0.00%|            otherwise a new object
   916|         0|            0|            0|  0.00%|        """
   917|         0|            0|            0|  0.00%|        try:
   918|         0|            0|            0|  0.00%|            if takeable:
   919|         0|            0|            0|  0.00%|                self._values[label] = value
   920|         0|            0|            0|  0.00%|            else:
   921|         0|            0|            0|  0.00%|                self.index._engine.set_value(self._values, label, value)
   922|         0|            0|            0|  0.00%|            return self
   923|         0|            0|            0|  0.00%|        except KeyError:
   924|         0|            0|            0|  0.00%|
   925|         0|            0|            0|  0.00%|            # set using a non-recursive method
   926|         0|            0|            0|  0.00%|            self.loc[label] = value
   927|         0|            0|            0|  0.00%|            return self
   928|         0|            0|            0|  0.00%|
   929|         0|            0|            0|  0.00%|    def reset_index(self, level=None, drop=False, name=None, inplace=False):
   930|         0|            0|            0|  0.00%|        """
   931|         0|            0|            0|  0.00%|        Analogous to the :meth:`pandas.DataFrame.reset_index` function, see
   932|         0|            0|            0|  0.00%|        docstring there.
   933|         0|            0|            0|  0.00%|
   934|         0|            0|            0|  0.00%|        Parameters
   935|         0|            0|            0|  0.00%|        ----------
   936|         0|            0|            0|  0.00%|        level : int, str, tuple, or list, default None
   937|         0|            0|            0|  0.00%|            Only remove the given levels from the index. Removes all levels by
   938|         0|            0|            0|  0.00%|            default
   939|         0|            0|            0|  0.00%|        drop : boolean, default False
   940|         0|            0|            0|  0.00%|            Do not try to insert index into dataframe columns
   941|         0|            0|            0|  0.00%|        name : object, default None
   942|         0|            0|            0|  0.00%|            The name of the column corresponding to the Series values
   943|         0|            0|            0|  0.00%|        inplace : boolean, default False
   944|         0|            0|            0|  0.00%|            Modify the Series in place (do not create a new object)
   945|         0|            0|            0|  0.00%|
   946|         0|            0|            0|  0.00%|        Returns
   947|         0|            0|            0|  0.00%|        ----------
   948|         0|            0|            0|  0.00%|        resetted : DataFrame, or Series if drop == True
   949|         0|            0|            0|  0.00%|        """
   950|         0|            0|            0|  0.00%|        inplace = validate_bool_kwarg(inplace, 'inplace')
   951|         0|            0|            0|  0.00%|        if drop:
   952|         0|            0|            0|  0.00%|            new_index = _default_index(len(self))
   953|         0|            0|            0|  0.00%|            if level is not None and isinstance(self.index, MultiIndex):
   954|         0|            0|            0|  0.00%|                if not isinstance(level, (tuple, list)):
   955|         0|            0|            0|  0.00%|                    level = [level]
   956|         0|            0|            0|  0.00%|                level = [self.index._get_level_number(lev) for lev in level]
   957|         0|            0|            0|  0.00%|                if len(level) < len(self.index.levels):
   958|         0|            0|            0|  0.00%|                    new_index = self.index.droplevel(level)
   959|         0|            0|            0|  0.00%|
   960|         0|            0|            0|  0.00%|            if inplace:
   961|         0|            0|            0|  0.00%|                self.index = new_index
   962|         0|            0|            0|  0.00%|                # set name if it was passed, otherwise, keep the previous name
   963|         0|            0|            0|  0.00%|                self.name = name or self.name
   964|         0|            0|            0|  0.00%|            else:
   965|         0|            0|            0|  0.00%|                return self._constructor(self._values.copy(),
   966|         0|            0|            0|  0.00%|                                         index=new_index).__finalize__(self)
   967|         0|            0|            0|  0.00%|        elif inplace:
   968|         0|            0|            0|  0.00%|            raise TypeError('Cannot reset_index inplace on a Series '
   969|         0|            0|            0|  0.00%|                            'to create a DataFrame')
   970|         0|            0|            0|  0.00%|        else:
   971|         0|            0|            0|  0.00%|            df = self.to_frame(name)
   972|         0|            0|            0|  0.00%|            return df.reset_index(level=level, drop=drop)
   973|         0|            0|            0|  0.00%|
   974|         0|            0|            0|  0.00%|    def __unicode__(self):
   975|         0|            0|            0|  0.00%|        """
   976|         0|            0|            0|  0.00%|        Return a string representation for a particular DataFrame
   977|         0|            0|            0|  0.00%|
   978|         0|            0|            0|  0.00%|        Invoked by unicode(df) in py2 only. Yields a Unicode String in both
   979|         0|            0|            0|  0.00%|        py2/py3.
   980|         0|            0|            0|  0.00%|        """
   981|         0|            0|            0|  0.00%|        buf = StringIO(u(""))
   982|         0|            0|            0|  0.00%|        width, height = get_terminal_size()
   983|         0|            0|            0|  0.00%|        max_rows = (height if get_option("display.max_rows") == 0 else
   984|         0|            0|            0|  0.00%|                    get_option("display.max_rows"))
   985|         0|            0|            0|  0.00%|        show_dimensions = get_option("display.show_dimensions")
   986|         0|            0|            0|  0.00%|
   987|         0|            0|            0|  0.00%|        self.to_string(buf=buf, name=self.name, dtype=self.dtype,
   988|         0|            0|            0|  0.00%|                       max_rows=max_rows, length=show_dimensions)
   989|         0|            0|            0|  0.00%|        result = buf.getvalue()
   990|         0|            0|            0|  0.00%|
   991|         0|            0|            0|  0.00%|        return result
   992|         0|            0|            0|  0.00%|
   993|         0|            0|            0|  0.00%|    def to_string(self, buf=None, na_rep='NaN', float_format=None, header=True,
   994|         0|            0|            0|  0.00%|                  index=True, length=False, dtype=False, name=False,
   995|         0|            0|            0|  0.00%|                  max_rows=None):
   996|         0|            0|            0|  0.00%|        """
   997|         0|            0|            0|  0.00%|        Render a string representation of the Series
   998|         0|            0|            0|  0.00%|
   999|         0|            0|            0|  0.00%|        Parameters
  1000|         0|            0|            0|  0.00%|        ----------
  1001|         0|            0|            0|  0.00%|        buf : StringIO-like, optional
  1002|         0|            0|            0|  0.00%|            buffer to write to
  1003|         0|            0|            0|  0.00%|        na_rep : string, optional
  1004|         0|            0|            0|  0.00%|            string representation of NAN to use, default 'NaN'
  1005|         0|            0|            0|  0.00%|        float_format : one-parameter function, optional
  1006|         0|            0|            0|  0.00%|            formatter function to apply to columns' elements if they are floats
  1007|         0|            0|            0|  0.00%|            default None
  1008|         0|            0|            0|  0.00%|        header: boolean, default True
  1009|         0|            0|            0|  0.00%|            Add the Series header (index name)
  1010|         0|            0|            0|  0.00%|        index : bool, optional
  1011|         0|            0|            0|  0.00%|            Add index (row) labels, default True
  1012|         0|            0|            0|  0.00%|        length : boolean, default False
  1013|         0|            0|            0|  0.00%|            Add the Series length
  1014|         0|            0|            0|  0.00%|        dtype : boolean, default False
  1015|         0|            0|            0|  0.00%|            Add the Series dtype
  1016|         0|            0|            0|  0.00%|        name : boolean, default False
  1017|         0|            0|            0|  0.00%|            Add the Series name if not None
  1018|         0|            0|            0|  0.00%|        max_rows : int, optional
  1019|         0|            0|            0|  0.00%|            Maximum number of rows to show before truncating. If None, show
  1020|         0|            0|            0|  0.00%|            all.
  1021|         0|            0|            0|  0.00%|
  1022|         0|            0|            0|  0.00%|        Returns
  1023|         0|            0|            0|  0.00%|        -------
  1024|         0|            0|            0|  0.00%|        formatted : string (if not buffer passed)
  1025|         0|            0|            0|  0.00%|        """
  1026|         0|            0|            0|  0.00%|
  1027|         0|            0|            0|  0.00%|        formatter = fmt.SeriesFormatter(self, name=name, length=length,
  1028|         0|            0|            0|  0.00%|                                        header=header, index=index,
  1029|         0|            0|            0|  0.00%|                                        dtype=dtype, na_rep=na_rep,
  1030|         0|            0|            0|  0.00%|                                        float_format=float_format,
  1031|         0|            0|            0|  0.00%|                                        max_rows=max_rows)
  1032|         0|            0|            0|  0.00%|        result = formatter.to_string()
  1033|         0|            0|            0|  0.00%|
  1034|         0|            0|            0|  0.00%|        # catch contract violations
  1035|         0|            0|            0|  0.00%|        if not isinstance(result, compat.text_type):
  1036|         0|            0|            0|  0.00%|            raise AssertionError("result must be of type unicode, type"
  1037|         0|            0|            0|  0.00%|                                 " of result is {0!r}"
  1038|         0|            0|            0|  0.00%|                                 "".format(result.__class__.__name__))
  1039|         0|            0|            0|  0.00%|
  1040|         0|            0|            0|  0.00%|        if buf is None:
  1041|         0|            0|            0|  0.00%|            return result
  1042|         0|            0|            0|  0.00%|        else:
  1043|         0|            0|            0|  0.00%|            try:
  1044|         0|            0|            0|  0.00%|                buf.write(result)
  1045|         0|            0|            0|  0.00%|            except AttributeError:
  1046|         0|            0|            0|  0.00%|                with open(buf, 'w') as f:
  1047|         0|            0|            0|  0.00%|                    f.write(result)
  1048|         0|            0|            0|  0.00%|
  1049|         0|            0|            0|  0.00%|    def __iter__(self):
  1050|         0|            0|            0|  0.00%|        """ provide iteration over the values of the Series
  1051|         0|            0|            0|  0.00%|        box values if necessary """
  1052|         0|            0|            0|  0.00%|        if is_datetimelike(self):
  1053|         0|            0|            0|  0.00%|            return (_maybe_box_datetimelike(x) for x in self._values)
  1054|         0|            0|            0|  0.00%|        else:
  1055|         0|            0|            0|  0.00%|            return iter(self._values)
  1056|         0|            0|            0|  0.00%|
  1057|         0|            0|            0|  0.00%|    def iteritems(self):
  1058|         0|            0|            0|  0.00%|        """
  1059|         0|            0|            0|  0.00%|        Lazily iterate over (index, value) tuples
  1060|         0|            0|            0|  0.00%|        """
  1061|         0|            0|            0|  0.00%|        return zip(iter(self.index), iter(self))
  1062|         0|            0|            0|  0.00%|
  1063|         0|            0|            0|  0.00%|    if compat.PY3:  # pragma: no cover
  1064|         0|            0|            0|  0.00%|        items = iteritems
  1065|         0|            0|            0|  0.00%|
  1066|         0|            0|            0|  0.00%|    # ----------------------------------------------------------------------
  1067|         0|            0|            0|  0.00%|    # Misc public methods
  1068|         0|            0|            0|  0.00%|
  1069|         0|            0|            0|  0.00%|    def keys(self):
  1070|         0|            0|            0|  0.00%|        """Alias for index"""
  1071|         0|            0|            0|  0.00%|        return self.index
  1072|         0|            0|            0|  0.00%|
  1073|         0|            0|            0|  0.00%|    def tolist(self):
  1074|         0|            0|            0|  0.00%|        """ Convert Series to a nested list """
  1075|         0|            0|            0|  0.00%|        return list(self.asobject)
  1076|         0|            0|            0|  0.00%|
  1077|         0|            0|            0|  0.00%|    def to_dict(self):
  1078|         0|            0|            0|  0.00%|        """
  1079|         0|            0|            0|  0.00%|        Convert Series to {label -> value} dict
  1080|         0|            0|            0|  0.00%|
  1081|         0|            0|            0|  0.00%|        Returns
  1082|         0|            0|            0|  0.00%|        -------
  1083|         0|            0|            0|  0.00%|        value_dict : dict
  1084|         0|            0|            0|  0.00%|        """
  1085|         0|            0|            0|  0.00%|        return dict(compat.iteritems(self))
  1086|         0|            0|            0|  0.00%|
  1087|         0|            0|            0|  0.00%|    def to_frame(self, name=None):
  1088|         0|            0|            0|  0.00%|        """
  1089|         0|            0|            0|  0.00%|        Convert Series to DataFrame
  1090|         0|            0|            0|  0.00%|
  1091|         0|            0|            0|  0.00%|        Parameters
  1092|         0|            0|            0|  0.00%|        ----------
  1093|         0|            0|            0|  0.00%|        name : object, default None
  1094|         0|            0|            0|  0.00%|            The passed name should substitute for the series name (if it has
  1095|         0|            0|            0|  0.00%|            one).
  1096|         0|            0|            0|  0.00%|
  1097|         0|            0|            0|  0.00%|        Returns
  1098|         0|            0|            0|  0.00%|        -------
  1099|         0|            0|            0|  0.00%|        data_frame : DataFrame
  1100|         0|            0|            0|  0.00%|        """
  1101|         0|            0|            0|  0.00%|        if name is None:
  1102|         0|            0|            0|  0.00%|            df = self._constructor_expanddim(self)
  1103|         0|            0|            0|  0.00%|        else:
  1104|         0|            0|            0|  0.00%|            df = self._constructor_expanddim({name: self})
  1105|         0|            0|            0|  0.00%|
  1106|         0|            0|            0|  0.00%|        return df
  1107|         0|            0|            0|  0.00%|
  1108|         0|            0|            0|  0.00%|    def to_sparse(self, kind='block', fill_value=None):
  1109|         0|            0|            0|  0.00%|        """
  1110|         0|            0|            0|  0.00%|        Convert Series to SparseSeries
  1111|         0|            0|            0|  0.00%|
  1112|         0|            0|            0|  0.00%|        Parameters
  1113|         0|            0|            0|  0.00%|        ----------
  1114|         0|            0|            0|  0.00%|        kind : {'block', 'integer'}
  1115|         0|            0|            0|  0.00%|        fill_value : float, defaults to NaN (missing)
  1116|         0|            0|            0|  0.00%|
  1117|         0|            0|            0|  0.00%|        Returns
  1118|         0|            0|            0|  0.00%|        -------
  1119|         0|            0|            0|  0.00%|        sp : SparseSeries
  1120|         0|            0|            0|  0.00%|        """
  1121|         0|            0|            0|  0.00%|        from pandas.core.sparse.series import SparseSeries
  1122|         0|            0|            0|  0.00%|        return SparseSeries(self, kind=kind,
  1123|         0|            0|            0|  0.00%|                            fill_value=fill_value).__finalize__(self)
  1124|         0|            0|            0|  0.00%|
  1125|         0|            0|            0|  0.00%|    def _set_name(self, name, inplace=False):
  1126|         0|            0|            0|  0.00%|        """
  1127|         0|            0|            0|  0.00%|        Set the Series name.
  1128|         0|            0|            0|  0.00%|
  1129|         0|            0|            0|  0.00%|        Parameters
  1130|         0|            0|            0|  0.00%|        ----------
  1131|         0|            0|            0|  0.00%|        name : str
  1132|         0|            0|            0|  0.00%|        inplace : bool
  1133|         0|            0|            0|  0.00%|            whether to modify `self` directly or return a copy
  1134|         0|            0|            0|  0.00%|        """
  1135|         0|            0|            0|  0.00%|        inplace = validate_bool_kwarg(inplace, 'inplace')
  1136|         0|            0|            0|  0.00%|        ser = self if inplace else self.copy()
  1137|         0|            0|            0|  0.00%|        ser.name = name
  1138|         0|            0|            0|  0.00%|        return ser
  1139|         0|            0|            0|  0.00%|
  1140|         0|            0|            0|  0.00%|    # ----------------------------------------------------------------------
  1141|         0|            0|            0|  0.00%|    # Statistics, overridden ndarray methods
  1142|         0|            0|            0|  0.00%|
  1143|         0|            0|            0|  0.00%|    # TODO: integrate bottleneck
  1144|         0|            0|            0|  0.00%|
  1145|         0|            0|            0|  0.00%|    def count(self, level=None):
  1146|         0|            0|            0|  0.00%|        """
  1147|         0|            0|            0|  0.00%|        Return number of non-NA/null observations in the Series
  1148|         0|            0|            0|  0.00%|
  1149|         0|            0|            0|  0.00%|        Parameters
  1150|         0|            0|            0|  0.00%|        ----------
  1151|         0|            0|            0|  0.00%|        level : int or level name, default None
  1152|         0|            0|            0|  0.00%|            If the axis is a MultiIndex (hierarchical), count along a
  1153|         0|            0|            0|  0.00%|            particular level, collapsing into a smaller Series
  1154|         0|            0|            0|  0.00%|
  1155|         0|            0|            0|  0.00%|        Returns
  1156|         0|            0|            0|  0.00%|        -------
  1157|         0|            0|            0|  0.00%|        nobs : int or Series (if level specified)
  1158|         0|            0|            0|  0.00%|        """
  1159|         0|            0|            0|  0.00%|        from pandas.core.index import _get_na_value
  1160|         0|            0|            0|  0.00%|
  1161|         0|            0|            0|  0.00%|        if level is None:
  1162|         0|            0|            0|  0.00%|            return notnull(_values_from_object(self)).sum()
  1163|         0|            0|            0|  0.00%|
  1164|         0|            0|            0|  0.00%|        if isinstance(level, compat.string_types):
  1165|         0|            0|            0|  0.00%|            level = self.index._get_level_number(level)
  1166|         0|            0|            0|  0.00%|
  1167|         0|            0|            0|  0.00%|        lev = self.index.levels[level]
  1168|         0|            0|            0|  0.00%|        lab = np.array(self.index.labels[level], subok=False, copy=True)
  1169|         0|            0|            0|  0.00%|
  1170|         0|            0|            0|  0.00%|        mask = lab == -1
  1171|         0|            0|            0|  0.00%|        if mask.any():
  1172|         0|            0|            0|  0.00%|            lab[mask] = cnt = len(lev)
  1173|         0|            0|            0|  0.00%|            lev = lev.insert(cnt, _get_na_value(lev.dtype.type))
  1174|         0|            0|            0|  0.00%|
  1175|         0|            0|            0|  0.00%|        obs = lab[notnull(self.values)]
  1176|         0|            0|            0|  0.00%|        out = np.bincount(obs, minlength=len(lev) or None)
  1177|         0|            0|            0|  0.00%|        return self._constructor(out, index=lev,
  1178|         0|            0|            0|  0.00%|                                 dtype='int64').__finalize__(self)
  1179|         0|            0|            0|  0.00%|
  1180|         0|            0|            0|  0.00%|    def mode(self):
  1181|         0|            0|            0|  0.00%|        """Return the mode(s) of the dataset.
  1182|         0|            0|            0|  0.00%|
  1183|         0|            0|            0|  0.00%|        Always returns Series even if only one value is returned.
  1184|         0|            0|            0|  0.00%|
  1185|         0|            0|            0|  0.00%|        Returns
  1186|         0|            0|            0|  0.00%|        -------
  1187|         0|            0|            0|  0.00%|        modes : Series (sorted)
  1188|         0|            0|            0|  0.00%|        """
  1189|         0|            0|            0|  0.00%|        # TODO: Add option for bins like value_counts()
  1190|         0|            0|            0|  0.00%|        return algorithms.mode(self)
  1191|         0|            0|            0|  0.00%|
  1192|         0|            0|            0|  0.00%|    @Appender(base._shared_docs['unique'] % _shared_doc_kwargs)
  1193|         0|            0|            0|  0.00%|    def unique(self):
  1194|         0|            0|            0|  0.00%|        result = super(Series, self).unique()
  1195|         0|            0|            0|  0.00%|
  1196|         0|            0|            0|  0.00%|        if is_datetime64tz_dtype(self.dtype):
  1197|         0|            0|            0|  0.00%|            # we are special casing datetime64tz_dtype
  1198|         0|            0|            0|  0.00%|            # to return an object array of tz-aware Timestamps
  1199|         0|            0|            0|  0.00%|
  1200|         0|            0|            0|  0.00%|            # TODO: it must return DatetimeArray with tz in pandas 2.0
  1201|         0|            0|            0|  0.00%|            result = result.asobject.values
  1202|         0|            0|            0|  0.00%|
  1203|         0|            0|            0|  0.00%|        return result
  1204|         0|            0|            0|  0.00%|
  1205|         0|            0|            0|  0.00%|    @Appender(base._shared_docs['drop_duplicates'] % _shared_doc_kwargs)
  1206|         0|            0|            0|  0.00%|    def drop_duplicates(self, keep='first', inplace=False):
  1207|         0|            0|            0|  0.00%|        return super(Series, self).drop_duplicates(keep=keep, inplace=inplace)
  1208|         0|            0|            0|  0.00%|
  1209|         0|            0|            0|  0.00%|    @Appender(base._shared_docs['duplicated'] % _shared_doc_kwargs)
  1210|         0|            0|            0|  0.00%|    def duplicated(self, keep='first'):
  1211|         0|            0|            0|  0.00%|        return super(Series, self).duplicated(keep=keep)
  1212|         0|            0|            0|  0.00%|
  1213|         0|            0|            0|  0.00%|    def idxmin(self, axis=None, skipna=True, *args, **kwargs):
  1214|         0|            0|            0|  0.00%|        """
  1215|         0|            0|            0|  0.00%|        Index of first occurrence of minimum of values.
  1216|         0|            0|            0|  0.00%|
  1217|         0|            0|            0|  0.00%|        Parameters
  1218|         0|            0|            0|  0.00%|        ----------
  1219|         0|            0|            0|  0.00%|        skipna : boolean, default True
  1220|         0|            0|            0|  0.00%|            Exclude NA/null values
  1221|         0|            0|            0|  0.00%|
  1222|         0|            0|            0|  0.00%|        Returns
  1223|         0|            0|            0|  0.00%|        -------
  1224|         0|            0|            0|  0.00%|        idxmin : Index of minimum of values
  1225|         0|            0|            0|  0.00%|
  1226|         0|            0|            0|  0.00%|        Notes
  1227|         0|            0|            0|  0.00%|        -----
  1228|         0|            0|            0|  0.00%|        This method is the Series version of ``ndarray.argmin``.
  1229|         0|            0|            0|  0.00%|
  1230|         0|            0|            0|  0.00%|        See Also
  1231|         0|            0|            0|  0.00%|        --------
  1232|         0|            0|            0|  0.00%|        DataFrame.idxmin
  1233|         0|            0|            0|  0.00%|        numpy.ndarray.argmin
  1234|         0|            0|            0|  0.00%|        """
  1235|         0|            0|            0|  0.00%|        skipna = nv.validate_argmin_with_skipna(skipna, args, kwargs)
  1236|         0|            0|            0|  0.00%|        i = nanops.nanargmin(_values_from_object(self), skipna=skipna)
  1237|         0|            0|            0|  0.00%|        if i == -1:
  1238|         0|            0|            0|  0.00%|            return np.nan
  1239|         0|            0|            0|  0.00%|        return self.index[i]
  1240|         0|            0|            0|  0.00%|
  1241|         0|            0|            0|  0.00%|    def idxmax(self, axis=None, skipna=True, *args, **kwargs):
  1242|         0|            0|            0|  0.00%|        """
  1243|         0|            0|            0|  0.00%|        Index of first occurrence of maximum of values.
  1244|         0|            0|            0|  0.00%|
  1245|         0|            0|            0|  0.00%|        Parameters
  1246|         0|            0|            0|  0.00%|        ----------
  1247|         0|            0|            0|  0.00%|        skipna : boolean, default True
  1248|         0|            0|            0|  0.00%|            Exclude NA/null values
  1249|         0|            0|            0|  0.00%|
  1250|         0|            0|            0|  0.00%|        Returns
  1251|         0|            0|            0|  0.00%|        -------
  1252|         0|            0|            0|  0.00%|        idxmax : Index of maximum of values
  1253|         0|            0|            0|  0.00%|
  1254|         0|            0|            0|  0.00%|        Notes
  1255|         0|            0|            0|  0.00%|        -----
  1256|         0|            0|            0|  0.00%|        This method is the Series version of ``ndarray.argmax``.
  1257|         0|            0|            0|  0.00%|
  1258|         0|            0|            0|  0.00%|        See Also
  1259|         0|            0|            0|  0.00%|        --------
  1260|         0|            0|            0|  0.00%|        DataFrame.idxmax
  1261|         0|            0|            0|  0.00%|        numpy.ndarray.argmax
  1262|         0|            0|            0|  0.00%|        """
  1263|         0|            0|            0|  0.00%|        skipna = nv.validate_argmax_with_skipna(skipna, args, kwargs)
  1264|         0|            0|            0|  0.00%|        i = nanops.nanargmax(_values_from_object(self), skipna=skipna)
  1265|         0|            0|            0|  0.00%|        if i == -1:
  1266|         0|            0|            0|  0.00%|            return np.nan
  1267|         0|            0|            0|  0.00%|        return self.index[i]
  1268|         0|            0|            0|  0.00%|
  1269|         0|            0|            0|  0.00%|    # ndarray compat
  1270|         0|            0|            0|  0.00%|    argmin = idxmin
  1271|         0|            0|            0|  0.00%|    argmax = idxmax
  1272|         0|            0|            0|  0.00%|
  1273|         0|            0|            0|  0.00%|    def round(self, decimals=0, *args, **kwargs):
  1274|         0|            0|            0|  0.00%|        """
  1275|         0|            0|            0|  0.00%|        Round each value in a Series to the given number of decimals.
  1276|         0|            0|            0|  0.00%|
  1277|         0|            0|            0|  0.00%|        Parameters
  1278|         0|            0|            0|  0.00%|        ----------
  1279|         0|            0|            0|  0.00%|        decimals : int
  1280|         0|            0|            0|  0.00%|            Number of decimal places to round to (default: 0).
  1281|         0|            0|            0|  0.00%|            If decimals is negative, it specifies the number of
  1282|         0|            0|            0|  0.00%|            positions to the left of the decimal point.
  1283|         0|            0|            0|  0.00%|
  1284|         0|            0|            0|  0.00%|        Returns
  1285|         0|            0|            0|  0.00%|        -------
  1286|         0|            0|            0|  0.00%|        Series object
  1287|         0|            0|            0|  0.00%|
  1288|         0|            0|            0|  0.00%|        See Also
  1289|         0|            0|            0|  0.00%|        --------
  1290|         0|            0|            0|  0.00%|        numpy.around
  1291|         0|            0|            0|  0.00%|        DataFrame.round
  1292|         0|            0|            0|  0.00%|
  1293|         0|            0|            0|  0.00%|        """
  1294|         0|            0|            0|  0.00%|        nv.validate_round(args, kwargs)
  1295|         0|            0|            0|  0.00%|        result = _values_from_object(self).round(decimals)
  1296|         0|            0|            0|  0.00%|        result = self._constructor(result, index=self.index).__finalize__(self)
  1297|         0|            0|            0|  0.00%|
  1298|         0|            0|            0|  0.00%|        return result
  1299|         0|            0|            0|  0.00%|
  1300|         0|            0|            0|  0.00%|    def quantile(self, q=0.5, interpolation='linear'):
  1301|         0|            0|            0|  0.00%|        """
  1302|         0|            0|            0|  0.00%|        Return value at the given quantile, a la numpy.percentile.
  1303|         0|            0|            0|  0.00%|
  1304|         0|            0|            0|  0.00%|        Parameters
  1305|         0|            0|            0|  0.00%|        ----------
  1306|         0|            0|            0|  0.00%|        q : float or array-like, default 0.5 (50% quantile)
  1307|         0|            0|            0|  0.00%|            0 <= q <= 1, the quantile(s) to compute
  1308|         0|            0|            0|  0.00%|        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
  1309|         0|            0|            0|  0.00%|            .. versionadded:: 0.18.0
  1310|         0|            0|            0|  0.00%|
  1311|         0|            0|            0|  0.00%|            This optional parameter specifies the interpolation method to use,
  1312|         0|            0|            0|  0.00%|            when the desired quantile lies between two data points `i` and `j`:
  1313|         0|            0|            0|  0.00%|
  1314|         0|            0|            0|  0.00%|                * linear: `i + (j - i) * fraction`, where `fraction` is the
  1315|         0|            0|            0|  0.00%|                  fractional part of the index surrounded by `i` and `j`.
  1316|         0|            0|            0|  0.00%|                * lower: `i`.
  1317|         0|            0|            0|  0.00%|                * higher: `j`.
  1318|         0|            0|            0|  0.00%|                * nearest: `i` or `j` whichever is nearest.
  1319|         0|            0|            0|  0.00%|                * midpoint: (`i` + `j`) / 2.
  1320|         0|            0|            0|  0.00%|
  1321|         0|            0|            0|  0.00%|        Returns
  1322|         0|            0|            0|  0.00%|        -------
  1323|         0|            0|            0|  0.00%|        quantile : float or Series
  1324|         0|            0|            0|  0.00%|            if ``q`` is an array, a Series will be returned where the
  1325|         0|            0|            0|  0.00%|            index is ``q`` and the values are the quantiles.
  1326|         0|            0|            0|  0.00%|
  1327|         0|            0|            0|  0.00%|        Examples
  1328|         0|            0|            0|  0.00%|        --------
  1329|         0|            0|            0|  0.00%|        >>> s = Series([1, 2, 3, 4])
  1330|         0|            0|            0|  0.00%|        >>> s.quantile(.5)
  1331|         0|            0|            0|  0.00%|        2.5
  1332|         0|            0|            0|  0.00%|        >>> s.quantile([.25, .5, .75])
  1333|         0|            0|            0|  0.00%|        0.25    1.75
  1334|         0|            0|            0|  0.00%|        0.50    2.50
  1335|         0|            0|            0|  0.00%|        0.75    3.25
  1336|         0|            0|            0|  0.00%|        dtype: float64
  1337|         0|            0|            0|  0.00%|
  1338|         0|            0|            0|  0.00%|        """
  1339|         0|            0|            0|  0.00%|
  1340|         0|            0|            0|  0.00%|        self._check_percentile(q)
  1341|         0|            0|            0|  0.00%|
  1342|         0|            0|            0|  0.00%|        result = self._data.quantile(qs=q, interpolation=interpolation)
  1343|         0|            0|            0|  0.00%|
  1344|         0|            0|            0|  0.00%|        if is_list_like(q):
  1345|         0|            0|            0|  0.00%|            return self._constructor(result,
  1346|         0|            0|            0|  0.00%|                                     index=Float64Index(q),
  1347|         0|            0|            0|  0.00%|                                     name=self.name)
  1348|         0|            0|            0|  0.00%|        else:
  1349|         0|            0|            0|  0.00%|            # scalar
  1350|         0|            0|            0|  0.00%|            return result
  1351|         0|            0|            0|  0.00%|
  1352|         0|            0|            0|  0.00%|    def corr(self, other, method='pearson', min_periods=None):
  1353|         0|            0|            0|  0.00%|        """
  1354|         0|            0|            0|  0.00%|        Compute correlation with `other` Series, excluding missing values
  1355|         0|            0|            0|  0.00%|
  1356|         0|            0|            0|  0.00%|        Parameters
  1357|         0|            0|            0|  0.00%|        ----------
  1358|         0|            0|            0|  0.00%|        other : Series
  1359|         0|            0|            0|  0.00%|        method : {'pearson', 'kendall', 'spearman'}
  1360|         0|            0|            0|  0.00%|            * pearson : standard correlation coefficient
  1361|         0|            0|            0|  0.00%|            * kendall : Kendall Tau correlation coefficient
  1362|         0|            0|            0|  0.00%|            * spearman : Spearman rank correlation
  1363|         0|            0|            0|  0.00%|        min_periods : int, optional
  1364|         0|            0|            0|  0.00%|            Minimum number of observations needed to have a valid result
  1365|         0|            0|            0|  0.00%|
  1366|         0|            0|            0|  0.00%|
  1367|         0|            0|            0|  0.00%|        Returns
  1368|         0|            0|            0|  0.00%|        -------
  1369|         0|            0|            0|  0.00%|        correlation : float
  1370|         0|            0|            0|  0.00%|        """
  1371|         0|            0|            0|  0.00%|        this, other = self.align(other, join='inner', copy=False)
  1372|         0|            0|            0|  0.00%|        if len(this) == 0:
  1373|         0|            0|            0|  0.00%|            return np.nan
  1374|         0|            0|            0|  0.00%|        return nanops.nancorr(this.values, other.values, method=method,
  1375|         0|            0|            0|  0.00%|                              min_periods=min_periods)
  1376|         0|            0|            0|  0.00%|
  1377|         0|            0|            0|  0.00%|    def cov(self, other, min_periods=None):
  1378|         0|            0|            0|  0.00%|        """
  1379|         0|            0|            0|  0.00%|        Compute covariance with Series, excluding missing values
  1380|         0|            0|            0|  0.00%|
  1381|         0|            0|            0|  0.00%|        Parameters
  1382|         0|            0|            0|  0.00%|        ----------
  1383|         0|            0|            0|  0.00%|        other : Series
  1384|         0|            0|            0|  0.00%|        min_periods : int, optional
  1385|         0|            0|            0|  0.00%|            Minimum number of observations needed to have a valid result
  1386|         0|            0|            0|  0.00%|
  1387|         0|            0|            0|  0.00%|        Returns
  1388|         0|            0|            0|  0.00%|        -------
  1389|         0|            0|            0|  0.00%|        covariance : float
  1390|         0|            0|            0|  0.00%|
  1391|         0|            0|            0|  0.00%|        Normalized by N-1 (unbiased estimator).
  1392|         0|            0|            0|  0.00%|        """
  1393|         0|            0|            0|  0.00%|        this, other = self.align(other, join='inner', copy=False)
  1394|         0|            0|            0|  0.00%|        if len(this) == 0:
  1395|         0|            0|            0|  0.00%|            return np.nan
  1396|         0|            0|            0|  0.00%|        return nanops.nancov(this.values, other.values,
  1397|         0|            0|            0|  0.00%|                             min_periods=min_periods)
  1398|         0|            0|            0|  0.00%|
  1399|         0|            0|            0|  0.00%|    def diff(self, periods=1):
  1400|         0|            0|            0|  0.00%|        """
  1401|         0|            0|            0|  0.00%|        1st discrete difference of object
  1402|         0|            0|            0|  0.00%|
  1403|         0|            0|            0|  0.00%|        Parameters
  1404|         0|            0|            0|  0.00%|        ----------
  1405|         0|            0|            0|  0.00%|        periods : int, default 1
  1406|         0|            0|            0|  0.00%|            Periods to shift for forming difference
  1407|         0|            0|            0|  0.00%|
  1408|         0|            0|            0|  0.00%|        Returns
  1409|         0|            0|            0|  0.00%|        -------
  1410|         0|            0|            0|  0.00%|        diffed : Series
  1411|         0|            0|            0|  0.00%|        """
  1412|         0|            0|            0|  0.00%|        result = algorithms.diff(_values_from_object(self), periods)
  1413|         0|            0|            0|  0.00%|        return self._constructor(result, index=self.index).__finalize__(self)
  1414|         0|            0|            0|  0.00%|
  1415|         0|            0|            0|  0.00%|    def autocorr(self, lag=1):
  1416|         0|            0|            0|  0.00%|        """
  1417|         0|            0|            0|  0.00%|        Lag-N autocorrelation
  1418|         0|            0|            0|  0.00%|
  1419|         0|            0|            0|  0.00%|        Parameters
  1420|         0|            0|            0|  0.00%|        ----------
  1421|         0|            0|            0|  0.00%|        lag : int, default 1
  1422|         0|            0|            0|  0.00%|            Number of lags to apply before performing autocorrelation.
  1423|         0|            0|            0|  0.00%|
  1424|         0|            0|            0|  0.00%|        Returns
  1425|         0|            0|            0|  0.00%|        -------
  1426|         0|            0|            0|  0.00%|        autocorr : float
  1427|         0|            0|            0|  0.00%|        """
  1428|         0|            0|            0|  0.00%|        return self.corr(self.shift(lag))
  1429|         0|            0|            0|  0.00%|
  1430|         0|            0|            0|  0.00%|    def dot(self, other):
  1431|         0|            0|            0|  0.00%|        """
  1432|         0|            0|            0|  0.00%|        Matrix multiplication with DataFrame or inner-product with Series
  1433|         0|            0|            0|  0.00%|        objects
  1434|         0|            0|            0|  0.00%|
  1435|         0|            0|            0|  0.00%|        Parameters
  1436|         0|            0|            0|  0.00%|        ----------
  1437|         0|            0|            0|  0.00%|        other : Series or DataFrame
  1438|         0|            0|            0|  0.00%|
  1439|         0|            0|            0|  0.00%|        Returns
  1440|         0|            0|            0|  0.00%|        -------
  1441|         0|            0|            0|  0.00%|        dot_product : scalar or Series
  1442|         0|            0|            0|  0.00%|        """
  1443|         0|            0|            0|  0.00%|        from pandas.core.frame import DataFrame
  1444|         0|            0|            0|  0.00%|        if isinstance(other, (Series, DataFrame)):
  1445|         0|            0|            0|  0.00%|            common = self.index.union(other.index)
  1446|         0|            0|            0|  0.00%|            if (len(common) > len(self.index) or
  1447|         0|            0|            0|  0.00%|                    len(common) > len(other.index)):
  1448|         0|            0|            0|  0.00%|                raise ValueError('matrices are not aligned')
  1449|         0|            0|            0|  0.00%|
  1450|         0|            0|            0|  0.00%|            left = self.reindex(index=common, copy=False)
  1451|         0|            0|            0|  0.00%|            right = other.reindex(index=common, copy=False)
  1452|         0|            0|            0|  0.00%|            lvals = left.values
  1453|         0|            0|            0|  0.00%|            rvals = right.values
  1454|         0|            0|            0|  0.00%|        else:
  1455|         0|            0|            0|  0.00%|            left = self
  1456|         0|            0|            0|  0.00%|            lvals = self.values
  1457|         0|            0|            0|  0.00%|            rvals = np.asarray(other)
  1458|         0|            0|            0|  0.00%|            if lvals.shape[0] != rvals.shape[0]:
  1459|         0|            0|            0|  0.00%|                raise Exception('Dot product shape mismatch, %s vs %s' %
  1460|         0|            0|            0|  0.00%|                                (lvals.shape, rvals.shape))
  1461|         0|            0|            0|  0.00%|
  1462|         0|            0|            0|  0.00%|        if isinstance(other, DataFrame):
  1463|         0|            0|            0|  0.00%|            return self._constructor(np.dot(lvals, rvals),
  1464|         0|            0|            0|  0.00%|                                     index=other.columns).__finalize__(self)
  1465|         0|            0|            0|  0.00%|        elif isinstance(other, Series):
  1466|         0|            0|            0|  0.00%|            return np.dot(lvals, rvals)
  1467|         0|            0|            0|  0.00%|        elif isinstance(rvals, np.ndarray):
  1468|         0|            0|            0|  0.00%|            return np.dot(lvals, rvals)
  1469|         0|            0|            0|  0.00%|        else:  # pragma: no cover
  1470|         0|            0|            0|  0.00%|            raise TypeError('unsupported type: %s' % type(other))
  1471|         0|            0|            0|  0.00%|
  1472|         0|            0|            0|  0.00%|    @Substitution(klass='Series')
  1473|         0|            0|            0|  0.00%|    @Appender(base._shared_docs['searchsorted'])
  1474|         0|            0|            0|  0.00%|    @deprecate_kwarg(old_arg_name='v', new_arg_name='value')
  1475|         0|            0|            0|  0.00%|    def searchsorted(self, value, side='left', sorter=None):
  1476|         0|            0|            0|  0.00%|        if sorter is not None:
  1477|         0|            0|            0|  0.00%|            sorter = _ensure_platform_int(sorter)
  1478|         0|            0|            0|  0.00%|        return self._values.searchsorted(Series(value)._values,
  1479|         0|            0|            0|  0.00%|                                         side=side, sorter=sorter)
  1480|         0|            0|            0|  0.00%|
  1481|         0|            0|            0|  0.00%|    # -------------------------------------------------------------------
  1482|         0|            0|            0|  0.00%|    # Combination
  1483|         0|            0|            0|  0.00%|
  1484|         0|            0|            0|  0.00%|    def append(self, to_append, ignore_index=False, verify_integrity=False):
  1485|         0|            0|            0|  0.00%|        """
  1486|         0|            0|            0|  0.00%|        Concatenate two or more Series.
  1487|         0|            0|            0|  0.00%|
  1488|         0|            0|            0|  0.00%|        Parameters
  1489|         0|            0|            0|  0.00%|        ----------
  1490|         0|            0|            0|  0.00%|        to_append : Series or list/tuple of Series
  1491|         0|            0|            0|  0.00%|        ignore_index : boolean, default False
  1492|         0|            0|            0|  0.00%|            If True, do not use the index labels.
  1493|         0|            0|            0|  0.00%|
  1494|         0|            0|            0|  0.00%|            .. versionadded: 0.19.0
  1495|         0|            0|            0|  0.00%|
  1496|         0|            0|            0|  0.00%|        verify_integrity : boolean, default False
  1497|         0|            0|            0|  0.00%|            If True, raise Exception on creating index with duplicates
  1498|         0|            0|            0|  0.00%|
  1499|         0|            0|            0|  0.00%|        Returns
  1500|         0|            0|            0|  0.00%|        -------
  1501|         0|            0|            0|  0.00%|        appended : Series
  1502|         0|            0|            0|  0.00%|
  1503|         0|            0|            0|  0.00%|        Examples
  1504|         0|            0|            0|  0.00%|        --------
  1505|         0|            0|            0|  0.00%|        >>> s1 = pd.Series([1, 2, 3])
  1506|         0|            0|            0|  0.00%|        >>> s2 = pd.Series([4, 5, 6])
  1507|         0|            0|            0|  0.00%|        >>> s3 = pd.Series([4, 5, 6], index=[3,4,5])
  1508|         0|            0|            0|  0.00%|        >>> s1.append(s2)
  1509|         0|            0|            0|  0.00%|        0    1
  1510|         0|            0|            0|  0.00%|        1    2
  1511|         0|            0|            0|  0.00%|        2    3
  1512|         0|            0|            0|  0.00%|        0    4
  1513|         0|            0|            0|  0.00%|        1    5
  1514|         0|            0|            0|  0.00%|        2    6
  1515|         0|            0|            0|  0.00%|        dtype: int64
  1516|         0|            0|            0|  0.00%|
  1517|         0|            0|            0|  0.00%|        >>> s1.append(s3)
  1518|         0|            0|            0|  0.00%|        0    1
  1519|         0|            0|            0|  0.00%|        1    2
  1520|         0|            0|            0|  0.00%|        2    3
  1521|         0|            0|            0|  0.00%|        3    4
  1522|         0|            0|            0|  0.00%|        4    5
  1523|         0|            0|            0|  0.00%|        5    6
  1524|         0|            0|            0|  0.00%|        dtype: int64
  1525|         0|            0|            0|  0.00%|
  1526|         0|            0|            0|  0.00%|        With `ignore_index` set to True:
  1527|         0|            0|            0|  0.00%|
  1528|         0|            0|            0|  0.00%|        >>> s1.append(s2, ignore_index=True)
  1529|         0|            0|            0|  0.00%|        0    1
  1530|         0|            0|            0|  0.00%|        1    2
  1531|         0|            0|            0|  0.00%|        2    3
  1532|         0|            0|            0|  0.00%|        3    4
  1533|         0|            0|            0|  0.00%|        4    5
  1534|         0|            0|            0|  0.00%|        5    6
  1535|         0|            0|            0|  0.00%|        dtype: int64
  1536|         0|            0|            0|  0.00%|
  1537|         0|            0|            0|  0.00%|        With `verify_integrity` set to True:
  1538|         0|            0|            0|  0.00%|
  1539|         0|            0|            0|  0.00%|        >>> s1.append(s2, verify_integrity=True)
  1540|         0|            0|            0|  0.00%|        Traceback (most recent call last):
  1541|         0|            0|            0|  0.00%|        ...
  1542|         0|            0|            0|  0.00%|        ValueError: Indexes have overlapping values: [0, 1, 2]
  1543|         0|            0|            0|  0.00%|
  1544|         0|            0|            0|  0.00%|
  1545|         0|            0|            0|  0.00%|        """
  1546|         0|            0|            0|  0.00%|        from pandas.core.reshape.concat import concat
  1547|         0|            0|            0|  0.00%|
  1548|         0|            0|            0|  0.00%|        if isinstance(to_append, (list, tuple)):
  1549|         0|            0|            0|  0.00%|            to_concat = [self] + to_append
  1550|         0|            0|            0|  0.00%|        else:
  1551|         0|            0|            0|  0.00%|            to_concat = [self, to_append]
  1552|         0|            0|            0|  0.00%|        return concat(to_concat, ignore_index=ignore_index,
  1553|         0|            0|            0|  0.00%|                      verify_integrity=verify_integrity)
  1554|         0|            0|            0|  0.00%|
  1555|         0|            0|            0|  0.00%|    def _binop(self, other, func, level=None, fill_value=None):
  1556|         0|            0|            0|  0.00%|        """
  1557|         0|            0|            0|  0.00%|        Perform generic binary operation with optional fill value
  1558|         0|            0|            0|  0.00%|
  1559|         0|            0|            0|  0.00%|        Parameters
  1560|         0|            0|            0|  0.00%|        ----------
  1561|         0|            0|            0|  0.00%|        other : Series
  1562|         0|            0|            0|  0.00%|        func : binary operator
  1563|         0|            0|            0|  0.00%|        fill_value : float or object
  1564|         0|            0|            0|  0.00%|            Value to substitute for NA/null values. If both Series are NA in a
  1565|         0|            0|            0|  0.00%|            location, the result will be NA regardless of the passed fill value
  1566|         0|            0|            0|  0.00%|        level : int or level name, default None
  1567|         0|            0|            0|  0.00%|            Broadcast across a level, matching Index values on the
  1568|         0|            0|            0|  0.00%|            passed MultiIndex level
  1569|         0|            0|            0|  0.00%|
  1570|         0|            0|            0|  0.00%|        Returns
  1571|         0|            0|            0|  0.00%|        -------
  1572|         0|            0|            0|  0.00%|        combined : Series
  1573|         0|            0|            0|  0.00%|        """
  1574|         0|            0|            0|  0.00%|        if not isinstance(other, Series):
  1575|         0|            0|            0|  0.00%|            raise AssertionError('Other operand must be Series')
  1576|         0|            0|            0|  0.00%|
  1577|         0|            0|            0|  0.00%|        new_index = self.index
  1578|         0|            0|            0|  0.00%|        this = self
  1579|         0|            0|            0|  0.00%|
  1580|         0|            0|            0|  0.00%|        if not self.index.equals(other.index):
  1581|         0|            0|            0|  0.00%|            this, other = self.align(other, level=level, join='outer',
  1582|         0|            0|            0|  0.00%|                                     copy=False)
  1583|         0|            0|            0|  0.00%|            new_index = this.index
  1584|         0|            0|            0|  0.00%|
  1585|         0|            0|            0|  0.00%|        this_vals = this.values
  1586|         0|            0|            0|  0.00%|        other_vals = other.values
  1587|         0|            0|            0|  0.00%|
  1588|         0|            0|            0|  0.00%|        if fill_value is not None:
  1589|         0|            0|            0|  0.00%|            this_mask = isnull(this_vals)
  1590|         0|            0|            0|  0.00%|            other_mask = isnull(other_vals)
  1591|         0|            0|            0|  0.00%|            this_vals = this_vals.copy()
  1592|         0|            0|            0|  0.00%|            other_vals = other_vals.copy()
  1593|         0|            0|            0|  0.00%|
  1594|         0|            0|            0|  0.00%|            # one but not both
  1595|         0|            0|            0|  0.00%|            mask = this_mask ^ other_mask
  1596|         0|            0|            0|  0.00%|            this_vals[this_mask & mask] = fill_value
  1597|         0|            0|            0|  0.00%|            other_vals[other_mask & mask] = fill_value
  1598|         0|            0|            0|  0.00%|
  1599|         0|            0|            0|  0.00%|        with np.errstate(all='ignore'):
  1600|         0|            0|            0|  0.00%|            result = func(this_vals, other_vals)
  1601|         0|            0|            0|  0.00%|        name = _maybe_match_name(self, other)
  1602|         0|            0|            0|  0.00%|        result = self._constructor(result, index=new_index, name=name)
  1603|         0|            0|            0|  0.00%|        result = result.__finalize__(self)
  1604|         0|            0|            0|  0.00%|        if name is None:
  1605|         0|            0|            0|  0.00%|            # When name is None, __finalize__ overwrites current name
  1606|         0|            0|            0|  0.00%|            result.name = None
  1607|         0|            0|            0|  0.00%|        return result
  1608|         0|            0|            0|  0.00%|
  1609|         0|            0|            0|  0.00%|    def combine(self, other, func, fill_value=nan):
  1610|         0|            0|            0|  0.00%|        """
  1611|         0|            0|            0|  0.00%|        Perform elementwise binary operation on two Series using given function
  1612|         0|            0|            0|  0.00%|        with optional fill value when an index is missing from one Series or
  1613|         0|            0|            0|  0.00%|        the other
  1614|         0|            0|            0|  0.00%|
  1615|         0|            0|            0|  0.00%|        Parameters
  1616|         0|            0|            0|  0.00%|        ----------
  1617|         0|            0|            0|  0.00%|        other : Series or scalar value
  1618|         0|            0|            0|  0.00%|        func : function
  1619|         0|            0|            0|  0.00%|        fill_value : scalar value
  1620|         0|            0|            0|  0.00%|
  1621|         0|            0|            0|  0.00%|        Returns
  1622|         0|            0|            0|  0.00%|        -------
  1623|         0|            0|            0|  0.00%|        result : Series
  1624|         0|            0|            0|  0.00%|        """
  1625|         0|            0|            0|  0.00%|        if isinstance(other, Series):
  1626|         0|            0|            0|  0.00%|            new_index = self.index.union(other.index)
  1627|         0|            0|            0|  0.00%|            new_name = _maybe_match_name(self, other)
  1628|         0|            0|            0|  0.00%|            new_values = np.empty(len(new_index), dtype=self.dtype)
  1629|         0|            0|            0|  0.00%|            for i, idx in enumerate(new_index):
  1630|         0|            0|            0|  0.00%|                lv = self.get(idx, fill_value)
  1631|         0|            0|            0|  0.00%|                rv = other.get(idx, fill_value)
  1632|         0|            0|            0|  0.00%|                with np.errstate(all='ignore'):
  1633|         0|            0|            0|  0.00%|                    new_values[i] = func(lv, rv)
  1634|         0|            0|            0|  0.00%|        else:
  1635|         0|            0|            0|  0.00%|            new_index = self.index
  1636|         0|            0|            0|  0.00%|            with np.errstate(all='ignore'):
  1637|         0|            0|            0|  0.00%|                new_values = func(self._values, other)
  1638|         0|            0|            0|  0.00%|            new_name = self.name
  1639|         0|            0|            0|  0.00%|        return self._constructor(new_values, index=new_index, name=new_name)
  1640|         0|            0|            0|  0.00%|
  1641|         0|            0|            0|  0.00%|    def combine_first(self, other):
  1642|         0|            0|            0|  0.00%|        """
  1643|         0|            0|            0|  0.00%|        Combine Series values, choosing the calling Series's values
  1644|         0|            0|            0|  0.00%|        first. Result index will be the union of the two indexes
  1645|         0|            0|            0|  0.00%|
  1646|         0|            0|            0|  0.00%|        Parameters
  1647|         0|            0|            0|  0.00%|        ----------
  1648|         0|            0|            0|  0.00%|        other : Series
  1649|         0|            0|            0|  0.00%|
  1650|         0|            0|            0|  0.00%|        Returns
  1651|         0|            0|            0|  0.00%|        -------
  1652|         0|            0|            0|  0.00%|        y : Series
  1653|         0|            0|            0|  0.00%|        """
  1654|         0|            0|            0|  0.00%|        new_index = self.index.union(other.index)
  1655|         0|            0|            0|  0.00%|        this = self.reindex(new_index, copy=False)
  1656|         0|            0|            0|  0.00%|        other = other.reindex(new_index, copy=False)
  1657|         0|            0|            0|  0.00%|        # TODO: do we need name?
  1658|         0|            0|            0|  0.00%|        name = _maybe_match_name(self, other)  # noqa
  1659|         0|            0|            0|  0.00%|        rs_vals = com._where_compat(isnull(this), other._values, this._values)
  1660|         0|            0|            0|  0.00%|        return self._constructor(rs_vals, index=new_index).__finalize__(self)
  1661|         0|            0|            0|  0.00%|
  1662|         0|            0|            0|  0.00%|    def update(self, other):
  1663|         0|            0|            0|  0.00%|        """
  1664|         0|            0|            0|  0.00%|        Modify Series in place using non-NA values from passed
  1665|         0|            0|            0|  0.00%|        Series. Aligns on index
  1666|         0|            0|            0|  0.00%|
  1667|         0|            0|            0|  0.00%|        Parameters
  1668|         0|            0|            0|  0.00%|        ----------
  1669|         0|            0|            0|  0.00%|        other : Series
  1670|         0|            0|            0|  0.00%|        """
  1671|         0|            0|            0|  0.00%|        other = other.reindex_like(self)
  1672|         0|            0|            0|  0.00%|        mask = notnull(other)
  1673|         0|            0|            0|  0.00%|
  1674|         0|            0|            0|  0.00%|        self._data = self._data.putmask(mask=mask, new=other, inplace=True)
  1675|         0|            0|            0|  0.00%|        self._maybe_update_cacher()
  1676|         0|            0|            0|  0.00%|
  1677|         0|            0|            0|  0.00%|    # ----------------------------------------------------------------------
  1678|         0|            0|            0|  0.00%|    # Reindexing, sorting
  1679|         0|            0|            0|  0.00%|
  1680|         0|            0|            0|  0.00%|    @Appender(generic._shared_docs['sort_values'] % _shared_doc_kwargs)
  1681|         0|            0|            0|  0.00%|    def sort_values(self, axis=0, ascending=True, inplace=False,
  1682|         0|            0|            0|  0.00%|                    kind='quicksort', na_position='last'):
  1683|         0|            0|            0|  0.00%|
  1684|         0|            0|            0|  0.00%|        inplace = validate_bool_kwarg(inplace, 'inplace')
  1685|         0|            0|            0|  0.00%|        axis = self._get_axis_number(axis)
  1686|         0|            0|            0|  0.00%|
  1687|         0|            0|            0|  0.00%|        # GH 5856/5853
  1688|         0|            0|            0|  0.00%|        if inplace and self._is_cached:
  1689|         0|            0|            0|  0.00%|            raise ValueError("This Series is a view of some other array, to "
  1690|         0|            0|            0|  0.00%|                             "sort in-place you must create a copy")
  1691|         0|            0|            0|  0.00%|
  1692|         0|            0|            0|  0.00%|        def _try_kind_sort(arr):
  1693|         0|            0|            0|  0.00%|            # easier to ask forgiveness than permission
  1694|         0|            0|            0|  0.00%|            try:
  1695|         0|            0|            0|  0.00%|                # if kind==mergesort, it can fail for object dtype
  1696|         0|            0|            0|  0.00%|                return arr.argsort(kind=kind)
  1697|         0|            0|            0|  0.00%|            except TypeError:
  1698|         0|            0|            0|  0.00%|                # stable sort not available for object dtype
  1699|         0|            0|            0|  0.00%|                # uses the argsort default quicksort
  1700|         0|            0|            0|  0.00%|                return arr.argsort(kind='quicksort')
  1701|         0|            0|            0|  0.00%|
  1702|         0|            0|            0|  0.00%|        arr = self._values
  1703|         0|            0|            0|  0.00%|        sortedIdx = np.empty(len(self), dtype=np.int32)
  1704|         0|            0|            0|  0.00%|
  1705|         0|            0|            0|  0.00%|        bad = isnull(arr)
  1706|         0|            0|            0|  0.00%|
  1707|         0|            0|            0|  0.00%|        good = ~bad
  1708|         0|            0|            0|  0.00%|        idx = _default_index(len(self))
  1709|         0|            0|            0|  0.00%|
  1710|         0|            0|            0|  0.00%|        argsorted = _try_kind_sort(arr[good])
  1711|         0|            0|            0|  0.00%|
  1712|         0|            0|            0|  0.00%|        if is_list_like(ascending):
  1713|         0|            0|            0|  0.00%|            if len(ascending) != 1:
  1714|         0|            0|            0|  0.00%|                raise ValueError('Length of ascending (%d) must be 1 '
  1715|         0|            0|            0|  0.00%|                                 'for Series' % (len(ascending)))
  1716|         0|            0|            0|  0.00%|            ascending = ascending[0]
  1717|         0|            0|            0|  0.00%|
  1718|         0|            0|            0|  0.00%|        if not is_bool(ascending):
  1719|         0|            0|            0|  0.00%|            raise ValueError('ascending must be boolean')
  1720|         0|            0|            0|  0.00%|
  1721|         0|            0|            0|  0.00%|        if not ascending:
  1722|         0|            0|            0|  0.00%|            argsorted = argsorted[::-1]
  1723|         0|            0|            0|  0.00%|
  1724|         0|            0|            0|  0.00%|        if na_position == 'last':
  1725|         0|            0|            0|  0.00%|            n = good.sum()
  1726|         0|            0|            0|  0.00%|            sortedIdx[:n] = idx[good][argsorted]
  1727|         0|            0|            0|  0.00%|            sortedIdx[n:] = idx[bad]
  1728|         0|            0|            0|  0.00%|        elif na_position == 'first':
  1729|         0|            0|            0|  0.00%|            n = bad.sum()
  1730|         0|            0|            0|  0.00%|            sortedIdx[n:] = idx[good][argsorted]
  1731|         0|            0|            0|  0.00%|            sortedIdx[:n] = idx[bad]
  1732|         0|            0|            0|  0.00%|        else:
  1733|         0|            0|            0|  0.00%|            raise ValueError('invalid na_position: {!r}'.format(na_position))
  1734|         0|            0|            0|  0.00%|
  1735|         0|            0|            0|  0.00%|        result = self._constructor(arr[sortedIdx], index=self.index[sortedIdx])
  1736|         0|            0|            0|  0.00%|
  1737|         0|            0|            0|  0.00%|        if inplace:
  1738|         0|            0|            0|  0.00%|            self._update_inplace(result)
  1739|         0|            0|            0|  0.00%|        else:
  1740|         0|            0|            0|  0.00%|            return result.__finalize__(self)
  1741|         0|            0|            0|  0.00%|
  1742|         0|            0|            0|  0.00%|    @Appender(generic._shared_docs['sort_index'] % _shared_doc_kwargs)
  1743|         0|            0|            0|  0.00%|    def sort_index(self, axis=0, level=None, ascending=True, inplace=False,
  1744|         0|            0|            0|  0.00%|                   kind='quicksort', na_position='last', sort_remaining=True):
  1745|         0|            0|            0|  0.00%|
  1746|         0|            0|            0|  0.00%|        # TODO: this can be combined with DataFrame.sort_index impl as
  1747|         0|            0|            0|  0.00%|        # almost identical
  1748|         0|            0|            0|  0.00%|        inplace = validate_bool_kwarg(inplace, 'inplace')
  1749|         0|            0|            0|  0.00%|        axis = self._get_axis_number(axis)
  1750|         0|            0|            0|  0.00%|        index = self.index
  1751|         0|            0|            0|  0.00%|
  1752|         0|            0|            0|  0.00%|        if level:
  1753|         0|            0|            0|  0.00%|            new_index, indexer = index.sortlevel(level, ascending=ascending,
  1754|         0|            0|            0|  0.00%|                                                 sort_remaining=sort_remaining)
  1755|         0|            0|            0|  0.00%|        elif isinstance(index, MultiIndex):
  1756|         0|            0|            0|  0.00%|            from pandas.core.sorting import lexsort_indexer
  1757|         0|            0|            0|  0.00%|            labels = index._sort_levels_monotonic()
  1758|         0|            0|            0|  0.00%|            indexer = lexsort_indexer(labels._get_labels_for_sorting(),
  1759|         0|            0|            0|  0.00%|                                      orders=ascending,
  1760|         0|            0|            0|  0.00%|                                      na_position=na_position)
  1761|         0|            0|            0|  0.00%|        else:
  1762|         0|            0|            0|  0.00%|            from pandas.core.sorting import nargsort
  1763|         0|            0|            0|  0.00%|
  1764|         0|            0|            0|  0.00%|            # Check monotonic-ness before sort an index
  1765|         0|            0|            0|  0.00%|            # GH11080
  1766|         0|            0|            0|  0.00%|            if ((ascending and index.is_monotonic_increasing) or
  1767|         0|            0|            0|  0.00%|                    (not ascending and index.is_monotonic_decreasing)):
  1768|         0|            0|            0|  0.00%|                if inplace:
  1769|         0|            0|            0|  0.00%|                    return
  1770|         0|            0|            0|  0.00%|                else:
  1771|         0|            0|            0|  0.00%|                    return self.copy()
  1772|         0|            0|            0|  0.00%|
  1773|         0|            0|            0|  0.00%|            indexer = nargsort(index, kind=kind, ascending=ascending,
  1774|         0|            0|            0|  0.00%|                               na_position=na_position)
  1775|         0|            0|            0|  0.00%|
  1776|         0|            0|            0|  0.00%|        indexer = _ensure_platform_int(indexer)
  1777|         0|            0|            0|  0.00%|        new_index = index.take(indexer)
  1778|         0|            0|            0|  0.00%|        new_index = new_index._sort_levels_monotonic()
  1779|         0|            0|            0|  0.00%|
  1780|         0|            0|            0|  0.00%|        new_values = self._values.take(indexer)
  1781|         0|            0|            0|  0.00%|        result = self._constructor(new_values, index=new_index)
  1782|         0|            0|            0|  0.00%|
  1783|         0|            0|            0|  0.00%|        if inplace:
  1784|         0|            0|            0|  0.00%|            self._update_inplace(result)
  1785|         0|            0|            0|  0.00%|        else:
  1786|         0|            0|            0|  0.00%|            return result.__finalize__(self)
  1787|         0|            0|            0|  0.00%|
  1788|         0|            0|            0|  0.00%|    def argsort(self, axis=0, kind='quicksort', order=None):
  1789|         0|            0|            0|  0.00%|        """
  1790|         0|            0|            0|  0.00%|        Overrides ndarray.argsort. Argsorts the value, omitting NA/null values,
  1791|         0|            0|            0|  0.00%|        and places the result in the same locations as the non-NA values
  1792|         0|            0|            0|  0.00%|
  1793|         0|            0|            0|  0.00%|        Parameters
  1794|         0|            0|            0|  0.00%|        ----------
  1795|         0|            0|            0|  0.00%|        axis : int (can only be zero)
  1796|         0|            0|            0|  0.00%|        kind : {'mergesort', 'quicksort', 'heapsort'}, default 'quicksort'
  1797|         0|            0|            0|  0.00%|            Choice of sorting algorithm. See np.sort for more
  1798|         0|            0|            0|  0.00%|            information. 'mergesort' is the only stable algorithm
  1799|         0|            0|            0|  0.00%|        order : ignored
  1800|         0|            0|            0|  0.00%|
  1801|         0|            0|            0|  0.00%|        Returns
  1802|         0|            0|            0|  0.00%|        -------
  1803|         0|            0|            0|  0.00%|        argsorted : Series, with -1 indicated where nan values are present
  1804|         0|            0|            0|  0.00%|
  1805|         0|            0|            0|  0.00%|        See also
  1806|         0|            0|            0|  0.00%|        --------
  1807|         0|            0|            0|  0.00%|        numpy.ndarray.argsort
  1808|         0|            0|            0|  0.00%|        """
  1809|         0|            0|            0|  0.00%|        values = self._values
  1810|         0|            0|            0|  0.00%|        mask = isnull(values)
  1811|         0|            0|            0|  0.00%|
  1812|         0|            0|            0|  0.00%|        if mask.any():
  1813|         0|            0|            0|  0.00%|            result = Series(-1, index=self.index, name=self.name,
  1814|         0|            0|            0|  0.00%|                            dtype='int64')
  1815|         0|            0|            0|  0.00%|            notmask = ~mask
  1816|         0|            0|            0|  0.00%|            result[notmask] = np.argsort(values[notmask], kind=kind)
  1817|         0|            0|            0|  0.00%|            return self._constructor(result,
  1818|         0|            0|            0|  0.00%|                                     index=self.index).__finalize__(self)
  1819|         0|            0|            0|  0.00%|        else:
  1820|         0|            0|            0|  0.00%|            return self._constructor(
  1821|         0|            0|            0|  0.00%|                np.argsort(values, kind=kind), index=self.index,
  1822|         0|            0|            0|  0.00%|                dtype='int64').__finalize__(self)
  1823|         0|            0|            0|  0.00%|
  1824|         0|            0|            0|  0.00%|    def nlargest(self, n=5, keep='first'):
  1825|         0|            0|            0|  0.00%|        """Return the largest `n` elements.
  1826|         0|            0|            0|  0.00%|
  1827|         0|            0|            0|  0.00%|        Parameters
  1828|         0|            0|            0|  0.00%|        ----------
  1829|         0|            0|            0|  0.00%|        n : int
  1830|         0|            0|            0|  0.00%|            Return this many descending sorted values
  1831|         0|            0|            0|  0.00%|        keep : {'first', 'last', False}, default 'first'
  1832|         0|            0|            0|  0.00%|            Where there are duplicate values:
  1833|         0|            0|            0|  0.00%|            - ``first`` : take the first occurrence.
  1834|         0|            0|            0|  0.00%|            - ``last`` : take the last occurrence.
  1835|         0|            0|            0|  0.00%|
  1836|         0|            0|            0|  0.00%|        Returns
  1837|         0|            0|            0|  0.00%|        -------
  1838|         0|            0|            0|  0.00%|        top_n : Series
  1839|         0|            0|            0|  0.00%|            The n largest values in the Series, in sorted order
  1840|         0|            0|            0|  0.00%|
  1841|         0|            0|            0|  0.00%|        Notes
  1842|         0|            0|            0|  0.00%|        -----
  1843|         0|            0|            0|  0.00%|        Faster than ``.sort_values(ascending=False).head(n)`` for small `n`
  1844|         0|            0|            0|  0.00%|        relative to the size of the ``Series`` object.
  1845|         0|            0|            0|  0.00%|
  1846|         0|            0|            0|  0.00%|        See Also
  1847|         0|            0|            0|  0.00%|        --------
  1848|         0|            0|            0|  0.00%|        Series.nsmallest
  1849|         0|            0|            0|  0.00%|
  1850|         0|            0|            0|  0.00%|        Examples
  1851|         0|            0|            0|  0.00%|        --------
  1852|         0|            0|            0|  0.00%|        >>> import pandas as pd
  1853|         0|            0|            0|  0.00%|        >>> import numpy as np
  1854|         0|            0|            0|  0.00%|        >>> s = pd.Series(np.random.randn(10**6))
  1855|         0|            0|            0|  0.00%|        >>> s.nlargest(10)  # only sorts up to the N requested
  1856|         0|            0|            0|  0.00%|        219921    4.644710
  1857|         0|            0|            0|  0.00%|        82124     4.608745
  1858|         0|            0|            0|  0.00%|        421689    4.564644
  1859|         0|            0|            0|  0.00%|        425277    4.447014
  1860|         0|            0|            0|  0.00%|        718691    4.414137
  1861|         0|            0|            0|  0.00%|        43154     4.403520
  1862|         0|            0|            0|  0.00%|        283187    4.313922
  1863|         0|            0|            0|  0.00%|        595519    4.273635
  1864|         0|            0|            0|  0.00%|        503969    4.250236
  1865|         0|            0|            0|  0.00%|        121637    4.240952
  1866|         0|            0|            0|  0.00%|        dtype: float64
  1867|         0|            0|            0|  0.00%|        """
  1868|         0|            0|            0|  0.00%|        return algorithms.SelectNSeries(self, n=n, keep=keep).nlargest()
  1869|         0|            0|            0|  0.00%|
  1870|         0|            0|            0|  0.00%|    def nsmallest(self, n=5, keep='first'):
  1871|         0|            0|            0|  0.00%|        """Return the smallest `n` elements.
  1872|         0|            0|            0|  0.00%|
  1873|         0|            0|            0|  0.00%|        Parameters
  1874|         0|            0|            0|  0.00%|        ----------
  1875|         0|            0|            0|  0.00%|        n : int
  1876|         0|            0|            0|  0.00%|            Return this many ascending sorted values
  1877|         0|            0|            0|  0.00%|        keep : {'first', 'last', False}, default 'first'
  1878|         0|            0|            0|  0.00%|            Where there are duplicate values:
  1879|         0|            0|            0|  0.00%|            - ``first`` : take the first occurrence.
  1880|         0|            0|            0|  0.00%|            - ``last`` : take the last occurrence.
  1881|         0|            0|            0|  0.00%|
  1882|         0|            0|            0|  0.00%|        Returns
  1883|         0|            0|            0|  0.00%|        -------
  1884|         0|            0|            0|  0.00%|        bottom_n : Series
  1885|         0|            0|            0|  0.00%|            The n smallest values in the Series, in sorted order
  1886|         0|            0|            0|  0.00%|
  1887|         0|            0|            0|  0.00%|        Notes
  1888|         0|            0|            0|  0.00%|        -----
  1889|         0|            0|            0|  0.00%|        Faster than ``.sort_values().head(n)`` for small `n` relative to
  1890|         0|            0|            0|  0.00%|        the size of the ``Series`` object.
  1891|         0|            0|            0|  0.00%|
  1892|         0|            0|            0|  0.00%|        See Also
  1893|         0|            0|            0|  0.00%|        --------
  1894|         0|            0|            0|  0.00%|        Series.nlargest
  1895|         0|            0|            0|  0.00%|
  1896|         0|            0|            0|  0.00%|        Examples
  1897|         0|            0|            0|  0.00%|        --------
  1898|         0|            0|            0|  0.00%|        >>> import pandas as pd
  1899|         0|            0|            0|  0.00%|        >>> import numpy as np
  1900|         0|            0|            0|  0.00%|        >>> s = pd.Series(np.random.randn(10**6))
  1901|         0|            0|            0|  0.00%|        >>> s.nsmallest(10)  # only sorts up to the N requested
  1902|         0|            0|            0|  0.00%|        288532   -4.954580
  1903|         0|            0|            0|  0.00%|        732345   -4.835960
  1904|         0|            0|            0|  0.00%|        64803    -4.812550
  1905|         0|            0|            0|  0.00%|        446457   -4.609998
  1906|         0|            0|            0|  0.00%|        501225   -4.483945
  1907|         0|            0|            0|  0.00%|        669476   -4.472935
  1908|         0|            0|            0|  0.00%|        973615   -4.401699
  1909|         0|            0|            0|  0.00%|        621279   -4.355126
  1910|         0|            0|            0|  0.00%|        773916   -4.347355
  1911|         0|            0|            0|  0.00%|        359919   -4.331927
  1912|         0|            0|            0|  0.00%|        dtype: float64
  1913|         0|            0|            0|  0.00%|        """
  1914|         0|            0|            0|  0.00%|        return algorithms.SelectNSeries(self, n=n, keep=keep).nsmallest()
  1915|         0|            0|            0|  0.00%|
  1916|         0|            0|            0|  0.00%|    def sortlevel(self, level=0, ascending=True, sort_remaining=True):
  1917|         0|            0|            0|  0.00%|        """
  1918|         0|            0|            0|  0.00%|        DEPRECATED: use :meth:`Series.sort_index`
  1919|         0|            0|            0|  0.00%|
  1920|         0|            0|            0|  0.00%|        Sort Series with MultiIndex by chosen level. Data will be
  1921|         0|            0|            0|  0.00%|        lexicographically sorted by the chosen level followed by the other
  1922|         0|            0|            0|  0.00%|        levels (in order)
  1923|         0|            0|            0|  0.00%|
  1924|         0|            0|            0|  0.00%|        Parameters
  1925|         0|            0|            0|  0.00%|        ----------
  1926|         0|            0|            0|  0.00%|        level : int or level name, default None
  1927|         0|            0|            0|  0.00%|        ascending : bool, default True
  1928|         0|            0|            0|  0.00%|
  1929|         0|            0|            0|  0.00%|        Returns
  1930|         0|            0|            0|  0.00%|        -------
  1931|         0|            0|            0|  0.00%|        sorted : Series
  1932|         0|            0|            0|  0.00%|
  1933|         0|            0|            0|  0.00%|        See Also
  1934|         0|            0|            0|  0.00%|        --------
  1935|         0|            0|            0|  0.00%|        Series.sort_index(level=...)
  1936|         0|            0|            0|  0.00%|
  1937|         0|            0|            0|  0.00%|        """
  1938|         0|            0|            0|  0.00%|        warnings.warn("sortlevel is deprecated, use sort_index(level=...)",
  1939|         0|            0|            0|  0.00%|                      FutureWarning, stacklevel=2)
  1940|         0|            0|            0|  0.00%|        return self.sort_index(level=level, ascending=ascending,
  1941|         0|            0|            0|  0.00%|                               sort_remaining=sort_remaining)
  1942|         0|            0|            0|  0.00%|
  1943|         0|            0|            0|  0.00%|    def swaplevel(self, i=-2, j=-1, copy=True):
  1944|         0|            0|            0|  0.00%|        """
  1945|         0|            0|            0|  0.00%|        Swap levels i and j in a MultiIndex
  1946|         0|            0|            0|  0.00%|
  1947|         0|            0|            0|  0.00%|        Parameters
  1948|         0|            0|            0|  0.00%|        ----------
  1949|         0|            0|            0|  0.00%|        i, j : int, string (can be mixed)
  1950|         0|            0|            0|  0.00%|            Level of index to be swapped. Can pass level name as string.
  1951|         0|            0|            0|  0.00%|
  1952|         0|            0|            0|  0.00%|        Returns
  1953|         0|            0|            0|  0.00%|        -------
  1954|         0|            0|            0|  0.00%|        swapped : Series
  1955|         0|            0|            0|  0.00%|
  1956|         0|            0|            0|  0.00%|        .. versionchanged:: 0.18.1
  1957|         0|            0|            0|  0.00%|
  1958|         0|            0|            0|  0.00%|           The indexes ``i`` and ``j`` are now optional, and default to
  1959|         0|            0|            0|  0.00%|           the two innermost levels of the index.
  1960|         0|            0|            0|  0.00%|
  1961|         0|            0|            0|  0.00%|        """
  1962|         0|            0|            0|  0.00%|        new_index = self.index.swaplevel(i, j)
  1963|         0|            0|            0|  0.00%|        return self._constructor(self._values, index=new_index,
  1964|         0|            0|            0|  0.00%|                                 copy=copy).__finalize__(self)
  1965|         0|            0|            0|  0.00%|
  1966|         0|            0|            0|  0.00%|    def reorder_levels(self, order):
  1967|         0|            0|            0|  0.00%|        """
  1968|         0|            0|            0|  0.00%|        Rearrange index levels using input order. May not drop or duplicate
  1969|         0|            0|            0|  0.00%|        levels
  1970|         0|            0|            0|  0.00%|
  1971|         0|            0|            0|  0.00%|        Parameters
  1972|         0|            0|            0|  0.00%|        ----------
  1973|         0|            0|            0|  0.00%|        order : list of int representing new level order.
  1974|         0|            0|            0|  0.00%|               (reference level by number or key)
  1975|         0|            0|            0|  0.00%|        axis : where to reorder levels
  1976|         0|            0|            0|  0.00%|
  1977|         0|            0|            0|  0.00%|        Returns
  1978|         0|            0|            0|  0.00%|        -------
  1979|         0|            0|            0|  0.00%|        type of caller (new object)
  1980|         0|            0|            0|  0.00%|        """
  1981|         0|            0|            0|  0.00%|        if not isinstance(self.index, MultiIndex):  # pragma: no cover
  1982|         0|            0|            0|  0.00%|            raise Exception('Can only reorder levels on a hierarchical axis.')
  1983|         0|            0|            0|  0.00%|
  1984|         0|            0|            0|  0.00%|        result = self.copy()
  1985|         0|            0|            0|  0.00%|        result.index = result.index.reorder_levels(order)
  1986|         0|            0|            0|  0.00%|        return result
  1987|         0|            0|            0|  0.00%|
  1988|         0|            0|            0|  0.00%|    def unstack(self, level=-1, fill_value=None):
  1989|         0|            0|            0|  0.00%|        """
  1990|         0|            0|            0|  0.00%|        Unstack, a.k.a. pivot, Series with MultiIndex to produce DataFrame.
  1991|         0|            0|            0|  0.00%|        The level involved will automatically get sorted.
  1992|         0|            0|            0|  0.00%|
  1993|         0|            0|            0|  0.00%|        Parameters
  1994|         0|            0|            0|  0.00%|        ----------
  1995|         0|            0|            0|  0.00%|        level : int, string, or list of these, default last level
  1996|         0|            0|            0|  0.00%|            Level(s) to unstack, can pass level name
  1997|         0|            0|            0|  0.00%|        fill_value : replace NaN with this value if the unstack produces
  1998|         0|            0|            0|  0.00%|            missing values
  1999|         0|            0|            0|  0.00%|
  2000|         0|            0|            0|  0.00%|            .. versionadded: 0.18.0
  2001|         0|            0|            0|  0.00%|
  2002|         0|            0|            0|  0.00%|        Examples
  2003|         0|            0|            0|  0.00%|        --------
  2004|         0|            0|            0|  0.00%|        >>> s = pd.Series([1, 2, 3, 4],
  2005|         0|            0|            0|  0.00%|        ...     index=pd.MultiIndex.from_product([['one', 'two'], ['a', 'b']]))
  2006|         0|            0|            0|  0.00%|        >>> s
  2007|         0|            0|            0|  0.00%|        one  a    1
  2008|         0|            0|            0|  0.00%|             b    2
  2009|         0|            0|            0|  0.00%|        two  a    3
  2010|         0|            0|            0|  0.00%|             b    4
  2011|         0|            0|            0|  0.00%|        dtype: int64
  2012|         0|            0|            0|  0.00%|
  2013|         0|            0|            0|  0.00%|        >>> s.unstack(level=-1)
  2014|         0|            0|            0|  0.00%|             a  b
  2015|         0|            0|            0|  0.00%|        one  1  2
  2016|         0|            0|            0|  0.00%|        two  3  4
  2017|         0|            0|            0|  0.00%|
  2018|         0|            0|            0|  0.00%|        >>> s.unstack(level=0)
  2019|         0|            0|            0|  0.00%|           one  two
  2020|         0|            0|            0|  0.00%|        a    1    3
  2021|         0|            0|            0|  0.00%|        b    2    4
  2022|         0|            0|            0|  0.00%|
  2023|         0|            0|            0|  0.00%|        Returns
  2024|         0|            0|            0|  0.00%|        -------
  2025|         0|            0|            0|  0.00%|        unstacked : DataFrame
  2026|         0|            0|            0|  0.00%|        """
  2027|         0|            0|            0|  0.00%|        from pandas.core.reshape.reshape import unstack
  2028|         0|            0|            0|  0.00%|        return unstack(self, level, fill_value)
  2029|         0|            0|            0|  0.00%|
  2030|         0|            0|            0|  0.00%|    # ----------------------------------------------------------------------
  2031|         0|            0|            0|  0.00%|    # function application
  2032|         0|            0|            0|  0.00%|
  2033|         0|            0|            0|  0.00%|    def map(self, arg, na_action=None):
  2034|         0|            0|            0|  0.00%|        """
  2035|         0|            0|            0|  0.00%|        Map values of Series using input correspondence (which can be
  2036|         0|            0|            0|  0.00%|        a dict, Series, or function)
  2037|         0|            0|            0|  0.00%|
  2038|         0|            0|            0|  0.00%|        Parameters
  2039|         0|            0|            0|  0.00%|        ----------
  2040|         0|            0|            0|  0.00%|        arg : function, dict, or Series
  2041|         0|            0|            0|  0.00%|        na_action : {None, 'ignore'}
  2042|         0|            0|            0|  0.00%|            If 'ignore', propagate NA values, without passing them to the
  2043|         0|            0|            0|  0.00%|            mapping function
  2044|         0|            0|            0|  0.00%|
  2045|         0|            0|            0|  0.00%|        Returns
  2046|         0|            0|            0|  0.00%|        -------
  2047|         0|            0|            0|  0.00%|        y : Series
  2048|         0|            0|            0|  0.00%|            same index as caller
  2049|         0|            0|            0|  0.00%|
  2050|         0|            0|            0|  0.00%|        Examples
  2051|         0|            0|            0|  0.00%|        --------
  2052|         0|            0|            0|  0.00%|
  2053|         0|            0|            0|  0.00%|        Map inputs to outputs (both of type `Series`)
  2054|         0|            0|            0|  0.00%|
  2055|         0|            0|            0|  0.00%|        >>> x = pd.Series([1,2,3], index=['one', 'two', 'three'])
  2056|         0|            0|            0|  0.00%|        >>> x
  2057|         0|            0|            0|  0.00%|        one      1
  2058|         0|            0|            0|  0.00%|        two      2
  2059|         0|            0|            0|  0.00%|        three    3
  2060|         0|            0|            0|  0.00%|        dtype: int64
  2061|         0|            0|            0|  0.00%|
  2062|         0|            0|            0|  0.00%|        >>> y = pd.Series(['foo', 'bar', 'baz'], index=[1,2,3])
  2063|         0|            0|            0|  0.00%|        >>> y
  2064|         0|            0|            0|  0.00%|        1    foo
  2065|         0|            0|            0|  0.00%|        2    bar
  2066|         0|            0|            0|  0.00%|        3    baz
  2067|         0|            0|            0|  0.00%|
  2068|         0|            0|            0|  0.00%|        >>> x.map(y)
  2069|         0|            0|            0|  0.00%|        one   foo
  2070|         0|            0|            0|  0.00%|        two   bar
  2071|         0|            0|            0|  0.00%|        three baz
  2072|         0|            0|            0|  0.00%|
  2073|         0|            0|            0|  0.00%|        If `arg` is a dictionary, return a new Series with values converted
  2074|         0|            0|            0|  0.00%|        according to the dictionary's mapping:
  2075|         0|            0|            0|  0.00%|
  2076|         0|            0|            0|  0.00%|        >>> z = {1: 'A', 2: 'B', 3: 'C'}
  2077|         0|            0|            0|  0.00%|
  2078|         0|            0|            0|  0.00%|        >>> x.map(z)
  2079|         0|            0|            0|  0.00%|        one   A
  2080|         0|            0|            0|  0.00%|        two   B
  2081|         0|            0|            0|  0.00%|        three C
  2082|         0|            0|            0|  0.00%|
  2083|         0|            0|            0|  0.00%|        Use na_action to control whether NA values are affected by the mapping
  2084|         0|            0|            0|  0.00%|        function.
  2085|         0|            0|            0|  0.00%|
  2086|         0|            0|            0|  0.00%|        >>> s = pd.Series([1, 2, 3, np.nan])
  2087|         0|            0|            0|  0.00%|
  2088|         0|            0|            0|  0.00%|        >>> s2 = s.map('this is a string {}'.format, na_action=None)
  2089|         0|            0|            0|  0.00%|        0    this is a string 1.0
  2090|         0|            0|            0|  0.00%|        1    this is a string 2.0
  2091|         0|            0|            0|  0.00%|        2    this is a string 3.0
  2092|         0|            0|            0|  0.00%|        3    this is a string nan
  2093|         0|            0|            0|  0.00%|        dtype: object
  2094|         0|            0|            0|  0.00%|
  2095|         0|            0|            0|  0.00%|        >>> s3 = s.map('this is a string {}'.format, na_action='ignore')
  2096|         0|            0|            0|  0.00%|        0    this is a string 1.0
  2097|         0|            0|            0|  0.00%|        1    this is a string 2.0
  2098|         0|            0|            0|  0.00%|        2    this is a string 3.0
  2099|         0|            0|            0|  0.00%|        3                     NaN
  2100|         0|            0|            0|  0.00%|        dtype: object
  2101|         0|            0|            0|  0.00%|
  2102|         0|            0|            0|  0.00%|        See Also
  2103|         0|            0|            0|  0.00%|        --------
  2104|         0|            0|            0|  0.00%|        Series.apply: For applying more complex functions on a Series
  2105|         0|            0|            0|  0.00%|        DataFrame.apply: Apply a function row-/column-wise
  2106|         0|            0|            0|  0.00%|        DataFrame.applymap: Apply a function elementwise on a whole DataFrame
  2107|         0|            0|            0|  0.00%|
  2108|         0|            0|            0|  0.00%|        Notes
  2109|         0|            0|            0|  0.00%|        -----
  2110|         0|            0|            0|  0.00%|        When `arg` is a dictionary, values in Series that are not in the
  2111|         0|            0|            0|  0.00%|        dictionary (as keys) are converted to ``NaN``. However, if the
  2112|         0|            0|            0|  0.00%|        dictionary is a ``dict`` subclass that defines ``__missing__`` (i.e.
  2113|         0|            0|            0|  0.00%|        provides a method for default values), then this default is used
  2114|         0|            0|            0|  0.00%|        rather than ``NaN``:
  2115|         0|            0|            0|  0.00%|
  2116|         0|            0|            0|  0.00%|        >>> from collections import Counter
  2117|         0|            0|            0|  0.00%|        >>> counter = Counter()
  2118|         0|            0|            0|  0.00%|        >>> counter['bar'] += 1
  2119|         0|            0|            0|  0.00%|        >>> y.map(counter)
  2120|         0|            0|            0|  0.00%|        1    0
  2121|         0|            0|            0|  0.00%|        2    1
  2122|         0|            0|            0|  0.00%|        3    0
  2123|         0|            0|            0|  0.00%|        dtype: int64
  2124|         0|            0|            0|  0.00%|        """
  2125|         0|            0|            0|  0.00%|
  2126|         0|            0|            0|  0.00%|        if is_extension_type(self.dtype):
  2127|         0|            0|            0|  0.00%|            values = self._values
  2128|         0|            0|            0|  0.00%|            if na_action is not None:
  2129|         0|            0|            0|  0.00%|                raise NotImplementedError
  2130|         0|            0|            0|  0.00%|            map_f = lambda values, f: values.map(f)
  2131|         0|            0|            0|  0.00%|        else:
  2132|         0|            0|            0|  0.00%|            values = self.asobject
  2133|         0|            0|            0|  0.00%|
  2134|         0|            0|            0|  0.00%|            if na_action == 'ignore':
  2135|         0|            0|            0|  0.00%|                def map_f(values, f):
  2136|         0|            0|            0|  0.00%|                    return lib.map_infer_mask(values, f,
  2137|         0|            0|            0|  0.00%|                                              isnull(values).view(np.uint8))
  2138|         0|            0|            0|  0.00%|            else:
  2139|         0|            0|            0|  0.00%|                map_f = lib.map_infer
  2140|         0|            0|            0|  0.00%|
  2141|         0|            0|            0|  0.00%|        if isinstance(arg, dict):
  2142|         0|            0|            0|  0.00%|            if hasattr(arg, '__missing__'):
  2143|         0|            0|            0|  0.00%|                # If a dictionary subclass defines a default value method,
  2144|         0|            0|            0|  0.00%|                # convert arg to a lookup function (GH #15999).
  2145|         0|            0|            0|  0.00%|                dict_with_default = arg
  2146|         0|            0|            0|  0.00%|                arg = lambda x: dict_with_default[x]
  2147|         0|            0|            0|  0.00%|            else:
  2148|         0|            0|            0|  0.00%|                # Dictionary does not have a default. Thus it's safe to
  2149|         0|            0|            0|  0.00%|                # convert to an indexed series for efficiency.
  2150|         0|            0|            0|  0.00%|                arg = self._constructor(arg, index=arg.keys())
  2151|         0|            0|            0|  0.00%|
  2152|         0|            0|            0|  0.00%|        if isinstance(arg, Series):
  2153|         0|            0|            0|  0.00%|            # arg is a Series
  2154|         0|            0|            0|  0.00%|            indexer = arg.index.get_indexer(values)
  2155|         0|            0|            0|  0.00%|            new_values = algorithms.take_1d(arg._values, indexer)
  2156|         0|            0|            0|  0.00%|        else:
  2157|         0|            0|            0|  0.00%|            # arg is a function
  2158|         0|            0|            0|  0.00%|            new_values = map_f(values, arg)
  2159|         0|            0|            0|  0.00%|
  2160|         0|            0|            0|  0.00%|        return self._constructor(new_values,
  2161|         0|            0|            0|  0.00%|                                 index=self.index).__finalize__(self)
  2162|         0|            0|            0|  0.00%|
  2163|         0|            0|            0|  0.00%|    def _gotitem(self, key, ndim, subset=None):
  2164|         0|            0|            0|  0.00%|        """
  2165|         0|            0|            0|  0.00%|        sub-classes to define
  2166|         0|            0|            0|  0.00%|        return a sliced object
  2167|         0|            0|            0|  0.00%|
  2168|         0|            0|            0|  0.00%|        Parameters
  2169|         0|            0|            0|  0.00%|        ----------
  2170|         0|            0|            0|  0.00%|        key : string / list of selections
  2171|         0|            0|            0|  0.00%|        ndim : 1,2
  2172|         0|            0|            0|  0.00%|            requested ndim of result
  2173|         0|            0|            0|  0.00%|        subset : object, default None
  2174|         0|            0|            0|  0.00%|            subset to act on
  2175|         0|            0|            0|  0.00%|        """
  2176|         0|            0|            0|  0.00%|        return self
  2177|         0|            0|            0|  0.00%|
  2178|         0|            0|            0|  0.00%|    _agg_doc = dedent("""
  2179|         0|            0|            0|  0.00%|    Examples
  2180|         0|            0|            0|  0.00%|    --------
  2181|         0|            0|            0|  0.00%|
  2182|         0|            0|            0|  0.00%|    >>> s = Series(np.random.randn(10))
  2183|         0|            0|            0|  0.00%|
  2184|         0|            0|            0|  0.00%|    >>> s.agg('min')
  2185|         0|            0|            0|  0.00%|    -1.3018049988556679
  2186|         0|            0|            0|  0.00%|
  2187|         0|            0|            0|  0.00%|    >>> s.agg(['min', 'max'])
  2188|         0|            0|            0|  0.00%|    min   -1.301805
  2189|         0|            0|            0|  0.00%|    max    1.127688
  2190|         0|            0|            0|  0.00%|    dtype: float64
  2191|         0|            0|            0|  0.00%|
  2192|         0|            0|            0|  0.00%|    See also
  2193|         0|            0|            0|  0.00%|    --------
  2194|         0|            0|            0|  0.00%|    pandas.Series.apply
  2195|         0|            0|            0|  0.00%|    pandas.Series.transform
  2196|         0|            0|            0|  0.00%|
  2197|         0|            0|            0|  0.00%|    """)
  2198|         0|            0|            0|  0.00%|
  2199|         0|            0|            0|  0.00%|    @Appender(_agg_doc)
  2200|         0|            0|            0|  0.00%|    @Appender(generic._shared_docs['aggregate'] % dict(
  2201|         0|            0|            0|  0.00%|        versionadded='.. versionadded:: 0.20.0',
  2202|         0|            0|            0|  0.00%|        **_shared_doc_kwargs))
  2203|         0|            0|            0|  0.00%|    def aggregate(self, func, axis=0, *args, **kwargs):
  2204|         0|            0|            0|  0.00%|        axis = self._get_axis_number(axis)
  2205|         0|            0|            0|  0.00%|        result, how = self._aggregate(func, *args, **kwargs)
  2206|         0|            0|            0|  0.00%|        if result is None:
  2207|         0|            0|            0|  0.00%|
  2208|         0|            0|            0|  0.00%|            # we can be called from an inner function which
  2209|         0|            0|            0|  0.00%|            # passes this meta-data
  2210|         0|            0|            0|  0.00%|            kwargs.pop('_axis', None)
  2211|         0|            0|            0|  0.00%|            kwargs.pop('_level', None)
  2212|         0|            0|            0|  0.00%|
  2213|         0|            0|            0|  0.00%|            # try a regular apply, this evaluates lambdas
  2214|         0|            0|            0|  0.00%|            # row-by-row; however if the lambda is expected a Series
  2215|         0|            0|            0|  0.00%|            # expression, e.g.: lambda x: x-x.quantile(0.25)
  2216|         0|            0|            0|  0.00%|            # this will fail, so we can try a vectorized evaluation
  2217|         0|            0|            0|  0.00%|
  2218|         0|            0|            0|  0.00%|            # we cannot FIRST try the vectorized evaluation, becuase
  2219|         0|            0|            0|  0.00%|            # then .agg and .apply would have different semantics if the
  2220|         0|            0|            0|  0.00%|            # operation is actually defined on the Series, e.g. str
  2221|         0|            0|            0|  0.00%|            try:
  2222|         0|            0|            0|  0.00%|                result = self.apply(func, *args, **kwargs)
  2223|         0|            0|            0|  0.00%|            except (ValueError, AttributeError, TypeError):
  2224|         0|            0|            0|  0.00%|                result = func(self, *args, **kwargs)
  2225|         0|            0|            0|  0.00%|
  2226|         0|            0|            0|  0.00%|        return result
  2227|         0|            0|            0|  0.00%|
  2228|         0|            0|            0|  0.00%|    agg = aggregate
  2229|         0|            0|            0|  0.00%|
  2230|         0|            0|            0|  0.00%|    def apply(self, func, convert_dtype=True, args=(), **kwds):
  2231|         0|            0|            0|  0.00%|        """
  2232|         0|            0|            0|  0.00%|        Invoke function on values of Series. Can be ufunc (a NumPy function
  2233|         0|            0|            0|  0.00%|        that applies to the entire Series) or a Python function that only works
  2234|         0|            0|            0|  0.00%|        on single values
  2235|         0|            0|            0|  0.00%|
  2236|         0|            0|            0|  0.00%|        Parameters
  2237|         0|            0|            0|  0.00%|        ----------
  2238|         0|            0|            0|  0.00%|        func : function
  2239|         0|            0|            0|  0.00%|        convert_dtype : boolean, default True
  2240|         0|            0|            0|  0.00%|            Try to find better dtype for elementwise function results. If
  2241|         0|            0|            0|  0.00%|            False, leave as dtype=object
  2242|         0|            0|            0|  0.00%|        args : tuple
  2243|         0|            0|            0|  0.00%|            Positional arguments to pass to function in addition to the value
  2244|         0|            0|            0|  0.00%|        Additional keyword arguments will be passed as keywords to the function
  2245|         0|            0|            0|  0.00%|
  2246|         0|            0|            0|  0.00%|        Returns
  2247|         0|            0|            0|  0.00%|        -------
  2248|         0|            0|            0|  0.00%|        y : Series or DataFrame if func returns a Series
  2249|         0|            0|            0|  0.00%|
  2250|         0|            0|            0|  0.00%|        See also
  2251|         0|            0|            0|  0.00%|        --------
  2252|         0|            0|            0|  0.00%|        Series.map: For element-wise operations
  2253|         0|            0|            0|  0.00%|        Series.agg: only perform aggregating type operations
  2254|         0|            0|            0|  0.00%|        Series.transform: only perform transformating type operations
  2255|         0|            0|            0|  0.00%|
  2256|         0|            0|            0|  0.00%|        Examples
  2257|         0|            0|            0|  0.00%|        --------
  2258|         0|            0|            0|  0.00%|
  2259|         0|            0|            0|  0.00%|        Create a series with typical summer temperatures for each city.
  2260|         0|            0|            0|  0.00%|
  2261|         0|            0|            0|  0.00%|        >>> import pandas as pd
  2262|         0|            0|            0|  0.00%|        >>> import numpy as np
  2263|         0|            0|            0|  0.00%|        >>> series = pd.Series([20, 21, 12], index=['London',
  2264|         0|            0|            0|  0.00%|        ... 'New York','Helsinki'])
  2265|         0|            0|            0|  0.00%|        >>> series
  2266|         0|            0|            0|  0.00%|        London      20
  2267|         0|            0|            0|  0.00%|        New York    21
  2268|         0|            0|            0|  0.00%|        Helsinki    12
  2269|         0|            0|            0|  0.00%|        dtype: int64
  2270|         0|            0|            0|  0.00%|
  2271|         0|            0|            0|  0.00%|        Square the values by defining a function and passing it as an
  2272|         0|            0|            0|  0.00%|        argument to ``apply()``.
  2273|         0|            0|            0|  0.00%|
  2274|         0|            0|            0|  0.00%|        >>> def square(x):
  2275|         0|            0|            0|  0.00%|        ...     return x**2
  2276|         0|            0|            0|  0.00%|        >>> series.apply(square)
  2277|         0|            0|            0|  0.00%|        London      400
  2278|         0|            0|            0|  0.00%|        New York    441
  2279|         0|            0|            0|  0.00%|        Helsinki    144
  2280|         0|            0|            0|  0.00%|        dtype: int64
  2281|         0|            0|            0|  0.00%|
  2282|         0|            0|            0|  0.00%|        Square the values by passing an anonymous function as an
  2283|         0|            0|            0|  0.00%|        argument to ``apply()``.
  2284|         0|            0|            0|  0.00%|
  2285|         0|            0|            0|  0.00%|        >>> series.apply(lambda x: x**2)
  2286|         0|            0|            0|  0.00%|        London      400
  2287|         0|            0|            0|  0.00%|        New York    441
  2288|         0|            0|            0|  0.00%|        Helsinki    144
  2289|         0|            0|            0|  0.00%|        dtype: int64
  2290|         0|            0|            0|  0.00%|
  2291|         0|            0|            0|  0.00%|        Define a custom function that needs additional positional
  2292|         0|            0|            0|  0.00%|        arguments and pass these additional arguments using the
  2293|         0|            0|            0|  0.00%|        ``args`` keyword.
  2294|         0|            0|            0|  0.00%|
  2295|         0|            0|            0|  0.00%|        >>> def subtract_custom_value(x, custom_value):
  2296|         0|            0|            0|  0.00%|        ...     return x-custom_value
  2297|         0|            0|            0|  0.00%|
  2298|         0|            0|            0|  0.00%|        >>> series.apply(subtract_custom_value, args=(5,))
  2299|         0|            0|            0|  0.00%|        London      15
  2300|         0|            0|            0|  0.00%|        New York    16
  2301|         0|            0|            0|  0.00%|        Helsinki     7
  2302|         0|            0|            0|  0.00%|        dtype: int64
  2303|         0|            0|            0|  0.00%|
  2304|         0|            0|            0|  0.00%|        Define a custom function that takes keyword arguments
  2305|         0|            0|            0|  0.00%|        and pass these arguments to ``apply``.
  2306|         0|            0|            0|  0.00%|
  2307|         0|            0|            0|  0.00%|        >>> def add_custom_values(x, **kwargs):
  2308|         0|            0|            0|  0.00%|        ...     for month in kwargs:
  2309|         0|            0|            0|  0.00%|        ...         x+=kwargs[month]
  2310|         0|            0|            0|  0.00%|        ...         return x
  2311|         0|            0|            0|  0.00%|
  2312|         0|            0|            0|  0.00%|        >>> series.apply(add_custom_values, june=30, july=20, august=25)
  2313|         0|            0|            0|  0.00%|        London      95
  2314|         0|            0|            0|  0.00%|        New York    96
  2315|         0|            0|            0|  0.00%|        Helsinki    87
  2316|         0|            0|            0|  0.00%|        dtype: int64
  2317|         0|            0|            0|  0.00%|
  2318|         0|            0|            0|  0.00%|        Use a function from the Numpy library.
  2319|         0|            0|            0|  0.00%|
  2320|         0|            0|            0|  0.00%|        >>> series.apply(np.log)
  2321|         0|            0|            0|  0.00%|        London      2.995732
  2322|         0|            0|            0|  0.00%|        New York    3.044522
  2323|         0|            0|            0|  0.00%|        Helsinki    2.484907
  2324|         0|            0|            0|  0.00%|        dtype: float64
  2325|         0|            0|            0|  0.00%|
  2326|         0|            0|            0|  0.00%|
  2327|         0|            0|            0|  0.00%|        """
  2328|         0|            0|            0|  0.00%|        if len(self) == 0:
  2329|         0|            0|            0|  0.00%|            return self._constructor(dtype=self.dtype,
  2330|         0|            0|            0|  0.00%|                                     index=self.index).__finalize__(self)
  2331|         0|            0|            0|  0.00%|
  2332|         0|            0|            0|  0.00%|        # dispatch to agg
  2333|         0|            0|            0|  0.00%|        if isinstance(func, (list, dict)):
  2334|         0|            0|            0|  0.00%|            return self.aggregate(func, *args, **kwds)
  2335|         0|            0|            0|  0.00%|
  2336|         0|            0|            0|  0.00%|        # if we are a string, try to dispatch
  2337|         0|            0|            0|  0.00%|        if isinstance(func, compat.string_types):
  2338|         0|            0|            0|  0.00%|            return self._try_aggregate_string_function(func, *args, **kwds)
  2339|         0|            0|            0|  0.00%|
  2340|         0|            0|            0|  0.00%|        # handle ufuncs and lambdas
  2341|         0|            0|            0|  0.00%|        if kwds or args and not isinstance(func, np.ufunc):
  2342|         0|            0|            0|  0.00%|            f = lambda x: func(x, *args, **kwds)
  2343|         0|            0|            0|  0.00%|        else:
  2344|         0|            0|            0|  0.00%|            f = func
  2345|         0|            0|            0|  0.00%|
  2346|         0|            0|            0|  0.00%|        with np.errstate(all='ignore'):
  2347|         0|            0|            0|  0.00%|            if isinstance(f, np.ufunc):
  2348|         0|            0|            0|  0.00%|                return f(self)
  2349|         0|            0|            0|  0.00%|
  2350|         0|            0|            0|  0.00%|            # row-wise access
  2351|         0|            0|            0|  0.00%|            if is_extension_type(self.dtype):
  2352|         0|            0|            0|  0.00%|                mapped = self._values.map(f)
  2353|         0|            0|            0|  0.00%|            else:
  2354|         0|            0|            0|  0.00%|                values = self.asobject
  2355|         0|            0|            0|  0.00%|                mapped = lib.map_infer(values, f, convert=convert_dtype)
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\DBSrv5ConnPy\db_object.py:621 _tz_convert
  2356|         0|            0|            0|  0.00%|
  2357|         0|            0|            0|  0.00%|        if len(mapped) and isinstance(mapped[0], Series):
  2358|         0|            0|            0|  0.00%|            from pandas.core.frame import DataFrame
  2359|         0|            0|            0|  0.00%|            return DataFrame(mapped.tolist(), index=self.index)
  2360|         0|            0|            0|  0.00%|        else:
  2361|         0|            0|            0|  0.00%|            return self._constructor(mapped,
  2362|         0|            0|            0|  0.00%|                                     index=self.index).__finalize__(self)
  2363|         0|            0|            0|  0.00%|
  2364|         0|            0|            0|  0.00%|    def _reduce(self, op, name, axis=0, skipna=True, numeric_only=None,
  2365|         0|            0|            0|  0.00%|                filter_type=None, **kwds):
  2366|         0|            0|            0|  0.00%|        """
  2367|         0|            0|            0|  0.00%|        perform a reduction operation
  2368|         0|            0|            0|  0.00%|
  2369|         0|            0|            0|  0.00%|        if we have an ndarray as a value, then simply perform the operation,
  2370|         0|            0|            0|  0.00%|        otherwise delegate to the object
  2371|         0|            0|            0|  0.00%|
  2372|         0|            0|            0|  0.00%|        """
  2373|         0|            0|            0|  0.00%|        delegate = self._values
  2374|         0|            0|            0|  0.00%|        if isinstance(delegate, np.ndarray):
  2375|         0|            0|            0|  0.00%|            # Validate that 'axis' is consistent with Series's single axis.
  2376|         0|            0|            0|  0.00%|            self._get_axis_number(axis)
  2377|         0|            0|            0|  0.00%|            if numeric_only:
  2378|         0|            0|            0|  0.00%|                raise NotImplementedError('Series.{0} does not implement '
  2379|         0|            0|            0|  0.00%|                                          'numeric_only.'.format(name))
  2380|         0|            0|            0|  0.00%|            with np.errstate(all='ignore'):
  2381|         0|            0|            0|  0.00%|                return op(delegate, skipna=skipna, **kwds)
  2382|         0|            0|            0|  0.00%|
  2383|         0|            0|            0|  0.00%|        return delegate._reduce(op=op, name=name, axis=axis, skipna=skipna,
  2384|         0|            0|            0|  0.00%|                                numeric_only=numeric_only,
  2385|         0|            0|            0|  0.00%|                                filter_type=filter_type, **kwds)
  2386|         0|            0|            0|  0.00%|
  2387|         0|            0|            0|  0.00%|    def _reindex_indexer(self, new_index, indexer, copy):
  2388|         0|            0|            0|  0.00%|        if indexer is None:
  2389|         0|            0|            0|  0.00%|            if copy:
  2390|         0|            0|            0|  0.00%|                return self.copy()
  2391|         0|            0|            0|  0.00%|            return self
  2392|         0|            0|            0|  0.00%|
  2393|         0|            0|            0|  0.00%|        # be subclass-friendly
  2394|         0|            0|            0|  0.00%|        new_values = algorithms.take_1d(self.get_values(), indexer)
  2395|         0|            0|            0|  0.00%|        return self._constructor(new_values, index=new_index)
  2396|         0|            0|            0|  0.00%|
  2397|         0|            0|            0|  0.00%|    def _needs_reindex_multi(self, axes, method, level):
  2398|         0|            0|            0|  0.00%|        """ check if we do need a multi reindex; this is for compat with
  2399|         0|            0|            0|  0.00%|        higher dims
  2400|         0|            0|            0|  0.00%|        """
  2401|         0|            0|            0|  0.00%|        return False
  2402|         0|            0|            0|  0.00%|
  2403|         0|            0|            0|  0.00%|    @Appender(generic._shared_docs['align'] % _shared_doc_kwargs)
  2404|         0|            0|            0|  0.00%|    def align(self, other, join='outer', axis=None, level=None, copy=True,
  2405|         0|            0|            0|  0.00%|              fill_value=None, method=None, limit=None, fill_axis=0,
  2406|         0|            0|            0|  0.00%|              broadcast_axis=None):
  2407|         0|            0|            0|  0.00%|        return super(Series, self).align(other, join=join, axis=axis,
  2408|         0|            0|            0|  0.00%|                                         level=level, copy=copy,
  2409|         0|            0|            0|  0.00%|                                         fill_value=fill_value, method=method,
  2410|         0|            0|            0|  0.00%|                                         limit=limit, fill_axis=fill_axis,
  2411|         0|            0|            0|  0.00%|                                         broadcast_axis=broadcast_axis)
  2412|         0|            0|            0|  0.00%|
  2413|         0|            0|            0|  0.00%|    @Appender(generic._shared_docs['rename'] % _shared_doc_kwargs)
  2414|         0|            0|            0|  0.00%|    def rename(self, index=None, **kwargs):
  2415|         0|            0|            0|  0.00%|        kwargs['inplace'] = validate_bool_kwarg(kwargs.get('inplace', False),
  2416|         0|            0|            0|  0.00%|                                                'inplace')
  2417|         0|            0|            0|  0.00%|
  2418|         0|            0|            0|  0.00%|        non_mapping = is_scalar(index) or (is_list_like(index) and
  2419|         0|            0|            0|  0.00%|                                           not is_dict_like(index))
  2420|         0|            0|            0|  0.00%|        if non_mapping:
  2421|         0|            0|            0|  0.00%|            return self._set_name(index, inplace=kwargs.get('inplace'))
  2422|         0|            0|            0|  0.00%|        return super(Series, self).rename(index=index, **kwargs)
  2423|         0|            0|            0|  0.00%|
  2424|         0|            0|            0|  0.00%|    @Appender(generic._shared_docs['reindex'] % _shared_doc_kwargs)
  2425|         0|            0|            0|  0.00%|    def reindex(self, index=None, **kwargs):
  2426|         0|            0|            0|  0.00%|        return super(Series, self).reindex(index=index, **kwargs)
  2427|         0|            0|            0|  0.00%|
  2428|         0|            0|            0|  0.00%|    @Appender(generic._shared_docs['fillna'] % _shared_doc_kwargs)
  2429|         0|            0|            0|  0.00%|    def fillna(self, value=None, method=None, axis=None, inplace=False,
  2430|         0|            0|            0|  0.00%|               limit=None, downcast=None, **kwargs):
  2431|         0|            0|            0|  0.00%|        return super(Series, self).fillna(value=value, method=method,
  2432|         0|            0|            0|  0.00%|                                          axis=axis, inplace=inplace,
  2433|         0|            0|            0|  0.00%|                                          limit=limit, downcast=downcast,
  2434|         0|            0|            0|  0.00%|                                          **kwargs)
  2435|         0|            0|            0|  0.00%|
  2436|         0|            0|            0|  0.00%|    @Appender(generic._shared_docs['shift'] % _shared_doc_kwargs)
  2437|         0|            0|            0|  0.00%|    def shift(self, periods=1, freq=None, axis=0):
  2438|         0|            0|            0|  0.00%|        return super(Series, self).shift(periods=periods, freq=freq, axis=axis)
  2439|         0|            0|            0|  0.00%|
  2440|         0|            0|            0|  0.00%|    def reindex_axis(self, labels, axis=0, **kwargs):
  2441|         0|            0|            0|  0.00%|        """ for compatibility with higher dims """
  2442|         0|            0|            0|  0.00%|        if axis != 0:
  2443|         0|            0|            0|  0.00%|            raise ValueError("cannot reindex series on non-zero axis!")
  2444|         0|            0|            0|  0.00%|        return self.reindex(index=labels, **kwargs)
  2445|         0|            0|            0|  0.00%|
  2446|         0|            0|            0|  0.00%|    def memory_usage(self, index=True, deep=False):
  2447|         0|            0|            0|  0.00%|        """Memory usage of the Series
  2448|         0|            0|            0|  0.00%|
  2449|         0|            0|            0|  0.00%|        Parameters
  2450|         0|            0|            0|  0.00%|        ----------
  2451|         0|            0|            0|  0.00%|        index : bool
  2452|         0|            0|            0|  0.00%|            Specifies whether to include memory usage of Series index
  2453|         0|            0|            0|  0.00%|        deep : bool
  2454|         0|            0|            0|  0.00%|            Introspect the data deeply, interrogate
  2455|         0|            0|            0|  0.00%|            `object` dtypes for system-level memory consumption
  2456|         0|            0|            0|  0.00%|
  2457|         0|            0|            0|  0.00%|        Returns
  2458|         0|            0|            0|  0.00%|        -------
  2459|         0|            0|            0|  0.00%|        scalar bytes of memory consumed
  2460|         0|            0|            0|  0.00%|
  2461|         0|            0|            0|  0.00%|        Notes
  2462|         0|            0|            0|  0.00%|        -----
  2463|         0|            0|            0|  0.00%|        Memory usage does not include memory consumed by elements that
  2464|         0|            0|            0|  0.00%|        are not components of the array if deep=False
  2465|         0|            0|            0|  0.00%|
  2466|         0|            0|            0|  0.00%|        See Also
  2467|         0|            0|            0|  0.00%|        --------
  2468|         0|            0|            0|  0.00%|        numpy.ndarray.nbytes
  2469|         0|            0|            0|  0.00%|        """
  2470|         0|            0|            0|  0.00%|        v = super(Series, self).memory_usage(deep=deep)
  2471|         0|            0|            0|  0.00%|        if index:
  2472|         0|            0|            0|  0.00%|            v += self.index.memory_usage(deep=deep)
  2473|         0|            0|            0|  0.00%|        return v
  2474|         0|            0|            0|  0.00%|
  2475|         0|            0|            0|  0.00%|    def take(self, indices, axis=0, convert=True, is_copy=False, **kwargs):
  2476|         0|            0|            0|  0.00%|        """
  2477|         0|            0|            0|  0.00%|        return Series corresponding to requested indices
  2478|         0|            0|            0|  0.00%|
  2479|         0|            0|            0|  0.00%|        Parameters
  2480|         0|            0|            0|  0.00%|        ----------
  2481|         0|            0|            0|  0.00%|        indices : list / array of ints
  2482|         0|            0|            0|  0.00%|        convert : translate negative to positive indices (default)
  2483|         0|            0|            0|  0.00%|
  2484|         0|            0|            0|  0.00%|        Returns
  2485|         0|            0|            0|  0.00%|        -------
  2486|         0|            0|            0|  0.00%|        taken : Series
  2487|         0|            0|            0|  0.00%|
  2488|         0|            0|            0|  0.00%|        See also
  2489|         0|            0|            0|  0.00%|        --------
  2490|         0|            0|            0|  0.00%|        numpy.ndarray.take
  2491|         0|            0|            0|  0.00%|        """
  2492|         0|            0|            0|  0.00%|        if kwargs:
  2493|         0|            0|            0|  0.00%|            nv.validate_take(tuple(), kwargs)
  2494|         0|            0|            0|  0.00%|
  2495|         0|            0|            0|  0.00%|        # check/convert indicies here
  2496|         0|            0|            0|  0.00%|        if convert:
  2497|         0|            0|            0|  0.00%|            indices = maybe_convert_indices(indices, len(self._get_axis(axis)))
  2498|         0|            0|            0|  0.00%|
  2499|         0|            0|            0|  0.00%|        indices = _ensure_platform_int(indices)
  2500|         0|            0|            0|  0.00%|        new_index = self.index.take(indices)
  2501|         0|            0|            0|  0.00%|        new_values = self._values.take(indices)
  2502|         0|            0|            0|  0.00%|        return (self._constructor(new_values, index=new_index, fastpath=True)
  2503|         0|            0|            0|  0.00%|                    .__finalize__(self))
  2504|         0|            0|            0|  0.00%|
  2505|         0|            0|            0|  0.00%|    def isin(self, values):
  2506|         0|            0|            0|  0.00%|        """
  2507|         0|            0|            0|  0.00%|        Return a boolean :class:`~pandas.Series` showing whether each element
  2508|         0|            0|            0|  0.00%|        in the :class:`~pandas.Series` is exactly contained in the passed
  2509|         0|            0|            0|  0.00%|        sequence of ``values``.
  2510|         0|            0|            0|  0.00%|
  2511|         0|            0|            0|  0.00%|        Parameters
  2512|         0|            0|            0|  0.00%|        ----------
  2513|         0|            0|            0|  0.00%|        values : set or list-like
  2514|         0|            0|            0|  0.00%|            The sequence of values to test. Passing in a single string will
  2515|         0|            0|            0|  0.00%|            raise a ``TypeError``. Instead, turn a single string into a
  2516|         0|            0|            0|  0.00%|            ``list`` of one element.
  2517|         0|            0|            0|  0.00%|
  2518|         0|            0|            0|  0.00%|            .. versionadded:: 0.18.1
  2519|         0|            0|            0|  0.00%|
  2520|         0|            0|            0|  0.00%|            Support for values as a set
  2521|         0|            0|            0|  0.00%|
  2522|         0|            0|            0|  0.00%|        Returns
  2523|         0|            0|            0|  0.00%|        -------
  2524|         0|            0|            0|  0.00%|        isin : Series (bool dtype)
  2525|         0|            0|            0|  0.00%|
  2526|         0|            0|            0|  0.00%|        Raises
  2527|         0|            0|            0|  0.00%|        ------
  2528|         0|            0|            0|  0.00%|        TypeError
  2529|         0|            0|            0|  0.00%|          * If ``values`` is a string
  2530|         0|            0|            0|  0.00%|
  2531|         0|            0|            0|  0.00%|        See Also
  2532|         0|            0|            0|  0.00%|        --------
  2533|         0|            0|            0|  0.00%|        pandas.DataFrame.isin
  2534|         0|            0|            0|  0.00%|
  2535|         0|            0|            0|  0.00%|        Examples
  2536|         0|            0|            0|  0.00%|        --------
  2537|         0|            0|            0|  0.00%|
  2538|         0|            0|            0|  0.00%|        >>> s = pd.Series(list('abc'))
  2539|         0|            0|            0|  0.00%|        >>> s.isin(['a', 'c', 'e'])
  2540|         0|            0|            0|  0.00%|        0     True
  2541|         0|            0|            0|  0.00%|        1    False
  2542|         0|            0|            0|  0.00%|        2     True
  2543|         0|            0|            0|  0.00%|        dtype: bool
  2544|         0|            0|            0|  0.00%|
  2545|         0|            0|            0|  0.00%|        Passing a single string as ``s.isin('a')`` will raise an error. Use
  2546|         0|            0|            0|  0.00%|        a list of one element instead:
  2547|         0|            0|            0|  0.00%|
  2548|         0|            0|            0|  0.00%|        >>> s.isin(['a'])
  2549|         0|            0|            0|  0.00%|        0     True
  2550|         0|            0|            0|  0.00%|        1    False
  2551|         0|            0|            0|  0.00%|        2    False
  2552|         0|            0|            0|  0.00%|        dtype: bool
  2553|         0|            0|            0|  0.00%|
  2554|         0|            0|            0|  0.00%|        """
  2555|         0|            0|            0|  0.00%|        result = algorithms.isin(_values_from_object(self), values)
  2556|         0|            0|            0|  0.00%|        return self._constructor(result, index=self.index).__finalize__(self)
  2557|         0|            0|            0|  0.00%|
  2558|         0|            0|            0|  0.00%|    def between(self, left, right, inclusive=True):
  2559|         0|            0|            0|  0.00%|        """
  2560|         0|            0|            0|  0.00%|        Return boolean Series equivalent to left <= series <= right. NA values
  2561|         0|            0|            0|  0.00%|        will be treated as False
  2562|         0|            0|            0|  0.00%|
  2563|         0|            0|            0|  0.00%|        Parameters
  2564|         0|            0|            0|  0.00%|        ----------
  2565|         0|            0|            0|  0.00%|        left : scalar
  2566|         0|            0|            0|  0.00%|            Left boundary
  2567|         0|            0|            0|  0.00%|        right : scalar
  2568|         0|            0|            0|  0.00%|            Right boundary
  2569|         0|            0|            0|  0.00%|
  2570|         0|            0|            0|  0.00%|        Returns
  2571|         0|            0|            0|  0.00%|        -------
  2572|         0|            0|            0|  0.00%|        is_between : Series
  2573|         0|            0|            0|  0.00%|        """
  2574|         0|            0|            0|  0.00%|        if inclusive:
  2575|         0|            0|            0|  0.00%|            lmask = self >= left
  2576|         0|            0|            0|  0.00%|            rmask = self <= right
  2577|         0|            0|            0|  0.00%|        else:
  2578|         0|            0|            0|  0.00%|            lmask = self > left
  2579|         0|            0|            0|  0.00%|            rmask = self < right
  2580|         0|            0|            0|  0.00%|
  2581|         0|            0|            0|  0.00%|        return lmask & rmask
  2582|         0|            0|            0|  0.00%|
  2583|         0|            0|            0|  0.00%|    @classmethod
  2584|         0|            0|            0|  0.00%|    def from_csv(cls, path, sep=',', parse_dates=True, header=None,
  2585|         0|            0|            0|  0.00%|                 index_col=0, encoding=None, infer_datetime_format=False):
  2586|         0|            0|            0|  0.00%|        """
  2587|         0|            0|            0|  0.00%|        Read CSV file (DISCOURAGED, please use :func:`pandas.read_csv`
  2588|         0|            0|            0|  0.00%|        instead).
  2589|         0|            0|            0|  0.00%|
  2590|         0|            0|            0|  0.00%|        It is preferable to use the more powerful :func:`pandas.read_csv`
  2591|         0|            0|            0|  0.00%|        for most general purposes, but ``from_csv`` makes for an easy
  2592|         0|            0|            0|  0.00%|        roundtrip to and from a file (the exact counterpart of
  2593|         0|            0|            0|  0.00%|        ``to_csv``), especially with a time Series.
  2594|         0|            0|            0|  0.00%|
  2595|         0|            0|            0|  0.00%|        This method only differs from :func:`pandas.read_csv` in some defaults:
  2596|         0|            0|            0|  0.00%|
  2597|         0|            0|            0|  0.00%|        - `index_col` is ``0`` instead of ``None`` (take first column as index
  2598|         0|            0|            0|  0.00%|          by default)
  2599|         0|            0|            0|  0.00%|        - `header` is ``None`` instead of ``0`` (the first row is not used as
  2600|         0|            0|            0|  0.00%|          the column names)
  2601|         0|            0|            0|  0.00%|        - `parse_dates` is ``True`` instead of ``False`` (try parsing the index
  2602|         0|            0|            0|  0.00%|          as datetime by default)
  2603|         0|            0|            0|  0.00%|
  2604|         0|            0|            0|  0.00%|        With :func:`pandas.read_csv`, the option ``squeeze=True`` can be used
  2605|         0|            0|            0|  0.00%|        to return a Series like ``from_csv``.
  2606|         0|            0|            0|  0.00%|
  2607|         0|            0|            0|  0.00%|        Parameters
  2608|         0|            0|            0|  0.00%|        ----------
  2609|         0|            0|            0|  0.00%|        path : string file path or file handle / StringIO
  2610|         0|            0|            0|  0.00%|        sep : string, default ','
  2611|         0|            0|            0|  0.00%|            Field delimiter
  2612|         0|            0|            0|  0.00%|        parse_dates : boolean, default True
  2613|         0|            0|            0|  0.00%|            Parse dates. Different default from read_table
  2614|         0|            0|            0|  0.00%|        header : int, default None
  2615|         0|            0|            0|  0.00%|            Row to use as header (skip prior rows)
  2616|         0|            0|            0|  0.00%|        index_col : int or sequence, default 0
  2617|         0|            0|            0|  0.00%|            Column to use for index. If a sequence is given, a MultiIndex
  2618|         0|            0|            0|  0.00%|            is used. Different default from read_table
  2619|         0|            0|            0|  0.00%|        encoding : string, optional
  2620|         0|            0|            0|  0.00%|            a string representing the encoding to use if the contents are
  2621|         0|            0|            0|  0.00%|            non-ascii, for python versions prior to 3
  2622|         0|            0|            0|  0.00%|        infer_datetime_format: boolean, default False
  2623|         0|            0|            0|  0.00%|            If True and `parse_dates` is True for a column, try to infer the
  2624|         0|            0|            0|  0.00%|            datetime format based on the first datetime string. If the format
  2625|         0|            0|            0|  0.00%|            can be inferred, there often will be a large parsing speed-up.
  2626|         0|            0|            0|  0.00%|
  2627|         0|            0|            0|  0.00%|        See also
  2628|         0|            0|            0|  0.00%|        --------
  2629|         0|            0|            0|  0.00%|        pandas.read_csv
  2630|         0|            0|            0|  0.00%|
  2631|         0|            0|            0|  0.00%|        Returns
  2632|         0|            0|            0|  0.00%|        -------
  2633|         0|            0|            0|  0.00%|        y : Series
  2634|         0|            0|            0|  0.00%|        """
  2635|         0|            0|            0|  0.00%|        from pandas.core.frame import DataFrame
  2636|         0|            0|            0|  0.00%|        df = DataFrame.from_csv(path, header=header, index_col=index_col,
  2637|         0|            0|            0|  0.00%|                                sep=sep, parse_dates=parse_dates,
  2638|         0|            0|            0|  0.00%|                                encoding=encoding,
  2639|         0|            0|            0|  0.00%|                                infer_datetime_format=infer_datetime_format)
  2640|         0|            0|            0|  0.00%|        result = df.iloc[:, 0]
  2641|         0|            0|            0|  0.00%|        if header is None:
  2642|         0|            0|            0|  0.00%|            result.index.name = result.name = None
  2643|         0|            0|            0|  0.00%|
  2644|         0|            0|            0|  0.00%|        return result
  2645|         0|            0|            0|  0.00%|
  2646|         0|            0|            0|  0.00%|    def to_csv(self, path=None, index=True, sep=",", na_rep='',
  2647|         0|            0|            0|  0.00%|               float_format=None, header=False, index_label=None,
  2648|         0|            0|            0|  0.00%|               mode='w', encoding=None, date_format=None, decimal='.'):
  2649|         0|            0|            0|  0.00%|        """
  2650|         0|            0|            0|  0.00%|        Write Series to a comma-separated values (csv) file
  2651|         0|            0|            0|  0.00%|
  2652|         0|            0|            0|  0.00%|        Parameters
  2653|         0|            0|            0|  0.00%|        ----------
  2654|         0|            0|            0|  0.00%|        path : string or file handle, default None
  2655|         0|            0|            0|  0.00%|            File path or object, if None is provided the result is returned as
  2656|         0|            0|            0|  0.00%|            a string.
  2657|         0|            0|            0|  0.00%|        na_rep : string, default ''
  2658|         0|            0|            0|  0.00%|            Missing data representation
  2659|         0|            0|            0|  0.00%|        float_format : string, default None
  2660|         0|            0|            0|  0.00%|            Format string for floating point numbers
  2661|         0|            0|            0|  0.00%|        header : boolean, default False
  2662|         0|            0|            0|  0.00%|            Write out series name
  2663|         0|            0|            0|  0.00%|        index : boolean, default True
  2664|         0|            0|            0|  0.00%|            Write row names (index)
  2665|         0|            0|            0|  0.00%|        index_label : string or sequence, default None
  2666|         0|            0|            0|  0.00%|            Column label for index column(s) if desired. If None is given, and
  2667|         0|            0|            0|  0.00%|            `header` and `index` are True, then the index names are used. A
  2668|         0|            0|            0|  0.00%|            sequence should be given if the DataFrame uses MultiIndex.
  2669|         0|            0|            0|  0.00%|        mode : Python write mode, default 'w'
  2670|         0|            0|            0|  0.00%|        sep : character, default ","
  2671|         0|            0|            0|  0.00%|            Field delimiter for the output file.
  2672|         0|            0|            0|  0.00%|        encoding : string, optional
  2673|         0|            0|            0|  0.00%|            a string representing the encoding to use if the contents are
  2674|         0|            0|            0|  0.00%|            non-ascii, for python versions prior to 3
  2675|         0|            0|            0|  0.00%|        date_format: string, default None
  2676|         0|            0|            0|  0.00%|            Format string for datetime objects.
  2677|         0|            0|            0|  0.00%|        decimal: string, default '.'
  2678|         0|            0|            0|  0.00%|            Character recognized as decimal separator. E.g. use ',' for
  2679|         0|            0|            0|  0.00%|            European data
  2680|         0|            0|            0|  0.00%|        """
  2681|         0|            0|            0|  0.00%|        from pandas.core.frame import DataFrame
  2682|         0|            0|            0|  0.00%|        df = DataFrame(self)
  2683|         0|            0|            0|  0.00%|        # result is only a string if no path provided, otherwise None
  2684|         0|            0|            0|  0.00%|        result = df.to_csv(path, index=index, sep=sep, na_rep=na_rep,
  2685|         0|            0|            0|  0.00%|                           float_format=float_format, header=header,
  2686|         0|            0|            0|  0.00%|                           index_label=index_label, mode=mode,
  2687|         0|            0|            0|  0.00%|                           encoding=encoding, date_format=date_format,
  2688|         0|            0|            0|  0.00%|                           decimal=decimal)
  2689|         0|            0|            0|  0.00%|        if path is None:
  2690|         0|            0|            0|  0.00%|            return result
  2691|         0|            0|            0|  0.00%|
  2692|         0|            0|            0|  0.00%|    @Appender(generic._shared_docs['to_excel'] % _shared_doc_kwargs)
  2693|         0|            0|            0|  0.00%|    def to_excel(self, excel_writer, sheet_name='Sheet1', na_rep='',
  2694|         0|            0|            0|  0.00%|                 float_format=None, columns=None, header=True, index=True,
  2695|         0|            0|            0|  0.00%|                 index_label=None, startrow=0, startcol=0, engine=None,
  2696|         0|            0|            0|  0.00%|                 merge_cells=True, encoding=None, inf_rep='inf', verbose=True):
  2697|         0|            0|            0|  0.00%|        df = self.to_frame()
  2698|         0|            0|            0|  0.00%|        df.to_excel(excel_writer=excel_writer, sheet_name=sheet_name,
  2699|         0|            0|            0|  0.00%|                    na_rep=na_rep, float_format=float_format, columns=columns,
  2700|         0|            0|            0|  0.00%|                    header=header, index=index, index_label=index_label,
  2701|         0|            0|            0|  0.00%|                    startrow=startrow, startcol=startcol, engine=engine,
  2702|         0|            0|            0|  0.00%|                    merge_cells=merge_cells, encoding=encoding,
  2703|         0|            0|            0|  0.00%|                    inf_rep=inf_rep, verbose=verbose)
  2704|         0|            0|            0|  0.00%|
  2705|         0|            0|            0|  0.00%|    def dropna(self, axis=0, inplace=False, **kwargs):
  2706|         0|            0|            0|  0.00%|        """
  2707|         0|            0|            0|  0.00%|        Return Series without null values
  2708|         0|            0|            0|  0.00%|
  2709|         0|            0|            0|  0.00%|        Returns
  2710|         0|            0|            0|  0.00%|        -------
  2711|         0|            0|            0|  0.00%|        valid : Series
  2712|         0|            0|            0|  0.00%|        inplace : boolean, default False
  2713|         0|            0|            0|  0.00%|            Do operation in place.
  2714|         0|            0|            0|  0.00%|        """
  2715|         0|            0|            0|  0.00%|        inplace = validate_bool_kwarg(inplace, 'inplace')
  2716|         0|            0|            0|  0.00%|        kwargs.pop('how', None)
  2717|         0|            0|            0|  0.00%|        if kwargs:
  2718|         0|            0|            0|  0.00%|            raise TypeError('dropna() got an unexpected keyword '
  2719|         0|            0|            0|  0.00%|                            'argument "{0}"'.format(list(kwargs.keys())[0]))
  2720|         0|            0|            0|  0.00%|
  2721|         0|            0|            0|  0.00%|        axis = self._get_axis_number(axis or 0)
  2722|         0|            0|            0|  0.00%|
  2723|         0|            0|            0|  0.00%|        if self._can_hold_na:
  2724|         0|            0|            0|  0.00%|            result = remove_na(self)
  2725|         0|            0|            0|  0.00%|            if inplace:
  2726|         0|            0|            0|  0.00%|                self._update_inplace(result)
  2727|         0|            0|            0|  0.00%|            else:
  2728|         0|            0|            0|  0.00%|                return result
  2729|         0|            0|            0|  0.00%|        else:
  2730|         0|            0|            0|  0.00%|            if inplace:
  2731|         0|            0|            0|  0.00%|                # do nothing
  2732|         0|            0|            0|  0.00%|                pass
  2733|         0|            0|            0|  0.00%|            else:
  2734|         0|            0|            0|  0.00%|                return self.copy()
  2735|         0|            0|            0|  0.00%|
  2736|         0|            0|            0|  0.00%|    valid = lambda self, inplace=False, **kwargs: self.dropna(inplace=inplace,
  2737|         0|            0|            0|  0.00%|                                                              **kwargs)
  2738|         0|            0|            0|  0.00%|
  2739|         0|            0|            0|  0.00%|    def first_valid_index(self):
  2740|         0|            0|            0|  0.00%|        """
  2741|         0|            0|            0|  0.00%|        Return label for first non-NA/null value
  2742|         0|            0|            0|  0.00%|        """
  2743|         0|            0|            0|  0.00%|        if len(self) == 0:
  2744|         0|            0|            0|  0.00%|            return None
  2745|         0|            0|            0|  0.00%|
  2746|         0|            0|            0|  0.00%|        mask = isnull(self._values)
  2747|         0|            0|            0|  0.00%|        i = mask.argmin()
  2748|         0|            0|            0|  0.00%|        if mask[i]:
  2749|         0|            0|            0|  0.00%|            return None
  2750|         0|            0|            0|  0.00%|        else:
  2751|         0|            0|            0|  0.00%|            return self.index[i]
  2752|         0|            0|            0|  0.00%|
  2753|         0|            0|            0|  0.00%|    def last_valid_index(self):
  2754|         0|            0|            0|  0.00%|        """
  2755|         0|            0|            0|  0.00%|        Return label for last non-NA/null value
  2756|         0|            0|            0|  0.00%|        """
  2757|         0|            0|            0|  0.00%|        if len(self) == 0:
  2758|         0|            0|            0|  0.00%|            return None
  2759|         0|            0|            0|  0.00%|
  2760|         0|            0|            0|  0.00%|        mask = isnull(self._values[::-1])
  2761|         0|            0|            0|  0.00%|        i = mask.argmin()
  2762|         0|            0|            0|  0.00%|        if mask[i]:
  2763|         0|            0|            0|  0.00%|            return None
  2764|         0|            0|            0|  0.00%|        else:
  2765|         0|            0|            0|  0.00%|            return self.index[len(self) - i - 1]
  2766|         0|            0|            0|  0.00%|
  2767|         0|            0|            0|  0.00%|    # ----------------------------------------------------------------------
  2768|         0|            0|            0|  0.00%|    # Time series-oriented methods
  2769|         0|            0|            0|  0.00%|
  2770|         0|            0|            0|  0.00%|    def to_timestamp(self, freq=None, how='start', copy=True):
  2771|         0|            0|            0|  0.00%|        """
  2772|         0|            0|            0|  0.00%|        Cast to datetimeindex of timestamps, at *beginning* of period
  2773|         0|            0|            0|  0.00%|
  2774|         0|            0|            0|  0.00%|        Parameters
  2775|         0|            0|            0|  0.00%|        ----------
  2776|         0|            0|            0|  0.00%|        freq : string, default frequency of PeriodIndex
  2777|         0|            0|            0|  0.00%|            Desired frequency
  2778|         0|            0|            0|  0.00%|        how : {'s', 'e', 'start', 'end'}
  2779|         0|            0|            0|  0.00%|            Convention for converting period to timestamp; start of period
  2780|         0|            0|            0|  0.00%|            vs. end
  2781|         0|            0|            0|  0.00%|
  2782|         0|            0|            0|  0.00%|        Returns
  2783|         0|            0|            0|  0.00%|        -------
  2784|         0|            0|            0|  0.00%|        ts : Series with DatetimeIndex
  2785|         0|            0|            0|  0.00%|        """
  2786|         0|            0|            0|  0.00%|        new_values = self._values
  2787|         0|            0|            0|  0.00%|        if copy:
  2788|         0|            0|            0|  0.00%|            new_values = new_values.copy()
  2789|         0|            0|            0|  0.00%|
  2790|         0|            0|            0|  0.00%|        new_index = self.index.to_timestamp(freq=freq, how=how)
  2791|         0|            0|            0|  0.00%|        return self._constructor(new_values,
  2792|         0|            0|            0|  0.00%|                                 index=new_index).__finalize__(self)
  2793|         0|            0|            0|  0.00%|
  2794|         0|            0|            0|  0.00%|    def to_period(self, freq=None, copy=True):
  2795|         0|            0|            0|  0.00%|        """
  2796|         0|            0|            0|  0.00%|        Convert Series from DatetimeIndex to PeriodIndex with desired
  2797|         0|            0|            0|  0.00%|        frequency (inferred from index if not passed)
  2798|         0|            0|            0|  0.00%|
  2799|         0|            0|            0|  0.00%|        Parameters
  2800|         0|            0|            0|  0.00%|        ----------
  2801|         0|            0|            0|  0.00%|        freq : string, default
  2802|         0|            0|            0|  0.00%|
  2803|         0|            0|            0|  0.00%|        Returns
  2804|         0|            0|            0|  0.00%|        -------
  2805|         0|            0|            0|  0.00%|        ts : Series with PeriodIndex
  2806|         0|            0|            0|  0.00%|        """
  2807|         0|            0|            0|  0.00%|        new_values = self._values
  2808|         0|            0|            0|  0.00%|        if copy:
  2809|         0|            0|            0|  0.00%|            new_values = new_values.copy()
  2810|         0|            0|            0|  0.00%|
  2811|         0|            0|            0|  0.00%|        new_index = self.index.to_period(freq=freq)
  2812|         0|            0|            0|  0.00%|        return self._constructor(new_values,
  2813|         0|            0|            0|  0.00%|                                 index=new_index).__finalize__(self)
  2814|         0|            0|            0|  0.00%|
  2815|         0|            0|            0|  0.00%|    # -------------------------------------------------------------------------
  2816|         0|            0|            0|  0.00%|    # Datetimelike delegation methods
  2817|         0|            0|            0|  0.00%|
  2818|         0|            0|            0|  0.00%|    def _make_dt_accessor(self):
  2819|         0|            0|            0|  0.00%|        try:
  2820|         0|            0|            0|  0.00%|            return maybe_to_datetimelike(self)
  2821|         0|            0|            0|  0.00%|        except Exception:
  2822|         0|            0|            0|  0.00%|            raise AttributeError("Can only use .dt accessor with datetimelike "
  2823|         0|            0|            0|  0.00%|                                 "values")
  2824|         0|            0|            0|  0.00%|
  2825|         0|            0|            0|  0.00%|    dt = base.AccessorProperty(CombinedDatetimelikeProperties,
  2826|         0|            0|            0|  0.00%|                               _make_dt_accessor)
  2827|         0|            0|            0|  0.00%|
  2828|         0|            0|            0|  0.00%|    # -------------------------------------------------------------------------
  2829|         0|            0|            0|  0.00%|    # Categorical methods
  2830|         0|            0|            0|  0.00%|
  2831|         0|            0|            0|  0.00%|    def _make_cat_accessor(self):
  2832|         0|            0|            0|  0.00%|        if not is_categorical_dtype(self.dtype):
  2833|         0|            0|            0|  0.00%|            raise AttributeError("Can only use .cat accessor with a "
  2834|         0|            0|            0|  0.00%|                                 "'category' dtype")
  2835|         0|            0|            0|  0.00%|        return CategoricalAccessor(self.values, self.index)
  2836|         0|            0|            0|  0.00%|
  2837|         0|            0|            0|  0.00%|    cat = base.AccessorProperty(CategoricalAccessor, _make_cat_accessor)
  2838|         0|            0|            0|  0.00%|
  2839|         0|            0|            0|  0.00%|    def _dir_deletions(self):
  2840|         0|            0|            0|  0.00%|        return self._accessors
  2841|         0|            0|            0|  0.00%|
  2842|         0|            0|            0|  0.00%|    def _dir_additions(self):
  2843|         0|            0|            0|  0.00%|        rv = set()
  2844|         0|            0|            0|  0.00%|        for accessor in self._accessors:
  2845|         0|            0|            0|  0.00%|            try:
  2846|         0|            0|            0|  0.00%|                getattr(self, accessor)
  2847|         0|            0|            0|  0.00%|                rv.add(accessor)
  2848|         0|            0|            0|  0.00%|            except AttributeError:
  2849|         0|            0|            0|  0.00%|                pass
  2850|         0|            0|            0|  0.00%|        return rv
  2851|         0|            0|            0|  0.00%|
  2852|         0|            0|            0|  0.00%|
  2853|         0|            0|            0|  0.00%|Series._setup_axes(['index'], info_axis=0, stat_axis=0, aliases={'rows': 0})
  2854|         0|            0|            0|  0.00%|Series._add_numeric_operations()
  2855|         0|            0|            0|  0.00%|Series._add_series_only_operations()
  2856|         0|            0|            0|  0.00%|Series._add_series_or_dataframe_operations()
  2857|         0|            0|            0|  0.00%|_INDEX_TYPES = ndarray, Index, list, tuple
  2858|         0|            0|            0|  0.00%|
  2859|         0|            0|            0|  0.00%|# -----------------------------------------------------------------------------
  2860|         0|            0|            0|  0.00%|# Supplementary functions
  2861|         0|            0|            0|  0.00%|
  2862|         0|            0|            0|  0.00%|
  2863|         0|            0|            0|  0.00%|def remove_na(series):
  2864|         0|            0|            0|  0.00%|    """
  2865|         0|            0|            0|  0.00%|    Return series containing only true/non-NaN values, possibly empty.
  2866|         0|            0|            0|  0.00%|    """
  2867|         0|            0|            0|  0.00%|    return series[notnull(_values_from_object(series))]
  2868|         0|            0|            0|  0.00%|
  2869|         0|            0|            0|  0.00%|
  2870|         0|            0|            0|  0.00%|def _sanitize_index(data, index, copy=False):
  2871|         0|            0|            0|  0.00%|    """ sanitize an index type to return an ndarray of the underlying, pass
  2872|         0|            0|            0|  0.00%|    thru a non-Index
  2873|         0|            0|            0|  0.00%|    """
  2874|         0|            0|            0|  0.00%|
  2875|         0|            0|            0|  0.00%|    if index is None:
  2876|         0|            0|            0|  0.00%|        return data
  2877|         0|            0|            0|  0.00%|
  2878|         0|            0|            0|  0.00%|    if len(data) != len(index):
  2879|         0|            0|            0|  0.00%|        raise ValueError('Length of values does not match length of ' 'index')
  2880|         0|            0|            0|  0.00%|
  2881|         0|            0|            0|  0.00%|    if isinstance(data, PeriodIndex):
  2882|         0|            0|            0|  0.00%|        data = data.asobject
  2883|         0|            0|            0|  0.00%|    elif isinstance(data, DatetimeIndex):
  2884|         0|            0|            0|  0.00%|        data = data._to_embed(keep_tz=True)
  2885|         0|            0|            0|  0.00%|    elif isinstance(data, np.ndarray):
  2886|         0|            0|            0|  0.00%|
  2887|         0|            0|            0|  0.00%|        # coerce datetimelike types
  2888|         0|            0|            0|  0.00%|        if data.dtype.kind in ['M', 'm']:
  2889|         0|            0|            0|  0.00%|            data = _sanitize_array(data, index, copy=copy)
  2890|         0|            0|            0|  0.00%|
  2891|         0|            0|            0|  0.00%|    return data
  2892|         0|            0|            0|  0.00%|
  2893|         0|            0|            0|  0.00%|
  2894|         0|            0|            0|  0.00%|def _sanitize_array(data, index, dtype=None, copy=False,
  2895|         0|            0|            0|  0.00%|                    raise_cast_failure=False):
  2896|         0|            0|            0|  0.00%|    """ sanitize input data to an ndarray, copy if specified, coerce to the
  2897|         0|            0|            0|  0.00%|    dtype if specified
  2898|         0|            0|            0|  0.00%|    """
  2899|         0|            0|            0|  0.00%|
  2900|         0|            0|            0|  0.00%|    if dtype is not None:
  2901|         0|            0|            0|  0.00%|        dtype = pandas_dtype(dtype)
  2902|         0|            0|            0|  0.00%|
  2903|         0|            0|            0|  0.00%|    if isinstance(data, ma.MaskedArray):
  2904|         0|            0|            0|  0.00%|        mask = ma.getmaskarray(data)
  2905|         0|            0|            0|  0.00%|        if mask.any():
  2906|         0|            0|            0|  0.00%|            data, fill_value = maybe_upcast(data, copy=True)
  2907|         0|            0|            0|  0.00%|            data[mask] = fill_value
  2908|         0|            0|            0|  0.00%|        else:
  2909|         0|            0|            0|  0.00%|            data = data.copy()
  2910|         0|            0|            0|  0.00%|
  2911|         0|            0|            0|  0.00%|    def _try_cast(arr, take_fast_path):
  2912|         0|            0|            0|  0.00%|
  2913|         0|            0|            0|  0.00%|        # perf shortcut as this is the most common case
  2914|         0|            0|            0|  0.00%|        if take_fast_path:
  2915|         0|            0|            0|  0.00%|            if maybe_castable(arr) and not copy and dtype is None:
  2916|         0|            0|            0|  0.00%|                return arr
  2917|         0|            0|            0|  0.00%|
  2918|         0|            0|            0|  0.00%|        try:
  2919|         0|            0|            0|  0.00%|            subarr = maybe_cast_to_datetime(arr, dtype)
  2920|         0|            0|            0|  0.00%|            if not is_extension_type(subarr):
  2921|         0|            0|            0|  0.00%|                subarr = np.array(subarr, dtype=dtype, copy=copy)
  2922|         0|            0|            0|  0.00%|        except (ValueError, TypeError):
  2923|         0|            0|            0|  0.00%|            if is_categorical_dtype(dtype):
  2924|         0|            0|            0|  0.00%|                subarr = Categorical(arr)
  2925|         0|            0|            0|  0.00%|            elif dtype is not None and raise_cast_failure:
  2926|         0|            0|            0|  0.00%|                raise
  2927|         0|            0|            0|  0.00%|            else:
  2928|         0|            0|            0|  0.00%|                subarr = np.array(arr, dtype=object, copy=copy)
  2929|         0|            0|            0|  0.00%|        return subarr
  2930|         0|            0|            0|  0.00%|
  2931|         0|            0|            0|  0.00%|    # GH #846
  2932|         0|            0|            0|  0.00%|    if isinstance(data, (np.ndarray, Index, Series)):
  2933|         0|            0|            0|  0.00%|
  2934|         0|            0|            0|  0.00%|        if dtype is not None:
  2935|         0|            0|            0|  0.00%|            subarr = np.array(data, copy=False)
  2936|         0|            0|            0|  0.00%|
  2937|         0|            0|            0|  0.00%|            # possibility of nan -> garbage
  2938|         0|            0|            0|  0.00%|            if is_float_dtype(data.dtype) and is_integer_dtype(dtype):
  2939|         0|            0|            0|  0.00%|                if not isnull(data).any():
  2940|         0|            0|            0|  0.00%|                    subarr = _try_cast(data, True)
  2941|         0|            0|            0|  0.00%|                elif copy:
  2942|         0|            0|            0|  0.00%|                    subarr = data.copy()
  2943|         0|            0|            0|  0.00%|            else:
  2944|         0|            0|            0|  0.00%|                subarr = _try_cast(data, True)
  2945|         0|            0|            0|  0.00%|        elif isinstance(data, Index):
  2946|         0|            0|            0|  0.00%|            # don't coerce Index types
  2947|         0|            0|            0|  0.00%|            # e.g. indexes can have different conversions (so don't fast path
  2948|         0|            0|            0|  0.00%|            # them)
  2949|         0|            0|            0|  0.00%|            # GH 6140
  2950|         0|            0|            0|  0.00%|            subarr = _sanitize_index(data, index, copy=True)
  2951|         0|            0|            0|  0.00%|        else:
  2952|         0|            0|            0|  0.00%|            subarr = _try_cast(data, True)
  2953|         0|            0|            0|  0.00%|
  2954|         0|            0|            0|  0.00%|        if copy:
  2955|         0|            0|            0|  0.00%|            subarr = data.copy()
  2956|         0|            0|            0|  0.00%|
  2957|         0|            0|            0|  0.00%|    elif isinstance(data, Categorical):
  2958|         0|            0|            0|  0.00%|        subarr = data
  2959|         0|            0|            0|  0.00%|
  2960|         0|            0|            0|  0.00%|        if copy:
  2961|         0|            0|            0|  0.00%|            subarr = data.copy()
  2962|         0|            0|            0|  0.00%|        return subarr
  2963|         0|            0|            0|  0.00%|
  2964|         0|            0|            0|  0.00%|    elif isinstance(data, (list, tuple)) and len(data) > 0:
  2965|         0|            0|            0|  0.00%|        if dtype is not None:
  2966|         0|            0|            0|  0.00%|            try:
  2967|         0|            0|            0|  0.00%|                subarr = _try_cast(data, False)
  2968|         0|            0|            0|  0.00%|            except Exception:
  2969|         0|            0|            0|  0.00%|                if raise_cast_failure:  # pragma: no cover
  2970|         0|            0|            0|  0.00%|                    raise
  2971|         0|            0|            0|  0.00%|                subarr = np.array(data, dtype=object, copy=copy)
  2972|         0|            0|            0|  0.00%|                subarr = lib.maybe_convert_objects(subarr)
  2973|         0|            0|            0|  0.00%|
  2974|         0|            0|            0|  0.00%|        else:
  2975|         0|            0|            0|  0.00%|            subarr = maybe_convert_platform(data)
  2976|         0|            0|            0|  0.00%|
  2977|         0|            0|            0|  0.00%|        subarr = maybe_cast_to_datetime(subarr, dtype)
  2978|         0|            0|            0|  0.00%|
  2979|         0|            0|            0|  0.00%|    else:
  2980|         0|            0|            0|  0.00%|        subarr = _try_cast(data, False)
  2981|         0|            0|            0|  0.00%|
  2982|         0|            0|            0|  0.00%|    def create_from_value(value, index, dtype):
  2983|         0|            0|            0|  0.00%|        # return a new empty value suitable for the dtype
  2984|         0|            0|            0|  0.00%|
  2985|         0|            0|            0|  0.00%|        if is_datetimetz(dtype):
  2986|         0|            0|            0|  0.00%|            subarr = DatetimeIndex([value] * len(index), dtype=dtype)
  2987|         0|            0|            0|  0.00%|        elif is_categorical_dtype(dtype):
  2988|         0|            0|            0|  0.00%|            subarr = Categorical([value] * len(index))
  2989|         0|            0|            0|  0.00%|        else:
  2990|         0|            0|            0|  0.00%|            if not isinstance(dtype, (np.dtype, type(np.dtype))):
  2991|         0|            0|            0|  0.00%|                dtype = dtype.dtype
  2992|         0|            0|            0|  0.00%|            subarr = np.empty(len(index), dtype=dtype)
  2993|         0|            0|            0|  0.00%|            subarr.fill(value)
  2994|         0|            0|            0|  0.00%|
  2995|         0|            0|            0|  0.00%|        return subarr
  2996|         0|            0|            0|  0.00%|
  2997|         0|            0|            0|  0.00%|    # scalar like, GH
  2998|         0|            0|            0|  0.00%|    if getattr(subarr, 'ndim', 0) == 0:
  2999|         0|            0|            0|  0.00%|        if isinstance(data, list):  # pragma: no cover
  3000|         0|            0|            0|  0.00%|            subarr = np.array(data, dtype=object)
  3001|         0|            0|            0|  0.00%|        elif index is not None:
  3002|         0|            0|            0|  0.00%|            value = data
  3003|         0|            0|            0|  0.00%|
  3004|         0|            0|            0|  0.00%|            # figure out the dtype from the value (upcast if necessary)
  3005|         0|            0|            0|  0.00%|            if dtype is None:
  3006|         0|            0|            0|  0.00%|                dtype, value = infer_dtype_from_scalar(value)
  3007|         0|            0|            0|  0.00%|            else:
  3008|         0|            0|            0|  0.00%|                # need to possibly convert the value here
  3009|         0|            0|            0|  0.00%|                value = maybe_cast_to_datetime(value, dtype)
  3010|         0|            0|            0|  0.00%|
  3011|         0|            0|            0|  0.00%|            subarr = create_from_value(value, index, dtype)
  3012|         0|            0|            0|  0.00%|
  3013|         0|            0|            0|  0.00%|        else:
  3014|         0|            0|            0|  0.00%|            return subarr.item()
  3015|         0|            0|            0|  0.00%|
  3016|         0|            0|            0|  0.00%|    # the result that we want
  3017|         0|            0|            0|  0.00%|    elif subarr.ndim == 1:
  3018|         0|            0|            0|  0.00%|        if index is not None:
  3019|         0|            0|            0|  0.00%|
  3020|         0|            0|            0|  0.00%|            # a 1-element ndarray
  3021|         0|            0|            0|  0.00%|            if len(subarr) != len(index) and len(subarr) == 1:
  3022|         0|            0|            0|  0.00%|                subarr = create_from_value(subarr[0], index,
  3023|         0|            0|            0|  0.00%|                                           subarr.dtype)
  3024|         0|            0|            0|  0.00%|
  3025|         0|            0|            0|  0.00%|    elif subarr.ndim > 1:
  3026|         0|            0|            0|  0.00%|        if isinstance(data, np.ndarray):
  3027|         0|            0|            0|  0.00%|            raise Exception('Data must be 1-dimensional')
  3028|         0|            0|            0|  0.00%|        else:
  3029|         0|            0|            0|  0.00%|            subarr = _asarray_tuplesafe(data, dtype=dtype)
  3030|         0|            0|            0|  0.00%|
  3031|         0|            0|            0|  0.00%|    # This is to prevent mixed-type Series getting all casted to
  3032|         0|            0|            0|  0.00%|    # NumPy string type, e.g. NaN --> '-1#IND'.
  3033|         0|            0|            0|  0.00%|    if issubclass(subarr.dtype.type, compat.string_types):
  3034|         0|            0|            0|  0.00%|        subarr = np.array(data, dtype=object, copy=copy)
  3035|         0|            0|            0|  0.00%|
  3036|         0|            0|            0|  0.00%|    return subarr
  3037|         0|            0|            0|  0.00%|
  3038|         0|            0|            0|  0.00%|
  3039|         0|            0|            0|  0.00%|# ----------------------------------------------------------------------
  3040|         0|            0|            0|  0.00%|# Add plotting methods to Series
  3041|         0|            0|            0|  0.00%|
  3042|         0|            0|            0|  0.00%|import pandas.plotting._core as _gfx  # noqa
  3043|         0|            0|            0|  0.00%|
  3044|         0|            0|            0|  0.00%|Series.plot = base.AccessorProperty(_gfx.SeriesPlotMethods,
  3045|         0|            0|            0|  0.00%|                                    _gfx.SeriesPlotMethods)
  3046|         0|            0|            0|  0.00%|Series.hist = _gfx.hist_series
  3047|         0|            0|            0|  0.00%|
  3048|         0|            0|            0|  0.00%|# Add arithmetic!
  3049|         0|            0|            0|  0.00%|ops.add_flex_arithmetic_methods(Series, **ops.series_flex_funcs)
  3050|         0|            0|            0|  0.00%|ops.add_special_arithmetic_methods(Series, **ops.series_special_funcs)
File: D:\Application\Anaconda\lib\site-packages\tornado\ioloop.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|#!/usr/bin/env python
     2|         0|            0|            0|  0.00%|#
     3|         0|            0|            0|  0.00%|# Copyright 2009 Facebook
     4|         0|            0|            0|  0.00%|#
     5|         0|            0|            0|  0.00%|# Licensed under the Apache License, Version 2.0 (the "License"); you may
     6|         0|            0|            0|  0.00%|# not use this file except in compliance with the License. You may obtain
     7|         0|            0|            0|  0.00%|# a copy of the License at
     8|         0|            0|            0|  0.00%|#
     9|         0|            0|            0|  0.00%|#     http://www.apache.org/licenses/LICENSE-2.0
    10|         0|            0|            0|  0.00%|#
    11|         0|            0|            0|  0.00%|# Unless required by applicable law or agreed to in writing, software
    12|         0|            0|            0|  0.00%|# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
    13|         0|            0|            0|  0.00%|# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
    14|         0|            0|            0|  0.00%|# License for the specific language governing permissions and limitations
    15|         0|            0|            0|  0.00%|# under the License.
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|"""An I/O event loop for non-blocking sockets.
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|Typical applications will use a single `IOLoop` object, in the
    20|         0|            0|            0|  0.00%|`IOLoop.instance` singleton.  The `IOLoop.start` method should usually
    21|         0|            0|            0|  0.00%|be called at the end of the ``main()`` function.  Atypical applications may
    22|         0|            0|            0|  0.00%|use more than one `IOLoop`, such as one `IOLoop` per thread, or per `unittest`
    23|         0|            0|            0|  0.00%|case.
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|In addition to I/O events, the `IOLoop` can also schedule time-based events.
    26|         0|            0|            0|  0.00%|`IOLoop.add_timeout` is a non-blocking alternative to `time.sleep`.
    27|         0|            0|            0|  0.00%|"""
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|from __future__ import absolute_import, division, print_function
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|import collections
    32|         0|            0|            0|  0.00%|import datetime
    33|         0|            0|            0|  0.00%|import errno
    34|         0|            0|            0|  0.00%|import functools
    35|         0|            0|            0|  0.00%|import heapq
    36|         0|            0|            0|  0.00%|import itertools
    37|         0|            0|            0|  0.00%|import logging
    38|         0|            0|            0|  0.00%|import numbers
    39|         0|            0|            0|  0.00%|import os
    40|         0|            0|            0|  0.00%|import select
    41|         0|            0|            0|  0.00%|import sys
    42|         0|            0|            0|  0.00%|import threading
    43|         0|            0|            0|  0.00%|import time
    44|         0|            0|            0|  0.00%|import traceback
    45|         0|            0|            0|  0.00%|import math
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|from tornado.concurrent import TracebackFuture, is_future
    48|         0|            0|            0|  0.00%|from tornado.log import app_log, gen_log
    49|         0|            0|            0|  0.00%|from tornado.platform.auto import set_close_exec, Waker
    50|         0|            0|            0|  0.00%|from tornado import stack_context
    51|         0|            0|            0|  0.00%|from tornado.util import PY3, Configurable, errno_from_exception, timedelta_to_seconds
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|try:
    54|         0|            0|            0|  0.00%|    import signal
    55|         0|            0|            0|  0.00%|except ImportError:
    56|         0|            0|            0|  0.00%|    signal = None
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|if PY3:
    60|         0|            0|            0|  0.00%|    import _thread as thread
    61|         0|            0|            0|  0.00%|else:
    62|         0|            0|            0|  0.00%|    import thread
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|_POLL_TIMEOUT = 3600.0
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|class TimeoutError(Exception):
    69|         0|            0|            0|  0.00%|    pass
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|class IOLoop(Configurable):
    73|         0|            0|            0|  0.00%|    """A level-triggered I/O loop.
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|    We use ``epoll`` (Linux) or ``kqueue`` (BSD and Mac OS X) if they
    76|         0|            0|            0|  0.00%|    are available, or else we fall back on select(). If you are
    77|         0|            0|            0|  0.00%|    implementing a system that needs to handle thousands of
    78|         0|            0|            0|  0.00%|    simultaneous connections, you should use a system that supports
    79|         0|            0|            0|  0.00%|    either ``epoll`` or ``kqueue``.
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|    Example usage for a simple TCP server:
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|    .. testcode::
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|        import errno
    86|         0|            0|            0|  0.00%|        import functools
    87|         0|            0|            0|  0.00%|        import tornado.ioloop
    88|         0|            0|            0|  0.00%|        import socket
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|        def connection_ready(sock, fd, events):
    91|         0|            0|            0|  0.00%|            while True:
    92|         0|            0|            0|  0.00%|                try:
    93|         0|            0|            0|  0.00%|                    connection, address = sock.accept()
    94|         0|            0|            0|  0.00%|                except socket.error as e:
    95|         0|            0|            0|  0.00%|                    if e.args[0] not in (errno.EWOULDBLOCK, errno.EAGAIN):
    96|         0|            0|            0|  0.00%|                        raise
    97|         0|            0|            0|  0.00%|                    return
    98|         0|            0|            0|  0.00%|                connection.setblocking(0)
    99|         0|            0|            0|  0.00%|                handle_connection(connection, address)
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|        if __name__ == '__main__':
   102|         0|            0|            0|  0.00%|            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
   103|         0|            0|            0|  0.00%|            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
   104|         0|            0|            0|  0.00%|            sock.setblocking(0)
   105|         0|            0|            0|  0.00%|            sock.bind(("", port))
   106|         0|            0|            0|  0.00%|            sock.listen(128)
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|            io_loop = tornado.ioloop.IOLoop.current()
   109|         0|            0|            0|  0.00%|            callback = functools.partial(connection_ready, sock)
   110|         0|            0|            0|  0.00%|            io_loop.add_handler(sock.fileno(), callback, io_loop.READ)
   111|         0|            0|            0|  0.00%|            io_loop.start()
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|    .. testoutput::
   114|         0|            0|            0|  0.00%|       :hide:
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|    By default, a newly-constructed `IOLoop` becomes the thread's current
   117|         0|            0|            0|  0.00%|    `IOLoop`, unless there already is a current `IOLoop`. This behavior
   118|         0|            0|            0|  0.00%|    can be controlled with the ``make_current`` argument to the `IOLoop`
   119|         0|            0|            0|  0.00%|    constructor: if ``make_current=True``, the new `IOLoop` will always
   120|         0|            0|            0|  0.00%|    try to become current and it raises an error if there is already a
   121|         0|            0|            0|  0.00%|    current instance. If ``make_current=False``, the new `IOLoop` will
   122|         0|            0|            0|  0.00%|    not try to become current.
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|    .. versionchanged:: 4.2
   125|         0|            0|            0|  0.00%|       Added the ``make_current`` keyword argument to the `IOLoop`
   126|         0|            0|            0|  0.00%|       constructor.
   127|         0|            0|            0|  0.00%|    """
   128|         0|            0|            0|  0.00%|    # Constants from the epoll module
   129|         0|            0|            0|  0.00%|    _EPOLLIN = 0x001
   130|         0|            0|            0|  0.00%|    _EPOLLPRI = 0x002
   131|         0|            0|            0|  0.00%|    _EPOLLOUT = 0x004
   132|         0|            0|            0|  0.00%|    _EPOLLERR = 0x008
   133|         0|            0|            0|  0.00%|    _EPOLLHUP = 0x010
   134|         0|            0|            0|  0.00%|    _EPOLLRDHUP = 0x2000
   135|         0|            0|            0|  0.00%|    _EPOLLONESHOT = (1 << 30)
   136|         0|            0|            0|  0.00%|    _EPOLLET = (1 << 31)
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|    # Our events map exactly to the epoll events
   139|         0|            0|            0|  0.00%|    NONE = 0
   140|         0|            0|            0|  0.00%|    READ = _EPOLLIN
   141|         0|            0|            0|  0.00%|    WRITE = _EPOLLOUT
   142|         0|            0|            0|  0.00%|    ERROR = _EPOLLERR | _EPOLLHUP
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    # Global lock for creating global IOLoop instance
   145|         0|            0|            0|  0.00%|    _instance_lock = threading.Lock()
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|    _current = threading.local()
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|    @staticmethod
   150|         0|            0|            0|  0.00%|    def instance():
   151|         0|            0|            0|  0.00%|        """Returns a global `IOLoop` instance.
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|        Most applications have a single, global `IOLoop` running on the
   154|         0|            0|            0|  0.00%|        main thread.  Use this method to get this instance from
   155|         0|            0|            0|  0.00%|        another thread.  In most other cases, it is better to use `current()`
   156|         0|            0|            0|  0.00%|        to get the current thread's `IOLoop`.
   157|         0|            0|            0|  0.00%|        """
   158|         0|            0|            0|  0.00%|        if not hasattr(IOLoop, "_instance"):
   159|         0|            0|            0|  0.00%|            with IOLoop._instance_lock:
   160|         0|            0|            0|  0.00%|                if not hasattr(IOLoop, "_instance"):
   161|         0|            0|            0|  0.00%|                    # New instance after double check
   162|         0|            0|            0|  0.00%|                    IOLoop._instance = IOLoop()
   163|         0|            0|            0|  0.00%|        return IOLoop._instance
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|    @staticmethod
   166|         0|            0|            0|  0.00%|    def initialized():
   167|         0|            0|            0|  0.00%|        """Returns true if the singleton instance has been created."""
   168|         0|            0|            0|  0.00%|        return hasattr(IOLoop, "_instance")
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    def install(self):
   171|         0|            0|            0|  0.00%|        """Installs this `IOLoop` object as the singleton instance.
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|        This is normally not necessary as `instance()` will create
   174|         0|            0|            0|  0.00%|        an `IOLoop` on demand, but you may want to call `install` to use
   175|         0|            0|            0|  0.00%|        a custom subclass of `IOLoop`.
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|        When using an `IOLoop` subclass, `install` must be called prior
   178|         0|            0|            0|  0.00%|        to creating any objects that implicitly create their own
   179|         0|            0|            0|  0.00%|        `IOLoop` (e.g., :class:`tornado.httpclient.AsyncHTTPClient`).
   180|         0|            0|            0|  0.00%|        """
   181|         0|            0|            0|  0.00%|        assert not IOLoop.initialized()
   182|         0|            0|            0|  0.00%|        IOLoop._instance = self
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|    @staticmethod
   185|         0|            0|            0|  0.00%|    def clear_instance():
   186|         0|            0|            0|  0.00%|        """Clear the global `IOLoop` instance.
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|        .. versionadded:: 4.0
   189|         0|            0|            0|  0.00%|        """
   190|         0|            0|            0|  0.00%|        if hasattr(IOLoop, "_instance"):
   191|         0|            0|            0|  0.00%|            del IOLoop._instance
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|    @staticmethod
   194|         0|            0|            0|  0.00%|    def current(instance=True):
   195|         0|            0|            0|  0.00%|        """Returns the current thread's `IOLoop`.
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|        If an `IOLoop` is currently running or has been marked as
   198|         0|            0|            0|  0.00%|        current by `make_current`, returns that instance.  If there is
   199|         0|            0|            0|  0.00%|        no current `IOLoop`, returns `IOLoop.instance()` (i.e. the
   200|         0|            0|            0|  0.00%|        main thread's `IOLoop`, creating one if necessary) if ``instance``
   201|         0|            0|            0|  0.00%|        is true.
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|        In general you should use `IOLoop.current` as the default when
   204|         0|            0|            0|  0.00%|        constructing an asynchronous object, and use `IOLoop.instance`
   205|         0|            0|            0|  0.00%|        when you mean to communicate to the main thread from a different
   206|         0|            0|            0|  0.00%|        one.
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|        .. versionchanged:: 4.1
   209|         0|            0|            0|  0.00%|           Added ``instance`` argument to control the fallback to
   210|         0|            0|            0|  0.00%|           `IOLoop.instance()`.
   211|         0|            0|            0|  0.00%|        """
   212|         0|            0|            0|  0.00%|        current = getattr(IOLoop._current, "instance", None)
   213|         0|            0|            0|  0.00%|        if current is None and instance:
   214|         0|            0|            0|  0.00%|            return IOLoop.instance()
   215|         0|            0|            0|  0.00%|        return current
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|    def make_current(self):
   218|         0|            0|            0|  0.00%|        """Makes this the `IOLoop` for the current thread.
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|        An `IOLoop` automatically becomes current for its thread
   221|         0|            0|            0|  0.00%|        when it is started, but it is sometimes useful to call
   222|         0|            0|            0|  0.00%|        `make_current` explicitly before starting the `IOLoop`,
   223|         0|            0|            0|  0.00%|        so that code run at startup time can find the right
   224|         0|            0|            0|  0.00%|        instance.
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|        .. versionchanged:: 4.1
   227|         0|            0|            0|  0.00%|           An `IOLoop` created while there is no current `IOLoop`
   228|         0|            0|            0|  0.00%|           will automatically become current.
   229|         0|            0|            0|  0.00%|        """
   230|         0|            0|            0|  0.00%|        IOLoop._current.instance = self
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|    @staticmethod
   233|         0|            0|            0|  0.00%|    def clear_current():
   234|         0|            0|            0|  0.00%|        IOLoop._current.instance = None
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|    @classmethod
   237|         0|            0|            0|  0.00%|    def configurable_base(cls):
   238|         0|            0|            0|  0.00%|        return IOLoop
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|    @classmethod
   241|         0|            0|            0|  0.00%|    def configurable_default(cls):
   242|         0|            0|            0|  0.00%|        if hasattr(select, "epoll"):
   243|         0|            0|            0|  0.00%|            from tornado.platform.epoll import EPollIOLoop
   244|         0|            0|            0|  0.00%|            return EPollIOLoop
   245|         0|            0|            0|  0.00%|        if hasattr(select, "kqueue"):
   246|         0|            0|            0|  0.00%|            # Python 2.6+ on BSD or Mac
   247|         0|            0|            0|  0.00%|            from tornado.platform.kqueue import KQueueIOLoop
   248|         0|            0|            0|  0.00%|            return KQueueIOLoop
   249|         0|            0|            0|  0.00%|        from tornado.platform.select import SelectIOLoop
   250|         0|            0|            0|  0.00%|        return SelectIOLoop
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|    def initialize(self, make_current=None):
   253|         0|            0|            0|  0.00%|        if make_current is None:
   254|         0|            0|            0|  0.00%|            if IOLoop.current(instance=False) is None:
   255|         0|            0|            0|  0.00%|                self.make_current()
   256|         0|            0|            0|  0.00%|        elif make_current:
   257|         0|            0|            0|  0.00%|            if IOLoop.current(instance=False) is not None:
   258|         0|            0|            0|  0.00%|                raise RuntimeError("current IOLoop already exists")
   259|         0|            0|            0|  0.00%|            self.make_current()
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|    def close(self, all_fds=False):
   262|         0|            0|            0|  0.00%|        """Closes the `IOLoop`, freeing any resources used.
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|        If ``all_fds`` is true, all file descriptors registered on the
   265|         0|            0|            0|  0.00%|        IOLoop will be closed (not just the ones created by the
   266|         0|            0|            0|  0.00%|        `IOLoop` itself).
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|        Many applications will only use a single `IOLoop` that runs for the
   269|         0|            0|            0|  0.00%|        entire lifetime of the process.  In that case closing the `IOLoop`
   270|         0|            0|            0|  0.00%|        is not necessary since everything will be cleaned up when the
   271|         0|            0|            0|  0.00%|        process exits.  `IOLoop.close` is provided mainly for scenarios
   272|         0|            0|            0|  0.00%|        such as unit tests, which create and destroy a large number of
   273|         0|            0|            0|  0.00%|        ``IOLoops``.
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|        An `IOLoop` must be completely stopped before it can be closed.  This
   276|         0|            0|            0|  0.00%|        means that `IOLoop.stop()` must be called *and* `IOLoop.start()` must
   277|         0|            0|            0|  0.00%|        be allowed to return before attempting to call `IOLoop.close()`.
   278|         0|            0|            0|  0.00%|        Therefore the call to `close` will usually appear just after
   279|         0|            0|            0|  0.00%|        the call to `start` rather than near the call to `stop`.
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|        .. versionchanged:: 3.1
   282|         0|            0|            0|  0.00%|           If the `IOLoop` implementation supports non-integer objects
   283|         0|            0|            0|  0.00%|           for "file descriptors", those objects will have their
   284|         0|            0|            0|  0.00%|           ``close`` method when ``all_fds`` is true.
   285|         0|            0|            0|  0.00%|        """
   286|         0|            0|            0|  0.00%|        raise NotImplementedError()
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|    def add_handler(self, fd, handler, events):
   289|         0|            0|            0|  0.00%|        """Registers the given handler to receive the given events for ``fd``.
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|        The ``fd`` argument may either be an integer file descriptor or
   292|         0|            0|            0|  0.00%|        a file-like object with a ``fileno()`` method (and optionally a
   293|         0|            0|            0|  0.00%|        ``close()`` method, which may be called when the `IOLoop` is shut
   294|         0|            0|            0|  0.00%|        down).
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|        The ``events`` argument is a bitwise or of the constants
   297|         0|            0|            0|  0.00%|        ``IOLoop.READ``, ``IOLoop.WRITE``, and ``IOLoop.ERROR``.
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|        When an event occurs, ``handler(fd, events)`` will be run.
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|        .. versionchanged:: 4.0
   302|         0|            0|            0|  0.00%|           Added the ability to pass file-like objects in addition to
   303|         0|            0|            0|  0.00%|           raw file descriptors.
   304|         0|            0|            0|  0.00%|        """
   305|         0|            0|            0|  0.00%|        raise NotImplementedError()
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|    def update_handler(self, fd, events):
   308|         0|            0|            0|  0.00%|        """Changes the events we listen for ``fd``.
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|        .. versionchanged:: 4.0
   311|         0|            0|            0|  0.00%|           Added the ability to pass file-like objects in addition to
   312|         0|            0|            0|  0.00%|           raw file descriptors.
   313|         0|            0|            0|  0.00%|        """
   314|         0|            0|            0|  0.00%|        raise NotImplementedError()
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|    def remove_handler(self, fd):
   317|         0|            0|            0|  0.00%|        """Stop listening for events on ``fd``.
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|        .. versionchanged:: 4.0
   320|         0|            0|            0|  0.00%|           Added the ability to pass file-like objects in addition to
   321|         0|            0|            0|  0.00%|           raw file descriptors.
   322|         0|            0|            0|  0.00%|        """
   323|         0|            0|            0|  0.00%|        raise NotImplementedError()
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|    def set_blocking_signal_threshold(self, seconds, action):
   326|         0|            0|            0|  0.00%|        """Sends a signal if the `IOLoop` is blocked for more than
   327|         0|            0|            0|  0.00%|        ``s`` seconds.
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|        Pass ``seconds=None`` to disable.  Requires Python 2.6 on a unixy
   330|         0|            0|            0|  0.00%|        platform.
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|        The action parameter is a Python signal handler.  Read the
   333|         0|            0|            0|  0.00%|        documentation for the `signal` module for more information.
   334|         0|            0|            0|  0.00%|        If ``action`` is None, the process will be killed if it is
   335|         0|            0|            0|  0.00%|        blocked for too long.
   336|         0|            0|            0|  0.00%|        """
   337|         0|            0|            0|  0.00%|        raise NotImplementedError()
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|    def set_blocking_log_threshold(self, seconds):
   340|         0|            0|            0|  0.00%|        """Logs a stack trace if the `IOLoop` is blocked for more than
   341|         0|            0|            0|  0.00%|        ``s`` seconds.
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|        Equivalent to ``set_blocking_signal_threshold(seconds,
   344|         0|            0|            0|  0.00%|        self.log_stack)``
   345|         0|            0|            0|  0.00%|        """
   346|         0|            0|            0|  0.00%|        self.set_blocking_signal_threshold(seconds, self.log_stack)
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|    def log_stack(self, signal, frame):
   349|         0|            0|            0|  0.00%|        """Signal handler to log the stack trace of the current thread.
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|        For use with `set_blocking_signal_threshold`.
   352|         0|            0|            0|  0.00%|        """
   353|         0|            0|            0|  0.00%|        gen_log.warning('IOLoop blocked for %f seconds in\n%s',
   354|         0|            0|            0|  0.00%|                        self._blocking_signal_threshold,
   355|         0|            0|            0|  0.00%|                        ''.join(traceback.format_stack(frame)))
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|    def start(self):
   358|         0|            0|            0|  0.00%|        """Starts the I/O loop.
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|        The loop will run until one of the callbacks calls `stop()`, which
   361|         0|            0|            0|  0.00%|        will make the loop stop after the current event iteration completes.
   362|         0|            0|            0|  0.00%|        """
   363|         0|            0|            0|  0.00%|        raise NotImplementedError()
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|    def _setup_logging(self):
   366|         0|            0|            0|  0.00%|        """The IOLoop catches and logs exceptions, so it's
   367|         0|            0|            0|  0.00%|        important that log output be visible.  However, python's
   368|         0|            0|            0|  0.00%|        default behavior for non-root loggers (prior to python
   369|         0|            0|            0|  0.00%|        3.2) is to print an unhelpful "no handlers could be
   370|         0|            0|            0|  0.00%|        found" message rather than the actual log entry, so we
   371|         0|            0|            0|  0.00%|        must explicitly configure logging if we've made it this
   372|         0|            0|            0|  0.00%|        far without anything.
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|        This method should be called from start() in subclasses.
   375|         0|            0|            0|  0.00%|        """
   376|         0|            0|            0|  0.00%|        if not any([logging.getLogger().handlers,
   377|         0|            0|            0|  0.00%|                    logging.getLogger('tornado').handlers,
   378|         0|            0|            0|  0.00%|                    logging.getLogger('tornado.application').handlers]):
   379|         0|            0|            0|  0.00%|            logging.basicConfig()
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|    def stop(self):
   382|         0|            0|            0|  0.00%|        """Stop the I/O loop.
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|        If the event loop is not currently running, the next call to `start()`
   385|         0|            0|            0|  0.00%|        will return immediately.
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|        To use asynchronous methods from otherwise-synchronous code (such as
   388|         0|            0|            0|  0.00%|        unit tests), you can start and stop the event loop like this::
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|          ioloop = IOLoop()
   391|         0|            0|            0|  0.00%|          async_method(ioloop=ioloop, callback=ioloop.stop)
   392|         0|            0|            0|  0.00%|          ioloop.start()
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|        ``ioloop.start()`` will return after ``async_method`` has run
   395|         0|            0|            0|  0.00%|        its callback, whether that callback was invoked before or
   396|         0|            0|            0|  0.00%|        after ``ioloop.start``.
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|        Note that even after `stop` has been called, the `IOLoop` is not
   399|         0|            0|            0|  0.00%|        completely stopped until `IOLoop.start` has also returned.
   400|         0|            0|            0|  0.00%|        Some work that was scheduled before the call to `stop` may still
   401|         0|            0|            0|  0.00%|        be run before the `IOLoop` shuts down.
   402|         0|            0|            0|  0.00%|        """
   403|         0|            0|            0|  0.00%|        raise NotImplementedError()
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|    def run_sync(self, func, timeout=None):
   406|         0|            0|            0|  0.00%|        """Starts the `IOLoop`, runs the given function, and stops the loop.
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|        The function must return either a yieldable object or
   409|         0|            0|            0|  0.00%|        ``None``. If the function returns a yieldable object, the
   410|         0|            0|            0|  0.00%|        `IOLoop` will run until the yieldable is resolved (and
   411|         0|            0|            0|  0.00%|        `run_sync()` will return the yieldable's result). If it raises
   412|         0|            0|            0|  0.00%|        an exception, the `IOLoop` will stop and the exception will be
   413|         0|            0|            0|  0.00%|        re-raised to the caller.
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|        The keyword-only argument ``timeout`` may be used to set
   416|         0|            0|            0|  0.00%|        a maximum duration for the function.  If the timeout expires,
   417|         0|            0|            0|  0.00%|        a `TimeoutError` is raised.
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|        This method is useful in conjunction with `tornado.gen.coroutine`
   420|         0|            0|            0|  0.00%|        to allow asynchronous calls in a ``main()`` function::
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|            @gen.coroutine
   423|         0|            0|            0|  0.00%|            def main():
   424|         0|            0|            0|  0.00%|                # do stuff...
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|            if __name__ == '__main__':
   427|         0|            0|            0|  0.00%|                IOLoop.current().run_sync(main)
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|        .. versionchanged:: 4.3
   430|         0|            0|            0|  0.00%|           Returning a non-``None``, non-yieldable value is now an error.
   431|         0|            0|            0|  0.00%|        """
   432|         0|            0|            0|  0.00%|        future_cell = [None]
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|        def run():
   435|         0|            0|            0|  0.00%|            try:
   436|         0|            0|            0|  0.00%|                result = func()
   437|         0|            0|            0|  0.00%|                if result is not None:
   438|         0|            0|            0|  0.00%|                    from tornado.gen import convert_yielded
   439|         0|            0|            0|  0.00%|                    result = convert_yielded(result)
   440|         0|            0|            0|  0.00%|            except Exception:
   441|         0|            0|            0|  0.00%|                future_cell[0] = TracebackFuture()
   442|         0|            0|            0|  0.00%|                future_cell[0].set_exc_info(sys.exc_info())
   443|         0|            0|            0|  0.00%|            else:
   444|         0|            0|            0|  0.00%|                if is_future(result):
   445|         0|            0|            0|  0.00%|                    future_cell[0] = result
   446|         0|            0|            0|  0.00%|                else:
   447|         0|            0|            0|  0.00%|                    future_cell[0] = TracebackFuture()
   448|         0|            0|            0|  0.00%|                    future_cell[0].set_result(result)
   449|         0|            0|            0|  0.00%|            self.add_future(future_cell[0], lambda future: self.stop())
   450|         0|            0|            0|  0.00%|        self.add_callback(run)
   451|         0|            0|            0|  0.00%|        if timeout is not None:
   452|         0|            0|            0|  0.00%|            timeout_handle = self.add_timeout(self.time() + timeout, self.stop)
   453|         0|            0|            0|  0.00%|        self.start()
   454|         0|            0|            0|  0.00%|        if timeout is not None:
   455|         0|            0|            0|  0.00%|            self.remove_timeout(timeout_handle)
   456|         0|            0|            0|  0.00%|        if not future_cell[0].done():
   457|         0|            0|            0|  0.00%|            raise TimeoutError('Operation timed out after %s seconds' % timeout)
   458|         0|            0|            0|  0.00%|        return future_cell[0].result()
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|    def time(self):
   461|         0|            0|            0|  0.00%|        """Returns the current time according to the `IOLoop`'s clock.
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|        The return value is a floating-point number relative to an
   464|         0|            0|            0|  0.00%|        unspecified time in the past.
   465|         0|            0|            0|  0.00%|
   466|         0|            0|            0|  0.00%|        By default, the `IOLoop`'s time function is `time.time`.  However,
   467|         0|            0|            0|  0.00%|        it may be configured to use e.g. `time.monotonic` instead.
   468|         0|            0|            0|  0.00%|        Calls to `add_timeout` that pass a number instead of a
   469|         0|            0|            0|  0.00%|        `datetime.timedelta` should use this function to compute the
   470|         0|            0|            0|  0.00%|        appropriate time, so they can work no matter what time function
   471|         0|            0|            0|  0.00%|        is chosen.
   472|         0|            0|            0|  0.00%|        """
   473|         0|            0|            0|  0.00%|        return time.time()
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|    def add_timeout(self, deadline, callback, *args, **kwargs):
   476|         0|            0|            0|  0.00%|        """Runs the ``callback`` at the time ``deadline`` from the I/O loop.
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|        Returns an opaque handle that may be passed to
   479|         0|            0|            0|  0.00%|        `remove_timeout` to cancel.
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|        ``deadline`` may be a number denoting a time (on the same
   482|         0|            0|            0|  0.00%|        scale as `IOLoop.time`, normally `time.time`), or a
   483|         0|            0|            0|  0.00%|        `datetime.timedelta` object for a deadline relative to the
   484|         0|            0|            0|  0.00%|        current time.  Since Tornado 4.0, `call_later` is a more
   485|         0|            0|            0|  0.00%|        convenient alternative for the relative case since it does not
   486|         0|            0|            0|  0.00%|        require a timedelta object.
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|        Note that it is not safe to call `add_timeout` from other threads.
   489|         0|            0|            0|  0.00%|        Instead, you must use `add_callback` to transfer control to the
   490|         0|            0|            0|  0.00%|        `IOLoop`'s thread, and then call `add_timeout` from there.
   491|         0|            0|            0|  0.00%|
   492|         0|            0|            0|  0.00%|        Subclasses of IOLoop must implement either `add_timeout` or
   493|         0|            0|            0|  0.00%|        `call_at`; the default implementations of each will call
   494|         0|            0|            0|  0.00%|        the other.  `call_at` is usually easier to implement, but
   495|         0|            0|            0|  0.00%|        subclasses that wish to maintain compatibility with Tornado
   496|         0|            0|            0|  0.00%|        versions prior to 4.0 must use `add_timeout` instead.
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|        .. versionchanged:: 4.0
   499|         0|            0|            0|  0.00%|           Now passes through ``*args`` and ``**kwargs`` to the callback.
   500|         0|            0|            0|  0.00%|        """
   501|         0|            0|            0|  0.00%|        if isinstance(deadline, numbers.Real):
   502|         0|            0|            0|  0.00%|            return self.call_at(deadline, callback, *args, **kwargs)
   503|         0|            0|            0|  0.00%|        elif isinstance(deadline, datetime.timedelta):
   504|         0|            0|            0|  0.00%|            return self.call_at(self.time() + timedelta_to_seconds(deadline),
   505|         0|            0|            0|  0.00%|                                callback, *args, **kwargs)
   506|         0|            0|            0|  0.00%|        else:
   507|         0|            0|            0|  0.00%|            raise TypeError("Unsupported deadline %r" % deadline)
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|    def call_later(self, delay, callback, *args, **kwargs):
   510|         0|            0|            0|  0.00%|        """Runs the ``callback`` after ``delay`` seconds have passed.
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|        Returns an opaque handle that may be passed to `remove_timeout`
   513|         0|            0|            0|  0.00%|        to cancel.  Note that unlike the `asyncio` method of the same
   514|         0|            0|            0|  0.00%|        name, the returned object does not have a ``cancel()`` method.
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|        See `add_timeout` for comments on thread-safety and subclassing.
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|        .. versionadded:: 4.0
   519|         0|            0|            0|  0.00%|        """
   520|         0|            0|            0|  0.00%|        return self.call_at(self.time() + delay, callback, *args, **kwargs)
   521|         0|            0|            0|  0.00%|
   522|         0|            0|            0|  0.00%|    def call_at(self, when, callback, *args, **kwargs):
   523|         0|            0|            0|  0.00%|        """Runs the ``callback`` at the absolute time designated by ``when``.
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|        ``when`` must be a number using the same reference point as
   526|         0|            0|            0|  0.00%|        `IOLoop.time`.
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|        Returns an opaque handle that may be passed to `remove_timeout`
   529|         0|            0|            0|  0.00%|        to cancel.  Note that unlike the `asyncio` method of the same
   530|         0|            0|            0|  0.00%|        name, the returned object does not have a ``cancel()`` method.
   531|         0|            0|            0|  0.00%|
   532|         0|            0|            0|  0.00%|        See `add_timeout` for comments on thread-safety and subclassing.
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|        .. versionadded:: 4.0
   535|         0|            0|            0|  0.00%|        """
   536|         0|            0|            0|  0.00%|        return self.add_timeout(when, callback, *args, **kwargs)
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|    def remove_timeout(self, timeout):
   539|         0|            0|            0|  0.00%|        """Cancels a pending timeout.
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|        The argument is a handle as returned by `add_timeout`.  It is
   542|         0|            0|            0|  0.00%|        safe to call `remove_timeout` even if the callback has already
   543|         0|            0|            0|  0.00%|        been run.
   544|         0|            0|            0|  0.00%|        """
   545|         0|            0|            0|  0.00%|        raise NotImplementedError()
   546|         0|            0|            0|  0.00%|
   547|         0|            0|            0|  0.00%|    def add_callback(self, callback, *args, **kwargs):
   548|         0|            0|            0|  0.00%|        """Calls the given callback on the next I/O loop iteration.
   549|         0|            0|            0|  0.00%|
   550|         0|            0|            0|  0.00%|        It is safe to call this method from any thread at any time,
   551|         0|            0|            0|  0.00%|        except from a signal handler.  Note that this is the **only**
   552|         0|            0|            0|  0.00%|        method in `IOLoop` that makes this thread-safety guarantee; all
   553|         0|            0|            0|  0.00%|        other interaction with the `IOLoop` must be done from that
   554|         0|            0|            0|  0.00%|        `IOLoop`'s thread.  `add_callback()` may be used to transfer
   555|         0|            0|            0|  0.00%|        control from other threads to the `IOLoop`'s thread.
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|        To add a callback from a signal handler, see
   558|         0|            0|            0|  0.00%|        `add_callback_from_signal`.
   559|         0|            0|            0|  0.00%|        """
   560|         0|            0|            0|  0.00%|        raise NotImplementedError()
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|    def add_callback_from_signal(self, callback, *args, **kwargs):
   563|         0|            0|            0|  0.00%|        """Calls the given callback on the next I/O loop iteration.
   564|         0|            0|            0|  0.00%|
   565|         0|            0|            0|  0.00%|        Safe for use from a Python signal handler; should not be used
   566|         0|            0|            0|  0.00%|        otherwise.
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|        Callbacks added with this method will be run without any
   569|         0|            0|            0|  0.00%|        `.stack_context`, to avoid picking up the context of the function
   570|         0|            0|            0|  0.00%|        that was interrupted by the signal.
   571|         0|            0|            0|  0.00%|        """
   572|         0|            0|            0|  0.00%|        raise NotImplementedError()
   573|         0|            0|            0|  0.00%|
   574|         0|            0|            0|  0.00%|    def spawn_callback(self, callback, *args, **kwargs):
   575|         0|            0|            0|  0.00%|        """Calls the given callback on the next IOLoop iteration.
   576|         0|            0|            0|  0.00%|
   577|         0|            0|            0|  0.00%|        Unlike all other callback-related methods on IOLoop,
   578|         0|            0|            0|  0.00%|        ``spawn_callback`` does not associate the callback with its caller's
   579|         0|            0|            0|  0.00%|        ``stack_context``, so it is suitable for fire-and-forget callbacks
   580|         0|            0|            0|  0.00%|        that should not interfere with the caller.
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|        .. versionadded:: 4.0
   583|         0|            0|            0|  0.00%|        """
   584|         0|            0|            0|  0.00%|        with stack_context.NullContext():
   585|         0|            0|            0|  0.00%|            self.add_callback(callback, *args, **kwargs)
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|    def add_future(self, future, callback):
   588|         0|            0|            0|  0.00%|        """Schedules a callback on the ``IOLoop`` when the given
   589|         0|            0|            0|  0.00%|        `.Future` is finished.
   590|         0|            0|            0|  0.00%|
   591|         0|            0|            0|  0.00%|        The callback is invoked with one argument, the
   592|         0|            0|            0|  0.00%|        `.Future`.
   593|         0|            0|            0|  0.00%|        """
   594|         0|            0|            0|  0.00%|        assert is_future(future)
   595|         0|            0|            0|  0.00%|        callback = stack_context.wrap(callback)
   596|         0|            0|            0|  0.00%|        future.add_done_callback(
   597|         0|            0|            0|  0.00%|            lambda future: self.add_callback(callback, future))
   598|         0|            0|            0|  0.00%|
   599|         0|            0|            0|  0.00%|    def _run_callback(self, callback):
   600|         0|            0|            0|  0.00%|        """Runs a callback with error handling.
   601|         0|            0|            0|  0.00%|
   602|         0|            0|            0|  0.00%|        For use in subclasses.
   603|         0|            0|            0|  0.00%|        """
   604|         0|            0|            0|  0.00%|        try:
   605|         0|            0|            0|  0.00%|            ret = callback()
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\tornado\stack_context.py:273 null_wrapper
   606|         0|            0|            0|  0.00%|            if ret is not None:
   607|         0|            0|            0|  0.00%|                from tornado import gen
   608|         0|            0|            0|  0.00%|                # Functions that return Futures typically swallow all
   609|         0|            0|            0|  0.00%|                # exceptions and store them in the Future.  If a Future
   610|         0|            0|            0|  0.00%|                # makes it out to the IOLoop, ensure its exception (if any)
   611|         0|            0|            0|  0.00%|                # gets logged too.
   612|         0|            0|            0|  0.00%|                try:
   613|         0|            0|            0|  0.00%|                    ret = gen.convert_yielded(ret)
   614|         0|            0|            0|  0.00%|                except gen.BadYieldError:
   615|         0|            0|            0|  0.00%|                    # It's not unusual for add_callback to be used with
   616|         0|            0|            0|  0.00%|                    # methods returning a non-None and non-yieldable
   617|         0|            0|            0|  0.00%|                    # result, which should just be ignored.
   618|         0|            0|            0|  0.00%|                    pass
   619|         0|            0|            0|  0.00%|                else:
   620|         0|            0|            0|  0.00%|                    self.add_future(ret, self._discard_future_result)
   621|         0|            0|            0|  0.00%|        except Exception:
   622|         0|            0|            0|  0.00%|            self.handle_callback_exception(callback)
   623|         0|            0|            0|  0.00%|
   624|         0|            0|            0|  0.00%|    def _discard_future_result(self, future):
   625|         0|            0|            0|  0.00%|        """Avoid unhandled-exception warnings from spawned coroutines."""
   626|         0|            0|            0|  0.00%|        future.result()
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|    def handle_callback_exception(self, callback):
   629|         0|            0|            0|  0.00%|        """This method is called whenever a callback run by the `IOLoop`
   630|         0|            0|            0|  0.00%|        throws an exception.
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|        By default simply logs the exception as an error.  Subclasses
   633|         0|            0|            0|  0.00%|        may override this method to customize reporting of exceptions.
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|        The exception itself is not passed explicitly, but is available
   636|         0|            0|            0|  0.00%|        in `sys.exc_info`.
   637|         0|            0|            0|  0.00%|        """
   638|         0|            0|            0|  0.00%|        app_log.error("Exception in callback %r", callback, exc_info=True)
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|    def split_fd(self, fd):
   641|         0|            0|            0|  0.00%|        """Returns an (fd, obj) pair from an ``fd`` parameter.
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|        We accept both raw file descriptors and file-like objects as
   644|         0|            0|            0|  0.00%|        input to `add_handler` and related methods.  When a file-like
   645|         0|            0|            0|  0.00%|        object is passed, we must retain the object itself so we can
   646|         0|            0|            0|  0.00%|        close it correctly when the `IOLoop` shuts down, but the
   647|         0|            0|            0|  0.00%|        poller interfaces favor file descriptors (they will accept
   648|         0|            0|            0|  0.00%|        file-like objects and call ``fileno()`` for you, but they
   649|         0|            0|            0|  0.00%|        always return the descriptor itself).
   650|         0|            0|            0|  0.00%|
   651|         0|            0|            0|  0.00%|        This method is provided for use by `IOLoop` subclasses and should
   652|         0|            0|            0|  0.00%|        not generally be used by application code.
   653|         0|            0|            0|  0.00%|
   654|         0|            0|            0|  0.00%|        .. versionadded:: 4.0
   655|         0|            0|            0|  0.00%|        """
   656|         0|            0|            0|  0.00%|        try:
   657|         0|            0|            0|  0.00%|            return fd.fileno(), fd
   658|         0|            0|            0|  0.00%|        except AttributeError:
   659|         0|            0|            0|  0.00%|            return fd, fd
   660|         0|            0|            0|  0.00%|
   661|         0|            0|            0|  0.00%|    def close_fd(self, fd):
   662|         0|            0|            0|  0.00%|        """Utility method to close an ``fd``.
   663|         0|            0|            0|  0.00%|
   664|         0|            0|            0|  0.00%|        If ``fd`` is a file-like object, we close it directly; otherwise
   665|         0|            0|            0|  0.00%|        we use `os.close`.
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|        This method is provided for use by `IOLoop` subclasses (in
   668|         0|            0|            0|  0.00%|        implementations of ``IOLoop.close(all_fds=True)`` and should
   669|         0|            0|            0|  0.00%|        not generally be used by application code.
   670|         0|            0|            0|  0.00%|
   671|         0|            0|            0|  0.00%|        .. versionadded:: 4.0
   672|         0|            0|            0|  0.00%|        """
   673|         0|            0|            0|  0.00%|        try:
   674|         0|            0|            0|  0.00%|            try:
   675|         0|            0|            0|  0.00%|                fd.close()
   676|         0|            0|            0|  0.00%|            except AttributeError:
   677|         0|            0|            0|  0.00%|                os.close(fd)
   678|         0|            0|            0|  0.00%|        except OSError:
   679|         0|            0|            0|  0.00%|            pass
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|
   682|         0|            0|            0|  0.00%|class PollIOLoop(IOLoop):
   683|         0|            0|            0|  0.00%|    """Base class for IOLoops built around a select-like function.
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|    For concrete implementations, see `tornado.platform.epoll.EPollIOLoop`
   686|         0|            0|            0|  0.00%|    (Linux), `tornado.platform.kqueue.KQueueIOLoop` (BSD and Mac), or
   687|         0|            0|            0|  0.00%|    `tornado.platform.select.SelectIOLoop` (all platforms).
   688|         0|            0|            0|  0.00%|    """
   689|         0|            0|            0|  0.00%|    def initialize(self, impl, time_func=None, **kwargs):
   690|         0|            0|            0|  0.00%|        super(PollIOLoop, self).initialize(**kwargs)
   691|         0|            0|            0|  0.00%|        self._impl = impl
   692|         0|            0|            0|  0.00%|        if hasattr(self._impl, 'fileno'):
   693|         0|            0|            0|  0.00%|            set_close_exec(self._impl.fileno())
   694|         0|            0|            0|  0.00%|        self.time_func = time_func or time.time
   695|         0|            0|            0|  0.00%|        self._handlers = {}
   696|         0|            0|            0|  0.00%|        self._events = {}
   697|         0|            0|            0|  0.00%|        self._callbacks = collections.deque()
   698|         0|            0|            0|  0.00%|        self._timeouts = []
   699|         0|            0|            0|  0.00%|        self._cancellations = 0
   700|         0|            0|            0|  0.00%|        self._running = False
   701|         0|            0|            0|  0.00%|        self._stopped = False
   702|         0|            0|            0|  0.00%|        self._closing = False
   703|         0|            0|            0|  0.00%|        self._thread_ident = None
   704|         0|            0|            0|  0.00%|        self._blocking_signal_threshold = None
   705|         0|            0|            0|  0.00%|        self._timeout_counter = itertools.count()
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|        # Create a pipe that we send bogus data to when we want to wake
   708|         0|            0|            0|  0.00%|        # the I/O loop when it is idle
   709|         0|            0|            0|  0.00%|        self._waker = Waker()
   710|         0|            0|            0|  0.00%|        self.add_handler(self._waker.fileno(),
   711|         0|            0|            0|  0.00%|                         lambda fd, events: self._waker.consume(),
   712|         0|            0|            0|  0.00%|                         self.READ)
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|    def close(self, all_fds=False):
   715|         0|            0|            0|  0.00%|        self._closing = True
   716|         0|            0|            0|  0.00%|        self.remove_handler(self._waker.fileno())
   717|         0|            0|            0|  0.00%|        if all_fds:
   718|         0|            0|            0|  0.00%|            for fd, handler in list(self._handlers.values()):
   719|         0|            0|            0|  0.00%|                self.close_fd(fd)
   720|         0|            0|            0|  0.00%|        self._waker.close()
   721|         0|            0|            0|  0.00%|        self._impl.close()
   722|         0|            0|            0|  0.00%|        self._callbacks = None
   723|         0|            0|            0|  0.00%|        self._timeouts = None
   724|         0|            0|            0|  0.00%|
   725|         0|            0|            0|  0.00%|    def add_handler(self, fd, handler, events):
   726|         0|            0|            0|  0.00%|        fd, obj = self.split_fd(fd)
   727|         0|            0|            0|  0.00%|        self._handlers[fd] = (obj, stack_context.wrap(handler))
   728|         0|            0|            0|  0.00%|        self._impl.register(fd, events | self.ERROR)
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|    def update_handler(self, fd, events):
   731|         0|            0|            0|  0.00%|        fd, obj = self.split_fd(fd)
   732|         0|            0|            0|  0.00%|        self._impl.modify(fd, events | self.ERROR)
   733|         0|            0|            0|  0.00%|
   734|         0|            0|            0|  0.00%|    def remove_handler(self, fd):
   735|         0|            0|            0|  0.00%|        fd, obj = self.split_fd(fd)
   736|         0|            0|            0|  0.00%|        self._handlers.pop(fd, None)
   737|         0|            0|            0|  0.00%|        self._events.pop(fd, None)
   738|         0|            0|            0|  0.00%|        try:
   739|         0|            0|            0|  0.00%|            self._impl.unregister(fd)
   740|         0|            0|            0|  0.00%|        except Exception:
   741|         0|            0|            0|  0.00%|            gen_log.debug("Error deleting fd from IOLoop", exc_info=True)
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|    def set_blocking_signal_threshold(self, seconds, action):
   744|         0|            0|            0|  0.00%|        if not hasattr(signal, "setitimer"):
   745|         0|            0|            0|  0.00%|            gen_log.error("set_blocking_signal_threshold requires a signal module "
   746|         0|            0|            0|  0.00%|                          "with the setitimer method")
   747|         0|            0|            0|  0.00%|            return
   748|         0|            0|            0|  0.00%|        self._blocking_signal_threshold = seconds
   749|         0|            0|            0|  0.00%|        if seconds is not None:
   750|         0|            0|            0|  0.00%|            signal.signal(signal.SIGALRM,
   751|         0|            0|            0|  0.00%|                          action if action is not None else signal.SIG_DFL)
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|    def start(self):
   754|         0|            0|            0|  0.00%|        if self._running:
   755|         0|            0|            0|  0.00%|            raise RuntimeError("IOLoop is already running")
   756|         0|            0|            0|  0.00%|        self._setup_logging()
   757|         0|            0|            0|  0.00%|        if self._stopped:
   758|         0|            0|            0|  0.00%|            self._stopped = False
   759|         0|            0|            0|  0.00%|            return
   760|         0|            0|            0|  0.00%|        old_current = getattr(IOLoop._current, "instance", None)
   761|         0|            0|            0|  0.00%|        IOLoop._current.instance = self
   762|         0|            0|            0|  0.00%|        self._thread_ident = thread.get_ident()
   763|         0|            0|            0|  0.00%|        self._running = True
   764|         0|            0|            0|  0.00%|
   765|         0|            0|            0|  0.00%|        # signal.set_wakeup_fd closes a race condition in event loops:
   766|         0|            0|            0|  0.00%|        # a signal may arrive at the beginning of select/poll/etc
   767|         0|            0|            0|  0.00%|        # before it goes into its interruptible sleep, so the signal
   768|         0|            0|            0|  0.00%|        # will be consumed without waking the select.  The solution is
   769|         0|            0|            0|  0.00%|        # for the (C, synchronous) signal handler to write to a pipe,
   770|         0|            0|            0|  0.00%|        # which will then be seen by select.
   771|         0|            0|            0|  0.00%|        #
   772|         0|            0|            0|  0.00%|        # In python's signal handling semantics, this only matters on the
   773|         0|            0|            0|  0.00%|        # main thread (fortunately, set_wakeup_fd only works on the main
   774|         0|            0|            0|  0.00%|        # thread and will raise a ValueError otherwise).
   775|         0|            0|            0|  0.00%|        #
   776|         0|            0|            0|  0.00%|        # If someone has already set a wakeup fd, we don't want to
   777|         0|            0|            0|  0.00%|        # disturb it.  This is an issue for twisted, which does its
   778|         0|            0|            0|  0.00%|        # SIGCHLD processing in response to its own wakeup fd being
   779|         0|            0|            0|  0.00%|        # written to.  As long as the wakeup fd is registered on the IOLoop,
   780|         0|            0|            0|  0.00%|        # the loop will still wake up and everything should work.
   781|         0|            0|            0|  0.00%|        old_wakeup_fd = None
   782|         0|            0|            0|  0.00%|        if hasattr(signal, 'set_wakeup_fd') and os.name == 'posix':
   783|         0|            0|            0|  0.00%|            # requires python 2.6+, unix.  set_wakeup_fd exists but crashes
   784|         0|            0|            0|  0.00%|            # the python process on windows.
   785|         0|            0|            0|  0.00%|            try:
   786|         0|            0|            0|  0.00%|                old_wakeup_fd = signal.set_wakeup_fd(self._waker.write_fileno())
   787|         0|            0|            0|  0.00%|                if old_wakeup_fd != -1:
   788|         0|            0|            0|  0.00%|                    # Already set, restore previous value.  This is a little racy,
   789|         0|            0|            0|  0.00%|                    # but there's no clean get_wakeup_fd and in real use the
   790|         0|            0|            0|  0.00%|                    # IOLoop is just started once at the beginning.
   791|         0|            0|            0|  0.00%|                    signal.set_wakeup_fd(old_wakeup_fd)
   792|         0|            0|            0|  0.00%|                    old_wakeup_fd = None
   793|         0|            0|            0|  0.00%|            except ValueError:
   794|         0|            0|            0|  0.00%|                # Non-main thread, or the previous value of wakeup_fd
   795|         0|            0|            0|  0.00%|                # is no longer valid.
   796|         0|            0|            0|  0.00%|                old_wakeup_fd = None
   797|         0|            0|            0|  0.00%|
   798|         0|            0|            0|  0.00%|        try:
   799|         0|            0|            0|  0.00%|            while True:
   800|         0|            0|            0|  0.00%|                # Prevent IO event starvation by delaying new callbacks
   801|         0|            0|            0|  0.00%|                # to the next iteration of the event loop.
   802|         0|            0|            0|  0.00%|                ncallbacks = len(self._callbacks)
   803|         0|            0|            0|  0.00%|
   804|         0|            0|            0|  0.00%|                # Add any timeouts that have come due to the callback list.
   805|         0|            0|            0|  0.00%|                # Do not run anything until we have determined which ones
   806|         0|            0|            0|  0.00%|                # are ready, so timeouts that call add_timeout cannot
   807|         0|            0|            0|  0.00%|                # schedule anything in this iteration.
   808|         0|            0|            0|  0.00%|                due_timeouts = []
   809|         0|            0|            0|  0.00%|                if self._timeouts:
   810|         0|            0|            0|  0.00%|                    now = self.time()
   811|         0|            0|            0|  0.00%|                    while self._timeouts:
   812|         0|            0|            0|  0.00%|                        if self._timeouts[0].callback is None:
   813|         0|            0|            0|  0.00%|                            # The timeout was cancelled.  Note that the
   814|         0|            0|            0|  0.00%|                            # cancellation check is repeated below for timeouts
   815|         0|            0|            0|  0.00%|                            # that are cancelled by another timeout or callback.
   816|         0|            0|            0|  0.00%|                            heapq.heappop(self._timeouts)
   817|         0|            0|            0|  0.00%|                            self._cancellations -= 1
   818|         0|            0|            0|  0.00%|                        elif self._timeouts[0].deadline <= now:
   819|         0|            0|            0|  0.00%|                            due_timeouts.append(heapq.heappop(self._timeouts))
   820|         0|            0|            0|  0.00%|                        else:
   821|         0|            0|            0|  0.00%|                            break
   822|         0|            0|            0|  0.00%|                    if (self._cancellations > 512 and
   823|         0|            0|            0|  0.00%|                            self._cancellations > (len(self._timeouts) >> 1)):
   824|         0|            0|            0|  0.00%|                        # Clean up the timeout queue when it gets large and it's
   825|         0|            0|            0|  0.00%|                        # more than half cancellations.
   826|         0|            0|            0|  0.00%|                        self._cancellations = 0
   827|         0|            0|            0|  0.00%|                        self._timeouts = [x for x in self._timeouts
   828|         0|            0|            0|  0.00%|                                          if x.callback is not None]
   829|         0|            0|            0|  0.00%|                        heapq.heapify(self._timeouts)
   830|         0|            0|            0|  0.00%|
   831|         0|            0|            0|  0.00%|                for i in range(ncallbacks):
   832|         0|            0|            0|  0.00%|                    self._run_callback(self._callbacks.popleft())
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\tornado\ioloop.py:599 _run_callback
   833|         0|            0|            0|  0.00%|                for timeout in due_timeouts:
   834|         0|            0|            0|  0.00%|                    if timeout.callback is not None:
   835|         0|            0|            0|  0.00%|                        self._run_callback(timeout.callback)
   836|         0|            0|            0|  0.00%|                # Closures may be holding on to a lot of memory, so allow
   837|         0|            0|            0|  0.00%|                # them to be freed before we go into our poll wait.
   838|         0|            0|            0|  0.00%|                due_timeouts = timeout = None
   839|         0|            0|            0|  0.00%|
   840|         0|            0|            0|  0.00%|                if self._callbacks:
   841|         0|            0|            0|  0.00%|                    # If any callbacks or timeouts called add_callback,
   842|         0|            0|            0|  0.00%|                    # we don't want to wait in poll() before we run them.
   843|         0|            0|            0|  0.00%|                    poll_timeout = 0.0
   844|         0|            0|            0|  0.00%|                elif self._timeouts:
   845|         0|            0|            0|  0.00%|                    # If there are any timeouts, schedule the first one.
   846|         0|            0|            0|  0.00%|                    # Use self.time() instead of 'now' to account for time
   847|         0|            0|            0|  0.00%|                    # spent running callbacks.
   848|         0|            0|            0|  0.00%|                    poll_timeout = self._timeouts[0].deadline - self.time()
   849|         0|            0|            0|  0.00%|                    poll_timeout = max(0, min(poll_timeout, _POLL_TIMEOUT))
   850|         0|            0|            0|  0.00%|                else:
   851|         0|            0|            0|  0.00%|                    # No timeouts and no callbacks, so use the default.
   852|         0|            0|            0|  0.00%|                    poll_timeout = _POLL_TIMEOUT
   853|         0|            0|            0|  0.00%|
   854|         0|            0|            0|  0.00%|                if not self._running:
   855|         0|            0|            0|  0.00%|                    break
   856|         0|            0|            0|  0.00%|
   857|         0|            0|            0|  0.00%|                if self._blocking_signal_threshold is not None:
   858|         0|            0|            0|  0.00%|                    # clear alarm so it doesn't fire while poll is waiting for
   859|         0|            0|            0|  0.00%|                    # events.
   860|         0|            0|            0|  0.00%|                    signal.setitimer(signal.ITIMER_REAL, 0, 0)
   861|         0|            0|            0|  0.00%|
   862|         0|            0|            0|  0.00%|                try:
   863|         0|            0|            0|  0.00%|                    event_pairs = self._impl.poll(poll_timeout)
   864|         0|            0|            0|  0.00%|                except Exception as e:
   865|         0|            0|            0|  0.00%|                    # Depending on python version and IOLoop implementation,
   866|         0|            0|            0|  0.00%|                    # different exception types may be thrown and there are
   867|         0|            0|            0|  0.00%|                    # two ways EINTR might be signaled:
   868|         0|            0|            0|  0.00%|                    # * e.errno == errno.EINTR
   869|         0|            0|            0|  0.00%|                    # * e.args is like (errno.EINTR, 'Interrupted system call')
   870|         0|            0|            0|  0.00%|                    if errno_from_exception(e) == errno.EINTR:
   871|         0|            0|            0|  0.00%|                        continue
   872|         0|            0|            0|  0.00%|                    else:
   873|         0|            0|            0|  0.00%|                        raise
   874|         0|            0|            0|  0.00%|
   875|         0|            0|            0|  0.00%|                if self._blocking_signal_threshold is not None:
   876|         0|            0|            0|  0.00%|                    signal.setitimer(signal.ITIMER_REAL,
   877|         0|            0|            0|  0.00%|                                     self._blocking_signal_threshold, 0)
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|                # Pop one fd at a time from the set of pending fds and run
   880|         0|            0|            0|  0.00%|                # its handler. Since that handler may perform actions on
   881|         0|            0|            0|  0.00%|                # other file descriptors, there may be reentrant calls to
   882|         0|            0|            0|  0.00%|                # this IOLoop that modify self._events
   883|         0|            0|            0|  0.00%|                self._events.update(event_pairs)
   884|         0|            0|            0|  0.00%|                while self._events:
   885|         0|            0|            0|  0.00%|                    fd, events = self._events.popitem()
   886|         0|            0|            0|  0.00%|                    try:
   887|         0|            0|            0|  0.00%|                        fd_obj, handler_func = self._handlers[fd]
   888|         0|            0|            0|  0.00%|                        handler_func(fd_obj, events)
   889|         0|            0|            0|  0.00%|                    except (OSError, IOError) as e:
   890|         0|            0|            0|  0.00%|                        if errno_from_exception(e) == errno.EPIPE:
   891|         0|            0|            0|  0.00%|                            # Happens when the client closes the connection
   892|         0|            0|            0|  0.00%|                            pass
   893|         0|            0|            0|  0.00%|                        else:
   894|         0|            0|            0|  0.00%|                            self.handle_callback_exception(self._handlers.get(fd))
   895|         0|            0|            0|  0.00%|                    except Exception:
   896|         0|            0|            0|  0.00%|                        self.handle_callback_exception(self._handlers.get(fd))
   897|         0|            0|            0|  0.00%|                fd_obj = handler_func = None
   898|         0|            0|            0|  0.00%|
   899|         0|            0|            0|  0.00%|        finally:
   900|         0|            0|            0|  0.00%|            # reset the stopped flag so another start/stop pair can be issued
   901|         0|            0|            0|  0.00%|            self._stopped = False
   902|         0|            0|            0|  0.00%|            if self._blocking_signal_threshold is not None:
   903|         0|            0|            0|  0.00%|                signal.setitimer(signal.ITIMER_REAL, 0, 0)
   904|         0|            0|            0|  0.00%|            IOLoop._current.instance = old_current
   905|         0|            0|            0|  0.00%|            if old_wakeup_fd is not None:
   906|         0|            0|            0|  0.00%|                signal.set_wakeup_fd(old_wakeup_fd)
   907|         0|            0|            0|  0.00%|
   908|         0|            0|            0|  0.00%|    def stop(self):
   909|         0|            0|            0|  0.00%|        self._running = False
   910|         0|            0|            0|  0.00%|        self._stopped = True
   911|         0|            0|            0|  0.00%|        self._waker.wake()
   912|         0|            0|            0|  0.00%|
   913|         0|            0|            0|  0.00%|    def time(self):
   914|         0|            0|            0|  0.00%|        return self.time_func()
   915|         0|            0|            0|  0.00%|
   916|         0|            0|            0|  0.00%|    def call_at(self, deadline, callback, *args, **kwargs):
   917|         0|            0|            0|  0.00%|        timeout = _Timeout(
   918|         0|            0|            0|  0.00%|            deadline,
   919|         0|            0|            0|  0.00%|            functools.partial(stack_context.wrap(callback), *args, **kwargs),
   920|         0|            0|            0|  0.00%|            self)
   921|         0|            0|            0|  0.00%|        heapq.heappush(self._timeouts, timeout)
   922|         0|            0|            0|  0.00%|        return timeout
   923|         0|            0|            0|  0.00%|
   924|         0|            0|            0|  0.00%|    def remove_timeout(self, timeout):
   925|         0|            0|            0|  0.00%|        # Removing from a heap is complicated, so just leave the defunct
   926|         0|            0|            0|  0.00%|        # timeout object in the queue (see discussion in
   927|         0|            0|            0|  0.00%|        # http://docs.python.org/library/heapq.html).
   928|         0|            0|            0|  0.00%|        # If this turns out to be a problem, we could add a garbage
   929|         0|            0|            0|  0.00%|        # collection pass whenever there are too many dead timeouts.
   930|         0|            0|            0|  0.00%|        timeout.callback = None
   931|         0|            0|            0|  0.00%|        self._cancellations += 1
   932|         0|            0|            0|  0.00%|
   933|         0|            0|            0|  0.00%|    def add_callback(self, callback, *args, **kwargs):
   934|         0|            0|            0|  0.00%|        if self._closing:
   935|         0|            0|            0|  0.00%|            return
   936|         0|            0|            0|  0.00%|        # Blindly insert into self._callbacks. This is safe even
   937|         0|            0|            0|  0.00%|        # from signal handlers because deque.append is atomic.
   938|         0|            0|            0|  0.00%|        self._callbacks.append(functools.partial(
   939|         0|            0|            0|  0.00%|            stack_context.wrap(callback), *args, **kwargs))
   940|         0|            0|            0|  0.00%|        if thread.get_ident() != self._thread_ident:
   941|         0|            0|            0|  0.00%|            # This will write one byte but Waker.consume() reads many
   942|         0|            0|            0|  0.00%|            # at once, so it's ok to write even when not strictly
   943|         0|            0|            0|  0.00%|            # necessary.
   944|         0|            0|            0|  0.00%|            self._waker.wake()
   945|         0|            0|            0|  0.00%|        else:
   946|         0|            0|            0|  0.00%|            # If we're on the IOLoop's thread, we don't need to wake anyone.
   947|         0|            0|            0|  0.00%|            pass
   948|         0|            0|            0|  0.00%|
   949|         0|            0|            0|  0.00%|    def add_callback_from_signal(self, callback, *args, **kwargs):
   950|         0|            0|            0|  0.00%|        with stack_context.NullContext():
   951|         0|            0|            0|  0.00%|            self.add_callback(callback, *args, **kwargs)
   952|         0|            0|            0|  0.00%|
   953|         0|            0|            0|  0.00%|
   954|         0|            0|            0|  0.00%|class _Timeout(object):
   955|         0|            0|            0|  0.00%|    """An IOLoop timeout, a UNIX timestamp and a callback"""
   956|         0|            0|            0|  0.00%|
   957|         0|            0|            0|  0.00%|    # Reduce memory overhead when there are lots of pending callbacks
   958|         0|            0|            0|  0.00%|    __slots__ = ['deadline', 'callback', 'tdeadline']
   959|         0|            0|            0|  0.00%|
   960|         0|            0|            0|  0.00%|    def __init__(self, deadline, callback, io_loop):
   961|         0|            0|            0|  0.00%|        if not isinstance(deadline, numbers.Real):
   962|         0|            0|            0|  0.00%|            raise TypeError("Unsupported deadline %r" % deadline)
   963|         0|            0|            0|  0.00%|        self.deadline = deadline
   964|         0|            0|            0|  0.00%|        self.callback = callback
   965|         0|            0|            0|  0.00%|        self.tdeadline = (deadline, next(io_loop._timeout_counter))
   966|         0|            0|            0|  0.00%|
   967|         0|            0|            0|  0.00%|    # Comparison methods to sort by deadline, with object id as a tiebreaker
   968|         0|            0|            0|  0.00%|    # to guarantee a consistent ordering.  The heapq module uses __le__
   969|         0|            0|            0|  0.00%|    # in python2.5, and __lt__ in 2.6+ (sort() and most other comparisons
   970|         0|            0|            0|  0.00%|    # use __lt__).
   971|         0|            0|            0|  0.00%|    def __lt__(self, other):
   972|         0|            0|            0|  0.00%|        return self.tdeadline < other.tdeadline
   973|         0|            0|            0|  0.00%|
   974|         0|            0|            0|  0.00%|    def __le__(self, other):
   975|         0|            0|            0|  0.00%|        return self.tdeadline <= other.tdeadline
   976|         0|            0|            0|  0.00%|
   977|         0|            0|            0|  0.00%|
   978|         0|            0|            0|  0.00%|class PeriodicCallback(object):
   979|         0|            0|            0|  0.00%|    """Schedules the given callback to be called periodically.
   980|         0|            0|            0|  0.00%|
   981|         0|            0|            0|  0.00%|    The callback is called every ``callback_time`` milliseconds.
   982|         0|            0|            0|  0.00%|    Note that the timeout is given in milliseconds, while most other
   983|         0|            0|            0|  0.00%|    time-related functions in Tornado use seconds.
   984|         0|            0|            0|  0.00%|
   985|         0|            0|            0|  0.00%|    If the callback runs for longer than ``callback_time`` milliseconds,
   986|         0|            0|            0|  0.00%|    subsequent invocations will be skipped to get back on schedule.
   987|         0|            0|            0|  0.00%|
   988|         0|            0|            0|  0.00%|    `start` must be called after the `PeriodicCallback` is created.
   989|         0|            0|            0|  0.00%|
   990|         0|            0|            0|  0.00%|    .. versionchanged:: 4.1
   991|         0|            0|            0|  0.00%|       The ``io_loop`` argument is deprecated.
   992|         0|            0|            0|  0.00%|    """
   993|         0|            0|            0|  0.00%|    def __init__(self, callback, callback_time, io_loop=None):
   994|         0|            0|            0|  0.00%|        self.callback = callback
   995|         0|            0|            0|  0.00%|        if callback_time <= 0:
   996|         0|            0|            0|  0.00%|            raise ValueError("Periodic callback must have a positive callback_time")
   997|         0|            0|            0|  0.00%|        self.callback_time = callback_time
   998|         0|            0|            0|  0.00%|        self.io_loop = io_loop or IOLoop.current()
   999|         0|            0|            0|  0.00%|        self._running = False
  1000|         0|            0|            0|  0.00%|        self._timeout = None
  1001|         0|            0|            0|  0.00%|
  1002|         0|            0|            0|  0.00%|    def start(self):
  1003|         0|            0|            0|  0.00%|        """Starts the timer."""
  1004|         0|            0|            0|  0.00%|        self._running = True
  1005|         0|            0|            0|  0.00%|        self._next_timeout = self.io_loop.time()
  1006|         0|            0|            0|  0.00%|        self._schedule_next()
  1007|         0|            0|            0|  0.00%|
  1008|         0|            0|            0|  0.00%|    def stop(self):
  1009|         0|            0|            0|  0.00%|        """Stops the timer."""
  1010|         0|            0|            0|  0.00%|        self._running = False
  1011|         0|            0|            0|  0.00%|        if self._timeout is not None:
  1012|         0|            0|            0|  0.00%|            self.io_loop.remove_timeout(self._timeout)
  1013|         0|            0|            0|  0.00%|            self._timeout = None
  1014|         0|            0|            0|  0.00%|
  1015|         0|            0|            0|  0.00%|    def is_running(self):
  1016|         0|            0|            0|  0.00%|        """Return True if this `.PeriodicCallback` has been started.
  1017|         0|            0|            0|  0.00%|
  1018|         0|            0|            0|  0.00%|        .. versionadded:: 4.1
  1019|         0|            0|            0|  0.00%|        """
  1020|         0|            0|            0|  0.00%|        return self._running
  1021|         0|            0|            0|  0.00%|
  1022|         0|            0|            0|  0.00%|    def _run(self):
  1023|         0|            0|            0|  0.00%|        if not self._running:
  1024|         0|            0|            0|  0.00%|            return
  1025|         0|            0|            0|  0.00%|        try:
  1026|         0|            0|            0|  0.00%|            return self.callback()
  1027|         0|            0|            0|  0.00%|        except Exception:
  1028|         0|            0|            0|  0.00%|            self.io_loop.handle_callback_exception(self.callback)
  1029|         0|            0|            0|  0.00%|        finally:
  1030|         0|            0|            0|  0.00%|            self._schedule_next()
  1031|         0|            0|            0|  0.00%|
  1032|         0|            0|            0|  0.00%|    def _schedule_next(self):
  1033|         0|            0|            0|  0.00%|        if self._running:
  1034|         0|            0|            0|  0.00%|            current_time = self.io_loop.time()
  1035|         0|            0|            0|  0.00%|
  1036|         0|            0|            0|  0.00%|            if self._next_timeout <= current_time:
  1037|         0|            0|            0|  0.00%|                callback_time_sec = self.callback_time / 1000.0
  1038|         0|            0|            0|  0.00%|                self._next_timeout += (math.floor((current_time - self._next_timeout) /
  1039|         0|            0|            0|  0.00%|                                                  callback_time_sec) + 1) * callback_time_sec
  1040|         0|            0|            0|  0.00%|
  1041|         0|            0|            0|  0.00%|            self._timeout = self.io_loop.add_timeout(self._next_timeout, self._run)
File: D:\Application\Anaconda\lib\site-packages\spyder_kernels\customize\spydercustomize.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|#
     2|         0|            0|            0|  0.00%|# Copyright (c) 2009- Spyder Kernels Contributors
     3|         0|            0|            0|  0.00%|#
     4|         0|            0|            0|  0.00%|# Licensed under the terms of the MIT License
     5|         0|            0|            0|  0.00%|# (see spyder_kernels/__init__.py for details)
     6|         0|            0|            0|  0.00%|# -----------------------------------------------------------------------------
     7|         0|            0|            0|  0.00%|#
     8|         0|            0|            0|  0.00%|# IMPORTANT NOTE: Don't add a coding line here! It's not necessary for
     9|         0|            0|            0|  0.00%|# site files
    10|         0|            0|            0|  0.00%|#
    11|         0|            0|            0|  0.00%|# Spyder consoles sitecustomize
    12|         0|            0|            0|  0.00%|#
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|import bdb
    15|         0|            0|            0|  0.00%|from distutils.version import LooseVersion
    16|         0|            0|            0|  0.00%|import io
    17|         0|            0|            0|  0.00%|import os
    18|         0|            0|            0|  0.00%|import os.path as osp
    19|         0|            0|            0|  0.00%|import pdb
    20|         0|            0|            0|  0.00%|import re
    21|         0|            0|            0|  0.00%|import shlex
    22|         0|            0|            0|  0.00%|import sys
    23|         0|            0|            0|  0.00%|import sysconfig
    24|         0|            0|            0|  0.00%|import time
    25|         0|            0|            0|  0.00%|import warnings
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|from IPython.core.getipython import get_ipython
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|# We are in Python 2?
    31|         0|            0|            0|  0.00%|PY2 = sys.version[0] == '2'
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|#==============================================================================
    35|         0|            0|            0|  0.00%|# sys.argv can be missing when Python is embedded, taking care of it.
    36|         0|            0|            0|  0.00%|# Fixes Issue 1473 and other crazy crashes with IPython 0.13 trying to
    37|         0|            0|            0|  0.00%|# access it.
    38|         0|            0|            0|  0.00%|#==============================================================================
    39|         0|            0|            0|  0.00%|if not hasattr(sys, 'argv'):
    40|         0|            0|            0|  0.00%|    sys.argv = ['']
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|#==============================================================================
    44|         0|            0|            0|  0.00%|# Main constants
    45|         0|            0|            0|  0.00%|#==============================================================================
    46|         0|            0|            0|  0.00%|IS_EXT_INTERPRETER = os.environ.get('SPY_EXTERNAL_INTERPRETER') == "True"
    47|         0|            0|            0|  0.00%|HIDE_CMD_WINDOWS = os.environ.get('SPY_HIDE_CMD') == "True"
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|#==============================================================================
    50|         0|            0|            0|  0.00%|# Important Note:
    51|         0|            0|            0|  0.00%|#
    52|         0|            0|            0|  0.00%|# We avoid importing spyder here, so we are handling Python 3 compatiblity
    53|         0|            0|            0|  0.00%|# by hand.
    54|         0|            0|            0|  0.00%|#==============================================================================
    55|         0|            0|            0|  0.00%|def _print(*objects, **options):
    56|         0|            0|            0|  0.00%|    end = options.get('end', '\n')
    57|         0|            0|            0|  0.00%|    file = options.get('file', sys.stdout)
    58|         0|            0|            0|  0.00%|    sep = options.get('sep', ' ')
    59|         0|            0|            0|  0.00%|    string = sep.join([str(obj) for obj in objects])
    60|         0|            0|            0|  0.00%|    if not PY2:
    61|         0|            0|            0|  0.00%|        # Python 3
    62|         0|            0|            0|  0.00%|        local_dict = {}
    63|         0|            0|            0|  0.00%|        exec('printf = print', local_dict) # to avoid syntax error in Python 2
    64|         0|            0|            0|  0.00%|        local_dict['printf'](string, file=file, end=end, sep=sep)
    65|         0|            0|            0|  0.00%|    else:
    66|         0|            0|            0|  0.00%|        # Python 2
    67|         0|            0|            0|  0.00%|        if end:
    68|         0|            0|            0|  0.00%|            print >>file, string
    69|         0|            0|            0|  0.00%|        else:
    70|         0|            0|            0|  0.00%|            print >>file, string,
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|#==============================================================================
    74|         0|            0|            0|  0.00%|# Execfile functions
    75|         0|            0|            0|  0.00%|#
    76|         0|            0|            0|  0.00%|# The definitions for Python 2 on Windows were taken from the IPython project
    77|         0|            0|            0|  0.00%|# Copyright (C) The IPython Development Team
    78|         0|            0|            0|  0.00%|# Distributed under the terms of the modified BSD license
    79|         0|            0|            0|  0.00%|#==============================================================================
    80|         0|            0|            0|  0.00%|try:
    81|         0|            0|            0|  0.00%|    # Python 2
    82|         0|            0|            0|  0.00%|    import __builtin__ as builtins
    83|         0|            0|            0|  0.00%|    if os.name == 'nt':
    84|         0|            0|            0|  0.00%|        def encode(u):
    85|         0|            0|            0|  0.00%|            return u.encode('utf8', 'replace')
    86|         0|            0|            0|  0.00%|        def execfile(fname, glob=None, loc=None):
    87|         0|            0|            0|  0.00%|            loc = loc if (loc is not None) else glob
    88|         0|            0|            0|  0.00%|            scripttext = builtins.open(fname).read()+ '\n'
    89|         0|            0|            0|  0.00%|            # compile converts unicode filename to str assuming
    90|         0|            0|            0|  0.00%|            # ascii. Let's do the conversion before calling compile
    91|         0|            0|            0|  0.00%|            if isinstance(fname, unicode):
    92|         0|            0|            0|  0.00%|                filename = encode(fname)
    93|         0|            0|            0|  0.00%|            else:
    94|         0|            0|            0|  0.00%|                filename = fname
    95|         0|            0|            0|  0.00%|            exec(compile(scripttext, filename, 'exec'), glob, loc)
    96|         0|            0|            0|  0.00%|    else:
    97|         0|            0|            0|  0.00%|        def execfile(fname, *where):
    98|         0|            0|            0|  0.00%|            if isinstance(fname, unicode):
    99|         0|            0|            0|  0.00%|                filename = fname.encode(sys.getfilesystemencoding())
   100|         0|            0|            0|  0.00%|            else:
   101|         0|            0|            0|  0.00%|                filename = fname
   102|         0|            0|            0|  0.00%|            builtins.execfile(filename, *where)
   103|         0|            0|            0|  0.00%|except ImportError:
   104|         0|            0|            0|  0.00%|    # Python 3
   105|         0|            0|            0|  0.00%|    import builtins
   106|         0|            0|            0|  0.00%|    basestring = (str,)
   107|         0|            0|            0|  0.00%|    def execfile(filename, namespace):
   108|         0|            0|            0|  0.00%|        # Open a source file correctly, whatever its encoding is
   109|         0|            0|            0|  0.00%|        with open(filename, 'rb') as f:
   110|         0|            0|            0|  0.00%|            exec(compile(f.read(), filename, 'exec'), namespace)
(call)|       196|            0|            0|  0.00%|# D:/Users/JCHANGI/Jason Chang/Work/Project/Mix_Run_Ratio/Mix_Run_Ratio_caller_example.py:4 <module>
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|#==============================================================================
   114|         0|            0|            0|  0.00%|# Setting console encoding (otherwise Python does not recognize encoding)
   115|         0|            0|            0|  0.00%|# for Windows platforms
   116|         0|            0|            0|  0.00%|#==============================================================================
   117|         0|            0|            0|  0.00%|if os.name == 'nt' and PY2:
   118|         0|            0|            0|  0.00%|    try:
   119|         0|            0|            0|  0.00%|        import locale, ctypes
   120|         0|            0|            0|  0.00%|        _t, _cp = locale.getdefaultlocale('LANG')
   121|         0|            0|            0|  0.00%|        try:
   122|         0|            0|            0|  0.00%|            _cp = int(_cp[2:])
   123|         0|            0|            0|  0.00%|            ctypes.windll.kernel32.SetConsoleCP(_cp)
   124|         0|            0|            0|  0.00%|            ctypes.windll.kernel32.SetConsoleOutputCP(_cp)
   125|         0|            0|            0|  0.00%|        except (ValueError, TypeError):
   126|         0|            0|            0|  0.00%|            # Code page number in locale is not valid
   127|         0|            0|            0|  0.00%|            pass
   128|         0|            0|            0|  0.00%|    except:
   129|         0|            0|            0|  0.00%|        pass
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|#==============================================================================
   133|         0|            0|            0|  0.00%|# Prevent subprocess.Popen calls to create visible console windows on Windows.
   134|         0|            0|            0|  0.00%|# See issue #4932
   135|         0|            0|            0|  0.00%|#==============================================================================
   136|         0|            0|            0|  0.00%|if os.name == 'nt' and HIDE_CMD_WINDOWS:
   137|         0|            0|            0|  0.00%|    import subprocess
   138|         0|            0|            0|  0.00%|    creation_flag = 0x08000000  # CREATE_NO_WINDOW
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|    class SubprocessPopen(subprocess.Popen):
   141|         0|            0|            0|  0.00%|        def __init__(self, *args, **kwargs):
   142|         0|            0|            0|  0.00%|            kwargs['creationflags'] = creation_flag
   143|         0|            0|            0|  0.00%|            super(SubprocessPopen, self).__init__(*args, **kwargs)
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|    subprocess.Popen = SubprocessPopen
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|#==============================================================================
   148|         0|            0|            0|  0.00%|# Importing user's sitecustomize
   149|         0|            0|            0|  0.00%|#==============================================================================
   150|         0|            0|            0|  0.00%|try:
   151|         0|            0|            0|  0.00%|    import sitecustomize  #analysis:ignore
   152|         0|            0|            0|  0.00%|except:
   153|         0|            0|            0|  0.00%|    pass
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|#==============================================================================
   157|         0|            0|            0|  0.00%|# Add default filesystem encoding on Linux to avoid an error with
   158|         0|            0|            0|  0.00%|# Matplotlib 1.5 in Python 2 (Fixes Issue 2793)
   159|         0|            0|            0|  0.00%|#==============================================================================
   160|         0|            0|            0|  0.00%|if PY2 and sys.platform.startswith('linux'):
   161|         0|            0|            0|  0.00%|    def _getfilesystemencoding_wrapper():
   162|         0|            0|            0|  0.00%|        return 'utf-8'
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|    sys.getfilesystemencoding = _getfilesystemencoding_wrapper
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|#==============================================================================
   168|         0|            0|            0|  0.00%|# Set PyQt API to #2
   169|         0|            0|            0|  0.00%|#==============================================================================
   170|         0|            0|            0|  0.00%|if os.environ.get("QT_API") == 'pyqt':
   171|         0|            0|            0|  0.00%|    try:
   172|         0|            0|            0|  0.00%|        import sip
   173|         0|            0|            0|  0.00%|        for qtype in ('QString', 'QVariant', 'QDate', 'QDateTime',
   174|         0|            0|            0|  0.00%|                      'QTextStream', 'QTime', 'QUrl'):
   175|         0|            0|            0|  0.00%|            sip.setapi(qtype, 2)
   176|         0|            0|            0|  0.00%|    except:
   177|         0|            0|            0|  0.00%|        pass
   178|         0|            0|            0|  0.00%|else:
   179|         0|            0|            0|  0.00%|    try:
   180|         0|            0|            0|  0.00%|        os.environ.pop('QT_API')
   181|         0|            0|            0|  0.00%|    except KeyError:
   182|         0|            0|            0|  0.00%|        pass
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|#==============================================================================
   186|         0|            0|            0|  0.00%|# IPython kernel adjustments
   187|         0|            0|            0|  0.00%|#==============================================================================
   188|         0|            0|            0|  0.00%|# Use ipydb as the debugger to patch on IPython consoles
   189|         0|            0|            0|  0.00%|from IPython.core.debugger import Pdb as ipyPdb
   190|         0|            0|            0|  0.00%|pdb.Pdb = ipyPdb
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|# Patch unittest.main so that errors are printed directly in the console.
   193|         0|            0|            0|  0.00%|# See http://comments.gmane.org/gmane.comp.python.ipython.devel/10557
   194|         0|            0|            0|  0.00%|# Fixes Issue 1370
   195|         0|            0|            0|  0.00%|import unittest
   196|         0|            0|            0|  0.00%|from unittest import TestProgram
   197|         0|            0|            0|  0.00%|class IPyTesProgram(TestProgram):
   198|         0|            0|            0|  0.00%|    def __init__(self, *args, **kwargs):
   199|         0|            0|            0|  0.00%|        test_runner = unittest.TextTestRunner(stream=sys.stderr)
   200|         0|            0|            0|  0.00%|        kwargs['testRunner'] = kwargs.pop('testRunner', test_runner)
   201|         0|            0|            0|  0.00%|        kwargs['exit'] = False
   202|         0|            0|            0|  0.00%|        TestProgram.__init__(self, *args, **kwargs)
   203|         0|            0|            0|  0.00%|unittest.main = IPyTesProgram
   204|         0|            0|            0|  0.00%|
   205|         0|            0|            0|  0.00%|# Ignore some IPython/ipykernel warnings
   206|         0|            0|            0|  0.00%|try:
   207|         0|            0|            0|  0.00%|    warnings.filterwarnings(action='ignore', category=DeprecationWarning,
   208|         0|            0|            0|  0.00%|                            module='ipykernel.ipkernel')
   209|         0|            0|            0|  0.00%|except:
   210|         0|            0|            0|  0.00%|    pass
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|#==============================================================================
   213|         0|            0|            0|  0.00%|# Turtle adjustments
   214|         0|            0|            0|  0.00%|#==============================================================================
   215|         0|            0|            0|  0.00%|# This is needed to prevent turtle scripts crashes after multiple runs in the
   216|         0|            0|            0|  0.00%|# same IPython Console instance.
   217|         0|            0|            0|  0.00%|# See Spyder issue #6278
   218|         0|            0|            0|  0.00%|try:
   219|         0|            0|            0|  0.00%|    import turtle
   220|         0|            0|            0|  0.00%|    from turtle import Screen, Terminator
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|    def spyder_bye():
   223|         0|            0|            0|  0.00%|        try:
   224|         0|            0|            0|  0.00%|            Screen().bye()
   225|         0|            0|            0|  0.00%|            turtle.TurtleScreen._RUNNING = True
   226|         0|            0|            0|  0.00%|        except Terminator:
   227|         0|            0|            0|  0.00%|            pass
   228|         0|            0|            0|  0.00%|    turtle.bye = spyder_bye
   229|         0|            0|            0|  0.00%|except:
   230|         0|            0|            0|  0.00%|    pass
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|#==============================================================================
   234|         0|            0|            0|  0.00%|# Pandas adjustments
   235|         0|            0|            0|  0.00%|#==============================================================================
   236|         0|            0|            0|  0.00%|try:
   237|         0|            0|            0|  0.00%|    import pandas as pd
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|    # Set Pandas output encoding
   240|         0|            0|            0|  0.00%|    pd.options.display.encoding = 'utf-8'
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|    # Filter warning that appears for DataFrames with np.nan values
   243|         0|            0|            0|  0.00%|    # Example:
   244|         0|            0|            0|  0.00%|    # >>> import pandas as pd, numpy as np
   245|         0|            0|            0|  0.00%|    # >>> pd.Series([np.nan,np.nan,np.nan],index=[1,2,3])
   246|         0|            0|            0|  0.00%|    # Fixes Issue 2991
   247|         0|            0|            0|  0.00%|    # For 0.18-
   248|         0|            0|            0|  0.00%|    warnings.filterwarnings(action='ignore', category=RuntimeWarning,
   249|         0|            0|            0|  0.00%|                            module='pandas.core.format',
   250|         0|            0|            0|  0.00%|                            message=".*invalid value encountered in.*")
   251|         0|            0|            0|  0.00%|    # For 0.18.1+
   252|         0|            0|            0|  0.00%|    warnings.filterwarnings(action='ignore', category=RuntimeWarning,
   253|         0|            0|            0|  0.00%|                            module='pandas.formats.format',
   254|         0|            0|            0|  0.00%|                            message=".*invalid value encountered in.*")
   255|         0|            0|            0|  0.00%|except:
   256|         0|            0|            0|  0.00%|    pass
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|# =============================================================================
   260|         0|            0|            0|  0.00%|# Numpy adjustments
   261|         0|            0|            0|  0.00%|# =============================================================================
   262|         0|            0|            0|  0.00%|try:
   263|         0|            0|            0|  0.00%|    # Filter warning that appears when users have 'Show max/min'
   264|         0|            0|            0|  0.00%|    # turned on and Numpy arrays contain a nan value.
   265|         0|            0|            0|  0.00%|    # Fixes Issue 7063
   266|         0|            0|            0|  0.00%|    # Note: It only happens in Numpy 1.14+
   267|         0|            0|            0|  0.00%|    warnings.filterwarnings(action='ignore', category=RuntimeWarning,
   268|         0|            0|            0|  0.00%|                            module='numpy.core._methods',
   269|         0|            0|            0|  0.00%|                            message=".*invalid value encountered in.*")
   270|         0|            0|            0|  0.00%|except:
   271|         0|            0|            0|  0.00%|    pass
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|# =============================================================================
   275|         0|            0|            0|  0.00%|# Multiprocessing adjustments
   276|         0|            0|            0|  0.00%|# =============================================================================
   277|         0|            0|            0|  0.00%|# This patch is only needed on Windows and Python 3
   278|         0|            0|            0|  0.00%|if os.name == 'nt' and not PY2:
   279|         0|            0|            0|  0.00%|    # This could fail with changes in Python itself, so we protect it
   280|         0|            0|            0|  0.00%|    # with a try/except
   281|         0|            0|            0|  0.00%|    try:
   282|         0|            0|            0|  0.00%|        import multiprocessing.spawn
   283|         0|            0|            0|  0.00%|        _old_preparation_data = multiprocessing.spawn.get_preparation_data
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|        def _patched_preparation_data(name):
   286|         0|            0|            0|  0.00%|            """
   287|         0|            0|            0|  0.00%|            Patched get_preparation_data to work when all variables are
   288|         0|            0|            0|  0.00%|            removed before execution.
   289|         0|            0|            0|  0.00%|            """
   290|         0|            0|            0|  0.00%|            try:
   291|         0|            0|            0|  0.00%|                return _old_preparation_data(name)
   292|         0|            0|            0|  0.00%|            except AttributeError:
   293|         0|            0|            0|  0.00%|                main_module = sys.modules['__main__']
   294|         0|            0|            0|  0.00%|                # Any string for __spec__ does the job
   295|         0|            0|            0|  0.00%|                main_module.__spec__ = ''
   296|         0|            0|            0|  0.00%|                return _old_preparation_data(name)
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|        multiprocessing.spawn.get_preparation_data = _patched_preparation_data
   299|         0|            0|            0|  0.00%|    except Exception:
   300|         0|            0|            0|  0.00%|        pass
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|#==============================================================================
   304|         0|            0|            0|  0.00%|# Pdb adjustments
   305|         0|            0|            0|  0.00%|#==============================================================================
   306|         0|            0|            0|  0.00%|class SpyderPdb(pdb.Pdb):
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    send_initial_notification = True
   309|         0|            0|            0|  0.00%|    starting = True
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|    # --- Methods overriden by us
   312|         0|            0|            0|  0.00%|    def preloop(self):
   313|         0|            0|            0|  0.00%|        """Ask Spyder for berkpoints before the first prompt is created."""
   314|         0|            0|            0|  0.00%|        if self.starting:
   315|         0|            0|            0|  0.00%|            get_ipython().kernel._ask_spyder_for_breakpoints()
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|    # --- Methods defined by us
   318|         0|            0|            0|  0.00%|    def set_spyder_breakpoints(self, breakpoints):
   319|         0|            0|            0|  0.00%|        self.clear_all_breaks()
   320|         0|            0|            0|  0.00%|        #------Really deleting all breakpoints:
   321|         0|            0|            0|  0.00%|        for bp in bdb.Breakpoint.bpbynumber:
   322|         0|            0|            0|  0.00%|            if bp:
   323|         0|            0|            0|  0.00%|                bp.deleteMe()
   324|         0|            0|            0|  0.00%|        bdb.Breakpoint.next = 1
   325|         0|            0|            0|  0.00%|        bdb.Breakpoint.bplist = {}
   326|         0|            0|            0|  0.00%|        bdb.Breakpoint.bpbynumber = [None]
   327|         0|            0|            0|  0.00%|        #------
   328|         0|            0|            0|  0.00%|        i = 0
   329|         0|            0|            0|  0.00%|        for fname, data in list(breakpoints.items()):
   330|         0|            0|            0|  0.00%|            if osp.isfile(fname):
   331|         0|            0|            0|  0.00%|                for linenumber, condition in data:
   332|         0|            0|            0|  0.00%|                    i += 1
   333|         0|            0|            0|  0.00%|                    self.set_break(self.canonic(fname), linenumber,
   334|         0|            0|            0|  0.00%|                                   cond=condition)
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|        # Jump to first breakpoint.
   337|         0|            0|            0|  0.00%|        # Fixes issue 2034
   338|         0|            0|            0|  0.00%|        if self.starting:
   339|         0|            0|            0|  0.00%|            # Only run this after a Pdb session is created
   340|         0|            0|            0|  0.00%|            self.starting = False
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|            # Get all breakpoints for the file we're going to debug
   343|         0|            0|            0|  0.00%|            frame = self.curframe
   344|         0|            0|            0|  0.00%|            lineno = frame.f_lineno
   345|         0|            0|            0|  0.00%|            breaks = self.get_file_breaks(frame.f_code.co_filename)
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|            # Do 'continue' if the first breakpoint is *not* placed
   348|         0|            0|            0|  0.00%|            # where the debugger is going to land.
   349|         0|            0|            0|  0.00%|            # Fixes issue 4681
   350|         0|            0|            0|  0.00%|            if breaks and lineno != breaks[0] and osp.isfile(fname):
   351|         0|            0|            0|  0.00%|                get_ipython().kernel.pdb_continue()
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|    def notify_spyder(self, frame):
   354|         0|            0|            0|  0.00%|        if not frame:
   355|         0|            0|            0|  0.00%|            return
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|        kernel = get_ipython().kernel
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|        # Get filename and line number of the current frame
   360|         0|            0|            0|  0.00%|        fname = self.canonic(frame.f_code.co_filename)
   361|         0|            0|            0|  0.00%|        if PY2:
   362|         0|            0|            0|  0.00%|            try:
   363|         0|            0|            0|  0.00%|                fname = unicode(fname, "utf-8")
   364|         0|            0|            0|  0.00%|            except TypeError:
   365|         0|            0|            0|  0.00%|                pass
   366|         0|            0|            0|  0.00%|        lineno = frame.f_lineno
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|        # Set step of the current frame (if any)
   369|         0|            0|            0|  0.00%|        step = {}
   370|         0|            0|            0|  0.00%|        if isinstance(fname, basestring) and isinstance(lineno, int):
   371|         0|            0|            0|  0.00%|            if osp.isfile(fname):
   372|         0|            0|            0|  0.00%|                step = dict(fname=fname, lineno=lineno)
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|        # Publish Pdb state so we can update the Variable Explorer
   375|         0|            0|            0|  0.00%|        # and the Editor on the Spyder side
   376|         0|            0|            0|  0.00%|        kernel._pdb_step = step
   377|         0|            0|            0|  0.00%|        kernel.publish_pdb_state()
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|pdb.Pdb = SpyderPdb
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|#XXX: I know, this function is now also implemented as is in utils/misc.py but
   384|         0|            0|            0|  0.00%|#     I'm kind of reluctant to import spyder in sitecustomize, even if this
   385|         0|            0|            0|  0.00%|#     import is very clean.
   386|         0|            0|            0|  0.00%|def monkeypatch_method(cls, patch_name):
   387|         0|            0|            0|  0.00%|    # This function's code was inspired from the following thread:
   388|         0|            0|            0|  0.00%|    # "[Python-Dev] Monkeypatching idioms -- elegant or ugly?"
   389|         0|            0|            0|  0.00%|    # by Robert Brewer <fumanchu at aminus.org>
   390|         0|            0|            0|  0.00%|    # (Tue Jan 15 19:13:25 CET 2008)
   391|         0|            0|            0|  0.00%|    """
   392|         0|            0|            0|  0.00%|    Add the decorated method to the given class; replace as needed.
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|    If the named method already exists on the given class, it will
   395|         0|            0|            0|  0.00%|    be replaced, and a reference to the old method is created as
   396|         0|            0|            0|  0.00%|    cls._old<patch_name><name>. If the "_old_<patch_name>_<name>" attribute
   397|         0|            0|            0|  0.00%|    already exists, KeyError is raised.
   398|         0|            0|            0|  0.00%|    """
   399|         0|            0|            0|  0.00%|    def decorator(func):
   400|         0|            0|            0|  0.00%|        fname = func.__name__
   401|         0|            0|            0|  0.00%|        old_func = getattr(cls, fname, None)
   402|         0|            0|            0|  0.00%|        if old_func is not None:
   403|         0|            0|            0|  0.00%|            # Add the old func to a list of old funcs.
   404|         0|            0|            0|  0.00%|            old_ref = "_old_%s_%s" % (patch_name, fname)
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|            old_attr = getattr(cls, old_ref, None)
   407|         0|            0|            0|  0.00%|            if old_attr is None:
   408|         0|            0|            0|  0.00%|                setattr(cls, old_ref, old_func)
   409|         0|            0|            0|  0.00%|            else:
   410|         0|            0|            0|  0.00%|                raise KeyError("%s.%s already exists."
   411|         0|            0|            0|  0.00%|                               % (cls.__name__, old_ref))
   412|         0|            0|            0|  0.00%|        setattr(cls, fname, func)
   413|         0|            0|            0|  0.00%|        return func
   414|         0|            0|            0|  0.00%|    return decorator
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|@monkeypatch_method(pdb.Pdb, 'Pdb')
   418|         0|            0|            0|  0.00%|def __init__(self, completekey='tab', stdin=None, stdout=None,
   419|         0|            0|            0|  0.00%|             skip=None, nosigint=False):
   420|         0|            0|            0|  0.00%|    self._old_Pdb___init__()
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|@monkeypatch_method(pdb.Pdb, 'Pdb')
   424|         0|            0|            0|  0.00%|def user_return(self, frame, return_value):
   425|         0|            0|            0|  0.00%|    """This function is called when a return trap is set here."""
   426|         0|            0|            0|  0.00%|    # This is useful when debugging in an active interpreter (otherwise,
   427|         0|            0|            0|  0.00%|    # the debugger will stop before reaching the target file)
   428|         0|            0|            0|  0.00%|    if self._wait_for_mainpyfile:
   429|         0|            0|            0|  0.00%|        if (self.mainpyfile != self.canonic(frame.f_code.co_filename)
   430|         0|            0|            0|  0.00%|            or frame.f_lineno<= 0):
   431|         0|            0|            0|  0.00%|            return
   432|         0|            0|            0|  0.00%|        self._wait_for_mainpyfile = 0
   433|         0|            0|            0|  0.00%|    self._old_Pdb_user_return(frame, return_value)
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|@monkeypatch_method(pdb.Pdb, 'Pdb')
   437|         0|            0|            0|  0.00%|def interaction(self, frame, traceback):
   438|         0|            0|            0|  0.00%|    if frame is not None and "spydercustomize.py" in frame.f_code.co_filename:
   439|         0|            0|            0|  0.00%|        self.run('exit')
   440|         0|            0|            0|  0.00%|    else:
   441|         0|            0|            0|  0.00%|        self.setup(frame, traceback)
   442|         0|            0|            0|  0.00%|        if self.send_initial_notification:
   443|         0|            0|            0|  0.00%|            self.notify_spyder(frame)
   444|         0|            0|            0|  0.00%|        self.print_stack_entry(self.stack[self.curindex])
   445|         0|            0|            0|  0.00%|        self._cmdloop()
   446|         0|            0|            0|  0.00%|        self.forget()
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|@monkeypatch_method(pdb.Pdb, 'Pdb')
   450|         0|            0|            0|  0.00%|def _cmdloop(self):
   451|         0|            0|            0|  0.00%|    while True:
   452|         0|            0|            0|  0.00%|        try:
   453|         0|            0|            0|  0.00%|            # keyboard interrupts allow for an easy way to cancel
   454|         0|            0|            0|  0.00%|            # the current command, so allow them during interactive input
   455|         0|            0|            0|  0.00%|            self.allow_kbdint = True
   456|         0|            0|            0|  0.00%|            self.cmdloop()
   457|         0|            0|            0|  0.00%|            self.allow_kbdint = False
   458|         0|            0|            0|  0.00%|            break
   459|         0|            0|            0|  0.00%|        except KeyboardInterrupt:
   460|         0|            0|            0|  0.00%|            _print("--KeyboardInterrupt--\n"
   461|         0|            0|            0|  0.00%|                   "For copying text while debugging, use Ctrl+Shift+C",
   462|         0|            0|            0|  0.00%|                   file=self.stdout)
   463|         0|            0|            0|  0.00%|
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|@monkeypatch_method(pdb.Pdb, 'Pdb')
   466|         0|            0|            0|  0.00%|def reset(self):
   467|         0|            0|            0|  0.00%|    self._old_Pdb_reset()
   468|         0|            0|            0|  0.00%|    kernel = get_ipython().kernel
   469|         0|            0|            0|  0.00%|    kernel._register_pdb_session(self)
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|#XXX: notify spyder on any pdb command (is that good or too lazy? i.e. is more
   473|         0|            0|            0|  0.00%|#     specific behaviour desired?)
   474|         0|            0|            0|  0.00%|@monkeypatch_method(pdb.Pdb, 'Pdb')
   475|         0|            0|            0|  0.00%|def postcmd(self, stop, line):
   476|         0|            0|            0|  0.00%|    if "_set_spyder_breakpoints" not in line:
   477|         0|            0|            0|  0.00%|        self.notify_spyder(self.curframe)
   478|         0|            0|            0|  0.00%|    return self._old_Pdb_postcmd(stop, line)
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|# Breakpoints don't work for files with non-ascii chars in Python 2
   482|         0|            0|            0|  0.00%|# Fixes Issue 1484
   483|         0|            0|            0|  0.00%|if PY2:
   484|         0|            0|            0|  0.00%|    @monkeypatch_method(pdb.Pdb, 'Pdb')
   485|         0|            0|            0|  0.00%|    def break_here(self, frame):
   486|         0|            0|            0|  0.00%|        from bdb import effective
   487|         0|            0|            0|  0.00%|        filename = self.canonic(frame.f_code.co_filename)
   488|         0|            0|            0|  0.00%|        try:
   489|         0|            0|            0|  0.00%|            filename = unicode(filename, "utf-8")
   490|         0|            0|            0|  0.00%|        except TypeError:
   491|         0|            0|            0|  0.00%|            pass
   492|         0|            0|            0|  0.00%|        if not filename in self.breaks:
   493|         0|            0|            0|  0.00%|            return False
   494|         0|            0|            0|  0.00%|        lineno = frame.f_lineno
   495|         0|            0|            0|  0.00%|        if not lineno in self.breaks[filename]:
   496|         0|            0|            0|  0.00%|            # The line itself has no breakpoint, but maybe the line is the
   497|         0|            0|            0|  0.00%|            # first line of a function with breakpoint set by function name.
   498|         0|            0|            0|  0.00%|            lineno = frame.f_code.co_firstlineno
   499|         0|            0|            0|  0.00%|            if not lineno in self.breaks[filename]:
   500|         0|            0|            0|  0.00%|                return False
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|        # flag says ok to delete temp. bp
   503|         0|            0|            0|  0.00%|        (bp, flag) = effective(filename, lineno, frame)
   504|         0|            0|            0|  0.00%|        if bp:
   505|         0|            0|            0|  0.00%|            self.currentbp = bp.number
   506|         0|            0|            0|  0.00%|            if (flag and bp.temporary):
   507|         0|            0|            0|  0.00%|                self.do_clear(str(bp.number))
   508|         0|            0|            0|  0.00%|            return True
   509|         0|            0|            0|  0.00%|        else:
   510|         0|            0|            0|  0.00%|            return False
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|#==============================================================================
   514|         0|            0|            0|  0.00%|# User module reloader
   515|         0|            0|            0|  0.00%|#==============================================================================
   516|         0|            0|            0|  0.00%|class UserModuleReloader(object):
   517|         0|            0|            0|  0.00%|    """
   518|         0|            0|            0|  0.00%|    User Module Reloader (UMR) aims at deleting user modules
   519|         0|            0|            0|  0.00%|    to force Python to deeply reload them during import
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|    pathlist [list]: blacklist in terms of module path
   522|         0|            0|            0|  0.00%|    namelist [list]: blacklist in terms of module name
   523|         0|            0|            0|  0.00%|    """
   524|         0|            0|            0|  0.00%|    def __init__(self, namelist=None, pathlist=None):
   525|         0|            0|            0|  0.00%|        if namelist is None:
   526|         0|            0|            0|  0.00%|            namelist = []
   527|         0|            0|            0|  0.00%|        else:
   528|         0|            0|            0|  0.00%|            try:
   529|         0|            0|            0|  0.00%|                namelist = namelist.split(',')
   530|         0|            0|            0|  0.00%|            except Exception:
   531|         0|            0|            0|  0.00%|                namelist = []
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|        # Spyder modules
   534|         0|            0|            0|  0.00%|        spy_modules = ['spyder_kernels']
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|        # Matplotlib modules
   537|         0|            0|            0|  0.00%|        mpl_modules = ['matplotlib', 'tkinter', 'Tkinter']
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|        # Add other, necessary modules to the UMR blacklist
   540|         0|            0|            0|  0.00%|        # astropy: see issue 6962
   541|         0|            0|            0|  0.00%|        # pytorch: see issue 7041
   542|         0|            0|            0|  0.00%|        # fastmat: see issue 7190
   543|         0|            0|            0|  0.00%|        # pythoncom: see issue 7190
   544|         0|            0|            0|  0.00%|        # tensorflow: see issue 8697
   545|         0|            0|            0|  0.00%|        other_modules = ['pytorch', 'pythoncom', 'tensorflow']
   546|         0|            0|            0|  0.00%|        if PY2:
   547|         0|            0|            0|  0.00%|            py2_modules = ['astropy', 'fastmat']
   548|         0|            0|            0|  0.00%|            other_modules = other_modules + py2_modules
   549|         0|            0|            0|  0.00%|        self.namelist = namelist + spy_modules + mpl_modules + other_modules
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|        if pathlist is None:
   552|         0|            0|            0|  0.00%|            pathlist = []
   553|         0|            0|            0|  0.00%|        self.pathlist = self.create_pathlist(pathlist)
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|        # List of previously loaded modules
   556|         0|            0|            0|  0.00%|        self.previous_modules = list(sys.modules.keys())
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|        # List of module names to reload
   559|         0|            0|            0|  0.00%|        self.modnames_to_reload = []
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|        # Activate Cython support
   562|         0|            0|            0|  0.00%|        self.has_cython = False
   563|         0|            0|            0|  0.00%|        self.activate_cython()
   564|         0|            0|            0|  0.00%|
   565|         0|            0|            0|  0.00%|        # Check if the UMR is enabled or not
   566|         0|            0|            0|  0.00%|        enabled = os.environ.get("SPY_UMR_ENABLED", "")
   567|         0|            0|            0|  0.00%|        self.enabled = enabled.lower() == "true"
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|        # Check if the UMR should print the list of reloaded modules or not
   570|         0|            0|            0|  0.00%|        verbose = os.environ.get("SPY_UMR_VERBOSE", "")
   571|         0|            0|            0|  0.00%|        self.verbose = verbose.lower() == "true"
   572|         0|            0|            0|  0.00%|
   573|         0|            0|            0|  0.00%|    def create_pathlist(self, initial_pathlist):
   574|         0|            0|            0|  0.00%|        """
   575|         0|            0|            0|  0.00%|        Add to pathlist Python library paths to be skipped from module
   576|         0|            0|            0|  0.00%|        reloading.
   577|         0|            0|            0|  0.00%|        """
   578|         0|            0|            0|  0.00%|        # Get standard installation paths
   579|         0|            0|            0|  0.00%|        try:
   580|         0|            0|            0|  0.00%|            paths = sysconfig.get_paths()
   581|         0|            0|            0|  0.00%|            standard_paths = [paths['stdlib'],
   582|         0|            0|            0|  0.00%|                              paths['purelib'],
   583|         0|            0|            0|  0.00%|                              paths['scripts'],
   584|         0|            0|            0|  0.00%|                              paths['data']]
   585|         0|            0|            0|  0.00%|        except Exception:
   586|         0|            0|            0|  0.00%|            standard_paths = []
   587|         0|            0|            0|  0.00%|
   588|         0|            0|            0|  0.00%|        # Get user installation path
   589|         0|            0|            0|  0.00%|        # See Spyder issue 8776
   590|         0|            0|            0|  0.00%|        try:
   591|         0|            0|            0|  0.00%|            import site
   592|         0|            0|            0|  0.00%|            if getattr(site, 'getusersitepackages', False):
   593|         0|            0|            0|  0.00%|                # Virtualenvs don't have this function but
   594|         0|            0|            0|  0.00%|                # conda envs do
   595|         0|            0|            0|  0.00%|                user_path = [site.getusersitepackages()]
   596|         0|            0|            0|  0.00%|            elif getattr(site, 'USER_SITE', False):
   597|         0|            0|            0|  0.00%|                # However, it seems virtualenvs have this
   598|         0|            0|            0|  0.00%|                # constant
   599|         0|            0|            0|  0.00%|                user_path = [site.USER_SITE]
   600|         0|            0|            0|  0.00%|            else:
   601|         0|            0|            0|  0.00%|                user_path = []
   602|         0|            0|            0|  0.00%|        except Exception:
   603|         0|            0|            0|  0.00%|            user_path = []
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|        return initial_pathlist + standard_paths + user_path
   606|         0|            0|            0|  0.00%|
   607|         0|            0|            0|  0.00%|    def is_module_reloadable(self, module, modname):
   608|         0|            0|            0|  0.00%|        """Decide if a module is reloadable or not."""
   609|         0|            0|            0|  0.00%|        if self.has_cython:
   610|         0|            0|            0|  0.00%|            # Don't return cached inline compiled .PYX files
   611|         0|            0|            0|  0.00%|            return False
   612|         0|            0|            0|  0.00%|        else:
   613|         0|            0|            0|  0.00%|            if (self.is_module_in_pathlist(module) or
   614|         0|            0|            0|  0.00%|                    self.is_module_in_namelist(modname)):
   615|         0|            0|            0|  0.00%|                return False
   616|         0|            0|            0|  0.00%|            else:
   617|         0|            0|            0|  0.00%|                return True
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|    def is_module_in_namelist(self, modname):
   620|         0|            0|            0|  0.00%|        """Decide if a module can be reloaded or not according to its name."""
   621|         0|            0|            0|  0.00%|        return set(modname.split('.')) & set(self.namelist)
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|    def is_module_in_pathlist(self, module):
   624|         0|            0|            0|  0.00%|        """Decide if a module can be reloaded or not according to its path."""
   625|         0|            0|            0|  0.00%|        modpath = getattr(module, '__file__', None)
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|        # Skip module according to different criteria
   628|         0|            0|            0|  0.00%|        if modpath is None:
   629|         0|            0|            0|  0.00%|            # *module* is a C module that is statically linked into the
   630|         0|            0|            0|  0.00%|            # interpreter. There is no way to know its path, so we
   631|         0|            0|            0|  0.00%|            # choose to ignore it.
   632|         0|            0|            0|  0.00%|            return True
   633|         0|            0|            0|  0.00%|        elif any([p in modpath for p in self.pathlist]):
   634|         0|            0|            0|  0.00%|            # We don't want to reload modules that belong to the
   635|         0|            0|            0|  0.00%|            # standard library or installed to site-packages,
   636|         0|            0|            0|  0.00%|            # just modules created by the user.
   637|         0|            0|            0|  0.00%|            return True
   638|         0|            0|            0|  0.00%|        elif not os.name == 'nt':
   639|         0|            0|            0|  0.00%|            # Module paths containing the strings below can be ihherited
   640|         0|            0|            0|  0.00%|            # from the default Linux installation, Homebrew or the user
   641|         0|            0|            0|  0.00%|            # site-packages in a virtualenv.
   642|         0|            0|            0|  0.00%|            patterns = [r'^/usr/lib.*',
   643|         0|            0|            0|  0.00%|                        r'^/usr/local/lib.*',
   644|         0|            0|            0|  0.00%|                        r'^/usr/.*/dist-packages/.*',
   645|         0|            0|            0|  0.00%|                        r'^/home/.*/.local/lib.*',
   646|         0|            0|            0|  0.00%|                        r'^/Library/.*',
   647|         0|            0|            0|  0.00%|                        r'^/Users/.*/Library/.*',
   648|         0|            0|            0|  0.00%|                        r'^/Users/.*/.local/.*',
   649|         0|            0|            0|  0.00%|            ]
   650|         0|            0|            0|  0.00%|
   651|         0|            0|            0|  0.00%|            if [p for p in patterns if re.search(p, modpath)]:
   652|         0|            0|            0|  0.00%|                return True
   653|         0|            0|            0|  0.00%|            else:
   654|         0|            0|            0|  0.00%|                return False
   655|         0|            0|            0|  0.00%|        else:
   656|         0|            0|            0|  0.00%|            return False
   657|         0|            0|            0|  0.00%|
   658|         0|            0|            0|  0.00%|    def activate_cython(self):
   659|         0|            0|            0|  0.00%|        """
   660|         0|            0|            0|  0.00%|        Activate Cython support.
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|        We need to run this here because if the support is
   663|         0|            0|            0|  0.00%|        active, we don't to run the UMR at all.
   664|         0|            0|            0|  0.00%|        """
   665|         0|            0|            0|  0.00%|        run_cython = os.environ.get("SPY_RUN_CYTHON") == "True"
   666|         0|            0|            0|  0.00%|
   667|         0|            0|            0|  0.00%|        if run_cython:
   668|         0|            0|            0|  0.00%|            try:
   669|         0|            0|            0|  0.00%|                __import__('Cython')
   670|         0|            0|            0|  0.00%|                self.has_cython = True
   671|         0|            0|            0|  0.00%|            except Exception:
   672|         0|            0|            0|  0.00%|                pass
   673|         0|            0|            0|  0.00%|
   674|         0|            0|            0|  0.00%|            if self.has_cython:
   675|         0|            0|            0|  0.00%|                # Import pyximport to enable Cython files support for
   676|         0|            0|            0|  0.00%|                # import statement
   677|         0|            0|            0|  0.00%|                import pyximport
   678|         0|            0|            0|  0.00%|                pyx_setup_args = {}
   679|         0|            0|            0|  0.00%|
   680|         0|            0|            0|  0.00%|                # Add Numpy include dir to pyximport/distutils
   681|         0|            0|            0|  0.00%|                try:
   682|         0|            0|            0|  0.00%|                    import numpy
   683|         0|            0|            0|  0.00%|                    pyx_setup_args['include_dirs'] = numpy.get_include()
   684|         0|            0|            0|  0.00%|                except Exception:
   685|         0|            0|            0|  0.00%|                    pass
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|                # Setup pyximport and enable Cython files reload
   688|         0|            0|            0|  0.00%|                pyximport.install(setup_args=pyx_setup_args,
   689|         0|            0|            0|  0.00%|                                  reload_support=True)
   690|         0|            0|            0|  0.00%|
   691|         0|            0|            0|  0.00%|    def run(self):
   692|         0|            0|            0|  0.00%|        """
   693|         0|            0|            0|  0.00%|        Delete user modules to force Python to deeply reload them
   694|         0|            0|            0|  0.00%|
   695|         0|            0|            0|  0.00%|        Do not del modules which are considered as system modules, i.e.
   696|         0|            0|            0|  0.00%|        modules installed in subdirectories of Python interpreter's binary
   697|         0|            0|            0|  0.00%|        Do not del C modules
   698|         0|            0|            0|  0.00%|        """
   699|         0|            0|            0|  0.00%|        self.modnames_to_reload = []
   700|         0|            0|            0|  0.00%|        for modname, module in list(sys.modules.items()):
   701|         0|            0|            0|  0.00%|            if modname not in self.previous_modules:
   702|         0|            0|            0|  0.00%|                # Decide if a module can be reloaded or not
   703|         0|            0|            0|  0.00%|                if self.is_module_reloadable(module, modname):
   704|         0|            0|            0|  0.00%|                    self.modnames_to_reload.append(modname)
   705|         0|            0|            0|  0.00%|                    del sys.modules[modname]
   706|         0|            0|            0|  0.00%|                else:
   707|         0|            0|            0|  0.00%|                    continue
   708|         0|            0|            0|  0.00%|
   709|         0|            0|            0|  0.00%|        # Report reloaded modules
   710|         0|            0|            0|  0.00%|        if self.verbose and self.modnames_to_reload:
   711|         0|            0|            0|  0.00%|            modnames = self.modnames_to_reload
   712|         0|            0|            0|  0.00%|            _print("\x1b[4;33m%s\x1b[24m%s\x1b[0m"\
   713|         0|            0|            0|  0.00%|                   % ("Reloaded modules", ": "+", ".join(modnames)))
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|__umr__ = UserModuleReloader(namelist=os.environ.get("SPY_UMR_NAMELIST",
   717|         0|            0|            0|  0.00%|                                                     None))
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|
   720|         0|            0|            0|  0.00%|#==============================================================================
   721|         0|            0|            0|  0.00%|# Handle Post Mortem Debugging and Traceback Linkage to Spyder
   722|         0|            0|            0|  0.00%|#==============================================================================
   723|         0|            0|            0|  0.00%|def clear_post_mortem():
   724|         0|            0|            0|  0.00%|    """
   725|         0|            0|            0|  0.00%|    Remove the post mortem excepthook and replace with a standard one.
   726|         0|            0|            0|  0.00%|    """
   727|         0|            0|            0|  0.00%|    ipython_shell = get_ipython()
   728|         0|            0|            0|  0.00%|    ipython_shell.set_custom_exc((), None)
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|
   731|         0|            0|            0|  0.00%|def post_mortem_excepthook(type, value, tb):
   732|         0|            0|            0|  0.00%|    """
   733|         0|            0|            0|  0.00%|    For post mortem exception handling, print a banner and enable post
   734|         0|            0|            0|  0.00%|    mortem debugging.
   735|         0|            0|            0|  0.00%|    """
   736|         0|            0|            0|  0.00%|    clear_post_mortem()
   737|         0|            0|            0|  0.00%|    ipython_shell = get_ipython()
   738|         0|            0|            0|  0.00%|    ipython_shell.showtraceback((type, value, tb))
   739|         0|            0|            0|  0.00%|    p = pdb.Pdb(ipython_shell.colors)
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|    if not type == SyntaxError:
   742|         0|            0|            0|  0.00%|        # wait for stderr to print (stderr.flush does not work in this case)
   743|         0|            0|            0|  0.00%|        time.sleep(0.1)
   744|         0|            0|            0|  0.00%|        _print('*' * 40)
   745|         0|            0|            0|  0.00%|        _print('Entering post mortem debugging...')
   746|         0|            0|            0|  0.00%|        _print('*' * 40)
   747|         0|            0|            0|  0.00%|        #  add ability to move between frames
   748|         0|            0|            0|  0.00%|        p.send_initial_notification = False
   749|         0|            0|            0|  0.00%|        p.reset()
   750|         0|            0|            0|  0.00%|        frame = tb.tb_frame
   751|         0|            0|            0|  0.00%|        prev = frame
   752|         0|            0|            0|  0.00%|        while frame.f_back:
   753|         0|            0|            0|  0.00%|            prev = frame
   754|         0|            0|            0|  0.00%|            frame = frame.f_back
   755|         0|            0|            0|  0.00%|        frame = prev
   756|         0|            0|            0|  0.00%|        # wait for stdout to print
   757|         0|            0|            0|  0.00%|        time.sleep(0.1)
   758|         0|            0|            0|  0.00%|        p.interaction(frame, tb)
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|def set_post_mortem():
   762|         0|            0|            0|  0.00%|    """
   763|         0|            0|            0|  0.00%|    Enable the post mortem debugging excepthook.
   764|         0|            0|            0|  0.00%|    """
   765|         0|            0|            0|  0.00%|    def ipython_post_mortem_debug(shell, etype, evalue, tb,
   766|         0|            0|            0|  0.00%|               tb_offset=None):
   767|         0|            0|            0|  0.00%|        post_mortem_excepthook(etype, evalue, tb)
   768|         0|            0|            0|  0.00%|    ipython_shell = get_ipython()
   769|         0|            0|            0|  0.00%|    ipython_shell.set_custom_exc((Exception,), ipython_post_mortem_debug)
   770|         0|            0|            0|  0.00%|
   771|         0|            0|            0|  0.00%|# Add post mortem debugging if requested and in a dedicated interpreter
   772|         0|            0|            0|  0.00%|# existing interpreters use "runfile" below
   773|         0|            0|            0|  0.00%|if "SPYDER_EXCEPTHOOK" in os.environ:
   774|         0|            0|            0|  0.00%|    set_post_mortem()
   775|         0|            0|            0|  0.00%|
   776|         0|            0|            0|  0.00%|
   777|         0|            0|            0|  0.00%|#==============================================================================
   778|         0|            0|            0|  0.00%|# runfile and debugfile commands
   779|         0|            0|            0|  0.00%|#==============================================================================
   780|         0|            0|            0|  0.00%|def _get_globals():
   781|         0|            0|            0|  0.00%|    """Return current namespace"""
   782|         0|            0|            0|  0.00%|    ipython_shell = get_ipython()
   783|         0|            0|            0|  0.00%|    return ipython_shell.user_ns
   784|         0|            0|            0|  0.00%|
   785|         0|            0|            0|  0.00%|
   786|         0|            0|            0|  0.00%|def runfile(filename, args=None, wdir=None, namespace=None, post_mortem=False):
   787|         0|            0|            0|  0.00%|    """
   788|         0|            0|            0|  0.00%|    Run filename
   789|         0|            0|            0|  0.00%|    args: command line arguments (string)
   790|         0|            0|            0|  0.00%|    wdir: working directory
   791|         0|            0|            0|  0.00%|    post_mortem: boolean, whether to enter post-mortem mode on error
   792|         0|            0|            0|  0.00%|    """
   793|         0|            0|            0|  0.00%|    try:
   794|         0|            0|            0|  0.00%|        filename = filename.decode('utf-8')
   795|         0|            0|            0|  0.00%|    except (UnicodeError, TypeError, AttributeError):
   796|         0|            0|            0|  0.00%|        # UnicodeError, TypeError --> eventually raised in Python 2
   797|         0|            0|            0|  0.00%|        # AttributeError --> systematically raised in Python 3
   798|         0|            0|            0|  0.00%|        pass
   799|         0|            0|            0|  0.00%|
   800|         0|            0|            0|  0.00%|    if __umr__.enabled:
   801|         0|            0|            0|  0.00%|        __umr__.run()
   802|         0|            0|            0|  0.00%|    if args is not None and not isinstance(args, basestring):
   803|         0|            0|            0|  0.00%|        raise TypeError("expected a character buffer object")
   804|         0|            0|            0|  0.00%|    if namespace is None:
   805|         0|            0|            0|  0.00%|        namespace = _get_globals()
   806|         0|            0|            0|  0.00%|    namespace['__file__'] = filename
   807|         0|            0|            0|  0.00%|    sys.argv = [filename]
   808|         0|            0|            0|  0.00%|    if args is not None:
   809|         0|            0|            0|  0.00%|        for arg in shlex.split(args):
   810|         0|            0|            0|  0.00%|            sys.argv.append(arg)
   811|         0|            0|            0|  0.00%|    if wdir is not None:
   812|         0|            0|            0|  0.00%|        try:
   813|         0|            0|            0|  0.00%|            wdir = wdir.decode('utf-8')
   814|         0|            0|            0|  0.00%|        except (UnicodeError, TypeError, AttributeError):
   815|         0|            0|            0|  0.00%|            # UnicodeError, TypeError --> eventually raised in Python 2
   816|         0|            0|            0|  0.00%|            # AttributeError --> systematically raised in Python 3
   817|         0|            0|            0|  0.00%|            pass
   818|         0|            0|            0|  0.00%|        os.chdir(wdir)
   819|         0|            0|            0|  0.00%|    if post_mortem:
   820|         0|            0|            0|  0.00%|        set_post_mortem()
   821|         0|            0|            0|  0.00%|    if __umr__.has_cython:
   822|         0|            0|            0|  0.00%|        # Cython files
   823|         0|            0|            0|  0.00%|        with io.open(filename, encoding='utf-8') as f:
   824|         0|            0|            0|  0.00%|            ipython_shell = get_ipython()
   825|         0|            0|            0|  0.00%|            ipython_shell.run_cell_magic('cython', '', f.read())
   826|         0|            0|            0|  0.00%|    else:
   827|         0|            0|            0|  0.00%|        execfile(filename, namespace)
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\spyder_kernels\customize\spydercustomize.py:107 execfile
   828|         0|            0|            0|  0.00%|
   829|         0|            0|            0|  0.00%|    clear_post_mortem()
   830|         0|            0|            0|  0.00%|    sys.argv = ['']
   831|         0|            0|            0|  0.00%|
   832|         0|            0|            0|  0.00%|    # Avoid error when running `%reset -f` programmatically
   833|         0|            0|            0|  0.00%|    # See issue spyder-ide/spyder-kernels#91
   834|         0|            0|            0|  0.00%|    try:
   835|         0|            0|            0|  0.00%|        namespace.pop('__file__')
   836|         0|            0|            0|  0.00%|    except KeyError:
   837|         0|            0|            0|  0.00%|        pass
   838|         0|            0|            0|  0.00%|
   839|         0|            0|            0|  0.00%|builtins.runfile = runfile
   840|         0|            0|            0|  0.00%|
   841|         0|            0|            0|  0.00%|
   842|         0|            0|            0|  0.00%|def debugfile(filename, args=None, wdir=None, post_mortem=False):
   843|         0|            0|            0|  0.00%|    """
   844|         0|            0|            0|  0.00%|    Debug filename
   845|         0|            0|            0|  0.00%|    args: command line arguments (string)
   846|         0|            0|            0|  0.00%|    wdir: working directory
   847|         0|            0|            0|  0.00%|    post_mortem: boolean, included for compatiblity with runfile
   848|         0|            0|            0|  0.00%|    """
   849|         0|            0|            0|  0.00%|    debugger = pdb.Pdb()
   850|         0|            0|            0|  0.00%|    filename = debugger.canonic(filename)
   851|         0|            0|            0|  0.00%|    debugger._wait_for_mainpyfile = 1
   852|         0|            0|            0|  0.00%|    debugger.mainpyfile = filename
   853|         0|            0|            0|  0.00%|    debugger._user_requested_quit = 0
   854|         0|            0|            0|  0.00%|    if os.name == 'nt':
   855|         0|            0|            0|  0.00%|        filename = filename.replace('\\', '/')
   856|         0|            0|            0|  0.00%|    debugger.run("runfile(%r, args=%r, wdir=%r)" % (filename, args, wdir))
   857|         0|            0|            0|  0.00%|
   858|         0|            0|            0|  0.00%|builtins.debugfile = debugfile
   859|         0|            0|            0|  0.00%|
   860|         0|            0|            0|  0.00%|
   861|         0|            0|            0|  0.00%|#==============================================================================
   862|         0|            0|            0|  0.00%|# Restoring original PYTHONPATH
   863|         0|            0|            0|  0.00%|#==============================================================================
   864|         0|            0|            0|  0.00%|try:
   865|         0|            0|            0|  0.00%|    os.environ['PYTHONPATH'] = os.environ['OLD_PYTHONPATH']
   866|         0|            0|            0|  0.00%|    del os.environ['OLD_PYTHONPATH']
   867|         0|            0|            0|  0.00%|except KeyError:
   868|         0|            0|            0|  0.00%|    pass
File: D:\Application\Anaconda\lib\site-packages\IPython\core\interactiveshell.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# -*- coding: utf-8 -*-
     2|         0|            0|            0|  0.00%|"""Main IPython class."""
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
     5|         0|            0|            0|  0.00%|#  Copyright (C) 2001 Janko Hauser <jhauser@zscout.de>
     6|         0|            0|            0|  0.00%|#  Copyright (C) 2001-2007 Fernando Perez. <fperez@colorado.edu>
     7|         0|            0|            0|  0.00%|#  Copyright (C) 2008-2011  The IPython Development Team
     8|         0|            0|            0|  0.00%|#
     9|         0|            0|            0|  0.00%|#  Distributed under the terms of the BSD License.  The full license is in
    10|         0|            0|            0|  0.00%|#  the file COPYING, distributed as part of this software.
    11|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|from __future__ import absolute_import, print_function
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|import __future__
    16|         0|            0|            0|  0.00%|import abc
    17|         0|            0|            0|  0.00%|import ast
    18|         0|            0|            0|  0.00%|import atexit
    19|         0|            0|            0|  0.00%|import functools
    20|         0|            0|            0|  0.00%|import os
    21|         0|            0|            0|  0.00%|import re
    22|         0|            0|            0|  0.00%|import runpy
    23|         0|            0|            0|  0.00%|import sys
    24|         0|            0|            0|  0.00%|import tempfile
    25|         0|            0|            0|  0.00%|import traceback
    26|         0|            0|            0|  0.00%|import types
    27|         0|            0|            0|  0.00%|import subprocess
    28|         0|            0|            0|  0.00%|import warnings
    29|         0|            0|            0|  0.00%|from io import open as io_open
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|from pickleshare import PickleShareDB
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|from traitlets.config.configurable import SingletonConfigurable
    34|         0|            0|            0|  0.00%|from IPython.core import oinspect
    35|         0|            0|            0|  0.00%|from IPython.core import magic
    36|         0|            0|            0|  0.00%|from IPython.core import page
    37|         0|            0|            0|  0.00%|from IPython.core import prefilter
    38|         0|            0|            0|  0.00%|from IPython.core import shadowns
    39|         0|            0|            0|  0.00%|from IPython.core import ultratb
    40|         0|            0|            0|  0.00%|from IPython.core.alias import Alias, AliasManager
    41|         0|            0|            0|  0.00%|from IPython.core.autocall import ExitAutocall
    42|         0|            0|            0|  0.00%|from IPython.core.builtin_trap import BuiltinTrap
    43|         0|            0|            0|  0.00%|from IPython.core.events import EventManager, available_events
    44|         0|            0|            0|  0.00%|from IPython.core.compilerop import CachingCompiler, check_linecache_ipython
    45|         0|            0|            0|  0.00%|from IPython.core.debugger import Pdb
    46|         0|            0|            0|  0.00%|from IPython.core.display_trap import DisplayTrap
    47|         0|            0|            0|  0.00%|from IPython.core.displayhook import DisplayHook
    48|         0|            0|            0|  0.00%|from IPython.core.displaypub import DisplayPublisher
    49|         0|            0|            0|  0.00%|from IPython.core.error import InputRejected, UsageError
    50|         0|            0|            0|  0.00%|from IPython.core.extensions import ExtensionManager
    51|         0|            0|            0|  0.00%|from IPython.core.formatters import DisplayFormatter
    52|         0|            0|            0|  0.00%|from IPython.core.history import HistoryManager
    53|         0|            0|            0|  0.00%|from IPython.core.inputsplitter import ESC_MAGIC, ESC_MAGIC2
    54|         0|            0|            0|  0.00%|from IPython.core.logger import Logger
    55|         0|            0|            0|  0.00%|from IPython.core.macro import Macro
    56|         0|            0|            0|  0.00%|from IPython.core.payload import PayloadManager
    57|         0|            0|            0|  0.00%|from IPython.core.prefilter import PrefilterManager
    58|         0|            0|            0|  0.00%|from IPython.core.profiledir import ProfileDir
    59|         0|            0|            0|  0.00%|from IPython.core.usage import default_banner
    60|         0|            0|            0|  0.00%|from IPython.testing.skipdoctest import skip_doctest_py2, skip_doctest
    61|         0|            0|            0|  0.00%|from IPython.utils import PyColorize
    62|         0|            0|            0|  0.00%|from IPython.utils import io
    63|         0|            0|            0|  0.00%|from IPython.utils import py3compat
    64|         0|            0|            0|  0.00%|from IPython.utils import openpy
    65|         0|            0|            0|  0.00%|from IPython.utils.decorators import undoc
    66|         0|            0|            0|  0.00%|from IPython.utils.io import ask_yes_no
    67|         0|            0|            0|  0.00%|from IPython.utils.ipstruct import Struct
    68|         0|            0|            0|  0.00%|from IPython.paths import get_ipython_dir
    69|         0|            0|            0|  0.00%|from IPython.utils.path import get_home_dir, get_py_filename, ensure_dir_exists
    70|         0|            0|            0|  0.00%|from IPython.utils.process import system, getoutput
    71|         0|            0|            0|  0.00%|from IPython.utils.py3compat import (builtin_mod, unicode_type, string_types,
    72|         0|            0|            0|  0.00%|                                     with_metaclass, iteritems)
    73|         0|            0|            0|  0.00%|from IPython.utils.strdispatch import StrDispatch
    74|         0|            0|            0|  0.00%|from IPython.utils.syspathcontext import prepended_to_syspath
    75|         0|            0|            0|  0.00%|from IPython.utils.text import format_screen, LSString, SList, DollarFormatter
    76|         0|            0|            0|  0.00%|from IPython.utils.tempdir import TemporaryDirectory
    77|         0|            0|            0|  0.00%|from traitlets import (
    78|         0|            0|            0|  0.00%|    Integer, Bool, CaselessStrEnum, Enum, List, Dict, Unicode, Instance, Type,
    79|         0|            0|            0|  0.00%|    observe, default,
    80|         0|            0|            0|  0.00%|)
    81|         0|            0|            0|  0.00%|from warnings import warn
    82|         0|            0|            0|  0.00%|from logging import error
    83|         0|            0|            0|  0.00%|import IPython.core.hooks
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|# NoOpContext is deprecated, but ipykernel imports it from here.
    86|         0|            0|            0|  0.00%|# See https://github.com/ipython/ipykernel/issues/157
    87|         0|            0|            0|  0.00%|from IPython.utils.contexts import NoOpContext
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|try:
    90|         0|            0|            0|  0.00%|    import docrepr.sphinxify as sphx
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|    def sphinxify(doc):
    93|         0|            0|            0|  0.00%|        with TemporaryDirectory() as dirname:
    94|         0|            0|            0|  0.00%|            return {
    95|         0|            0|            0|  0.00%|                'text/html': sphx.sphinxify(doc, dirname),
    96|         0|            0|            0|  0.00%|                'text/plain': doc
    97|         0|            0|            0|  0.00%|            }
    98|         0|            0|            0|  0.00%|except ImportError:
    99|         0|            0|            0|  0.00%|    sphinxify = None
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|class ProvisionalWarning(DeprecationWarning):
   103|         0|            0|            0|  0.00%|    """
   104|         0|            0|            0|  0.00%|    Warning class for unstable features
   105|         0|            0|            0|  0.00%|    """
   106|         0|            0|            0|  0.00%|    pass
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
   109|         0|            0|            0|  0.00%|# Globals
   110|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|# compiled regexps for autoindent management
   113|         0|            0|            0|  0.00%|dedent_re = re.compile(r'^\s+raise|^\s+return|^\s+pass')
   114|         0|            0|            0|  0.00%|
   115|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
   116|         0|            0|            0|  0.00%|# Utilities
   117|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|@undoc
   120|         0|            0|            0|  0.00%|def softspace(file, newvalue):
   121|         0|            0|            0|  0.00%|    """Copied from code.py, to remove the dependency"""
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|    oldvalue = 0
   124|         0|            0|            0|  0.00%|    try:
   125|         0|            0|            0|  0.00%|        oldvalue = file.softspace
   126|         0|            0|            0|  0.00%|    except AttributeError:
   127|         0|            0|            0|  0.00%|        pass
   128|         0|            0|            0|  0.00%|    try:
   129|         0|            0|            0|  0.00%|        file.softspace = newvalue
   130|         0|            0|            0|  0.00%|    except (AttributeError, TypeError):
   131|         0|            0|            0|  0.00%|        # "attribute-less object" or "read-only attributes"
   132|         0|            0|            0|  0.00%|        pass
   133|         0|            0|            0|  0.00%|    return oldvalue
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|@undoc
   136|         0|            0|            0|  0.00%|def no_op(*a, **kw): pass
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|class SpaceInInput(Exception): pass
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|def get_default_colors():
   143|         0|            0|            0|  0.00%|    "DEPRECATED"
   144|         0|            0|            0|  0.00%|    warn('get_default_color is Deprecated, and is `Neutral` on all platforms.',
   145|         0|            0|            0|  0.00%|            DeprecationWarning, stacklevel=2)
   146|         0|            0|            0|  0.00%|    return 'Neutral'
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|class SeparateUnicode(Unicode):
   150|         0|            0|            0|  0.00%|    r"""A Unicode subclass to validate separate_in, separate_out, etc.
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|    This is a Unicode based trait that converts '0'->'' and ``'\\n'->'\n'``.
   153|         0|            0|            0|  0.00%|    """
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|    def validate(self, obj, value):
   156|         0|            0|            0|  0.00%|        if value == '0': value = ''
   157|         0|            0|            0|  0.00%|        value = value.replace('\\n','\n')
   158|         0|            0|            0|  0.00%|        return super(SeparateUnicode, self).validate(obj, value)
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|@undoc
   162|         0|            0|            0|  0.00%|class DummyMod(object):
   163|         0|            0|            0|  0.00%|    """A dummy module used for IPython's interactive module when
   164|         0|            0|            0|  0.00%|    a namespace must be assigned to the module's __dict__."""
   165|         0|            0|            0|  0.00%|    pass
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|class ExecutionResult(object):
   169|         0|            0|            0|  0.00%|    """The result of a call to :meth:`InteractiveShell.run_cell`
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|    Stores information about what took place.
   172|         0|            0|            0|  0.00%|    """
   173|         0|            0|            0|  0.00%|    execution_count = None
   174|         0|            0|            0|  0.00%|    error_before_exec = None
   175|         0|            0|            0|  0.00%|    error_in_exec = None
   176|         0|            0|            0|  0.00%|    result = None
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    @property
   179|         0|            0|            0|  0.00%|    def success(self):
   180|         0|            0|            0|  0.00%|        return (self.error_before_exec is None) and (self.error_in_exec is None)
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|    def raise_error(self):
   183|         0|            0|            0|  0.00%|        """Reraises error if `success` is `False`, otherwise does nothing"""
   184|         0|            0|            0|  0.00%|        if self.error_before_exec is not None:
   185|         0|            0|            0|  0.00%|            raise self.error_before_exec
   186|         0|            0|            0|  0.00%|        if self.error_in_exec is not None:
   187|         0|            0|            0|  0.00%|            raise self.error_in_exec
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|    def __repr__(self):
   190|         0|            0|            0|  0.00%|        if sys.version_info > (3,):
   191|         0|            0|            0|  0.00%|            name = self.__class__.__qualname__
   192|         0|            0|            0|  0.00%|        else:
   193|         0|            0|            0|  0.00%|            name = self.__class__.__name__
   194|         0|            0|            0|  0.00%|        return '<%s object at %x, execution_count=%s error_before_exec=%s error_in_exec=%s result=%s>' %\
   195|         0|            0|            0|  0.00%|                (name, id(self), self.execution_count, self.error_before_exec, self.error_in_exec, repr(self.result))
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|class InteractiveShell(SingletonConfigurable):
   199|         0|            0|            0|  0.00%|    """An enhanced, interactive shell for Python."""
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|    _instance = None
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|    ast_transformers = List([], help=
   204|         0|            0|            0|  0.00%|        """
   205|         0|            0|            0|  0.00%|        A list of ast.NodeTransformer subclass instances, which will be applied
   206|         0|            0|            0|  0.00%|        to user input before code is run.
   207|         0|            0|            0|  0.00%|        """
   208|         0|            0|            0|  0.00%|    ).tag(config=True)
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|    autocall = Enum((0,1,2), default_value=0, help=
   211|         0|            0|            0|  0.00%|        """
   212|         0|            0|            0|  0.00%|        Make IPython automatically call any callable object even if you didn't
   213|         0|            0|            0|  0.00%|        type explicit parentheses. For example, 'str 43' becomes 'str(43)'
   214|         0|            0|            0|  0.00%|        automatically. The value can be '0' to disable the feature, '1' for
   215|         0|            0|            0|  0.00%|        'smart' autocall, where it is not applied if there are no more
   216|         0|            0|            0|  0.00%|        arguments on the line, and '2' for 'full' autocall, where all callable
   217|         0|            0|            0|  0.00%|        objects are automatically called (even if no arguments are present).
   218|         0|            0|            0|  0.00%|        """
   219|         0|            0|            0|  0.00%|    ).tag(config=True)
   220|         0|            0|            0|  0.00%|    # TODO: remove all autoindent logic and put into frontends.
   221|         0|            0|            0|  0.00%|    # We can't do this yet because even runlines uses the autoindent.
   222|         0|            0|            0|  0.00%|    autoindent = Bool(True, help=
   223|         0|            0|            0|  0.00%|        """
   224|         0|            0|            0|  0.00%|        Autoindent IPython code entered interactively.
   225|         0|            0|            0|  0.00%|        """
   226|         0|            0|            0|  0.00%|    ).tag(config=True)
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|    automagic = Bool(True, help=
   229|         0|            0|            0|  0.00%|        """
   230|         0|            0|            0|  0.00%|        Enable magic commands to be called without the leading %.
   231|         0|            0|            0|  0.00%|        """
   232|         0|            0|            0|  0.00%|    ).tag(config=True)
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|    banner1 = Unicode(default_banner,
   235|         0|            0|            0|  0.00%|        help="""The part of the banner to be printed before the profile"""
   236|         0|            0|            0|  0.00%|    ).tag(config=True)
   237|         0|            0|            0|  0.00%|    banner2 = Unicode('',
   238|         0|            0|            0|  0.00%|        help="""The part of the banner to be printed after the profile"""
   239|         0|            0|            0|  0.00%|    ).tag(config=True)
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|    cache_size = Integer(1000, help=
   242|         0|            0|            0|  0.00%|        """
   243|         0|            0|            0|  0.00%|        Set the size of the output cache.  The default is 1000, you can
   244|         0|            0|            0|  0.00%|        change it permanently in your config file.  Setting it to 0 completely
   245|         0|            0|            0|  0.00%|        disables the caching system, and the minimum value accepted is 20 (if
   246|         0|            0|            0|  0.00%|        you provide a value less than 20, it is reset to 0 and a warning is
   247|         0|            0|            0|  0.00%|        issued).  This limit is defined because otherwise you'll spend more
   248|         0|            0|            0|  0.00%|        time re-flushing a too small cache than working
   249|         0|            0|            0|  0.00%|        """
   250|         0|            0|            0|  0.00%|    ).tag(config=True)
   251|         0|            0|            0|  0.00%|    color_info = Bool(True, help=
   252|         0|            0|            0|  0.00%|        """
   253|         0|            0|            0|  0.00%|        Use colors for displaying information about objects. Because this
   254|         0|            0|            0|  0.00%|        information is passed through a pager (like 'less'), and some pagers
   255|         0|            0|            0|  0.00%|        get confused with color codes, this capability can be turned off.
   256|         0|            0|            0|  0.00%|        """
   257|         0|            0|            0|  0.00%|    ).tag(config=True)
   258|         0|            0|            0|  0.00%|    colors = CaselessStrEnum(('Neutral', 'NoColor','LightBG','Linux'),
   259|         0|            0|            0|  0.00%|                             default_value='Neutral',
   260|         0|            0|            0|  0.00%|        help="Set the color scheme (NoColor, Neutral, Linux, or LightBG)."
   261|         0|            0|            0|  0.00%|    ).tag(config=True)
   262|         0|            0|            0|  0.00%|    debug = Bool(False).tag(config=True)
   263|         0|            0|            0|  0.00%|    deep_reload = Bool(False, help=
   264|         0|            0|            0|  0.00%|        """
   265|         0|            0|            0|  0.00%|        **Deprecated**
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|        Will be removed in IPython 6.0
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|        Enable deep (recursive) reloading by default. IPython can use the
   270|         0|            0|            0|  0.00%|        deep_reload module which reloads changes in modules recursively (it
   271|         0|            0|            0|  0.00%|        replaces the reload() function, so you don't need to change anything to
   272|         0|            0|            0|  0.00%|        use it). `deep_reload` forces a full reload of modules whose code may
   273|         0|            0|            0|  0.00%|        have changed, which the default reload() function does not.  When
   274|         0|            0|            0|  0.00%|        deep_reload is off, IPython will use the normal reload(), but
   275|         0|            0|            0|  0.00%|        deep_reload will still be available as dreload().
   276|         0|            0|            0|  0.00%|        """
   277|         0|            0|            0|  0.00%|    ).tag(config=True)
   278|         0|            0|            0|  0.00%|    disable_failing_post_execute = Bool(False,
   279|         0|            0|            0|  0.00%|        help="Don't call post-execute functions that have failed in the past."
   280|         0|            0|            0|  0.00%|    ).tag(config=True)
   281|         0|            0|            0|  0.00%|    display_formatter = Instance(DisplayFormatter, allow_none=True)
   282|         0|            0|            0|  0.00%|    displayhook_class = Type(DisplayHook)
   283|         0|            0|            0|  0.00%|    display_pub_class = Type(DisplayPublisher)
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|    sphinxify_docstring = Bool(False, help=
   286|         0|            0|            0|  0.00%|        """
   287|         0|            0|            0|  0.00%|        Enables rich html representation of docstrings. (This requires the
   288|         0|            0|            0|  0.00%|        docrepr module).
   289|         0|            0|            0|  0.00%|        """).tag(config=True)
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|    @observe("sphinxify_docstring")
   292|         0|            0|            0|  0.00%|    def _sphinxify_docstring_changed(self, change):
   293|         0|            0|            0|  0.00%|        if change['new']:
   294|         0|            0|            0|  0.00%|            warn("`sphinxify_docstring` is provisional since IPython 5.0 and might change in future versions." , ProvisionalWarning)
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|    enable_html_pager = Bool(False, help=
   297|         0|            0|            0|  0.00%|        """
   298|         0|            0|            0|  0.00%|        (Provisional API) enables html representation in mime bundles sent
   299|         0|            0|            0|  0.00%|        to pagers.
   300|         0|            0|            0|  0.00%|        """).tag(config=True)
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|    @observe("enable_html_pager")
   303|         0|            0|            0|  0.00%|    def _enable_html_pager_changed(self, change):
   304|         0|            0|            0|  0.00%|        if change['new']:
   305|         0|            0|            0|  0.00%|            warn("`enable_html_pager` is provisional since IPython 5.0 and might change in future versions.", ProvisionalWarning)
   306|         0|            0|            0|  0.00%|
   307|         0|            0|            0|  0.00%|    data_pub_class = None
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|    exit_now = Bool(False)
   310|         0|            0|            0|  0.00%|    exiter = Instance(ExitAutocall)
   311|         0|            0|            0|  0.00%|    @default('exiter')
   312|         0|            0|            0|  0.00%|    def _exiter_default(self):
   313|         0|            0|            0|  0.00%|        return ExitAutocall(self)
   314|         0|            0|            0|  0.00%|    # Monotonically increasing execution counter
   315|         0|            0|            0|  0.00%|    execution_count = Integer(1)
   316|         0|            0|            0|  0.00%|    filename = Unicode("<ipython console>")
   317|         0|            0|            0|  0.00%|    ipython_dir= Unicode('').tag(config=True) # Set to get_ipython_dir() in __init__
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|    # Input splitter, to transform input line by line and detect when a block
   320|         0|            0|            0|  0.00%|    # is ready to be executed.
   321|         0|            0|            0|  0.00%|    input_splitter = Instance('IPython.core.inputsplitter.IPythonInputSplitter',
   322|         0|            0|            0|  0.00%|                              (), {'line_input_checker': True})
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|    # This InputSplitter instance is used to transform completed cells before
   325|         0|            0|            0|  0.00%|    # running them. It allows cell magics to contain blank lines.
   326|         0|            0|            0|  0.00%|    input_transformer_manager = Instance('IPython.core.inputsplitter.IPythonInputSplitter',
   327|         0|            0|            0|  0.00%|                                         (), {'line_input_checker': False})
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|    logstart = Bool(False, help=
   330|         0|            0|            0|  0.00%|        """
   331|         0|            0|            0|  0.00%|        Start logging to the default log file in overwrite mode.
   332|         0|            0|            0|  0.00%|        Use `logappend` to specify a log file to **append** logs to.
   333|         0|            0|            0|  0.00%|        """
   334|         0|            0|            0|  0.00%|    ).tag(config=True)
   335|         0|            0|            0|  0.00%|    logfile = Unicode('', help=
   336|         0|            0|            0|  0.00%|        """
   337|         0|            0|            0|  0.00%|        The name of the logfile to use.
   338|         0|            0|            0|  0.00%|        """
   339|         0|            0|            0|  0.00%|    ).tag(config=True)
   340|         0|            0|            0|  0.00%|    logappend = Unicode('', help=
   341|         0|            0|            0|  0.00%|        """
   342|         0|            0|            0|  0.00%|        Start logging to the given file in append mode.
   343|         0|            0|            0|  0.00%|        Use `logfile` to specify a log file to **overwrite** logs to.
   344|         0|            0|            0|  0.00%|        """
   345|         0|            0|            0|  0.00%|    ).tag(config=True)
   346|         0|            0|            0|  0.00%|    object_info_string_level = Enum((0,1,2), default_value=0,
   347|         0|            0|            0|  0.00%|    ).tag(config=True)
   348|         0|            0|            0|  0.00%|    pdb = Bool(False, help=
   349|         0|            0|            0|  0.00%|        """
   350|         0|            0|            0|  0.00%|        Automatically call the pdb debugger after every exception.
   351|         0|            0|            0|  0.00%|        """
   352|         0|            0|            0|  0.00%|    ).tag(config=True)
   353|         0|            0|            0|  0.00%|    display_page = Bool(False,
   354|         0|            0|            0|  0.00%|        help="""If True, anything that would be passed to the pager
   355|         0|            0|            0|  0.00%|        will be displayed as regular output instead."""
   356|         0|            0|            0|  0.00%|    ).tag(config=True)
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|    # deprecated prompt traits:
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|    prompt_in1 = Unicode('In [\\#]: ',
   361|         0|            0|            0|  0.00%|        help="Deprecated since IPython 4.0 and ignored since 5.0, set TerminalInteractiveShell.prompts object directly."
   362|         0|            0|            0|  0.00%|    ).tag(config=True)
   363|         0|            0|            0|  0.00%|    prompt_in2 = Unicode('   .\\D.: ',
   364|         0|            0|            0|  0.00%|        help="Deprecated since IPython 4.0 and ignored since 5.0, set TerminalInteractiveShell.prompts object directly."
   365|         0|            0|            0|  0.00%|    ).tag(config=True)
   366|         0|            0|            0|  0.00%|    prompt_out = Unicode('Out[\\#]: ',
   367|         0|            0|            0|  0.00%|        help="Deprecated since IPython 4.0 and ignored since 5.0, set TerminalInteractiveShell.prompts object directly."
   368|         0|            0|            0|  0.00%|    ).tag(config=True)
   369|         0|            0|            0|  0.00%|    prompts_pad_left = Bool(True,
   370|         0|            0|            0|  0.00%|        help="Deprecated since IPython 4.0 and ignored since 5.0, set TerminalInteractiveShell.prompts object directly."
   371|         0|            0|            0|  0.00%|    ).tag(config=True)
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|    @observe('prompt_in1', 'prompt_in2', 'prompt_out', 'prompt_pad_left')
   374|         0|            0|            0|  0.00%|    def _prompt_trait_changed(self, change):
   375|         0|            0|            0|  0.00%|        name = change['name']
   376|         0|            0|            0|  0.00%|        warn("InteractiveShell.{name} is deprecated since IPython 4.0 and ignored since 5.0, set TerminalInteractiveShell.prompts object directly.".format(
   377|         0|            0|            0|  0.00%|                name=name)
   378|         0|            0|            0|  0.00%|        )
   379|         0|            0|            0|  0.00%|        # protect against weird cases where self.config may not exist:
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|    show_rewritten_input = Bool(True,
   382|         0|            0|            0|  0.00%|        help="Show rewritten input, e.g. for autocall."
   383|         0|            0|            0|  0.00%|    ).tag(config=True)
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|    quiet = Bool(False).tag(config=True)
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|    history_length = Integer(10000,
   388|         0|            0|            0|  0.00%|        help='Total length of command history'
   389|         0|            0|            0|  0.00%|    ).tag(config=True)
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|    history_load_length = Integer(1000, help=
   392|         0|            0|            0|  0.00%|        """
   393|         0|            0|            0|  0.00%|        The number of saved history entries to be loaded
   394|         0|            0|            0|  0.00%|        into the history buffer at startup.
   395|         0|            0|            0|  0.00%|        """
   396|         0|            0|            0|  0.00%|    ).tag(config=True)
   397|         0|            0|            0|  0.00%|
   398|         0|            0|            0|  0.00%|    ast_node_interactivity = Enum(['all', 'last', 'last_expr', 'none'],
   399|         0|            0|            0|  0.00%|                                  default_value='last_expr',
   400|         0|            0|            0|  0.00%|                                  help="""
   401|         0|            0|            0|  0.00%|        'all', 'last', 'last_expr' or 'none', specifying which nodes should be
   402|         0|            0|            0|  0.00%|        run interactively (displaying output from expressions)."""
   403|         0|            0|            0|  0.00%|    ).tag(config=True)
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|    # TODO: this part of prompt management should be moved to the frontends.
   406|         0|            0|            0|  0.00%|    # Use custom TraitTypes that convert '0'->'' and '\\n'->'\n'
   407|         0|            0|            0|  0.00%|    separate_in = SeparateUnicode('\n').tag(config=True)
   408|         0|            0|            0|  0.00%|    separate_out = SeparateUnicode('').tag(config=True)
   409|         0|            0|            0|  0.00%|    separate_out2 = SeparateUnicode('').tag(config=True)
   410|         0|            0|            0|  0.00%|    wildcards_case_sensitive = Bool(True).tag(config=True)
   411|         0|            0|            0|  0.00%|    xmode = CaselessStrEnum(('Context','Plain', 'Verbose'),
   412|         0|            0|            0|  0.00%|                            default_value='Context').tag(config=True)
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|    # Subcomponents of InteractiveShell
   415|         0|            0|            0|  0.00%|    alias_manager = Instance('IPython.core.alias.AliasManager', allow_none=True)
   416|         0|            0|            0|  0.00%|    prefilter_manager = Instance('IPython.core.prefilter.PrefilterManager', allow_none=True)
   417|         0|            0|            0|  0.00%|    builtin_trap = Instance('IPython.core.builtin_trap.BuiltinTrap', allow_none=True)
   418|         0|            0|            0|  0.00%|    display_trap = Instance('IPython.core.display_trap.DisplayTrap', allow_none=True)
   419|         0|            0|            0|  0.00%|    extension_manager = Instance('IPython.core.extensions.ExtensionManager', allow_none=True)
   420|         0|            0|            0|  0.00%|    payload_manager = Instance('IPython.core.payload.PayloadManager', allow_none=True)
   421|         0|            0|            0|  0.00%|    history_manager = Instance('IPython.core.history.HistoryAccessorBase', allow_none=True)
   422|         0|            0|            0|  0.00%|    magics_manager = Instance('IPython.core.magic.MagicsManager', allow_none=True)
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|    profile_dir = Instance('IPython.core.application.ProfileDir', allow_none=True)
   425|         0|            0|            0|  0.00%|    @property
   426|         0|            0|            0|  0.00%|    def profile(self):
   427|         0|            0|            0|  0.00%|        if self.profile_dir is not None:
   428|         0|            0|            0|  0.00%|            name = os.path.basename(self.profile_dir.location)
   429|         0|            0|            0|  0.00%|            return name.replace('profile_','')
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|    # Private interface
   433|         0|            0|            0|  0.00%|    _post_execute = Dict()
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|    # Tracks any GUI loop loaded for pylab
   436|         0|            0|            0|  0.00%|    pylab_gui_select = None
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|    last_execution_succeeded = Bool(True, help='Did last executed command succeeded')
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|    def __init__(self, ipython_dir=None, profile_dir=None,
   441|         0|            0|            0|  0.00%|                 user_module=None, user_ns=None,
   442|         0|            0|            0|  0.00%|                 custom_exceptions=((), None), **kwargs):
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|        # This is where traits with a config_key argument are updated
   445|         0|            0|            0|  0.00%|        # from the values on config.
   446|         0|            0|            0|  0.00%|        super(InteractiveShell, self).__init__(**kwargs)
   447|         0|            0|            0|  0.00%|        if 'PromptManager' in self.config:
   448|         0|            0|            0|  0.00%|            warn('As of IPython 5.0 `PromptManager` config will have no effect'
   449|         0|            0|            0|  0.00%|                 ' and has been replaced by TerminalInteractiveShell.prompts_class')
   450|         0|            0|            0|  0.00%|        self.configurables = [self]
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|        # These are relatively independent and stateless
   453|         0|            0|            0|  0.00%|        self.init_ipython_dir(ipython_dir)
   454|         0|            0|            0|  0.00%|        self.init_profile_dir(profile_dir)
   455|         0|            0|            0|  0.00%|        self.init_instance_attrs()
   456|         0|            0|            0|  0.00%|        self.init_environment()
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|        # Check if we're in a virtualenv, and set up sys.path.
   459|         0|            0|            0|  0.00%|        self.init_virtualenv()
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|        # Create namespaces (user_ns, user_global_ns, etc.)
   462|         0|            0|            0|  0.00%|        self.init_create_namespaces(user_module, user_ns)
   463|         0|            0|            0|  0.00%|        # This has to be done after init_create_namespaces because it uses
   464|         0|            0|            0|  0.00%|        # something in self.user_ns, but before init_sys_modules, which
   465|         0|            0|            0|  0.00%|        # is the first thing to modify sys.
   466|         0|            0|            0|  0.00%|        # TODO: When we override sys.stdout and sys.stderr before this class
   467|         0|            0|            0|  0.00%|        # is created, we are saving the overridden ones here. Not sure if this
   468|         0|            0|            0|  0.00%|        # is what we want to do.
   469|         0|            0|            0|  0.00%|        self.save_sys_module_state()
   470|         0|            0|            0|  0.00%|        self.init_sys_modules()
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|        # While we're trying to have each part of the code directly access what
   473|         0|            0|            0|  0.00%|        # it needs without keeping redundant references to objects, we have too
   474|         0|            0|            0|  0.00%|        # much legacy code that expects ip.db to exist.
   475|         0|            0|            0|  0.00%|        self.db = PickleShareDB(os.path.join(self.profile_dir.location, 'db'))
   476|         0|            0|            0|  0.00%|
   477|         0|            0|            0|  0.00%|        self.init_history()
   478|         0|            0|            0|  0.00%|        self.init_encoding()
   479|         0|            0|            0|  0.00%|        self.init_prefilter()
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|        self.init_syntax_highlighting()
   482|         0|            0|            0|  0.00%|        self.init_hooks()
   483|         0|            0|            0|  0.00%|        self.init_events()
   484|         0|            0|            0|  0.00%|        self.init_pushd_popd_magic()
   485|         0|            0|            0|  0.00%|        self.init_user_ns()
   486|         0|            0|            0|  0.00%|        self.init_logger()
   487|         0|            0|            0|  0.00%|        self.init_builtins()
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|        # The following was in post_config_initialization
   490|         0|            0|            0|  0.00%|        self.init_inspector()
   491|         0|            0|            0|  0.00%|        if py3compat.PY3:
   492|         0|            0|            0|  0.00%|            self.raw_input_original = input
   493|         0|            0|            0|  0.00%|        else:
   494|         0|            0|            0|  0.00%|            self.raw_input_original = raw_input
   495|         0|            0|            0|  0.00%|        self.init_completer()
   496|         0|            0|            0|  0.00%|        # TODO: init_io() needs to happen before init_traceback handlers
   497|         0|            0|            0|  0.00%|        # because the traceback handlers hardcode the stdout/stderr streams.
   498|         0|            0|            0|  0.00%|        # This logic in in debugger.Pdb and should eventually be changed.
   499|         0|            0|            0|  0.00%|        self.init_io()
   500|         0|            0|            0|  0.00%|        self.init_traceback_handlers(custom_exceptions)
   501|         0|            0|            0|  0.00%|        self.init_prompts()
   502|         0|            0|            0|  0.00%|        self.init_display_formatter()
   503|         0|            0|            0|  0.00%|        self.init_display_pub()
   504|         0|            0|            0|  0.00%|        self.init_data_pub()
   505|         0|            0|            0|  0.00%|        self.init_displayhook()
   506|         0|            0|            0|  0.00%|        self.init_magics()
   507|         0|            0|            0|  0.00%|        self.init_alias()
   508|         0|            0|            0|  0.00%|        self.init_logstart()
   509|         0|            0|            0|  0.00%|        self.init_pdb()
   510|         0|            0|            0|  0.00%|        self.init_extension_manager()
   511|         0|            0|            0|  0.00%|        self.init_payload()
   512|         0|            0|            0|  0.00%|        self.init_deprecation_warnings()
   513|         0|            0|            0|  0.00%|        self.hooks.late_startup_hook()
   514|         0|            0|            0|  0.00%|        self.events.trigger('shell_initialized', self)
   515|         0|            0|            0|  0.00%|        atexit.register(self.atexit_operations)
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|    def get_ipython(self):
   518|         0|            0|            0|  0.00%|        """Return the currently running IPython instance."""
   519|         0|            0|            0|  0.00%|        return self
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   522|         0|            0|            0|  0.00%|    # Trait changed handlers
   523|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   524|         0|            0|            0|  0.00%|    @observe('ipython_dir')
   525|         0|            0|            0|  0.00%|    def _ipython_dir_changed(self, change):
   526|         0|            0|            0|  0.00%|        ensure_dir_exists(change['new'])
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|    def set_autoindent(self,value=None):
   529|         0|            0|            0|  0.00%|        """Set the autoindent flag.
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|        If called with no arguments, it acts as a toggle."""
   532|         0|            0|            0|  0.00%|        if value is None:
   533|         0|            0|            0|  0.00%|            self.autoindent = not self.autoindent
   534|         0|            0|            0|  0.00%|        else:
   535|         0|            0|            0|  0.00%|            self.autoindent = value
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   538|         0|            0|            0|  0.00%|    # init_* methods called by __init__
   539|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   540|         0|            0|            0|  0.00%|
   541|         0|            0|            0|  0.00%|    def init_ipython_dir(self, ipython_dir):
   542|         0|            0|            0|  0.00%|        if ipython_dir is not None:
   543|         0|            0|            0|  0.00%|            self.ipython_dir = ipython_dir
   544|         0|            0|            0|  0.00%|            return
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|        self.ipython_dir = get_ipython_dir()
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|    def init_profile_dir(self, profile_dir):
   549|         0|            0|            0|  0.00%|        if profile_dir is not None:
   550|         0|            0|            0|  0.00%|            self.profile_dir = profile_dir
   551|         0|            0|            0|  0.00%|            return
   552|         0|            0|            0|  0.00%|        self.profile_dir =\
   553|         0|            0|            0|  0.00%|            ProfileDir.create_profile_dir_by_name(self.ipython_dir, 'default')
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|    def init_instance_attrs(self):
   556|         0|            0|            0|  0.00%|        self.more = False
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|        # command compiler
   559|         0|            0|            0|  0.00%|        self.compile = CachingCompiler()
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|        # Make an empty namespace, which extension writers can rely on both
   562|         0|            0|            0|  0.00%|        # existing and NEVER being used by ipython itself.  This gives them a
   563|         0|            0|            0|  0.00%|        # convenient location for storing additional information and state
   564|         0|            0|            0|  0.00%|        # their extensions may require, without fear of collisions with other
   565|         0|            0|            0|  0.00%|        # ipython names that may develop later.
   566|         0|            0|            0|  0.00%|        self.meta = Struct()
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|        # Temporary files used for various purposes.  Deleted at exit.
   569|         0|            0|            0|  0.00%|        self.tempfiles = []
   570|         0|            0|            0|  0.00%|        self.tempdirs = []
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|        # keep track of where we started running (mainly for crash post-mortem)
   573|         0|            0|            0|  0.00%|        # This is not being used anywhere currently.
   574|         0|            0|            0|  0.00%|        self.starting_dir = py3compat.getcwd()
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|        # Indentation management
   577|         0|            0|            0|  0.00%|        self.indent_current_nsp = 0
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|        # Dict to track post-execution functions that have been registered
   580|         0|            0|            0|  0.00%|        self._post_execute = {}
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|    def init_environment(self):
   583|         0|            0|            0|  0.00%|        """Any changes we need to make to the user's environment."""
   584|         0|            0|            0|  0.00%|        pass
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|    def init_encoding(self):
   587|         0|            0|            0|  0.00%|        # Get system encoding at startup time.  Certain terminals (like Emacs
   588|         0|            0|            0|  0.00%|        # under Win32 have it set to None, and we need to have a known valid
   589|         0|            0|            0|  0.00%|        # encoding to use in the raw_input() method
   590|         0|            0|            0|  0.00%|        try:
   591|         0|            0|            0|  0.00%|            self.stdin_encoding = sys.stdin.encoding or 'ascii'
   592|         0|            0|            0|  0.00%|        except AttributeError:
   593|         0|            0|            0|  0.00%|            self.stdin_encoding = 'ascii'
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|    def init_syntax_highlighting(self):
   596|         0|            0|            0|  0.00%|        # Python source parser/formatter for syntax highlighting
   597|         0|            0|            0|  0.00%|        pyformat = PyColorize.Parser().format
   598|         0|            0|            0|  0.00%|        self.pycolorize = lambda src: pyformat(src,'str',self.colors)
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|    def refresh_style(self):
   601|         0|            0|            0|  0.00%|        # No-op here, used in subclass
   602|         0|            0|            0|  0.00%|        pass
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|    def init_pushd_popd_magic(self):
   605|         0|            0|            0|  0.00%|        # for pushd/popd management
   606|         0|            0|            0|  0.00%|        self.home_dir = get_home_dir()
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|        self.dir_stack = []
   609|         0|            0|            0|  0.00%|
   610|         0|            0|            0|  0.00%|    def init_logger(self):
   611|         0|            0|            0|  0.00%|        self.logger = Logger(self.home_dir, logfname='ipython_log.py',
   612|         0|            0|            0|  0.00%|                             logmode='rotate')
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|    def init_logstart(self):
   615|         0|            0|            0|  0.00%|        """Initialize logging in case it was requested at the command line.
   616|         0|            0|            0|  0.00%|        """
   617|         0|            0|            0|  0.00%|        if self.logappend:
   618|         0|            0|            0|  0.00%|            self.magic('logstart %s append' % self.logappend)
   619|         0|            0|            0|  0.00%|        elif self.logfile:
   620|         0|            0|            0|  0.00%|            self.magic('logstart %s' % self.logfile)
   621|         0|            0|            0|  0.00%|        elif self.logstart:
   622|         0|            0|            0|  0.00%|            self.magic('logstart')
   623|         0|            0|            0|  0.00%|
   624|         0|            0|            0|  0.00%|    def init_deprecation_warnings(self):
   625|         0|            0|            0|  0.00%|        """
   626|         0|            0|            0|  0.00%|        register default filter for deprecation warning.
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|        This will allow deprecation warning of function used interactively to show
   629|         0|            0|            0|  0.00%|        warning to users, and still hide deprecation warning from libraries import.
   630|         0|            0|            0|  0.00%|        """
   631|         0|            0|            0|  0.00%|        warnings.filterwarnings("default", category=DeprecationWarning, module=self.user_ns.get("__name__"))
   632|         0|            0|            0|  0.00%|
   633|         0|            0|            0|  0.00%|    def init_builtins(self):
   634|         0|            0|            0|  0.00%|        # A single, static flag that we set to True.  Its presence indicates
   635|         0|            0|            0|  0.00%|        # that an IPython shell has been created, and we make no attempts at
   636|         0|            0|            0|  0.00%|        # removing on exit or representing the existence of more than one
   637|         0|            0|            0|  0.00%|        # IPython at a time.
   638|         0|            0|            0|  0.00%|        builtin_mod.__dict__['__IPYTHON__'] = True
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|        self.builtin_trap = BuiltinTrap(shell=self)
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|    def init_inspector(self):
   643|         0|            0|            0|  0.00%|        # Object inspector
   644|         0|            0|            0|  0.00%|        self.inspector = oinspect.Inspector(oinspect.InspectColors,
   645|         0|            0|            0|  0.00%|                                            PyColorize.ANSICodeColors,
   646|         0|            0|            0|  0.00%|                                            'NoColor',
   647|         0|            0|            0|  0.00%|                                            self.object_info_string_level)
   648|         0|            0|            0|  0.00%|
   649|         0|            0|            0|  0.00%|    def init_io(self):
   650|         0|            0|            0|  0.00%|        # This will just use sys.stdout and sys.stderr. If you want to
   651|         0|            0|            0|  0.00%|        # override sys.stdout and sys.stderr themselves, you need to do that
   652|         0|            0|            0|  0.00%|        # *before* instantiating this class, because io holds onto
   653|         0|            0|            0|  0.00%|        # references to the underlying streams.
   654|         0|            0|            0|  0.00%|        # io.std* are deprecated, but don't show our own deprecation warnings
   655|         0|            0|            0|  0.00%|        # during initialization of the deprecated API.
   656|         0|            0|            0|  0.00%|        with warnings.catch_warnings():
   657|         0|            0|            0|  0.00%|            warnings.simplefilter('ignore', DeprecationWarning)
   658|         0|            0|            0|  0.00%|            io.stdout = io.IOStream(sys.stdout)
   659|         0|            0|            0|  0.00%|            io.stderr = io.IOStream(sys.stderr)
   660|         0|            0|            0|  0.00%|
   661|         0|            0|            0|  0.00%|    def init_prompts(self):
   662|         0|            0|            0|  0.00%|        # Set system prompts, so that scripts can decide if they are running
   663|         0|            0|            0|  0.00%|        # interactively.
   664|         0|            0|            0|  0.00%|        sys.ps1 = 'In : '
   665|         0|            0|            0|  0.00%|        sys.ps2 = '...: '
   666|         0|            0|            0|  0.00%|        sys.ps3 = 'Out: '
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|    def init_display_formatter(self):
   669|         0|            0|            0|  0.00%|        self.display_formatter = DisplayFormatter(parent=self)
   670|         0|            0|            0|  0.00%|        self.configurables.append(self.display_formatter)
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|    def init_display_pub(self):
   673|         0|            0|            0|  0.00%|        self.display_pub = self.display_pub_class(parent=self)
   674|         0|            0|            0|  0.00%|        self.configurables.append(self.display_pub)
   675|         0|            0|            0|  0.00%|
   676|         0|            0|            0|  0.00%|    def init_data_pub(self):
   677|         0|            0|            0|  0.00%|        if not self.data_pub_class:
   678|         0|            0|            0|  0.00%|            self.data_pub = None
   679|         0|            0|            0|  0.00%|            return
   680|         0|            0|            0|  0.00%|        self.data_pub = self.data_pub_class(parent=self)
   681|         0|            0|            0|  0.00%|        self.configurables.append(self.data_pub)
   682|         0|            0|            0|  0.00%|
   683|         0|            0|            0|  0.00%|    def init_displayhook(self):
   684|         0|            0|            0|  0.00%|        # Initialize displayhook, set in/out prompts and printing system
   685|         0|            0|            0|  0.00%|        self.displayhook = self.displayhook_class(
   686|         0|            0|            0|  0.00%|            parent=self,
   687|         0|            0|            0|  0.00%|            shell=self,
   688|         0|            0|            0|  0.00%|            cache_size=self.cache_size,
   689|         0|            0|            0|  0.00%|        )
   690|         0|            0|            0|  0.00%|        self.configurables.append(self.displayhook)
   691|         0|            0|            0|  0.00%|        # This is a context manager that installs/revmoes the displayhook at
   692|         0|            0|            0|  0.00%|        # the appropriate time.
   693|         0|            0|            0|  0.00%|        self.display_trap = DisplayTrap(hook=self.displayhook)
   694|         0|            0|            0|  0.00%|
   695|         0|            0|            0|  0.00%|    def init_virtualenv(self):
   696|         0|            0|            0|  0.00%|        """Add a virtualenv to sys.path so the user can import modules from it.
   697|         0|            0|            0|  0.00%|        This isn't perfect: it doesn't use the Python interpreter with which the
   698|         0|            0|            0|  0.00%|        virtualenv was built, and it ignores the --no-site-packages option. A
   699|         0|            0|            0|  0.00%|        warning will appear suggesting the user installs IPython in the
   700|         0|            0|            0|  0.00%|        virtualenv, but for many cases, it probably works well enough.
   701|         0|            0|            0|  0.00%|
   702|         0|            0|            0|  0.00%|        Adapted from code snippets online.
   703|         0|            0|            0|  0.00%|
   704|         0|            0|            0|  0.00%|        http://blog.ufsoft.org/2009/1/29/ipython-and-virtualenv
   705|         0|            0|            0|  0.00%|        """
   706|         0|            0|            0|  0.00%|        if 'VIRTUAL_ENV' not in os.environ:
   707|         0|            0|            0|  0.00%|            # Not in a virtualenv
   708|         0|            0|            0|  0.00%|            return
   709|         0|            0|            0|  0.00%|
   710|         0|            0|            0|  0.00%|        # venv detection:
   711|         0|            0|            0|  0.00%|        # stdlib venv may symlink sys.executable, so we can't use realpath.
   712|         0|            0|            0|  0.00%|        # but others can symlink *to* the venv Python, so we can't just use sys.executable.
   713|         0|            0|            0|  0.00%|        # So we just check every item in the symlink tree (generally <= 3)
   714|         0|            0|            0|  0.00%|        p = os.path.normcase(sys.executable)
   715|         0|            0|            0|  0.00%|        paths = [p]
   716|         0|            0|            0|  0.00%|        while os.path.islink(p):
   717|         0|            0|            0|  0.00%|            p = os.path.normcase(os.path.join(os.path.dirname(p), os.readlink(p)))
   718|         0|            0|            0|  0.00%|            paths.append(p)
   719|         0|            0|            0|  0.00%|        p_venv = os.path.normcase(os.environ['VIRTUAL_ENV'])
   720|         0|            0|            0|  0.00%|        if any(p.startswith(p_venv) for p in paths):
   721|         0|            0|            0|  0.00%|            # Running properly in the virtualenv, don't need to do anything
   722|         0|            0|            0|  0.00%|            return
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|        warn("Attempting to work in a virtualenv. If you encounter problems, please "
   725|         0|            0|            0|  0.00%|             "install IPython inside the virtualenv.")
   726|         0|            0|            0|  0.00%|        if sys.platform == "win32":
   727|         0|            0|            0|  0.00%|            virtual_env = os.path.join(os.environ['VIRTUAL_ENV'], 'Lib', 'site-packages')
   728|         0|            0|            0|  0.00%|        else:
   729|         0|            0|            0|  0.00%|            virtual_env = os.path.join(os.environ['VIRTUAL_ENV'], 'lib',
   730|         0|            0|            0|  0.00%|                       'python%d.%d' % sys.version_info[:2], 'site-packages')
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|        import site
   733|         0|            0|            0|  0.00%|        sys.path.insert(0, virtual_env)
   734|         0|            0|            0|  0.00%|        site.addsitedir(virtual_env)
   735|         0|            0|            0|  0.00%|
   736|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   737|         0|            0|            0|  0.00%|    # Things related to injections into the sys module
   738|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|    def save_sys_module_state(self):
   741|         0|            0|            0|  0.00%|        """Save the state of hooks in the sys module.
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|        This has to be called after self.user_module is created.
   744|         0|            0|            0|  0.00%|        """
   745|         0|            0|            0|  0.00%|        self._orig_sys_module_state = {'stdin': sys.stdin,
   746|         0|            0|            0|  0.00%|                                       'stdout': sys.stdout,
   747|         0|            0|            0|  0.00%|                                       'stderr': sys.stderr,
   748|         0|            0|            0|  0.00%|                                       'excepthook': sys.excepthook}
   749|         0|            0|            0|  0.00%|        self._orig_sys_modules_main_name = self.user_module.__name__
   750|         0|            0|            0|  0.00%|        self._orig_sys_modules_main_mod = sys.modules.get(self.user_module.__name__)
   751|         0|            0|            0|  0.00%|
   752|         0|            0|            0|  0.00%|    def restore_sys_module_state(self):
   753|         0|            0|            0|  0.00%|        """Restore the state of the sys module."""
   754|         0|            0|            0|  0.00%|        try:
   755|         0|            0|            0|  0.00%|            for k, v in iteritems(self._orig_sys_module_state):
   756|         0|            0|            0|  0.00%|                setattr(sys, k, v)
   757|         0|            0|            0|  0.00%|        except AttributeError:
   758|         0|            0|            0|  0.00%|            pass
   759|         0|            0|            0|  0.00%|        # Reset what what done in self.init_sys_modules
   760|         0|            0|            0|  0.00%|        if self._orig_sys_modules_main_mod is not None:
   761|         0|            0|            0|  0.00%|            sys.modules[self._orig_sys_modules_main_name] = self._orig_sys_modules_main_mod
   762|         0|            0|            0|  0.00%|
   763|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   764|         0|            0|            0|  0.00%|    # Things related to the banner
   765|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|    @property
   768|         0|            0|            0|  0.00%|    def banner(self):
   769|         0|            0|            0|  0.00%|        banner = self.banner1
   770|         0|            0|            0|  0.00%|        if self.profile and self.profile != 'default':
   771|         0|            0|            0|  0.00%|            banner += '\nIPython profile: %s\n' % self.profile
   772|         0|            0|            0|  0.00%|        if self.banner2:
   773|         0|            0|            0|  0.00%|            banner += '\n' + self.banner2
   774|         0|            0|            0|  0.00%|        return banner
   775|         0|            0|            0|  0.00%|
   776|         0|            0|            0|  0.00%|    def show_banner(self, banner=None):
   777|         0|            0|            0|  0.00%|        if banner is None:
   778|         0|            0|            0|  0.00%|            banner = self.banner
   779|         0|            0|            0|  0.00%|        sys.stdout.write(banner)
   780|         0|            0|            0|  0.00%|
   781|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   782|         0|            0|            0|  0.00%|    # Things related to hooks
   783|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   784|         0|            0|            0|  0.00%|
   785|         0|            0|            0|  0.00%|    def init_hooks(self):
   786|         0|            0|            0|  0.00%|        # hooks holds pointers used for user-side customizations
   787|         0|            0|            0|  0.00%|        self.hooks = Struct()
   788|         0|            0|            0|  0.00%|
   789|         0|            0|            0|  0.00%|        self.strdispatchers = {}
   790|         0|            0|            0|  0.00%|
   791|         0|            0|            0|  0.00%|        # Set all default hooks, defined in the IPython.hooks module.
   792|         0|            0|            0|  0.00%|        hooks = IPython.core.hooks
   793|         0|            0|            0|  0.00%|        for hook_name in hooks.__all__:
   794|         0|            0|            0|  0.00%|            # default hooks have priority 100, i.e. low; user hooks should have
   795|         0|            0|            0|  0.00%|            # 0-100 priority
   796|         0|            0|            0|  0.00%|            self.set_hook(hook_name,getattr(hooks,hook_name), 100, _warn_deprecated=False)
   797|         0|            0|            0|  0.00%|
   798|         0|            0|            0|  0.00%|        if self.display_page:
   799|         0|            0|            0|  0.00%|            self.set_hook('show_in_pager', page.as_hook(page.display_page), 90)
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|    def set_hook(self,name,hook, priority=50, str_key=None, re_key=None,
   802|         0|            0|            0|  0.00%|                 _warn_deprecated=True):
   803|         0|            0|            0|  0.00%|        """set_hook(name,hook) -> sets an internal IPython hook.
   804|         0|            0|            0|  0.00%|
   805|         0|            0|            0|  0.00%|        IPython exposes some of its internal API as user-modifiable hooks.  By
   806|         0|            0|            0|  0.00%|        adding your function to one of these hooks, you can modify IPython's
   807|         0|            0|            0|  0.00%|        behavior to call at runtime your own routines."""
   808|         0|            0|            0|  0.00%|
   809|         0|            0|            0|  0.00%|        # At some point in the future, this should validate the hook before it
   810|         0|            0|            0|  0.00%|        # accepts it.  Probably at least check that the hook takes the number
   811|         0|            0|            0|  0.00%|        # of args it's supposed to.
   812|         0|            0|            0|  0.00%|
   813|         0|            0|            0|  0.00%|        f = types.MethodType(hook,self)
   814|         0|            0|            0|  0.00%|
   815|         0|            0|            0|  0.00%|        # check if the hook is for strdispatcher first
   816|         0|            0|            0|  0.00%|        if str_key is not None:
   817|         0|            0|            0|  0.00%|            sdp = self.strdispatchers.get(name, StrDispatch())
   818|         0|            0|            0|  0.00%|            sdp.add_s(str_key, f, priority )
   819|         0|            0|            0|  0.00%|            self.strdispatchers[name] = sdp
   820|         0|            0|            0|  0.00%|            return
   821|         0|            0|            0|  0.00%|        if re_key is not None:
   822|         0|            0|            0|  0.00%|            sdp = self.strdispatchers.get(name, StrDispatch())
   823|         0|            0|            0|  0.00%|            sdp.add_re(re.compile(re_key), f, priority )
   824|         0|            0|            0|  0.00%|            self.strdispatchers[name] = sdp
   825|         0|            0|            0|  0.00%|            return
   826|         0|            0|            0|  0.00%|
   827|         0|            0|            0|  0.00%|        dp = getattr(self.hooks, name, None)
   828|         0|            0|            0|  0.00%|        if name not in IPython.core.hooks.__all__:
   829|         0|            0|            0|  0.00%|            print("Warning! Hook '%s' is not one of %s" % \
   830|         0|            0|            0|  0.00%|                  (name, IPython.core.hooks.__all__ ))
   831|         0|            0|            0|  0.00%|
   832|         0|            0|            0|  0.00%|        if _warn_deprecated and (name in IPython.core.hooks.deprecated):
   833|         0|            0|            0|  0.00%|            alternative = IPython.core.hooks.deprecated[name]
   834|         0|            0|            0|  0.00%|            warn("Hook {} is deprecated. Use {} instead.".format(name, alternative))
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|        if not dp:
   837|         0|            0|            0|  0.00%|            dp = IPython.core.hooks.CommandChainDispatcher()
   838|         0|            0|            0|  0.00%|
   839|         0|            0|            0|  0.00%|        try:
   840|         0|            0|            0|  0.00%|            dp.add(f,priority)
   841|         0|            0|            0|  0.00%|        except AttributeError:
   842|         0|            0|            0|  0.00%|            # it was not commandchain, plain old func - replace
   843|         0|            0|            0|  0.00%|            dp = f
   844|         0|            0|            0|  0.00%|
   845|         0|            0|            0|  0.00%|        setattr(self.hooks,name, dp)
   846|         0|            0|            0|  0.00%|
   847|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   848|         0|            0|            0|  0.00%|    # Things related to events
   849|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   850|         0|            0|            0|  0.00%|
   851|         0|            0|            0|  0.00%|    def init_events(self):
   852|         0|            0|            0|  0.00%|        self.events = EventManager(self, available_events)
   853|         0|            0|            0|  0.00%|
   854|         0|            0|            0|  0.00%|        self.events.register("pre_execute", self._clear_warning_registry)
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|    def register_post_execute(self, func):
   857|         0|            0|            0|  0.00%|        """DEPRECATED: Use ip.events.register('post_run_cell', func)
   858|         0|            0|            0|  0.00%|
   859|         0|            0|            0|  0.00%|        Register a function for calling after code execution.
   860|         0|            0|            0|  0.00%|        """
   861|         0|            0|            0|  0.00%|        warn("ip.register_post_execute is deprecated, use "
   862|         0|            0|            0|  0.00%|             "ip.events.register('post_run_cell', func) instead.")
   863|         0|            0|            0|  0.00%|        self.events.register('post_run_cell', func)
   864|         0|            0|            0|  0.00%|
   865|         0|            0|            0|  0.00%|    def _clear_warning_registry(self):
   866|         0|            0|            0|  0.00%|        # clear the warning registry, so that different code blocks with
   867|         0|            0|            0|  0.00%|        # overlapping line number ranges don't cause spurious suppression of
   868|         0|            0|            0|  0.00%|        # warnings (see gh-6611 for details)
   869|         0|            0|            0|  0.00%|        if "__warningregistry__" in self.user_global_ns:
   870|         0|            0|            0|  0.00%|            del self.user_global_ns["__warningregistry__"]
   871|         0|            0|            0|  0.00%|
   872|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   873|         0|            0|            0|  0.00%|    # Things related to the "main" module
   874|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   875|         0|            0|            0|  0.00%|
   876|         0|            0|            0|  0.00%|    def new_main_mod(self, filename, modname):
   877|         0|            0|            0|  0.00%|        """Return a new 'main' module object for user code execution.
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|        ``filename`` should be the path of the script which will be run in the
   880|         0|            0|            0|  0.00%|        module. Requests with the same filename will get the same module, with
   881|         0|            0|            0|  0.00%|        its namespace cleared.
   882|         0|            0|            0|  0.00%|
   883|         0|            0|            0|  0.00%|        ``modname`` should be the module name - normally either '__main__' or
   884|         0|            0|            0|  0.00%|        the basename of the file without the extension.
   885|         0|            0|            0|  0.00%|
   886|         0|            0|            0|  0.00%|        When scripts are executed via %run, we must keep a reference to their
   887|         0|            0|            0|  0.00%|        __main__ module around so that Python doesn't
   888|         0|            0|            0|  0.00%|        clear it, rendering references to module globals useless.
   889|         0|            0|            0|  0.00%|
   890|         0|            0|            0|  0.00%|        This method keeps said reference in a private dict, keyed by the
   891|         0|            0|            0|  0.00%|        absolute path of the script. This way, for multiple executions of the
   892|         0|            0|            0|  0.00%|        same script we only keep one copy of the namespace (the last one),
   893|         0|            0|            0|  0.00%|        thus preventing memory leaks from old references while allowing the
   894|         0|            0|            0|  0.00%|        objects from the last execution to be accessible.
   895|         0|            0|            0|  0.00%|        """
   896|         0|            0|            0|  0.00%|        filename = os.path.abspath(filename)
   897|         0|            0|            0|  0.00%|        try:
   898|         0|            0|            0|  0.00%|            main_mod = self._main_mod_cache[filename]
   899|         0|            0|            0|  0.00%|        except KeyError:
   900|         0|            0|            0|  0.00%|            main_mod = self._main_mod_cache[filename] = types.ModuleType(
   901|         0|            0|            0|  0.00%|                        py3compat.cast_bytes_py2(modname),
   902|         0|            0|            0|  0.00%|                        doc="Module created for script run in IPython")
   903|         0|            0|            0|  0.00%|        else:
   904|         0|            0|            0|  0.00%|            main_mod.__dict__.clear()
   905|         0|            0|            0|  0.00%|            main_mod.__name__ = modname
   906|         0|            0|            0|  0.00%|
   907|         0|            0|            0|  0.00%|        main_mod.__file__ = filename
   908|         0|            0|            0|  0.00%|        # It seems pydoc (and perhaps others) needs any module instance to
   909|         0|            0|            0|  0.00%|        # implement a __nonzero__ method
   910|         0|            0|            0|  0.00%|        main_mod.__nonzero__ = lambda : True
   911|         0|            0|            0|  0.00%|
   912|         0|            0|            0|  0.00%|        return main_mod
   913|         0|            0|            0|  0.00%|
   914|         0|            0|            0|  0.00%|    def clear_main_mod_cache(self):
   915|         0|            0|            0|  0.00%|        """Clear the cache of main modules.
   916|         0|            0|            0|  0.00%|
   917|         0|            0|            0|  0.00%|        Mainly for use by utilities like %reset.
   918|         0|            0|            0|  0.00%|
   919|         0|            0|            0|  0.00%|        Examples
   920|         0|            0|            0|  0.00%|        --------
   921|         0|            0|            0|  0.00%|
   922|         0|            0|            0|  0.00%|        In [15]: import IPython
   923|         0|            0|            0|  0.00%|
   924|         0|            0|            0|  0.00%|        In [16]: m = _ip.new_main_mod(IPython.__file__, 'IPython')
   925|         0|            0|            0|  0.00%|
   926|         0|            0|            0|  0.00%|        In [17]: len(_ip._main_mod_cache) > 0
   927|         0|            0|            0|  0.00%|        Out[17]: True
   928|         0|            0|            0|  0.00%|
   929|         0|            0|            0|  0.00%|        In [18]: _ip.clear_main_mod_cache()
   930|         0|            0|            0|  0.00%|
   931|         0|            0|            0|  0.00%|        In [19]: len(_ip._main_mod_cache) == 0
   932|         0|            0|            0|  0.00%|        Out[19]: True
   933|         0|            0|            0|  0.00%|        """
   934|         0|            0|            0|  0.00%|        self._main_mod_cache.clear()
   935|         0|            0|            0|  0.00%|
   936|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   937|         0|            0|            0|  0.00%|    # Things related to debugging
   938|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   939|         0|            0|            0|  0.00%|
   940|         0|            0|            0|  0.00%|    def init_pdb(self):
   941|         0|            0|            0|  0.00%|        # Set calling of pdb on exceptions
   942|         0|            0|            0|  0.00%|        # self.call_pdb is a property
   943|         0|            0|            0|  0.00%|        self.call_pdb = self.pdb
   944|         0|            0|            0|  0.00%|
   945|         0|            0|            0|  0.00%|    def _get_call_pdb(self):
   946|         0|            0|            0|  0.00%|        return self._call_pdb
   947|         0|            0|            0|  0.00%|
   948|         0|            0|            0|  0.00%|    def _set_call_pdb(self,val):
   949|         0|            0|            0|  0.00%|
   950|         0|            0|            0|  0.00%|        if val not in (0,1,False,True):
   951|         0|            0|            0|  0.00%|            raise ValueError('new call_pdb value must be boolean')
   952|         0|            0|            0|  0.00%|
   953|         0|            0|            0|  0.00%|        # store value in instance
   954|         0|            0|            0|  0.00%|        self._call_pdb = val
   955|         0|            0|            0|  0.00%|
   956|         0|            0|            0|  0.00%|        # notify the actual exception handlers
   957|         0|            0|            0|  0.00%|        self.InteractiveTB.call_pdb = val
   958|         0|            0|            0|  0.00%|
   959|         0|            0|            0|  0.00%|    call_pdb = property(_get_call_pdb,_set_call_pdb,None,
   960|         0|            0|            0|  0.00%|                        'Control auto-activation of pdb at exceptions')
   961|         0|            0|            0|  0.00%|
   962|         0|            0|            0|  0.00%|    def debugger(self,force=False):
   963|         0|            0|            0|  0.00%|        """Call the pdb debugger.
   964|         0|            0|            0|  0.00%|
   965|         0|            0|            0|  0.00%|        Keywords:
   966|         0|            0|            0|  0.00%|
   967|         0|            0|            0|  0.00%|          - force(False): by default, this routine checks the instance call_pdb
   968|         0|            0|            0|  0.00%|            flag and does not actually invoke the debugger if the flag is false.
   969|         0|            0|            0|  0.00%|            The 'force' option forces the debugger to activate even if the flag
   970|         0|            0|            0|  0.00%|            is false.
   971|         0|            0|            0|  0.00%|        """
   972|         0|            0|            0|  0.00%|
   973|         0|            0|            0|  0.00%|        if not (force or self.call_pdb):
   974|         0|            0|            0|  0.00%|            return
   975|         0|            0|            0|  0.00%|
   976|         0|            0|            0|  0.00%|        if not hasattr(sys,'last_traceback'):
   977|         0|            0|            0|  0.00%|            error('No traceback has been produced, nothing to debug.')
   978|         0|            0|            0|  0.00%|            return
   979|         0|            0|            0|  0.00%|
   980|         0|            0|            0|  0.00%|        self.InteractiveTB.debugger(force=True)
   981|         0|            0|            0|  0.00%|
   982|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   983|         0|            0|            0|  0.00%|    # Things related to IPython's various namespaces
   984|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
   985|         0|            0|            0|  0.00%|    default_user_namespaces = True
   986|         0|            0|            0|  0.00%|
   987|         0|            0|            0|  0.00%|    def init_create_namespaces(self, user_module=None, user_ns=None):
   988|         0|            0|            0|  0.00%|        # Create the namespace where the user will operate.  user_ns is
   989|         0|            0|            0|  0.00%|        # normally the only one used, and it is passed to the exec calls as
   990|         0|            0|            0|  0.00%|        # the locals argument.  But we do carry a user_global_ns namespace
   991|         0|            0|            0|  0.00%|        # given as the exec 'globals' argument,  This is useful in embedding
   992|         0|            0|            0|  0.00%|        # situations where the ipython shell opens in a context where the
   993|         0|            0|            0|  0.00%|        # distinction between locals and globals is meaningful.  For
   994|         0|            0|            0|  0.00%|        # non-embedded contexts, it is just the same object as the user_ns dict.
   995|         0|            0|            0|  0.00%|
   996|         0|            0|            0|  0.00%|        # FIXME. For some strange reason, __builtins__ is showing up at user
   997|         0|            0|            0|  0.00%|        # level as a dict instead of a module. This is a manual fix, but I
   998|         0|            0|            0|  0.00%|        # should really track down where the problem is coming from. Alex
   999|         0|            0|            0|  0.00%|        # Schmolck reported this problem first.
  1000|         0|            0|            0|  0.00%|
  1001|         0|            0|            0|  0.00%|        # A useful post by Alex Martelli on this topic:
  1002|         0|            0|            0|  0.00%|        # Re: inconsistent value from __builtins__
  1003|         0|            0|            0|  0.00%|        # Von: Alex Martelli <aleaxit@yahoo.com>
  1004|         0|            0|            0|  0.00%|        # Datum: Freitag 01 Oktober 2004 04:45:34 nachmittags/abends
  1005|         0|            0|            0|  0.00%|        # Gruppen: comp.lang.python
  1006|         0|            0|            0|  0.00%|
  1007|         0|            0|            0|  0.00%|        # Michael Hohn <hohn@hooknose.lbl.gov> wrote:
  1008|         0|            0|            0|  0.00%|        # > >>> print type(builtin_check.get_global_binding('__builtins__'))
  1009|         0|            0|            0|  0.00%|        # > <type 'dict'>
  1010|         0|            0|            0|  0.00%|        # > >>> print type(__builtins__)
  1011|         0|            0|            0|  0.00%|        # > <type 'module'>
  1012|         0|            0|            0|  0.00%|        # > Is this difference in return value intentional?
  1013|         0|            0|            0|  0.00%|
  1014|         0|            0|            0|  0.00%|        # Well, it's documented that '__builtins__' can be either a dictionary
  1015|         0|            0|            0|  0.00%|        # or a module, and it's been that way for a long time. Whether it's
  1016|         0|            0|            0|  0.00%|        # intentional (or sensible), I don't know. In any case, the idea is
  1017|         0|            0|            0|  0.00%|        # that if you need to access the built-in namespace directly, you
  1018|         0|            0|            0|  0.00%|        # should start with "import __builtin__" (note, no 's') which will
  1019|         0|            0|            0|  0.00%|        # definitely give you a module. Yeah, it's somewhat confusing:-(.
  1020|         0|            0|            0|  0.00%|
  1021|         0|            0|            0|  0.00%|        # These routines return a properly built module and dict as needed by
  1022|         0|            0|            0|  0.00%|        # the rest of the code, and can also be used by extension writers to
  1023|         0|            0|            0|  0.00%|        # generate properly initialized namespaces.
  1024|         0|            0|            0|  0.00%|        if (user_ns is not None) or (user_module is not None):
  1025|         0|            0|            0|  0.00%|            self.default_user_namespaces = False
  1026|         0|            0|            0|  0.00%|        self.user_module, self.user_ns = self.prepare_user_module(user_module, user_ns)
  1027|         0|            0|            0|  0.00%|
  1028|         0|            0|            0|  0.00%|        # A record of hidden variables we have added to the user namespace, so
  1029|         0|            0|            0|  0.00%|        # we can list later only variables defined in actual interactive use.
  1030|         0|            0|            0|  0.00%|        self.user_ns_hidden = {}
  1031|         0|            0|            0|  0.00%|
  1032|         0|            0|            0|  0.00%|        # Now that FakeModule produces a real module, we've run into a nasty
  1033|         0|            0|            0|  0.00%|        # problem: after script execution (via %run), the module where the user
  1034|         0|            0|            0|  0.00%|        # code ran is deleted.  Now that this object is a true module (needed
  1035|         0|            0|            0|  0.00%|        # so doctest and other tools work correctly), the Python module
  1036|         0|            0|            0|  0.00%|        # teardown mechanism runs over it, and sets to None every variable
  1037|         0|            0|            0|  0.00%|        # present in that module.  Top-level references to objects from the
  1038|         0|            0|            0|  0.00%|        # script survive, because the user_ns is updated with them.  However,
  1039|         0|            0|            0|  0.00%|        # calling functions defined in the script that use other things from
  1040|         0|            0|            0|  0.00%|        # the script will fail, because the function's closure had references
  1041|         0|            0|            0|  0.00%|        # to the original objects, which are now all None.  So we must protect
  1042|         0|            0|            0|  0.00%|        # these modules from deletion by keeping a cache.
  1043|         0|            0|            0|  0.00%|        #
  1044|         0|            0|            0|  0.00%|        # To avoid keeping stale modules around (we only need the one from the
  1045|         0|            0|            0|  0.00%|        # last run), we use a dict keyed with the full path to the script, so
  1046|         0|            0|            0|  0.00%|        # only the last version of the module is held in the cache.  Note,
  1047|         0|            0|            0|  0.00%|        # however, that we must cache the module *namespace contents* (their
  1048|         0|            0|            0|  0.00%|        # __dict__).  Because if we try to cache the actual modules, old ones
  1049|         0|            0|            0|  0.00%|        # (uncached) could be destroyed while still holding references (such as
  1050|         0|            0|            0|  0.00%|        # those held by GUI objects that tend to be long-lived)>
  1051|         0|            0|            0|  0.00%|        #
  1052|         0|            0|            0|  0.00%|        # The %reset command will flush this cache.  See the cache_main_mod()
  1053|         0|            0|            0|  0.00%|        # and clear_main_mod_cache() methods for details on use.
  1054|         0|            0|            0|  0.00%|
  1055|         0|            0|            0|  0.00%|        # This is the cache used for 'main' namespaces
  1056|         0|            0|            0|  0.00%|        self._main_mod_cache = {}
  1057|         0|            0|            0|  0.00%|
  1058|         0|            0|            0|  0.00%|        # A table holding all the namespaces IPython deals with, so that
  1059|         0|            0|            0|  0.00%|        # introspection facilities can search easily.
  1060|         0|            0|            0|  0.00%|        self.ns_table = {'user_global':self.user_module.__dict__,
  1061|         0|            0|            0|  0.00%|                         'user_local':self.user_ns,
  1062|         0|            0|            0|  0.00%|                         'builtin':builtin_mod.__dict__
  1063|         0|            0|            0|  0.00%|                         }
  1064|         0|            0|            0|  0.00%|
  1065|         0|            0|            0|  0.00%|    @property
  1066|         0|            0|            0|  0.00%|    def user_global_ns(self):
  1067|         0|            0|            0|  0.00%|        return self.user_module.__dict__
  1068|         0|            0|            0|  0.00%|
  1069|         0|            0|            0|  0.00%|    def prepare_user_module(self, user_module=None, user_ns=None):
  1070|         0|            0|            0|  0.00%|        """Prepare the module and namespace in which user code will be run.
  1071|         0|            0|            0|  0.00%|
  1072|         0|            0|            0|  0.00%|        When IPython is started normally, both parameters are None: a new module
  1073|         0|            0|            0|  0.00%|        is created automatically, and its __dict__ used as the namespace.
  1074|         0|            0|            0|  0.00%|
  1075|         0|            0|            0|  0.00%|        If only user_module is provided, its __dict__ is used as the namespace.
  1076|         0|            0|            0|  0.00%|        If only user_ns is provided, a dummy module is created, and user_ns
  1077|         0|            0|            0|  0.00%|        becomes the global namespace. If both are provided (as they may be
  1078|         0|            0|            0|  0.00%|        when embedding), user_ns is the local namespace, and user_module
  1079|         0|            0|            0|  0.00%|        provides the global namespace.
  1080|         0|            0|            0|  0.00%|
  1081|         0|            0|            0|  0.00%|        Parameters
  1082|         0|            0|            0|  0.00%|        ----------
  1083|         0|            0|            0|  0.00%|        user_module : module, optional
  1084|         0|            0|            0|  0.00%|            The current user module in which IPython is being run. If None,
  1085|         0|            0|            0|  0.00%|            a clean module will be created.
  1086|         0|            0|            0|  0.00%|        user_ns : dict, optional
  1087|         0|            0|            0|  0.00%|            A namespace in which to run interactive commands.
  1088|         0|            0|            0|  0.00%|
  1089|         0|            0|            0|  0.00%|        Returns
  1090|         0|            0|            0|  0.00%|        -------
  1091|         0|            0|            0|  0.00%|        A tuple of user_module and user_ns, each properly initialised.
  1092|         0|            0|            0|  0.00%|        """
  1093|         0|            0|            0|  0.00%|        if user_module is None and user_ns is not None:
  1094|         0|            0|            0|  0.00%|            user_ns.setdefault("__name__", "__main__")
  1095|         0|            0|            0|  0.00%|            user_module = DummyMod()
  1096|         0|            0|            0|  0.00%|            user_module.__dict__ = user_ns
  1097|         0|            0|            0|  0.00%|
  1098|         0|            0|            0|  0.00%|        if user_module is None:
  1099|         0|            0|            0|  0.00%|            user_module = types.ModuleType("__main__",
  1100|         0|            0|            0|  0.00%|                doc="Automatically created module for IPython interactive environment")
  1101|         0|            0|            0|  0.00%|
  1102|         0|            0|            0|  0.00%|        # We must ensure that __builtin__ (without the final 's') is always
  1103|         0|            0|            0|  0.00%|        # available and pointing to the __builtin__ *module*.  For more details:
  1104|         0|            0|            0|  0.00%|        # http://mail.python.org/pipermail/python-dev/2001-April/014068.html
  1105|         0|            0|            0|  0.00%|        user_module.__dict__.setdefault('__builtin__', builtin_mod)
  1106|         0|            0|            0|  0.00%|        user_module.__dict__.setdefault('__builtins__', builtin_mod)
  1107|         0|            0|            0|  0.00%|
  1108|         0|            0|            0|  0.00%|        if user_ns is None:
  1109|         0|            0|            0|  0.00%|            user_ns = user_module.__dict__
  1110|         0|            0|            0|  0.00%|
  1111|         0|            0|            0|  0.00%|        return user_module, user_ns
  1112|         0|            0|            0|  0.00%|
  1113|         0|            0|            0|  0.00%|    def init_sys_modules(self):
  1114|         0|            0|            0|  0.00%|        # We need to insert into sys.modules something that looks like a
  1115|         0|            0|            0|  0.00%|        # module but which accesses the IPython namespace, for shelve and
  1116|         0|            0|            0|  0.00%|        # pickle to work interactively. Normally they rely on getting
  1117|         0|            0|            0|  0.00%|        # everything out of __main__, but for embedding purposes each IPython
  1118|         0|            0|            0|  0.00%|        # instance has its own private namespace, so we can't go shoving
  1119|         0|            0|            0|  0.00%|        # everything into __main__.
  1120|         0|            0|            0|  0.00%|
  1121|         0|            0|            0|  0.00%|        # note, however, that we should only do this for non-embedded
  1122|         0|            0|            0|  0.00%|        # ipythons, which really mimic the __main__.__dict__ with their own
  1123|         0|            0|            0|  0.00%|        # namespace.  Embedded instances, on the other hand, should not do
  1124|         0|            0|            0|  0.00%|        # this because they need to manage the user local/global namespaces
  1125|         0|            0|            0|  0.00%|        # only, but they live within a 'normal' __main__ (meaning, they
  1126|         0|            0|            0|  0.00%|        # shouldn't overtake the execution environment of the script they're
  1127|         0|            0|            0|  0.00%|        # embedded in).
  1128|         0|            0|            0|  0.00%|
  1129|         0|            0|            0|  0.00%|        # This is overridden in the InteractiveShellEmbed subclass to a no-op.
  1130|         0|            0|            0|  0.00%|        main_name = self.user_module.__name__
  1131|         0|            0|            0|  0.00%|        sys.modules[main_name] = self.user_module
  1132|         0|            0|            0|  0.00%|
  1133|         0|            0|            0|  0.00%|    def init_user_ns(self):
  1134|         0|            0|            0|  0.00%|        """Initialize all user-visible namespaces to their minimum defaults.
  1135|         0|            0|            0|  0.00%|
  1136|         0|            0|            0|  0.00%|        Certain history lists are also initialized here, as they effectively
  1137|         0|            0|            0|  0.00%|        act as user namespaces.
  1138|         0|            0|            0|  0.00%|
  1139|         0|            0|            0|  0.00%|        Notes
  1140|         0|            0|            0|  0.00%|        -----
  1141|         0|            0|            0|  0.00%|        All data structures here are only filled in, they are NOT reset by this
  1142|         0|            0|            0|  0.00%|        method.  If they were not empty before, data will simply be added to
  1143|         0|            0|            0|  0.00%|        therm.
  1144|         0|            0|            0|  0.00%|        """
  1145|         0|            0|            0|  0.00%|        # This function works in two parts: first we put a few things in
  1146|         0|            0|            0|  0.00%|        # user_ns, and we sync that contents into user_ns_hidden so that these
  1147|         0|            0|            0|  0.00%|        # initial variables aren't shown by %who.  After the sync, we add the
  1148|         0|            0|            0|  0.00%|        # rest of what we *do* want the user to see with %who even on a new
  1149|         0|            0|            0|  0.00%|        # session (probably nothing, so they really only see their own stuff)
  1150|         0|            0|            0|  0.00%|
  1151|         0|            0|            0|  0.00%|        # The user dict must *always* have a __builtin__ reference to the
  1152|         0|            0|            0|  0.00%|        # Python standard __builtin__ namespace,  which must be imported.
  1153|         0|            0|            0|  0.00%|        # This is so that certain operations in prompt evaluation can be
  1154|         0|            0|            0|  0.00%|        # reliably executed with builtins.  Note that we can NOT use
  1155|         0|            0|            0|  0.00%|        # __builtins__ (note the 's'),  because that can either be a dict or a
  1156|         0|            0|            0|  0.00%|        # module, and can even mutate at runtime, depending on the context
  1157|         0|            0|            0|  0.00%|        # (Python makes no guarantees on it).  In contrast, __builtin__ is
  1158|         0|            0|            0|  0.00%|        # always a module object, though it must be explicitly imported.
  1159|         0|            0|            0|  0.00%|
  1160|         0|            0|            0|  0.00%|        # For more details:
  1161|         0|            0|            0|  0.00%|        # http://mail.python.org/pipermail/python-dev/2001-April/014068.html
  1162|         0|            0|            0|  0.00%|        ns = dict()
  1163|         0|            0|            0|  0.00%|
  1164|         0|            0|            0|  0.00%|        # make global variables for user access to the histories
  1165|         0|            0|            0|  0.00%|        ns['_ih'] = self.history_manager.input_hist_parsed
  1166|         0|            0|            0|  0.00%|        ns['_oh'] = self.history_manager.output_hist
  1167|         0|            0|            0|  0.00%|        ns['_dh'] = self.history_manager.dir_hist
  1168|         0|            0|            0|  0.00%|
  1169|         0|            0|            0|  0.00%|        ns['_sh'] = shadowns
  1170|         0|            0|            0|  0.00%|
  1171|         0|            0|            0|  0.00%|        # user aliases to input and output histories.  These shouldn't show up
  1172|         0|            0|            0|  0.00%|        # in %who, as they can have very large reprs.
  1173|         0|            0|            0|  0.00%|        ns['In']  = self.history_manager.input_hist_parsed
  1174|         0|            0|            0|  0.00%|        ns['Out'] = self.history_manager.output_hist
  1175|         0|            0|            0|  0.00%|
  1176|         0|            0|            0|  0.00%|        # Store myself as the public api!!!
  1177|         0|            0|            0|  0.00%|        ns['get_ipython'] = self.get_ipython
  1178|         0|            0|            0|  0.00%|
  1179|         0|            0|            0|  0.00%|        ns['exit'] = self.exiter
  1180|         0|            0|            0|  0.00%|        ns['quit'] = self.exiter
  1181|         0|            0|            0|  0.00%|
  1182|         0|            0|            0|  0.00%|        # Sync what we've added so far to user_ns_hidden so these aren't seen
  1183|         0|            0|            0|  0.00%|        # by %who
  1184|         0|            0|            0|  0.00%|        self.user_ns_hidden.update(ns)
  1185|         0|            0|            0|  0.00%|
  1186|         0|            0|            0|  0.00%|        # Anything put into ns now would show up in %who.  Think twice before
  1187|         0|            0|            0|  0.00%|        # putting anything here, as we really want %who to show the user their
  1188|         0|            0|            0|  0.00%|        # stuff, not our variables.
  1189|         0|            0|            0|  0.00%|
  1190|         0|            0|            0|  0.00%|        # Finally, update the real user's namespace
  1191|         0|            0|            0|  0.00%|        self.user_ns.update(ns)
  1192|         0|            0|            0|  0.00%|
  1193|         0|            0|            0|  0.00%|    @property
  1194|         0|            0|            0|  0.00%|    def all_ns_refs(self):
  1195|         0|            0|            0|  0.00%|        """Get a list of references to all the namespace dictionaries in which
  1196|         0|            0|            0|  0.00%|        IPython might store a user-created object.
  1197|         0|            0|            0|  0.00%|
  1198|         0|            0|            0|  0.00%|        Note that this does not include the displayhook, which also caches
  1199|         0|            0|            0|  0.00%|        objects from the output."""
  1200|         0|            0|            0|  0.00%|        return [self.user_ns, self.user_global_ns, self.user_ns_hidden] + \
  1201|         0|            0|            0|  0.00%|               [m.__dict__ for m in self._main_mod_cache.values()]
  1202|         0|            0|            0|  0.00%|
  1203|         0|            0|            0|  0.00%|    def reset(self, new_session=True):
  1204|         0|            0|            0|  0.00%|        """Clear all internal namespaces, and attempt to release references to
  1205|         0|            0|            0|  0.00%|        user objects.
  1206|         0|            0|            0|  0.00%|
  1207|         0|            0|            0|  0.00%|        If new_session is True, a new history session will be opened.
  1208|         0|            0|            0|  0.00%|        """
  1209|         0|            0|            0|  0.00%|        # Clear histories
  1210|         0|            0|            0|  0.00%|        self.history_manager.reset(new_session)
  1211|         0|            0|            0|  0.00%|        # Reset counter used to index all histories
  1212|         0|            0|            0|  0.00%|        if new_session:
  1213|         0|            0|            0|  0.00%|            self.execution_count = 1
  1214|         0|            0|            0|  0.00%|
  1215|         0|            0|            0|  0.00%|        # Flush cached output items
  1216|         0|            0|            0|  0.00%|        if self.displayhook.do_full_cache:
  1217|         0|            0|            0|  0.00%|            self.displayhook.flush()
  1218|         0|            0|            0|  0.00%|
  1219|         0|            0|            0|  0.00%|        # The main execution namespaces must be cleared very carefully,
  1220|         0|            0|            0|  0.00%|        # skipping the deletion of the builtin-related keys, because doing so
  1221|         0|            0|            0|  0.00%|        # would cause errors in many object's __del__ methods.
  1222|         0|            0|            0|  0.00%|        if self.user_ns is not self.user_global_ns:
  1223|         0|            0|            0|  0.00%|            self.user_ns.clear()
  1224|         0|            0|            0|  0.00%|        ns = self.user_global_ns
  1225|         0|            0|            0|  0.00%|        drop_keys = set(ns.keys())
  1226|         0|            0|            0|  0.00%|        drop_keys.discard('__builtin__')
  1227|         0|            0|            0|  0.00%|        drop_keys.discard('__builtins__')
  1228|         0|            0|            0|  0.00%|        drop_keys.discard('__name__')
  1229|         0|            0|            0|  0.00%|        for k in drop_keys:
  1230|         0|            0|            0|  0.00%|            del ns[k]
  1231|         0|            0|            0|  0.00%|
  1232|         0|            0|            0|  0.00%|        self.user_ns_hidden.clear()
  1233|         0|            0|            0|  0.00%|
  1234|         0|            0|            0|  0.00%|        # Restore the user namespaces to minimal usability
  1235|         0|            0|            0|  0.00%|        self.init_user_ns()
  1236|         0|            0|            0|  0.00%|
  1237|         0|            0|            0|  0.00%|        # Restore the default and user aliases
  1238|         0|            0|            0|  0.00%|        self.alias_manager.clear_aliases()
  1239|         0|            0|            0|  0.00%|        self.alias_manager.init_aliases()
  1240|         0|            0|            0|  0.00%|
  1241|         0|            0|            0|  0.00%|        # Flush the private list of module references kept for script
  1242|         0|            0|            0|  0.00%|        # execution protection
  1243|         0|            0|            0|  0.00%|        self.clear_main_mod_cache()
  1244|         0|            0|            0|  0.00%|
  1245|         0|            0|            0|  0.00%|    def del_var(self, varname, by_name=False):
  1246|         0|            0|            0|  0.00%|        """Delete a variable from the various namespaces, so that, as
  1247|         0|            0|            0|  0.00%|        far as possible, we're not keeping any hidden references to it.
  1248|         0|            0|            0|  0.00%|
  1249|         0|            0|            0|  0.00%|        Parameters
  1250|         0|            0|            0|  0.00%|        ----------
  1251|         0|            0|            0|  0.00%|        varname : str
  1252|         0|            0|            0|  0.00%|            The name of the variable to delete.
  1253|         0|            0|            0|  0.00%|        by_name : bool
  1254|         0|            0|            0|  0.00%|            If True, delete variables with the given name in each
  1255|         0|            0|            0|  0.00%|            namespace. If False (default), find the variable in the user
  1256|         0|            0|            0|  0.00%|            namespace, and delete references to it.
  1257|         0|            0|            0|  0.00%|        """
  1258|         0|            0|            0|  0.00%|        if varname in ('__builtin__', '__builtins__'):
  1259|         0|            0|            0|  0.00%|            raise ValueError("Refusing to delete %s" % varname)
  1260|         0|            0|            0|  0.00%|
  1261|         0|            0|            0|  0.00%|        ns_refs = self.all_ns_refs
  1262|         0|            0|            0|  0.00%|
  1263|         0|            0|            0|  0.00%|        if by_name:                    # Delete by name
  1264|         0|            0|            0|  0.00%|            for ns in ns_refs:
  1265|         0|            0|            0|  0.00%|                try:
  1266|         0|            0|            0|  0.00%|                    del ns[varname]
  1267|         0|            0|            0|  0.00%|                except KeyError:
  1268|         0|            0|            0|  0.00%|                    pass
  1269|         0|            0|            0|  0.00%|        else:                         # Delete by object
  1270|         0|            0|            0|  0.00%|            try:
  1271|         0|            0|            0|  0.00%|                obj = self.user_ns[varname]
  1272|         0|            0|            0|  0.00%|            except KeyError:
  1273|         0|            0|            0|  0.00%|                raise NameError("name '%s' is not defined" % varname)
  1274|         0|            0|            0|  0.00%|            # Also check in output history
  1275|         0|            0|            0|  0.00%|            ns_refs.append(self.history_manager.output_hist)
  1276|         0|            0|            0|  0.00%|            for ns in ns_refs:
  1277|         0|            0|            0|  0.00%|                to_delete = [n for n, o in iteritems(ns) if o is obj]
  1278|         0|            0|            0|  0.00%|                for name in to_delete:
  1279|         0|            0|            0|  0.00%|                    del ns[name]
  1280|         0|            0|            0|  0.00%|
  1281|         0|            0|            0|  0.00%|            # displayhook keeps extra references, but not in a dictionary
  1282|         0|            0|            0|  0.00%|            for name in ('_', '__', '___'):
  1283|         0|            0|            0|  0.00%|                if getattr(self.displayhook, name) is obj:
  1284|         0|            0|            0|  0.00%|                    setattr(self.displayhook, name, None)
  1285|         0|            0|            0|  0.00%|
  1286|         0|            0|            0|  0.00%|    def reset_selective(self, regex=None):
  1287|         0|            0|            0|  0.00%|        """Clear selective variables from internal namespaces based on a
  1288|         0|            0|            0|  0.00%|        specified regular expression.
  1289|         0|            0|            0|  0.00%|
  1290|         0|            0|            0|  0.00%|        Parameters
  1291|         0|            0|            0|  0.00%|        ----------
  1292|         0|            0|            0|  0.00%|        regex : string or compiled pattern, optional
  1293|         0|            0|            0|  0.00%|            A regular expression pattern that will be used in searching
  1294|         0|            0|            0|  0.00%|            variable names in the users namespaces.
  1295|         0|            0|            0|  0.00%|        """
  1296|         0|            0|            0|  0.00%|        if regex is not None:
  1297|         0|            0|            0|  0.00%|            try:
  1298|         0|            0|            0|  0.00%|                m = re.compile(regex)
  1299|         0|            0|            0|  0.00%|            except TypeError:
  1300|         0|            0|            0|  0.00%|                raise TypeError('regex must be a string or compiled pattern')
  1301|         0|            0|            0|  0.00%|            # Search for keys in each namespace that match the given regex
  1302|         0|            0|            0|  0.00%|            # If a match is found, delete the key/value pair.
  1303|         0|            0|            0|  0.00%|            for ns in self.all_ns_refs:
  1304|         0|            0|            0|  0.00%|                for var in ns:
  1305|         0|            0|            0|  0.00%|                    if m.search(var):
  1306|         0|            0|            0|  0.00%|                        del ns[var]
  1307|         0|            0|            0|  0.00%|
  1308|         0|            0|            0|  0.00%|    def push(self, variables, interactive=True):
  1309|         0|            0|            0|  0.00%|        """Inject a group of variables into the IPython user namespace.
  1310|         0|            0|            0|  0.00%|
  1311|         0|            0|            0|  0.00%|        Parameters
  1312|         0|            0|            0|  0.00%|        ----------
  1313|         0|            0|            0|  0.00%|        variables : dict, str or list/tuple of str
  1314|         0|            0|            0|  0.00%|            The variables to inject into the user's namespace.  If a dict, a
  1315|         0|            0|            0|  0.00%|            simple update is done.  If a str, the string is assumed to have
  1316|         0|            0|            0|  0.00%|            variable names separated by spaces.  A list/tuple of str can also
  1317|         0|            0|            0|  0.00%|            be used to give the variable names.  If just the variable names are
  1318|         0|            0|            0|  0.00%|            give (list/tuple/str) then the variable values looked up in the
  1319|         0|            0|            0|  0.00%|            callers frame.
  1320|         0|            0|            0|  0.00%|        interactive : bool
  1321|         0|            0|            0|  0.00%|            If True (default), the variables will be listed with the ``who``
  1322|         0|            0|            0|  0.00%|            magic.
  1323|         0|            0|            0|  0.00%|        """
  1324|         0|            0|            0|  0.00%|        vdict = None
  1325|         0|            0|            0|  0.00%|
  1326|         0|            0|            0|  0.00%|        # We need a dict of name/value pairs to do namespace updates.
  1327|         0|            0|            0|  0.00%|        if isinstance(variables, dict):
  1328|         0|            0|            0|  0.00%|            vdict = variables
  1329|         0|            0|            0|  0.00%|        elif isinstance(variables, string_types+(list, tuple)):
  1330|         0|            0|            0|  0.00%|            if isinstance(variables, string_types):
  1331|         0|            0|            0|  0.00%|                vlist = variables.split()
  1332|         0|            0|            0|  0.00%|            else:
  1333|         0|            0|            0|  0.00%|                vlist = variables
  1334|         0|            0|            0|  0.00%|            vdict = {}
  1335|         0|            0|            0|  0.00%|            cf = sys._getframe(1)
  1336|         0|            0|            0|  0.00%|            for name in vlist:
  1337|         0|            0|            0|  0.00%|                try:
  1338|         0|            0|            0|  0.00%|                    vdict[name] = eval(name, cf.f_globals, cf.f_locals)
  1339|         0|            0|            0|  0.00%|                except:
  1340|         0|            0|            0|  0.00%|                    print('Could not get variable %s from %s' %
  1341|         0|            0|            0|  0.00%|                           (name,cf.f_code.co_name))
  1342|         0|            0|            0|  0.00%|        else:
  1343|         0|            0|            0|  0.00%|            raise ValueError('variables must be a dict/str/list/tuple')
  1344|         0|            0|            0|  0.00%|
  1345|         0|            0|            0|  0.00%|        # Propagate variables to user namespace
  1346|         0|            0|            0|  0.00%|        self.user_ns.update(vdict)
  1347|         0|            0|            0|  0.00%|
  1348|         0|            0|            0|  0.00%|        # And configure interactive visibility
  1349|         0|            0|            0|  0.00%|        user_ns_hidden = self.user_ns_hidden
  1350|         0|            0|            0|  0.00%|        if interactive:
  1351|         0|            0|            0|  0.00%|            for name in vdict:
  1352|         0|            0|            0|  0.00%|                user_ns_hidden.pop(name, None)
  1353|         0|            0|            0|  0.00%|        else:
  1354|         0|            0|            0|  0.00%|            user_ns_hidden.update(vdict)
  1355|         0|            0|            0|  0.00%|
  1356|         0|            0|            0|  0.00%|    def drop_by_id(self, variables):
  1357|         0|            0|            0|  0.00%|        """Remove a dict of variables from the user namespace, if they are the
  1358|         0|            0|            0|  0.00%|        same as the values in the dictionary.
  1359|         0|            0|            0|  0.00%|
  1360|         0|            0|            0|  0.00%|        This is intended for use by extensions: variables that they've added can
  1361|         0|            0|            0|  0.00%|        be taken back out if they are unloaded, without removing any that the
  1362|         0|            0|            0|  0.00%|        user has overwritten.
  1363|         0|            0|            0|  0.00%|
  1364|         0|            0|            0|  0.00%|        Parameters
  1365|         0|            0|            0|  0.00%|        ----------
  1366|         0|            0|            0|  0.00%|        variables : dict
  1367|         0|            0|            0|  0.00%|          A dictionary mapping object names (as strings) to the objects.
  1368|         0|            0|            0|  0.00%|        """
  1369|         0|            0|            0|  0.00%|        for name, obj in iteritems(variables):
  1370|         0|            0|            0|  0.00%|            if name in self.user_ns and self.user_ns[name] is obj:
  1371|         0|            0|            0|  0.00%|                del self.user_ns[name]
  1372|         0|            0|            0|  0.00%|                self.user_ns_hidden.pop(name, None)
  1373|         0|            0|            0|  0.00%|
  1374|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  1375|         0|            0|            0|  0.00%|    # Things related to object introspection
  1376|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  1377|         0|            0|            0|  0.00%|
  1378|         0|            0|            0|  0.00%|    def _ofind(self, oname, namespaces=None):
  1379|         0|            0|            0|  0.00%|        """Find an object in the available namespaces.
  1380|         0|            0|            0|  0.00%|
  1381|         0|            0|            0|  0.00%|        self._ofind(oname) -> dict with keys: found,obj,ospace,ismagic
  1382|         0|            0|            0|  0.00%|
  1383|         0|            0|            0|  0.00%|        Has special code to detect magic functions.
  1384|         0|            0|            0|  0.00%|        """
  1385|         0|            0|            0|  0.00%|        oname = oname.strip()
  1386|         0|            0|            0|  0.00%|        #print '1- oname: <%r>' % oname  # dbg
  1387|         0|            0|            0|  0.00%|        if not oname.startswith(ESC_MAGIC) and \
  1388|         0|            0|            0|  0.00%|            not oname.startswith(ESC_MAGIC2) and \
  1389|         0|            0|            0|  0.00%|            not py3compat.isidentifier(oname, dotted=True):
  1390|         0|            0|            0|  0.00%|            return dict(found=False)
  1391|         0|            0|            0|  0.00%|
  1392|         0|            0|            0|  0.00%|        if namespaces is None:
  1393|         0|            0|            0|  0.00%|            # Namespaces to search in:
  1394|         0|            0|            0|  0.00%|            # Put them in a list. The order is important so that we
  1395|         0|            0|            0|  0.00%|            # find things in the same order that Python finds them.
  1396|         0|            0|            0|  0.00%|            namespaces = [ ('Interactive', self.user_ns),
  1397|         0|            0|            0|  0.00%|                           ('Interactive (global)', self.user_global_ns),
  1398|         0|            0|            0|  0.00%|                           ('Python builtin', builtin_mod.__dict__),
  1399|         0|            0|            0|  0.00%|                           ]
  1400|         0|            0|            0|  0.00%|
  1401|         0|            0|            0|  0.00%|        # initialize results to 'null'
  1402|         0|            0|            0|  0.00%|        found = False; obj = None;  ospace = None;
  1403|         0|            0|            0|  0.00%|        ismagic = False; isalias = False; parent = None
  1404|         0|            0|            0|  0.00%|
  1405|         0|            0|            0|  0.00%|        # We need to special-case 'print', which as of python2.6 registers as a
  1406|         0|            0|            0|  0.00%|        # function but should only be treated as one if print_function was
  1407|         0|            0|            0|  0.00%|        # loaded with a future import.  In this case, just bail.
  1408|         0|            0|            0|  0.00%|        if (oname == 'print' and not py3compat.PY3 and not \
  1409|         0|            0|            0|  0.00%|            (self.compile.compiler_flags & __future__.CO_FUTURE_PRINT_FUNCTION)):
  1410|         0|            0|            0|  0.00%|            return {'found':found, 'obj':obj, 'namespace':ospace,
  1411|         0|            0|            0|  0.00%|                    'ismagic':ismagic, 'isalias':isalias, 'parent':parent}
  1412|         0|            0|            0|  0.00%|
  1413|         0|            0|            0|  0.00%|        # Look for the given name by splitting it in parts.  If the head is
  1414|         0|            0|            0|  0.00%|        # found, then we look for all the remaining parts as members, and only
  1415|         0|            0|            0|  0.00%|        # declare success if we can find them all.
  1416|         0|            0|            0|  0.00%|        oname_parts = oname.split('.')
  1417|         0|            0|            0|  0.00%|        oname_head, oname_rest = oname_parts[0],oname_parts[1:]
  1418|         0|            0|            0|  0.00%|        for nsname,ns in namespaces:
  1419|         0|            0|            0|  0.00%|            try:
  1420|         0|            0|            0|  0.00%|                obj = ns[oname_head]
  1421|         0|            0|            0|  0.00%|            except KeyError:
  1422|         0|            0|            0|  0.00%|                continue
  1423|         0|            0|            0|  0.00%|            else:
  1424|         0|            0|            0|  0.00%|                #print 'oname_rest:', oname_rest  # dbg
  1425|         0|            0|            0|  0.00%|                for idx, part in enumerate(oname_rest):
  1426|         0|            0|            0|  0.00%|                    try:
  1427|         0|            0|            0|  0.00%|                        parent = obj
  1428|         0|            0|            0|  0.00%|                        # The last part is looked up in a special way to avoid
  1429|         0|            0|            0|  0.00%|                        # descriptor invocation as it may raise or have side
  1430|         0|            0|            0|  0.00%|                        # effects.
  1431|         0|            0|            0|  0.00%|                        if idx == len(oname_rest) - 1:
  1432|         0|            0|            0|  0.00%|                            obj = self._getattr_property(obj, part)
  1433|         0|            0|            0|  0.00%|                        else:
  1434|         0|            0|            0|  0.00%|                            obj = getattr(obj, part)
  1435|         0|            0|            0|  0.00%|                    except:
  1436|         0|            0|            0|  0.00%|                        # Blanket except b/c some badly implemented objects
  1437|         0|            0|            0|  0.00%|                        # allow __getattr__ to raise exceptions other than
  1438|         0|            0|            0|  0.00%|                        # AttributeError, which then crashes IPython.
  1439|         0|            0|            0|  0.00%|                        break
  1440|         0|            0|            0|  0.00%|                else:
  1441|         0|            0|            0|  0.00%|                    # If we finish the for loop (no break), we got all members
  1442|         0|            0|            0|  0.00%|                    found = True
  1443|         0|            0|            0|  0.00%|                    ospace = nsname
  1444|         0|            0|            0|  0.00%|                    break  # namespace loop
  1445|         0|            0|            0|  0.00%|
  1446|         0|            0|            0|  0.00%|        # Try to see if it's magic
  1447|         0|            0|            0|  0.00%|        if not found:
  1448|         0|            0|            0|  0.00%|            obj = None
  1449|         0|            0|            0|  0.00%|            if oname.startswith(ESC_MAGIC2):
  1450|         0|            0|            0|  0.00%|                oname = oname.lstrip(ESC_MAGIC2)
  1451|         0|            0|            0|  0.00%|                obj = self.find_cell_magic(oname)
  1452|         0|            0|            0|  0.00%|            elif oname.startswith(ESC_MAGIC):
  1453|         0|            0|            0|  0.00%|                oname = oname.lstrip(ESC_MAGIC)
  1454|         0|            0|            0|  0.00%|                obj = self.find_line_magic(oname)
  1455|         0|            0|            0|  0.00%|            else:
  1456|         0|            0|            0|  0.00%|                # search without prefix, so run? will find %run?
  1457|         0|            0|            0|  0.00%|                obj = self.find_line_magic(oname)
  1458|         0|            0|            0|  0.00%|                if obj is None:
  1459|         0|            0|            0|  0.00%|                    obj = self.find_cell_magic(oname)
  1460|         0|            0|            0|  0.00%|            if obj is not None:
  1461|         0|            0|            0|  0.00%|                found = True
  1462|         0|            0|            0|  0.00%|                ospace = 'IPython internal'
  1463|         0|            0|            0|  0.00%|                ismagic = True
  1464|         0|            0|            0|  0.00%|                isalias = isinstance(obj, Alias)
  1465|         0|            0|            0|  0.00%|
  1466|         0|            0|            0|  0.00%|        # Last try: special-case some literals like '', [], {}, etc:
  1467|         0|            0|            0|  0.00%|        if not found and oname_head in ["''",'""','[]','{}','()']:
  1468|         0|            0|            0|  0.00%|            obj = eval(oname_head)
  1469|         0|            0|            0|  0.00%|            found = True
  1470|         0|            0|            0|  0.00%|            ospace = 'Interactive'
  1471|         0|            0|            0|  0.00%|
  1472|         0|            0|            0|  0.00%|        return {'found':found, 'obj':obj, 'namespace':ospace,
  1473|         0|            0|            0|  0.00%|                'ismagic':ismagic, 'isalias':isalias, 'parent':parent}
  1474|         0|            0|            0|  0.00%|
  1475|         0|            0|            0|  0.00%|    @staticmethod
  1476|         0|            0|            0|  0.00%|    def _getattr_property(obj, attrname):
  1477|         0|            0|            0|  0.00%|        """Property-aware getattr to use in object finding.
  1478|         0|            0|            0|  0.00%|
  1479|         0|            0|            0|  0.00%|        If attrname represents a property, return it unevaluated (in case it has
  1480|         0|            0|            0|  0.00%|        side effects or raises an error.
  1481|         0|            0|            0|  0.00%|
  1482|         0|            0|            0|  0.00%|        """
  1483|         0|            0|            0|  0.00%|        if not isinstance(obj, type):
  1484|         0|            0|            0|  0.00%|            try:
  1485|         0|            0|            0|  0.00%|                # `getattr(type(obj), attrname)` is not guaranteed to return
  1486|         0|            0|            0|  0.00%|                # `obj`, but does so for property:
  1487|         0|            0|            0|  0.00%|                #
  1488|         0|            0|            0|  0.00%|                # property.__get__(self, None, cls) -> self
  1489|         0|            0|            0|  0.00%|                #
  1490|         0|            0|            0|  0.00%|                # The universal alternative is to traverse the mro manually
  1491|         0|            0|            0|  0.00%|                # searching for attrname in class dicts.
  1492|         0|            0|            0|  0.00%|                attr = getattr(type(obj), attrname)
  1493|         0|            0|            0|  0.00%|            except AttributeError:
  1494|         0|            0|            0|  0.00%|                pass
  1495|         0|            0|            0|  0.00%|            else:
  1496|         0|            0|            0|  0.00%|                # This relies on the fact that data descriptors (with both
  1497|         0|            0|            0|  0.00%|                # __get__ & __set__ magic methods) take precedence over
  1498|         0|            0|            0|  0.00%|                # instance-level attributes:
  1499|         0|            0|            0|  0.00%|                #
  1500|         0|            0|            0|  0.00%|                #    class A(object):
  1501|         0|            0|            0|  0.00%|                #        @property
  1502|         0|            0|            0|  0.00%|                #        def foobar(self): return 123
  1503|         0|            0|            0|  0.00%|                #    a = A()
  1504|         0|            0|            0|  0.00%|                #    a.__dict__['foobar'] = 345
  1505|         0|            0|            0|  0.00%|                #    a.foobar  # == 123
  1506|         0|            0|            0|  0.00%|                #
  1507|         0|            0|            0|  0.00%|                # So, a property may be returned right away.
  1508|         0|            0|            0|  0.00%|                if isinstance(attr, property):
  1509|         0|            0|            0|  0.00%|                    return attr
  1510|         0|            0|            0|  0.00%|
  1511|         0|            0|            0|  0.00%|        # Nothing helped, fall back.
  1512|         0|            0|            0|  0.00%|        return getattr(obj, attrname)
  1513|         0|            0|            0|  0.00%|
  1514|         0|            0|            0|  0.00%|    def _object_find(self, oname, namespaces=None):
  1515|         0|            0|            0|  0.00%|        """Find an object and return a struct with info about it."""
  1516|         0|            0|            0|  0.00%|        return Struct(self._ofind(oname, namespaces))
  1517|         0|            0|            0|  0.00%|
  1518|         0|            0|            0|  0.00%|    def _inspect(self, meth, oname, namespaces=None, **kw):
  1519|         0|            0|            0|  0.00%|        """Generic interface to the inspector system.
  1520|         0|            0|            0|  0.00%|
  1521|         0|            0|            0|  0.00%|        This function is meant to be called by pdef, pdoc & friends.
  1522|         0|            0|            0|  0.00%|        """
  1523|         0|            0|            0|  0.00%|        info = self._object_find(oname, namespaces)
  1524|         0|            0|            0|  0.00%|        docformat = sphinxify if self.sphinxify_docstring else None
  1525|         0|            0|            0|  0.00%|        if info.found:
  1526|         0|            0|            0|  0.00%|            pmethod = getattr(self.inspector, meth)
  1527|         0|            0|            0|  0.00%|            # TODO: only apply format_screen to the plain/text repr of the mime
  1528|         0|            0|            0|  0.00%|            # bundle.
  1529|         0|            0|            0|  0.00%|            formatter = format_screen if info.ismagic else docformat
  1530|         0|            0|            0|  0.00%|            if meth == 'pdoc':
  1531|         0|            0|            0|  0.00%|                pmethod(info.obj, oname, formatter)
  1532|         0|            0|            0|  0.00%|            elif meth == 'pinfo':
  1533|         0|            0|            0|  0.00%|                pmethod(info.obj, oname, formatter, info,
  1534|         0|            0|            0|  0.00%|                        enable_html_pager=self.enable_html_pager, **kw)
  1535|         0|            0|            0|  0.00%|            else:
  1536|         0|            0|            0|  0.00%|                pmethod(info.obj, oname)
  1537|         0|            0|            0|  0.00%|        else:
  1538|         0|            0|            0|  0.00%|            print('Object `%s` not found.' % oname)
  1539|         0|            0|            0|  0.00%|            return 'not found'  # so callers can take other action
  1540|         0|            0|            0|  0.00%|
  1541|         0|            0|            0|  0.00%|    def object_inspect(self, oname, detail_level=0):
  1542|         0|            0|            0|  0.00%|        """Get object info about oname"""
  1543|         0|            0|            0|  0.00%|        with self.builtin_trap:
  1544|         0|            0|            0|  0.00%|            info = self._object_find(oname)
  1545|         0|            0|            0|  0.00%|            if info.found:
  1546|         0|            0|            0|  0.00%|                return self.inspector.info(info.obj, oname, info=info,
  1547|         0|            0|            0|  0.00%|                            detail_level=detail_level
  1548|         0|            0|            0|  0.00%|                )
  1549|         0|            0|            0|  0.00%|            else:
  1550|         0|            0|            0|  0.00%|                return oinspect.object_info(name=oname, found=False)
  1551|         0|            0|            0|  0.00%|
  1552|         0|            0|            0|  0.00%|    def object_inspect_text(self, oname, detail_level=0):
  1553|         0|            0|            0|  0.00%|        """Get object info as formatted text"""
  1554|         0|            0|            0|  0.00%|        return self.object_inspect_mime(oname, detail_level)['text/plain']
  1555|         0|            0|            0|  0.00%|
  1556|         0|            0|            0|  0.00%|    def object_inspect_mime(self, oname, detail_level=0):
  1557|         0|            0|            0|  0.00%|        """Get object info as a mimebundle of formatted representations.
  1558|         0|            0|            0|  0.00%|
  1559|         0|            0|            0|  0.00%|        A mimebundle is a dictionary, keyed by mime-type.
  1560|         0|            0|            0|  0.00%|        It must always have the key `'text/plain'`.
  1561|         0|            0|            0|  0.00%|        """
  1562|         0|            0|            0|  0.00%|        with self.builtin_trap:
  1563|         0|            0|            0|  0.00%|            info = self._object_find(oname)
  1564|         0|            0|            0|  0.00%|            if info.found:
  1565|         0|            0|            0|  0.00%|                return self.inspector._get_info(info.obj, oname, info=info,
  1566|         0|            0|            0|  0.00%|                            detail_level=detail_level
  1567|         0|            0|            0|  0.00%|                )
  1568|         0|            0|            0|  0.00%|            else:
  1569|         0|            0|            0|  0.00%|                raise KeyError(oname)
  1570|         0|            0|            0|  0.00%|
  1571|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  1572|         0|            0|            0|  0.00%|    # Things related to history management
  1573|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  1574|         0|            0|            0|  0.00%|
  1575|         0|            0|            0|  0.00%|    def init_history(self):
  1576|         0|            0|            0|  0.00%|        """Sets up the command history, and starts regular autosaves."""
  1577|         0|            0|            0|  0.00%|        self.history_manager = HistoryManager(shell=self, parent=self)
  1578|         0|            0|            0|  0.00%|        self.configurables.append(self.history_manager)
  1579|         0|            0|            0|  0.00%|
  1580|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  1581|         0|            0|            0|  0.00%|    # Things related to exception handling and tracebacks (not debugging)
  1582|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  1583|         0|            0|            0|  0.00%|
  1584|         0|            0|            0|  0.00%|    debugger_cls = Pdb
  1585|         0|            0|            0|  0.00%|
  1586|         0|            0|            0|  0.00%|    def init_traceback_handlers(self, custom_exceptions):
  1587|         0|            0|            0|  0.00%|        # Syntax error handler.
  1588|         0|            0|            0|  0.00%|        self.SyntaxTB = ultratb.SyntaxTB(color_scheme='NoColor')
  1589|         0|            0|            0|  0.00%|
  1590|         0|            0|            0|  0.00%|        # The interactive one is initialized with an offset, meaning we always
  1591|         0|            0|            0|  0.00%|        # want to remove the topmost item in the traceback, which is our own
  1592|         0|            0|            0|  0.00%|        # internal code. Valid modes: ['Plain','Context','Verbose']
  1593|         0|            0|            0|  0.00%|        self.InteractiveTB = ultratb.AutoFormattedTB(mode = 'Plain',
  1594|         0|            0|            0|  0.00%|                                                     color_scheme='NoColor',
  1595|         0|            0|            0|  0.00%|                                                     tb_offset = 1,
  1596|         0|            0|            0|  0.00%|                                   check_cache=check_linecache_ipython,
  1597|         0|            0|            0|  0.00%|                                   debugger_cls=self.debugger_cls)
  1598|         0|            0|            0|  0.00%|
  1599|         0|            0|            0|  0.00%|        # The instance will store a pointer to the system-wide exception hook,
  1600|         0|            0|            0|  0.00%|        # so that runtime code (such as magics) can access it.  This is because
  1601|         0|            0|            0|  0.00%|        # during the read-eval loop, it may get temporarily overwritten.
  1602|         0|            0|            0|  0.00%|        self.sys_excepthook = sys.excepthook
  1603|         0|            0|            0|  0.00%|
  1604|         0|            0|            0|  0.00%|        # and add any custom exception handlers the user may have specified
  1605|         0|            0|            0|  0.00%|        self.set_custom_exc(*custom_exceptions)
  1606|         0|            0|            0|  0.00%|
  1607|         0|            0|            0|  0.00%|        # Set the exception mode
  1608|         0|            0|            0|  0.00%|        self.InteractiveTB.set_mode(mode=self.xmode)
  1609|         0|            0|            0|  0.00%|
  1610|         0|            0|            0|  0.00%|    def set_custom_exc(self, exc_tuple, handler):
  1611|         0|            0|            0|  0.00%|        """set_custom_exc(exc_tuple, handler)
  1612|         0|            0|            0|  0.00%|
  1613|         0|            0|            0|  0.00%|        Set a custom exception handler, which will be called if any of the
  1614|         0|            0|            0|  0.00%|        exceptions in exc_tuple occur in the mainloop (specifically, in the
  1615|         0|            0|            0|  0.00%|        run_code() method).
  1616|         0|            0|            0|  0.00%|
  1617|         0|            0|            0|  0.00%|        Parameters
  1618|         0|            0|            0|  0.00%|        ----------
  1619|         0|            0|            0|  0.00%|
  1620|         0|            0|            0|  0.00%|        exc_tuple : tuple of exception classes
  1621|         0|            0|            0|  0.00%|            A *tuple* of exception classes, for which to call the defined
  1622|         0|            0|            0|  0.00%|            handler.  It is very important that you use a tuple, and NOT A
  1623|         0|            0|            0|  0.00%|            LIST here, because of the way Python's except statement works.  If
  1624|         0|            0|            0|  0.00%|            you only want to trap a single exception, use a singleton tuple::
  1625|         0|            0|            0|  0.00%|
  1626|         0|            0|            0|  0.00%|                exc_tuple == (MyCustomException,)
  1627|         0|            0|            0|  0.00%|
  1628|         0|            0|            0|  0.00%|        handler : callable
  1629|         0|            0|            0|  0.00%|            handler must have the following signature::
  1630|         0|            0|            0|  0.00%|
  1631|         0|            0|            0|  0.00%|                def my_handler(self, etype, value, tb, tb_offset=None):
  1632|         0|            0|            0|  0.00%|                    ...
  1633|         0|            0|            0|  0.00%|                    return structured_traceback
  1634|         0|            0|            0|  0.00%|
  1635|         0|            0|            0|  0.00%|            Your handler must return a structured traceback (a list of strings),
  1636|         0|            0|            0|  0.00%|            or None.
  1637|         0|            0|            0|  0.00%|
  1638|         0|            0|            0|  0.00%|            This will be made into an instance method (via types.MethodType)
  1639|         0|            0|            0|  0.00%|            of IPython itself, and it will be called if any of the exceptions
  1640|         0|            0|            0|  0.00%|            listed in the exc_tuple are caught. If the handler is None, an
  1641|         0|            0|            0|  0.00%|            internal basic one is used, which just prints basic info.
  1642|         0|            0|            0|  0.00%|
  1643|         0|            0|            0|  0.00%|            To protect IPython from crashes, if your handler ever raises an
  1644|         0|            0|            0|  0.00%|            exception or returns an invalid result, it will be immediately
  1645|         0|            0|            0|  0.00%|            disabled.
  1646|         0|            0|            0|  0.00%|
  1647|         0|            0|            0|  0.00%|        WARNING: by putting in your own exception handler into IPython's main
  1648|         0|            0|            0|  0.00%|        execution loop, you run a very good chance of nasty crashes.  This
  1649|         0|            0|            0|  0.00%|        facility should only be used if you really know what you are doing."""
  1650|         0|            0|            0|  0.00%|
  1651|         0|            0|            0|  0.00%|        assert type(exc_tuple)==type(()) , \
  1652|         0|            0|            0|  0.00%|               "The custom exceptions must be given AS A TUPLE."
  1653|         0|            0|            0|  0.00%|
  1654|         0|            0|            0|  0.00%|        def dummy_handler(self, etype, value, tb, tb_offset=None):
  1655|         0|            0|            0|  0.00%|            print('*** Simple custom exception handler ***')
  1656|         0|            0|            0|  0.00%|            print('Exception type :',etype)
  1657|         0|            0|            0|  0.00%|            print('Exception value:',value)
  1658|         0|            0|            0|  0.00%|            print('Traceback      :',tb)
  1659|         0|            0|            0|  0.00%|            #print 'Source code    :','\n'.join(self.buffer)
  1660|         0|            0|            0|  0.00%|
  1661|         0|            0|            0|  0.00%|        def validate_stb(stb):
  1662|         0|            0|            0|  0.00%|            """validate structured traceback return type
  1663|         0|            0|            0|  0.00%|
  1664|         0|            0|            0|  0.00%|            return type of CustomTB *should* be a list of strings, but allow
  1665|         0|            0|            0|  0.00%|            single strings or None, which are harmless.
  1666|         0|            0|            0|  0.00%|
  1667|         0|            0|            0|  0.00%|            This function will *always* return a list of strings,
  1668|         0|            0|            0|  0.00%|            and will raise a TypeError if stb is inappropriate.
  1669|         0|            0|            0|  0.00%|            """
  1670|         0|            0|            0|  0.00%|            msg = "CustomTB must return list of strings, not %r" % stb
  1671|         0|            0|            0|  0.00%|            if stb is None:
  1672|         0|            0|            0|  0.00%|                return []
  1673|         0|            0|            0|  0.00%|            elif isinstance(stb, string_types):
  1674|         0|            0|            0|  0.00%|                return [stb]
  1675|         0|            0|            0|  0.00%|            elif not isinstance(stb, list):
  1676|         0|            0|            0|  0.00%|                raise TypeError(msg)
  1677|         0|            0|            0|  0.00%|            # it's a list
  1678|         0|            0|            0|  0.00%|            for line in stb:
  1679|         0|            0|            0|  0.00%|                # check every element
  1680|         0|            0|            0|  0.00%|                if not isinstance(line, string_types):
  1681|         0|            0|            0|  0.00%|                    raise TypeError(msg)
  1682|         0|            0|            0|  0.00%|            return stb
  1683|         0|            0|            0|  0.00%|
  1684|         0|            0|            0|  0.00%|        if handler is None:
  1685|         0|            0|            0|  0.00%|            wrapped = dummy_handler
  1686|         0|            0|            0|  0.00%|        else:
  1687|         0|            0|            0|  0.00%|            def wrapped(self,etype,value,tb,tb_offset=None):
  1688|         0|            0|            0|  0.00%|                """wrap CustomTB handler, to protect IPython from user code
  1689|         0|            0|            0|  0.00%|
  1690|         0|            0|            0|  0.00%|                This makes it harder (but not impossible) for custom exception
  1691|         0|            0|            0|  0.00%|                handlers to crash IPython.
  1692|         0|            0|            0|  0.00%|                """
  1693|         0|            0|            0|  0.00%|                try:
  1694|         0|            0|            0|  0.00%|                    stb = handler(self,etype,value,tb,tb_offset=tb_offset)
  1695|         0|            0|            0|  0.00%|                    return validate_stb(stb)
  1696|         0|            0|            0|  0.00%|                except:
  1697|         0|            0|            0|  0.00%|                    # clear custom handler immediately
  1698|         0|            0|            0|  0.00%|                    self.set_custom_exc((), None)
  1699|         0|            0|            0|  0.00%|                    print("Custom TB Handler failed, unregistering", file=sys.stderr)
  1700|         0|            0|            0|  0.00%|                    # show the exception in handler first
  1701|         0|            0|            0|  0.00%|                    stb = self.InteractiveTB.structured_traceback(*sys.exc_info())
  1702|         0|            0|            0|  0.00%|                    print(self.InteractiveTB.stb2text(stb))
  1703|         0|            0|            0|  0.00%|                    print("The original exception:")
  1704|         0|            0|            0|  0.00%|                    stb = self.InteractiveTB.structured_traceback(
  1705|         0|            0|            0|  0.00%|                                            (etype,value,tb), tb_offset=tb_offset
  1706|         0|            0|            0|  0.00%|                    )
  1707|         0|            0|            0|  0.00%|                return stb
  1708|         0|            0|            0|  0.00%|
  1709|         0|            0|            0|  0.00%|        self.CustomTB = types.MethodType(wrapped,self)
  1710|         0|            0|            0|  0.00%|        self.custom_exceptions = exc_tuple
  1711|         0|            0|            0|  0.00%|
  1712|         0|            0|            0|  0.00%|    def excepthook(self, etype, value, tb):
  1713|         0|            0|            0|  0.00%|      """One more defense for GUI apps that call sys.excepthook.
  1714|         0|            0|            0|  0.00%|
  1715|         0|            0|            0|  0.00%|      GUI frameworks like wxPython trap exceptions and call
  1716|         0|            0|            0|  0.00%|      sys.excepthook themselves.  I guess this is a feature that
  1717|         0|            0|            0|  0.00%|      enables them to keep running after exceptions that would
  1718|         0|            0|            0|  0.00%|      otherwise kill their mainloop. This is a bother for IPython
  1719|         0|            0|            0|  0.00%|      which excepts to catch all of the program exceptions with a try:
  1720|         0|            0|            0|  0.00%|      except: statement.
  1721|         0|            0|            0|  0.00%|
  1722|         0|            0|            0|  0.00%|      Normally, IPython sets sys.excepthook to a CrashHandler instance, so if
  1723|         0|            0|            0|  0.00%|      any app directly invokes sys.excepthook, it will look to the user like
  1724|         0|            0|            0|  0.00%|      IPython crashed.  In order to work around this, we can disable the
  1725|         0|            0|            0|  0.00%|      CrashHandler and replace it with this excepthook instead, which prints a
  1726|         0|            0|            0|  0.00%|      regular traceback using our InteractiveTB.  In this fashion, apps which
  1727|         0|            0|            0|  0.00%|      call sys.excepthook will generate a regular-looking exception from
  1728|         0|            0|            0|  0.00%|      IPython, and the CrashHandler will only be triggered by real IPython
  1729|         0|            0|            0|  0.00%|      crashes.
  1730|         0|            0|            0|  0.00%|
  1731|         0|            0|            0|  0.00%|      This hook should be used sparingly, only in places which are not likely
  1732|         0|            0|            0|  0.00%|      to be true IPython errors.
  1733|         0|            0|            0|  0.00%|      """
  1734|         0|            0|            0|  0.00%|      self.showtraceback((etype, value, tb), tb_offset=0)
  1735|         0|            0|            0|  0.00%|
  1736|         0|            0|            0|  0.00%|    def _get_exc_info(self, exc_tuple=None):
  1737|         0|            0|            0|  0.00%|        """get exc_info from a given tuple, sys.exc_info() or sys.last_type etc.
  1738|         0|            0|            0|  0.00%|
  1739|         0|            0|            0|  0.00%|        Ensures sys.last_type,value,traceback hold the exc_info we found,
  1740|         0|            0|            0|  0.00%|        from whichever source.
  1741|         0|            0|            0|  0.00%|
  1742|         0|            0|            0|  0.00%|        raises ValueError if none of these contain any information
  1743|         0|            0|            0|  0.00%|        """
  1744|         0|            0|            0|  0.00%|        if exc_tuple is None:
  1745|         0|            0|            0|  0.00%|            etype, value, tb = sys.exc_info()
  1746|         0|            0|            0|  0.00%|        else:
  1747|         0|            0|            0|  0.00%|            etype, value, tb = exc_tuple
  1748|         0|            0|            0|  0.00%|
  1749|         0|            0|            0|  0.00%|        if etype is None:
  1750|         0|            0|            0|  0.00%|            if hasattr(sys, 'last_type'):
  1751|         0|            0|            0|  0.00%|                etype, value, tb = sys.last_type, sys.last_value, \
  1752|         0|            0|            0|  0.00%|                                   sys.last_traceback
  1753|         0|            0|            0|  0.00%|
  1754|         0|            0|            0|  0.00%|        if etype is None:
  1755|         0|            0|            0|  0.00%|            raise ValueError("No exception to find")
  1756|         0|            0|            0|  0.00%|
  1757|         0|            0|            0|  0.00%|        # Now store the exception info in sys.last_type etc.
  1758|         0|            0|            0|  0.00%|        # WARNING: these variables are somewhat deprecated and not
  1759|         0|            0|            0|  0.00%|        # necessarily safe to use in a threaded environment, but tools
  1760|         0|            0|            0|  0.00%|        # like pdb depend on their existence, so let's set them.  If we
  1761|         0|            0|            0|  0.00%|        # find problems in the field, we'll need to revisit their use.
  1762|         0|            0|            0|  0.00%|        sys.last_type = etype
  1763|         0|            0|            0|  0.00%|        sys.last_value = value
  1764|         0|            0|            0|  0.00%|        sys.last_traceback = tb
  1765|         0|            0|            0|  0.00%|
  1766|         0|            0|            0|  0.00%|        return etype, value, tb
  1767|         0|            0|            0|  0.00%|
  1768|         0|            0|            0|  0.00%|    def show_usage_error(self, exc):
  1769|         0|            0|            0|  0.00%|        """Show a short message for UsageErrors
  1770|         0|            0|            0|  0.00%|
  1771|         0|            0|            0|  0.00%|        These are special exceptions that shouldn't show a traceback.
  1772|         0|            0|            0|  0.00%|        """
  1773|         0|            0|            0|  0.00%|        print("UsageError: %s" % exc, file=sys.stderr)
  1774|         0|            0|            0|  0.00%|
  1775|         0|            0|            0|  0.00%|    def get_exception_only(self, exc_tuple=None):
  1776|         0|            0|            0|  0.00%|        """
  1777|         0|            0|            0|  0.00%|        Return as a string (ending with a newline) the exception that
  1778|         0|            0|            0|  0.00%|        just occurred, without any traceback.
  1779|         0|            0|            0|  0.00%|        """
  1780|         0|            0|            0|  0.00%|        etype, value, tb = self._get_exc_info(exc_tuple)
  1781|         0|            0|            0|  0.00%|        msg = traceback.format_exception_only(etype, value)
  1782|         0|            0|            0|  0.00%|        return ''.join(msg)
  1783|         0|            0|            0|  0.00%|
  1784|         0|            0|            0|  0.00%|    def showtraceback(self, exc_tuple=None, filename=None, tb_offset=None,
  1785|         0|            0|            0|  0.00%|                      exception_only=False):
  1786|         0|            0|            0|  0.00%|        """Display the exception that just occurred.
  1787|         0|            0|            0|  0.00%|
  1788|         0|            0|            0|  0.00%|        If nothing is known about the exception, this is the method which
  1789|         0|            0|            0|  0.00%|        should be used throughout the code for presenting user tracebacks,
  1790|         0|            0|            0|  0.00%|        rather than directly invoking the InteractiveTB object.
  1791|         0|            0|            0|  0.00%|
  1792|         0|            0|            0|  0.00%|        A specific showsyntaxerror() also exists, but this method can take
  1793|         0|            0|            0|  0.00%|        care of calling it if needed, so unless you are explicitly catching a
  1794|         0|            0|            0|  0.00%|        SyntaxError exception, don't try to analyze the stack manually and
  1795|         0|            0|            0|  0.00%|        simply call this method."""
  1796|         0|            0|            0|  0.00%|
  1797|         0|            0|            0|  0.00%|        try:
  1798|         0|            0|            0|  0.00%|            try:
  1799|         0|            0|            0|  0.00%|                etype, value, tb = self._get_exc_info(exc_tuple)
  1800|         0|            0|            0|  0.00%|            except ValueError:
  1801|         0|            0|            0|  0.00%|                print('No traceback available to show.', file=sys.stderr)
  1802|         0|            0|            0|  0.00%|                return
  1803|         0|            0|            0|  0.00%|
  1804|         0|            0|            0|  0.00%|            if issubclass(etype, SyntaxError):
  1805|         0|            0|            0|  0.00%|                # Though this won't be called by syntax errors in the input
  1806|         0|            0|            0|  0.00%|                # line, there may be SyntaxError cases with imported code.
  1807|         0|            0|            0|  0.00%|                self.showsyntaxerror(filename)
  1808|         0|            0|            0|  0.00%|            elif etype is UsageError:
  1809|         0|            0|            0|  0.00%|                self.show_usage_error(value)
  1810|         0|            0|            0|  0.00%|            else:
  1811|         0|            0|            0|  0.00%|                if exception_only:
  1812|         0|            0|            0|  0.00%|                    stb = ['An exception has occurred, use %tb to see '
  1813|         0|            0|            0|  0.00%|                           'the full traceback.\n']
  1814|         0|            0|            0|  0.00%|                    stb.extend(self.InteractiveTB.get_exception_only(etype,
  1815|         0|            0|            0|  0.00%|                                                                     value))
  1816|         0|            0|            0|  0.00%|                else:
  1817|         0|            0|            0|  0.00%|                    try:
  1818|         0|            0|            0|  0.00%|                        # Exception classes can customise their traceback - we
  1819|         0|            0|            0|  0.00%|                        # use this in IPython.parallel for exceptions occurring
  1820|         0|            0|            0|  0.00%|                        # in the engines. This should return a list of strings.
  1821|         0|            0|            0|  0.00%|                        stb = value._render_traceback_()
  1822|         0|            0|            0|  0.00%|                    except Exception:
  1823|         0|            0|            0|  0.00%|                        stb = self.InteractiveTB.structured_traceback(etype,
  1824|         0|            0|            0|  0.00%|                                            value, tb, tb_offset=tb_offset)
  1825|         0|            0|            0|  0.00%|
  1826|         0|            0|            0|  0.00%|                    self._showtraceback(etype, value, stb)
  1827|         0|            0|            0|  0.00%|                    if self.call_pdb:
  1828|         0|            0|            0|  0.00%|                        # drop into debugger
  1829|         0|            0|            0|  0.00%|                        self.debugger(force=True)
  1830|         0|            0|            0|  0.00%|                    return
  1831|         0|            0|            0|  0.00%|
  1832|         0|            0|            0|  0.00%|                # Actually show the traceback
  1833|         0|            0|            0|  0.00%|                self._showtraceback(etype, value, stb)
  1834|         0|            0|            0|  0.00%|
  1835|         0|            0|            0|  0.00%|        except KeyboardInterrupt:
  1836|         0|            0|            0|  0.00%|            print('\n' + self.get_exception_only(), file=sys.stderr)
  1837|         0|            0|            0|  0.00%|
  1838|         0|            0|            0|  0.00%|    def _showtraceback(self, etype, evalue, stb):
  1839|         0|            0|            0|  0.00%|        """Actually show a traceback.
  1840|         0|            0|            0|  0.00%|
  1841|         0|            0|            0|  0.00%|        Subclasses may override this method to put the traceback on a different
  1842|         0|            0|            0|  0.00%|        place, like a side channel.
  1843|         0|            0|            0|  0.00%|        """
  1844|         0|            0|            0|  0.00%|        print(self.InteractiveTB.stb2text(stb))
  1845|         0|            0|            0|  0.00%|
  1846|         0|            0|            0|  0.00%|    def showsyntaxerror(self, filename=None):
  1847|         0|            0|            0|  0.00%|        """Display the syntax error that just occurred.
  1848|         0|            0|            0|  0.00%|
  1849|         0|            0|            0|  0.00%|        This doesn't display a stack trace because there isn't one.
  1850|         0|            0|            0|  0.00%|
  1851|         0|            0|            0|  0.00%|        If a filename is given, it is stuffed in the exception instead
  1852|         0|            0|            0|  0.00%|        of what was there before (because Python's parser always uses
  1853|         0|            0|            0|  0.00%|        "<string>" when reading from a string).
  1854|         0|            0|            0|  0.00%|        """
  1855|         0|            0|            0|  0.00%|        etype, value, last_traceback = self._get_exc_info()
  1856|         0|            0|            0|  0.00%|
  1857|         0|            0|            0|  0.00%|        if filename and issubclass(etype, SyntaxError):
  1858|         0|            0|            0|  0.00%|            try:
  1859|         0|            0|            0|  0.00%|                value.filename = filename
  1860|         0|            0|            0|  0.00%|            except:
  1861|         0|            0|            0|  0.00%|                # Not the format we expect; leave it alone
  1862|         0|            0|            0|  0.00%|                pass
  1863|         0|            0|            0|  0.00%|
  1864|         0|            0|            0|  0.00%|        stb = self.SyntaxTB.structured_traceback(etype, value, [])
  1865|         0|            0|            0|  0.00%|        self._showtraceback(etype, value, stb)
  1866|         0|            0|            0|  0.00%|
  1867|         0|            0|            0|  0.00%|    # This is overridden in TerminalInteractiveShell to show a message about
  1868|         0|            0|            0|  0.00%|    # the %paste magic.
  1869|         0|            0|            0|  0.00%|    def showindentationerror(self):
  1870|         0|            0|            0|  0.00%|        """Called by run_cell when there's an IndentationError in code entered
  1871|         0|            0|            0|  0.00%|        at the prompt.
  1872|         0|            0|            0|  0.00%|
  1873|         0|            0|            0|  0.00%|        This is overridden in TerminalInteractiveShell to show a message about
  1874|         0|            0|            0|  0.00%|        the %paste magic."""
  1875|         0|            0|            0|  0.00%|        self.showsyntaxerror()
  1876|         0|            0|            0|  0.00%|
  1877|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  1878|         0|            0|            0|  0.00%|    # Things related to readline
  1879|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  1880|         0|            0|            0|  0.00%|
  1881|         0|            0|            0|  0.00%|    def init_readline(self):
  1882|         0|            0|            0|  0.00%|        """DEPRECATED
  1883|         0|            0|            0|  0.00%|
  1884|         0|            0|            0|  0.00%|        Moved to terminal subclass, here only to simplify the init logic."""
  1885|         0|            0|            0|  0.00%|        # Set a number of methods that depend on readline to be no-op
  1886|         0|            0|            0|  0.00%|        warnings.warn('`init_readline` is no-op since IPython 5.0 and is Deprecated',
  1887|         0|            0|            0|  0.00%|                DeprecationWarning, stacklevel=2)
  1888|         0|            0|            0|  0.00%|        self.set_custom_completer = no_op
  1889|         0|            0|            0|  0.00%|
  1890|         0|            0|            0|  0.00%|    @skip_doctest
  1891|         0|            0|            0|  0.00%|    def set_next_input(self, s, replace=False):
  1892|         0|            0|            0|  0.00%|        """ Sets the 'default' input string for the next command line.
  1893|         0|            0|            0|  0.00%|
  1894|         0|            0|            0|  0.00%|        Example::
  1895|         0|            0|            0|  0.00%|
  1896|         0|            0|            0|  0.00%|            In [1]: _ip.set_next_input("Hello Word")
  1897|         0|            0|            0|  0.00%|            In [2]: Hello Word_  # cursor is here
  1898|         0|            0|            0|  0.00%|        """
  1899|         0|            0|            0|  0.00%|        self.rl_next_input = py3compat.cast_bytes_py2(s)
  1900|         0|            0|            0|  0.00%|
  1901|         0|            0|            0|  0.00%|    def _indent_current_str(self):
  1902|         0|            0|            0|  0.00%|        """return the current level of indentation as a string"""
  1903|         0|            0|            0|  0.00%|        return self.input_splitter.indent_spaces * ' '
  1904|         0|            0|            0|  0.00%|
  1905|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  1906|         0|            0|            0|  0.00%|    # Things related to text completion
  1907|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  1908|         0|            0|            0|  0.00%|
  1909|         0|            0|            0|  0.00%|    def init_completer(self):
  1910|         0|            0|            0|  0.00%|        """Initialize the completion machinery.
  1911|         0|            0|            0|  0.00%|
  1912|         0|            0|            0|  0.00%|        This creates completion machinery that can be used by client code,
  1913|         0|            0|            0|  0.00%|        either interactively in-process (typically triggered by the readline
  1914|         0|            0|            0|  0.00%|        library), programmatically (such as in test suites) or out-of-process
  1915|         0|            0|            0|  0.00%|        (typically over the network by remote frontends).
  1916|         0|            0|            0|  0.00%|        """
  1917|         0|            0|            0|  0.00%|        from IPython.core.completer import IPCompleter
  1918|         0|            0|            0|  0.00%|        from IPython.core.completerlib import (module_completer,
  1919|         0|            0|            0|  0.00%|                magic_run_completer, cd_completer, reset_completer)
  1920|         0|            0|            0|  0.00%|
  1921|         0|            0|            0|  0.00%|        self.Completer = IPCompleter(shell=self,
  1922|         0|            0|            0|  0.00%|                                     namespace=self.user_ns,
  1923|         0|            0|            0|  0.00%|                                     global_namespace=self.user_global_ns,
  1924|         0|            0|            0|  0.00%|                                     use_readline=False,
  1925|         0|            0|            0|  0.00%|                                     parent=self,
  1926|         0|            0|            0|  0.00%|                                     )
  1927|         0|            0|            0|  0.00%|        self.configurables.append(self.Completer)
  1928|         0|            0|            0|  0.00%|
  1929|         0|            0|            0|  0.00%|        # Add custom completers to the basic ones built into IPCompleter
  1930|         0|            0|            0|  0.00%|        sdisp = self.strdispatchers.get('complete_command', StrDispatch())
  1931|         0|            0|            0|  0.00%|        self.strdispatchers['complete_command'] = sdisp
  1932|         0|            0|            0|  0.00%|        self.Completer.custom_completers = sdisp
  1933|         0|            0|            0|  0.00%|
  1934|         0|            0|            0|  0.00%|        self.set_hook('complete_command', module_completer, str_key = 'import')
  1935|         0|            0|            0|  0.00%|        self.set_hook('complete_command', module_completer, str_key = 'from')
  1936|         0|            0|            0|  0.00%|        self.set_hook('complete_command', module_completer, str_key = '%aimport')
  1937|         0|            0|            0|  0.00%|        self.set_hook('complete_command', magic_run_completer, str_key = '%run')
  1938|         0|            0|            0|  0.00%|        self.set_hook('complete_command', cd_completer, str_key = '%cd')
  1939|         0|            0|            0|  0.00%|        self.set_hook('complete_command', reset_completer, str_key = '%reset')
  1940|         0|            0|            0|  0.00%|
  1941|         0|            0|            0|  0.00%|
  1942|         0|            0|            0|  0.00%|    @skip_doctest_py2
  1943|         0|            0|            0|  0.00%|    def complete(self, text, line=None, cursor_pos=None):
  1944|         0|            0|            0|  0.00%|        """Return the completed text and a list of completions.
  1945|         0|            0|            0|  0.00%|
  1946|         0|            0|            0|  0.00%|        Parameters
  1947|         0|            0|            0|  0.00%|        ----------
  1948|         0|            0|            0|  0.00%|
  1949|         0|            0|            0|  0.00%|           text : string
  1950|         0|            0|            0|  0.00%|             A string of text to be completed on.  It can be given as empty and
  1951|         0|            0|            0|  0.00%|             instead a line/position pair are given.  In this case, the
  1952|         0|            0|            0|  0.00%|             completer itself will split the line like readline does.
  1953|         0|            0|            0|  0.00%|
  1954|         0|            0|            0|  0.00%|           line : string, optional
  1955|         0|            0|            0|  0.00%|             The complete line that text is part of.
  1956|         0|            0|            0|  0.00%|
  1957|         0|            0|            0|  0.00%|           cursor_pos : int, optional
  1958|         0|            0|            0|  0.00%|             The position of the cursor on the input line.
  1959|         0|            0|            0|  0.00%|
  1960|         0|            0|            0|  0.00%|        Returns
  1961|         0|            0|            0|  0.00%|        -------
  1962|         0|            0|            0|  0.00%|          text : string
  1963|         0|            0|            0|  0.00%|            The actual text that was completed.
  1964|         0|            0|            0|  0.00%|
  1965|         0|            0|            0|  0.00%|          matches : list
  1966|         0|            0|            0|  0.00%|            A sorted list with all possible completions.
  1967|         0|            0|            0|  0.00%|
  1968|         0|            0|            0|  0.00%|        The optional arguments allow the completion to take more context into
  1969|         0|            0|            0|  0.00%|        account, and are part of the low-level completion API.
  1970|         0|            0|            0|  0.00%|
  1971|         0|            0|            0|  0.00%|        This is a wrapper around the completion mechanism, similar to what
  1972|         0|            0|            0|  0.00%|        readline does at the command line when the TAB key is hit.  By
  1973|         0|            0|            0|  0.00%|        exposing it as a method, it can be used by other non-readline
  1974|         0|            0|            0|  0.00%|        environments (such as GUIs) for text completion.
  1975|         0|            0|            0|  0.00%|
  1976|         0|            0|            0|  0.00%|        Simple usage example:
  1977|         0|            0|            0|  0.00%|
  1978|         0|            0|            0|  0.00%|        In [1]: x = 'hello'
  1979|         0|            0|            0|  0.00%|
  1980|         0|            0|            0|  0.00%|        In [2]: _ip.complete('x.l')
  1981|         0|            0|            0|  0.00%|        Out[2]: ('x.l', ['x.ljust', 'x.lower', 'x.lstrip'])
  1982|         0|            0|            0|  0.00%|        """
  1983|         0|            0|            0|  0.00%|
  1984|         0|            0|            0|  0.00%|        # Inject names into __builtin__ so we can complete on the added names.
  1985|         0|            0|            0|  0.00%|        with self.builtin_trap:
  1986|         0|            0|            0|  0.00%|            return self.Completer.complete(text, line, cursor_pos)
  1987|         0|            0|            0|  0.00%|
  1988|         0|            0|            0|  0.00%|    def set_custom_completer(self, completer, pos=0):
  1989|         0|            0|            0|  0.00%|        """Adds a new custom completer function.
  1990|         0|            0|            0|  0.00%|
  1991|         0|            0|            0|  0.00%|        The position argument (defaults to 0) is the index in the completers
  1992|         0|            0|            0|  0.00%|        list where you want the completer to be inserted."""
  1993|         0|            0|            0|  0.00%|
  1994|         0|            0|            0|  0.00%|        newcomp = types.MethodType(completer,self.Completer)
  1995|         0|            0|            0|  0.00%|        self.Completer.matchers.insert(pos,newcomp)
  1996|         0|            0|            0|  0.00%|
  1997|         0|            0|            0|  0.00%|    def set_completer_frame(self, frame=None):
  1998|         0|            0|            0|  0.00%|        """Set the frame of the completer."""
  1999|         0|            0|            0|  0.00%|        if frame:
  2000|         0|            0|            0|  0.00%|            self.Completer.namespace = frame.f_locals
  2001|         0|            0|            0|  0.00%|            self.Completer.global_namespace = frame.f_globals
  2002|         0|            0|            0|  0.00%|        else:
  2003|         0|            0|            0|  0.00%|            self.Completer.namespace = self.user_ns
  2004|         0|            0|            0|  0.00%|            self.Completer.global_namespace = self.user_global_ns
  2005|         0|            0|            0|  0.00%|
  2006|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2007|         0|            0|            0|  0.00%|    # Things related to magics
  2008|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2009|         0|            0|            0|  0.00%|
  2010|         0|            0|            0|  0.00%|    def init_magics(self):
  2011|         0|            0|            0|  0.00%|        from IPython.core import magics as m
  2012|         0|            0|            0|  0.00%|        self.magics_manager = magic.MagicsManager(shell=self,
  2013|         0|            0|            0|  0.00%|                                   parent=self,
  2014|         0|            0|            0|  0.00%|                                   user_magics=m.UserMagics(self))
  2015|         0|            0|            0|  0.00%|        self.configurables.append(self.magics_manager)
  2016|         0|            0|            0|  0.00%|
  2017|         0|            0|            0|  0.00%|        # Expose as public API from the magics manager
  2018|         0|            0|            0|  0.00%|        self.register_magics = self.magics_manager.register
  2019|         0|            0|            0|  0.00%|
  2020|         0|            0|            0|  0.00%|        self.register_magics(m.AutoMagics, m.BasicMagics, m.CodeMagics,
  2021|         0|            0|            0|  0.00%|            m.ConfigMagics, m.DisplayMagics, m.ExecutionMagics,
  2022|         0|            0|            0|  0.00%|            m.ExtensionMagics, m.HistoryMagics, m.LoggingMagics,
  2023|         0|            0|            0|  0.00%|            m.NamespaceMagics, m.OSMagics, m.PylabMagics, m.ScriptMagics,
  2024|         0|            0|            0|  0.00%|        )
  2025|         0|            0|            0|  0.00%|
  2026|         0|            0|            0|  0.00%|        # Register Magic Aliases
  2027|         0|            0|            0|  0.00%|        mman = self.magics_manager
  2028|         0|            0|            0|  0.00%|        # FIXME: magic aliases should be defined by the Magics classes
  2029|         0|            0|            0|  0.00%|        # or in MagicsManager, not here
  2030|         0|            0|            0|  0.00%|        mman.register_alias('ed', 'edit')
  2031|         0|            0|            0|  0.00%|        mman.register_alias('hist', 'history')
  2032|         0|            0|            0|  0.00%|        mman.register_alias('rep', 'recall')
  2033|         0|            0|            0|  0.00%|        mman.register_alias('SVG', 'svg', 'cell')
  2034|         0|            0|            0|  0.00%|        mman.register_alias('HTML', 'html', 'cell')
  2035|         0|            0|            0|  0.00%|        mman.register_alias('file', 'writefile', 'cell')
  2036|         0|            0|            0|  0.00%|
  2037|         0|            0|            0|  0.00%|        # FIXME: Move the color initialization to the DisplayHook, which
  2038|         0|            0|            0|  0.00%|        # should be split into a prompt manager and displayhook. We probably
  2039|         0|            0|            0|  0.00%|        # even need a centralize colors management object.
  2040|         0|            0|            0|  0.00%|        self.magic('colors %s' % self.colors)
  2041|         0|            0|            0|  0.00%|
  2042|         0|            0|            0|  0.00%|    # Defined here so that it's included in the documentation
  2043|         0|            0|            0|  0.00%|    @functools.wraps(magic.MagicsManager.register_function)
  2044|         0|            0|            0|  0.00%|    def register_magic_function(self, func, magic_kind='line', magic_name=None):
  2045|         0|            0|            0|  0.00%|        self.magics_manager.register_function(func,
  2046|         0|            0|            0|  0.00%|                                  magic_kind=magic_kind, magic_name=magic_name)
  2047|         0|            0|            0|  0.00%|
  2048|         0|            0|            0|  0.00%|    def run_line_magic(self, magic_name, line):
  2049|         0|            0|            0|  0.00%|        """Execute the given line magic.
  2050|         0|            0|            0|  0.00%|
  2051|         0|            0|            0|  0.00%|        Parameters
  2052|         0|            0|            0|  0.00%|        ----------
  2053|         0|            0|            0|  0.00%|        magic_name : str
  2054|         0|            0|            0|  0.00%|          Name of the desired magic function, without '%' prefix.
  2055|         0|            0|            0|  0.00%|
  2056|         0|            0|            0|  0.00%|        line : str
  2057|         0|            0|            0|  0.00%|          The rest of the input line as a single string.
  2058|         0|            0|            0|  0.00%|        """
  2059|         0|            0|            0|  0.00%|        fn = self.find_line_magic(magic_name)
  2060|         0|            0|            0|  0.00%|        if fn is None:
  2061|         0|            0|            0|  0.00%|            cm = self.find_cell_magic(magic_name)
  2062|         0|            0|            0|  0.00%|            etpl = "Line magic function `%%%s` not found%s."
  2063|         0|            0|            0|  0.00%|            extra = '' if cm is None else (' (But cell magic `%%%%%s` exists, '
  2064|         0|            0|            0|  0.00%|                                    'did you mean that instead?)' % magic_name )
  2065|         0|            0|            0|  0.00%|            error(etpl % (magic_name, extra))
  2066|         0|            0|            0|  0.00%|        else:
  2067|         0|            0|            0|  0.00%|            # Note: this is the distance in the stack to the user's frame.
  2068|         0|            0|            0|  0.00%|            # This will need to be updated if the internal calling logic gets
  2069|         0|            0|            0|  0.00%|            # refactored, or else we'll be expanding the wrong variables.
  2070|         0|            0|            0|  0.00%|            stack_depth = 2
  2071|         0|            0|            0|  0.00%|            magic_arg_s = self.var_expand(line, stack_depth)
  2072|         0|            0|            0|  0.00%|            # Put magic args in a list so we can call with f(*a) syntax
  2073|         0|            0|            0|  0.00%|            args = [magic_arg_s]
  2074|         0|            0|            0|  0.00%|            kwargs = {}
  2075|         0|            0|            0|  0.00%|            # Grab local namespace if we need it:
  2076|         0|            0|            0|  0.00%|            if getattr(fn, "needs_local_scope", False):
  2077|         0|            0|            0|  0.00%|                kwargs['local_ns'] = sys._getframe(stack_depth).f_locals
  2078|         0|            0|            0|  0.00%|            with self.builtin_trap:
  2079|         0|            0|            0|  0.00%|                result = fn(*args,**kwargs)
  2080|         0|            0|            0|  0.00%|            return result
  2081|         0|            0|            0|  0.00%|
  2082|         0|            0|            0|  0.00%|    def run_cell_magic(self, magic_name, line, cell):
  2083|         0|            0|            0|  0.00%|        """Execute the given cell magic.
  2084|         0|            0|            0|  0.00%|
  2085|         0|            0|            0|  0.00%|        Parameters
  2086|         0|            0|            0|  0.00%|        ----------
  2087|         0|            0|            0|  0.00%|        magic_name : str
  2088|         0|            0|            0|  0.00%|          Name of the desired magic function, without '%' prefix.
  2089|         0|            0|            0|  0.00%|
  2090|         0|            0|            0|  0.00%|        line : str
  2091|         0|            0|            0|  0.00%|          The rest of the first input line as a single string.
  2092|         0|            0|            0|  0.00%|
  2093|         0|            0|            0|  0.00%|        cell : str
  2094|         0|            0|            0|  0.00%|          The body of the cell as a (possibly multiline) string.
  2095|         0|            0|            0|  0.00%|        """
  2096|         0|            0|            0|  0.00%|        fn = self.find_cell_magic(magic_name)
  2097|         0|            0|            0|  0.00%|        if fn is None:
  2098|         0|            0|            0|  0.00%|            lm = self.find_line_magic(magic_name)
  2099|         0|            0|            0|  0.00%|            etpl = "Cell magic `%%{0}` not found{1}."
  2100|         0|            0|            0|  0.00%|            extra = '' if lm is None else (' (But line magic `%{0}` exists, '
  2101|         0|            0|            0|  0.00%|                            'did you mean that instead?)'.format(magic_name))
  2102|         0|            0|            0|  0.00%|            error(etpl.format(magic_name, extra))
  2103|         0|            0|            0|  0.00%|        elif cell == '':
  2104|         0|            0|            0|  0.00%|            message = '%%{0} is a cell magic, but the cell body is empty.'.format(magic_name)
  2105|         0|            0|            0|  0.00%|            if self.find_line_magic(magic_name) is not None:
  2106|         0|            0|            0|  0.00%|                message += ' Did you mean the line magic %{0} (single %)?'.format(magic_name)
  2107|         0|            0|            0|  0.00%|            raise UsageError(message)
  2108|         0|            0|            0|  0.00%|        else:
  2109|         0|            0|            0|  0.00%|            # Note: this is the distance in the stack to the user's frame.
  2110|         0|            0|            0|  0.00%|            # This will need to be updated if the internal calling logic gets
  2111|         0|            0|            0|  0.00%|            # refactored, or else we'll be expanding the wrong variables.
  2112|         0|            0|            0|  0.00%|            stack_depth = 2
  2113|         0|            0|            0|  0.00%|            magic_arg_s = self.var_expand(line, stack_depth)
  2114|         0|            0|            0|  0.00%|            with self.builtin_trap:
  2115|         0|            0|            0|  0.00%|                result = fn(magic_arg_s, cell)
  2116|         0|            0|            0|  0.00%|            return result
  2117|         0|            0|            0|  0.00%|
  2118|         0|            0|            0|  0.00%|    def find_line_magic(self, magic_name):
  2119|         0|            0|            0|  0.00%|        """Find and return a line magic by name.
  2120|         0|            0|            0|  0.00%|
  2121|         0|            0|            0|  0.00%|        Returns None if the magic isn't found."""
  2122|         0|            0|            0|  0.00%|        return self.magics_manager.magics['line'].get(magic_name)
  2123|         0|            0|            0|  0.00%|
  2124|         0|            0|            0|  0.00%|    def find_cell_magic(self, magic_name):
  2125|         0|            0|            0|  0.00%|        """Find and return a cell magic by name.
  2126|         0|            0|            0|  0.00%|
  2127|         0|            0|            0|  0.00%|        Returns None if the magic isn't found."""
  2128|         0|            0|            0|  0.00%|        return self.magics_manager.magics['cell'].get(magic_name)
  2129|         0|            0|            0|  0.00%|
  2130|         0|            0|            0|  0.00%|    def find_magic(self, magic_name, magic_kind='line'):
  2131|         0|            0|            0|  0.00%|        """Find and return a magic of the given type by name.
  2132|         0|            0|            0|  0.00%|
  2133|         0|            0|            0|  0.00%|        Returns None if the magic isn't found."""
  2134|         0|            0|            0|  0.00%|        return self.magics_manager.magics[magic_kind].get(magic_name)
  2135|         0|            0|            0|  0.00%|
  2136|         0|            0|            0|  0.00%|    def magic(self, arg_s):
  2137|         0|            0|            0|  0.00%|        """DEPRECATED. Use run_line_magic() instead.
  2138|         0|            0|            0|  0.00%|
  2139|         0|            0|            0|  0.00%|        Call a magic function by name.
  2140|         0|            0|            0|  0.00%|
  2141|         0|            0|            0|  0.00%|        Input: a string containing the name of the magic function to call and
  2142|         0|            0|            0|  0.00%|        any additional arguments to be passed to the magic.
  2143|         0|            0|            0|  0.00%|
  2144|         0|            0|            0|  0.00%|        magic('name -opt foo bar') is equivalent to typing at the ipython
  2145|         0|            0|            0|  0.00%|        prompt:
  2146|         0|            0|            0|  0.00%|
  2147|         0|            0|            0|  0.00%|        In[1]: %name -opt foo bar
  2148|         0|            0|            0|  0.00%|
  2149|         0|            0|            0|  0.00%|        To call a magic without arguments, simply use magic('name').
  2150|         0|            0|            0|  0.00%|
  2151|         0|            0|            0|  0.00%|        This provides a proper Python function to call IPython's magics in any
  2152|         0|            0|            0|  0.00%|        valid Python code you can type at the interpreter, including loops and
  2153|         0|            0|            0|  0.00%|        compound statements.
  2154|         0|            0|            0|  0.00%|        """
  2155|         0|            0|            0|  0.00%|        # TODO: should we issue a loud deprecation warning here?
  2156|         0|            0|            0|  0.00%|        magic_name, _, magic_arg_s = arg_s.partition(' ')
  2157|         0|            0|            0|  0.00%|        magic_name = magic_name.lstrip(prefilter.ESC_MAGIC)
  2158|         0|            0|            0|  0.00%|        return self.run_line_magic(magic_name, magic_arg_s)
  2159|         0|            0|            0|  0.00%|
  2160|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2161|         0|            0|            0|  0.00%|    # Things related to macros
  2162|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2163|         0|            0|            0|  0.00%|
  2164|         0|            0|            0|  0.00%|    def define_macro(self, name, themacro):
  2165|         0|            0|            0|  0.00%|        """Define a new macro
  2166|         0|            0|            0|  0.00%|
  2167|         0|            0|            0|  0.00%|        Parameters
  2168|         0|            0|            0|  0.00%|        ----------
  2169|         0|            0|            0|  0.00%|        name : str
  2170|         0|            0|            0|  0.00%|            The name of the macro.
  2171|         0|            0|            0|  0.00%|        themacro : str or Macro
  2172|         0|            0|            0|  0.00%|            The action to do upon invoking the macro.  If a string, a new
  2173|         0|            0|            0|  0.00%|            Macro object is created by passing the string to it.
  2174|         0|            0|            0|  0.00%|        """
  2175|         0|            0|            0|  0.00%|
  2176|         0|            0|            0|  0.00%|        from IPython.core import macro
  2177|         0|            0|            0|  0.00%|
  2178|         0|            0|            0|  0.00%|        if isinstance(themacro, string_types):
  2179|         0|            0|            0|  0.00%|            themacro = macro.Macro(themacro)
  2180|         0|            0|            0|  0.00%|        if not isinstance(themacro, macro.Macro):
  2181|         0|            0|            0|  0.00%|            raise ValueError('A macro must be a string or a Macro instance.')
  2182|         0|            0|            0|  0.00%|        self.user_ns[name] = themacro
  2183|         0|            0|            0|  0.00%|
  2184|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2185|         0|            0|            0|  0.00%|    # Things related to the running of system commands
  2186|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2187|         0|            0|            0|  0.00%|
  2188|         0|            0|            0|  0.00%|    def system_piped(self, cmd):
  2189|         0|            0|            0|  0.00%|        """Call the given cmd in a subprocess, piping stdout/err
  2190|         0|            0|            0|  0.00%|
  2191|         0|            0|            0|  0.00%|        Parameters
  2192|         0|            0|            0|  0.00%|        ----------
  2193|         0|            0|            0|  0.00%|        cmd : str
  2194|         0|            0|            0|  0.00%|          Command to execute (can not end in '&', as background processes are
  2195|         0|            0|            0|  0.00%|          not supported.  Should not be a command that expects input
  2196|         0|            0|            0|  0.00%|          other than simple text.
  2197|         0|            0|            0|  0.00%|        """
  2198|         0|            0|            0|  0.00%|        if cmd.rstrip().endswith('&'):
  2199|         0|            0|            0|  0.00%|            # this is *far* from a rigorous test
  2200|         0|            0|            0|  0.00%|            # We do not support backgrounding processes because we either use
  2201|         0|            0|            0|  0.00%|            # pexpect or pipes to read from.  Users can always just call
  2202|         0|            0|            0|  0.00%|            # os.system() or use ip.system=ip.system_raw
  2203|         0|            0|            0|  0.00%|            # if they really want a background process.
  2204|         0|            0|            0|  0.00%|            raise OSError("Background processes not supported.")
  2205|         0|            0|            0|  0.00%|
  2206|         0|            0|            0|  0.00%|        # we explicitly do NOT return the subprocess status code, because
  2207|         0|            0|            0|  0.00%|        # a non-None value would trigger :func:`sys.displayhook` calls.
  2208|         0|            0|            0|  0.00%|        # Instead, we store the exit_code in user_ns.
  2209|         0|            0|            0|  0.00%|        self.user_ns['_exit_code'] = system(self.var_expand(cmd, depth=1))
  2210|         0|            0|            0|  0.00%|
  2211|         0|            0|            0|  0.00%|    def system_raw(self, cmd):
  2212|         0|            0|            0|  0.00%|        """Call the given cmd in a subprocess using os.system on Windows or
  2213|         0|            0|            0|  0.00%|        subprocess.call using the system shell on other platforms.
  2214|         0|            0|            0|  0.00%|
  2215|         0|            0|            0|  0.00%|        Parameters
  2216|         0|            0|            0|  0.00%|        ----------
  2217|         0|            0|            0|  0.00%|        cmd : str
  2218|         0|            0|            0|  0.00%|          Command to execute.
  2219|         0|            0|            0|  0.00%|        """
  2220|         0|            0|            0|  0.00%|        cmd = self.var_expand(cmd, depth=1)
  2221|         0|            0|            0|  0.00%|        # protect os.system from UNC paths on Windows, which it can't handle:
  2222|         0|            0|            0|  0.00%|        if sys.platform == 'win32':
  2223|         0|            0|            0|  0.00%|            from IPython.utils._process_win32 import AvoidUNCPath
  2224|         0|            0|            0|  0.00%|            with AvoidUNCPath() as path:
  2225|         0|            0|            0|  0.00%|                if path is not None:
  2226|         0|            0|            0|  0.00%|                    cmd = '"pushd %s &&"%s' % (path, cmd)
  2227|         0|            0|            0|  0.00%|                cmd = py3compat.unicode_to_str(cmd)
  2228|         0|            0|            0|  0.00%|                try:
  2229|         0|            0|            0|  0.00%|                    ec = os.system(cmd)
  2230|         0|            0|            0|  0.00%|                except KeyboardInterrupt:
  2231|         0|            0|            0|  0.00%|                    print('\n' + self.get_exception_only(), file=sys.stderr)
  2232|         0|            0|            0|  0.00%|                    ec = -2
  2233|         0|            0|            0|  0.00%|        else:
  2234|         0|            0|            0|  0.00%|            cmd = py3compat.unicode_to_str(cmd)
  2235|         0|            0|            0|  0.00%|            # For posix the result of the subprocess.call() below is an exit
  2236|         0|            0|            0|  0.00%|            # code, which by convention is zero for success, positive for
  2237|         0|            0|            0|  0.00%|            # program failure.  Exit codes above 128 are reserved for signals,
  2238|         0|            0|            0|  0.00%|            # and the formula for converting a signal to an exit code is usually
  2239|         0|            0|            0|  0.00%|            # signal_number+128.  To more easily differentiate between exit
  2240|         0|            0|            0|  0.00%|            # codes and signals, ipython uses negative numbers.  For instance
  2241|         0|            0|            0|  0.00%|            # since control-c is signal 2 but exit code 130, ipython's
  2242|         0|            0|            0|  0.00%|            # _exit_code variable will read -2.  Note that some shells like
  2243|         0|            0|            0|  0.00%|            # csh and fish don't follow sh/bash conventions for exit codes.
  2244|         0|            0|            0|  0.00%|            executable = os.environ.get('SHELL', None)
  2245|         0|            0|            0|  0.00%|            try:
  2246|         0|            0|            0|  0.00%|                # Use env shell instead of default /bin/sh
  2247|         0|            0|            0|  0.00%|                ec = subprocess.call(cmd, shell=True, executable=executable)
  2248|         0|            0|            0|  0.00%|            except KeyboardInterrupt:
  2249|         0|            0|            0|  0.00%|                # intercept control-C; a long traceback is not useful here
  2250|         0|            0|            0|  0.00%|                print('\n' + self.get_exception_only(), file=sys.stderr)
  2251|         0|            0|            0|  0.00%|                ec = 130
  2252|         0|            0|            0|  0.00%|            if ec > 128:
  2253|         0|            0|            0|  0.00%|                ec = -(ec - 128)
  2254|         0|            0|            0|  0.00%|
  2255|         0|            0|            0|  0.00%|        # We explicitly do NOT return the subprocess status code, because
  2256|         0|            0|            0|  0.00%|        # a non-None value would trigger :func:`sys.displayhook` calls.
  2257|         0|            0|            0|  0.00%|        # Instead, we store the exit_code in user_ns.  Note the semantics
  2258|         0|            0|            0|  0.00%|        # of _exit_code: for control-c, _exit_code == -signal.SIGNIT,
  2259|         0|            0|            0|  0.00%|        # but raising SystemExit(_exit_code) will give status 254!
  2260|         0|            0|            0|  0.00%|        self.user_ns['_exit_code'] = ec
  2261|         0|            0|            0|  0.00%|
  2262|         0|            0|            0|  0.00%|    # use piped system by default, because it is better behaved
  2263|         0|            0|            0|  0.00%|    system = system_piped
  2264|         0|            0|            0|  0.00%|
  2265|         0|            0|            0|  0.00%|    def getoutput(self, cmd, split=True, depth=0):
  2266|         0|            0|            0|  0.00%|        """Get output (possibly including stderr) from a subprocess.
  2267|         0|            0|            0|  0.00%|
  2268|         0|            0|            0|  0.00%|        Parameters
  2269|         0|            0|            0|  0.00%|        ----------
  2270|         0|            0|            0|  0.00%|        cmd : str
  2271|         0|            0|            0|  0.00%|          Command to execute (can not end in '&', as background processes are
  2272|         0|            0|            0|  0.00%|          not supported.
  2273|         0|            0|            0|  0.00%|        split : bool, optional
  2274|         0|            0|            0|  0.00%|          If True, split the output into an IPython SList.  Otherwise, an
  2275|         0|            0|            0|  0.00%|          IPython LSString is returned.  These are objects similar to normal
  2276|         0|            0|            0|  0.00%|          lists and strings, with a few convenience attributes for easier
  2277|         0|            0|            0|  0.00%|          manipulation of line-based output.  You can use '?' on them for
  2278|         0|            0|            0|  0.00%|          details.
  2279|         0|            0|            0|  0.00%|        depth : int, optional
  2280|         0|            0|            0|  0.00%|          How many frames above the caller are the local variables which should
  2281|         0|            0|            0|  0.00%|          be expanded in the command string? The default (0) assumes that the
  2282|         0|            0|            0|  0.00%|          expansion variables are in the stack frame calling this function.
  2283|         0|            0|            0|  0.00%|        """
  2284|         0|            0|            0|  0.00%|        if cmd.rstrip().endswith('&'):
  2285|         0|            0|            0|  0.00%|            # this is *far* from a rigorous test
  2286|         0|            0|            0|  0.00%|            raise OSError("Background processes not supported.")
  2287|         0|            0|            0|  0.00%|        out = getoutput(self.var_expand(cmd, depth=depth+1))
  2288|         0|            0|            0|  0.00%|        if split:
  2289|         0|            0|            0|  0.00%|            out = SList(out.splitlines())
  2290|         0|            0|            0|  0.00%|        else:
  2291|         0|            0|            0|  0.00%|            out = LSString(out)
  2292|         0|            0|            0|  0.00%|        return out
  2293|         0|            0|            0|  0.00%|
  2294|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2295|         0|            0|            0|  0.00%|    # Things related to aliases
  2296|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2297|         0|            0|            0|  0.00%|
  2298|         0|            0|            0|  0.00%|    def init_alias(self):
  2299|         0|            0|            0|  0.00%|        self.alias_manager = AliasManager(shell=self, parent=self)
  2300|         0|            0|            0|  0.00%|        self.configurables.append(self.alias_manager)
  2301|         0|            0|            0|  0.00%|
  2302|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2303|         0|            0|            0|  0.00%|    # Things related to extensions
  2304|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2305|         0|            0|            0|  0.00%|
  2306|         0|            0|            0|  0.00%|    def init_extension_manager(self):
  2307|         0|            0|            0|  0.00%|        self.extension_manager = ExtensionManager(shell=self, parent=self)
  2308|         0|            0|            0|  0.00%|        self.configurables.append(self.extension_manager)
  2309|         0|            0|            0|  0.00%|
  2310|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2311|         0|            0|            0|  0.00%|    # Things related to payloads
  2312|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2313|         0|            0|            0|  0.00%|
  2314|         0|            0|            0|  0.00%|    def init_payload(self):
  2315|         0|            0|            0|  0.00%|        self.payload_manager = PayloadManager(parent=self)
  2316|         0|            0|            0|  0.00%|        self.configurables.append(self.payload_manager)
  2317|         0|            0|            0|  0.00%|
  2318|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2319|         0|            0|            0|  0.00%|    # Things related to the prefilter
  2320|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2321|         0|            0|            0|  0.00%|
  2322|         0|            0|            0|  0.00%|    def init_prefilter(self):
  2323|         0|            0|            0|  0.00%|        self.prefilter_manager = PrefilterManager(shell=self, parent=self)
  2324|         0|            0|            0|  0.00%|        self.configurables.append(self.prefilter_manager)
  2325|         0|            0|            0|  0.00%|        # Ultimately this will be refactored in the new interpreter code, but
  2326|         0|            0|            0|  0.00%|        # for now, we should expose the main prefilter method (there's legacy
  2327|         0|            0|            0|  0.00%|        # code out there that may rely on this).
  2328|         0|            0|            0|  0.00%|        self.prefilter = self.prefilter_manager.prefilter_lines
  2329|         0|            0|            0|  0.00%|
  2330|         0|            0|            0|  0.00%|    def auto_rewrite_input(self, cmd):
  2331|         0|            0|            0|  0.00%|        """Print to the screen the rewritten form of the user's command.
  2332|         0|            0|            0|  0.00%|
  2333|         0|            0|            0|  0.00%|        This shows visual feedback by rewriting input lines that cause
  2334|         0|            0|            0|  0.00%|        automatic calling to kick in, like::
  2335|         0|            0|            0|  0.00%|
  2336|         0|            0|            0|  0.00%|          /f x
  2337|         0|            0|            0|  0.00%|
  2338|         0|            0|            0|  0.00%|        into::
  2339|         0|            0|            0|  0.00%|
  2340|         0|            0|            0|  0.00%|          ------> f(x)
  2341|         0|            0|            0|  0.00%|
  2342|         0|            0|            0|  0.00%|        after the user's input prompt.  This helps the user understand that the
  2343|         0|            0|            0|  0.00%|        input line was transformed automatically by IPython.
  2344|         0|            0|            0|  0.00%|        """
  2345|         0|            0|            0|  0.00%|        if not self.show_rewritten_input:
  2346|         0|            0|            0|  0.00%|            return
  2347|         0|            0|            0|  0.00%|
  2348|         0|            0|            0|  0.00%|        # This is overridden in TerminalInteractiveShell to use fancy prompts
  2349|         0|            0|            0|  0.00%|        print("------> " + cmd)
  2350|         0|            0|            0|  0.00%|
  2351|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2352|         0|            0|            0|  0.00%|    # Things related to extracting values/expressions from kernel and user_ns
  2353|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2354|         0|            0|            0|  0.00%|
  2355|         0|            0|            0|  0.00%|    def _user_obj_error(self):
  2356|         0|            0|            0|  0.00%|        """return simple exception dict
  2357|         0|            0|            0|  0.00%|
  2358|         0|            0|            0|  0.00%|        for use in user_expressions
  2359|         0|            0|            0|  0.00%|        """
  2360|         0|            0|            0|  0.00%|
  2361|         0|            0|            0|  0.00%|        etype, evalue, tb = self._get_exc_info()
  2362|         0|            0|            0|  0.00%|        stb = self.InteractiveTB.get_exception_only(etype, evalue)
  2363|         0|            0|            0|  0.00%|
  2364|         0|            0|            0|  0.00%|        exc_info = {
  2365|         0|            0|            0|  0.00%|            u'status' : 'error',
  2366|         0|            0|            0|  0.00%|            u'traceback' : stb,
  2367|         0|            0|            0|  0.00%|            u'ename' : unicode_type(etype.__name__),
  2368|         0|            0|            0|  0.00%|            u'evalue' : py3compat.safe_unicode(evalue),
  2369|         0|            0|            0|  0.00%|        }
  2370|         0|            0|            0|  0.00%|
  2371|         0|            0|            0|  0.00%|        return exc_info
  2372|         0|            0|            0|  0.00%|
  2373|         0|            0|            0|  0.00%|    def _format_user_obj(self, obj):
  2374|         0|            0|            0|  0.00%|        """format a user object to display dict
  2375|         0|            0|            0|  0.00%|
  2376|         0|            0|            0|  0.00%|        for use in user_expressions
  2377|         0|            0|            0|  0.00%|        """
  2378|         0|            0|            0|  0.00%|
  2379|         0|            0|            0|  0.00%|        data, md = self.display_formatter.format(obj)
  2380|         0|            0|            0|  0.00%|        value = {
  2381|         0|            0|            0|  0.00%|            'status' : 'ok',
  2382|         0|            0|            0|  0.00%|            'data' : data,
  2383|         0|            0|            0|  0.00%|            'metadata' : md,
  2384|         0|            0|            0|  0.00%|        }
  2385|         0|            0|            0|  0.00%|        return value
  2386|         0|            0|            0|  0.00%|
  2387|         0|            0|            0|  0.00%|    def user_expressions(self, expressions):
  2388|         0|            0|            0|  0.00%|        """Evaluate a dict of expressions in the user's namespace.
  2389|         0|            0|            0|  0.00%|
  2390|         0|            0|            0|  0.00%|        Parameters
  2391|         0|            0|            0|  0.00%|        ----------
  2392|         0|            0|            0|  0.00%|        expressions : dict
  2393|         0|            0|            0|  0.00%|          A dict with string keys and string values.  The expression values
  2394|         0|            0|            0|  0.00%|          should be valid Python expressions, each of which will be evaluated
  2395|         0|            0|            0|  0.00%|          in the user namespace.
  2396|         0|            0|            0|  0.00%|
  2397|         0|            0|            0|  0.00%|        Returns
  2398|         0|            0|            0|  0.00%|        -------
  2399|         0|            0|            0|  0.00%|        A dict, keyed like the input expressions dict, with the rich mime-typed
  2400|         0|            0|            0|  0.00%|        display_data of each value.
  2401|         0|            0|            0|  0.00%|        """
  2402|         0|            0|            0|  0.00%|        out = {}
  2403|         0|            0|            0|  0.00%|        user_ns = self.user_ns
  2404|         0|            0|            0|  0.00%|        global_ns = self.user_global_ns
  2405|         0|            0|            0|  0.00%|
  2406|         0|            0|            0|  0.00%|        for key, expr in iteritems(expressions):
  2407|         0|            0|            0|  0.00%|            try:
  2408|         0|            0|            0|  0.00%|                value = self._format_user_obj(eval(expr, global_ns, user_ns))
  2409|         0|            0|            0|  0.00%|            except:
  2410|         0|            0|            0|  0.00%|                value = self._user_obj_error()
  2411|         0|            0|            0|  0.00%|            out[key] = value
  2412|         0|            0|            0|  0.00%|        return out
  2413|         0|            0|            0|  0.00%|
  2414|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2415|         0|            0|            0|  0.00%|    # Things related to the running of code
  2416|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2417|         0|            0|            0|  0.00%|
  2418|         0|            0|            0|  0.00%|    def ex(self, cmd):
  2419|         0|            0|            0|  0.00%|        """Execute a normal python statement in user namespace."""
  2420|         0|            0|            0|  0.00%|        with self.builtin_trap:
  2421|         0|            0|            0|  0.00%|            exec(cmd, self.user_global_ns, self.user_ns)
  2422|         0|            0|            0|  0.00%|
  2423|         0|            0|            0|  0.00%|    def ev(self, expr):
  2424|         0|            0|            0|  0.00%|        """Evaluate python expression expr in user namespace.
  2425|         0|            0|            0|  0.00%|
  2426|         0|            0|            0|  0.00%|        Returns the result of evaluation
  2427|         0|            0|            0|  0.00%|        """
  2428|         0|            0|            0|  0.00%|        with self.builtin_trap:
  2429|         0|            0|            0|  0.00%|            return eval(expr, self.user_global_ns, self.user_ns)
  2430|         0|            0|            0|  0.00%|
  2431|         0|            0|            0|  0.00%|    def safe_execfile(self, fname, *where, **kw):
  2432|         0|            0|            0|  0.00%|        """A safe version of the builtin execfile().
  2433|         0|            0|            0|  0.00%|
  2434|         0|            0|            0|  0.00%|        This version will never throw an exception, but instead print
  2435|         0|            0|            0|  0.00%|        helpful error messages to the screen.  This only works on pure
  2436|         0|            0|            0|  0.00%|        Python files with the .py extension.
  2437|         0|            0|            0|  0.00%|
  2438|         0|            0|            0|  0.00%|        Parameters
  2439|         0|            0|            0|  0.00%|        ----------
  2440|         0|            0|            0|  0.00%|        fname : string
  2441|         0|            0|            0|  0.00%|            The name of the file to be executed.
  2442|         0|            0|            0|  0.00%|        where : tuple
  2443|         0|            0|            0|  0.00%|            One or two namespaces, passed to execfile() as (globals,locals).
  2444|         0|            0|            0|  0.00%|            If only one is given, it is passed as both.
  2445|         0|            0|            0|  0.00%|        exit_ignore : bool (False)
  2446|         0|            0|            0|  0.00%|            If True, then silence SystemExit for non-zero status (it is always
  2447|         0|            0|            0|  0.00%|            silenced for zero status, as it is so common).
  2448|         0|            0|            0|  0.00%|        raise_exceptions : bool (False)
  2449|         0|            0|            0|  0.00%|            If True raise exceptions everywhere. Meant for testing.
  2450|         0|            0|            0|  0.00%|        shell_futures : bool (False)
  2451|         0|            0|            0|  0.00%|            If True, the code will share future statements with the interactive
  2452|         0|            0|            0|  0.00%|            shell. It will both be affected by previous __future__ imports, and
  2453|         0|            0|            0|  0.00%|            any __future__ imports in the code will affect the shell. If False,
  2454|         0|            0|            0|  0.00%|            __future__ imports are not shared in either direction.
  2455|         0|            0|            0|  0.00%|
  2456|         0|            0|            0|  0.00%|        """
  2457|         0|            0|            0|  0.00%|        kw.setdefault('exit_ignore', False)
  2458|         0|            0|            0|  0.00%|        kw.setdefault('raise_exceptions', False)
  2459|         0|            0|            0|  0.00%|        kw.setdefault('shell_futures', False)
  2460|         0|            0|            0|  0.00%|
  2461|         0|            0|            0|  0.00%|        fname = os.path.abspath(os.path.expanduser(fname))
  2462|         0|            0|            0|  0.00%|
  2463|         0|            0|            0|  0.00%|        # Make sure we can open the file
  2464|         0|            0|            0|  0.00%|        try:
  2465|         0|            0|            0|  0.00%|            with open(fname):
  2466|         0|            0|            0|  0.00%|                pass
  2467|         0|            0|            0|  0.00%|        except:
  2468|         0|            0|            0|  0.00%|            warn('Could not open file <%s> for safe execution.' % fname)
  2469|         0|            0|            0|  0.00%|            return
  2470|         0|            0|            0|  0.00%|
  2471|         0|            0|            0|  0.00%|        # Find things also in current directory.  This is needed to mimic the
  2472|         0|            0|            0|  0.00%|        # behavior of running a script from the system command line, where
  2473|         0|            0|            0|  0.00%|        # Python inserts the script's directory into sys.path
  2474|         0|            0|            0|  0.00%|        dname = os.path.dirname(fname)
  2475|         0|            0|            0|  0.00%|
  2476|         0|            0|            0|  0.00%|        with prepended_to_syspath(dname), self.builtin_trap:
  2477|         0|            0|            0|  0.00%|            try:
  2478|         0|            0|            0|  0.00%|                glob, loc = (where + (None, ))[:2]
  2479|         0|            0|            0|  0.00%|                py3compat.execfile(
  2480|         0|            0|            0|  0.00%|                    fname, glob, loc,
  2481|         0|            0|            0|  0.00%|                    self.compile if kw['shell_futures'] else None)
  2482|         0|            0|            0|  0.00%|            except SystemExit as status:
  2483|         0|            0|            0|  0.00%|                # If the call was made with 0 or None exit status (sys.exit(0)
  2484|         0|            0|            0|  0.00%|                # or sys.exit() ), don't bother showing a traceback, as both of
  2485|         0|            0|            0|  0.00%|                # these are considered normal by the OS:
  2486|         0|            0|            0|  0.00%|                # > python -c'import sys;sys.exit(0)'; echo $?
  2487|         0|            0|            0|  0.00%|                # 0
  2488|         0|            0|            0|  0.00%|                # > python -c'import sys;sys.exit()'; echo $?
  2489|         0|            0|            0|  0.00%|                # 0
  2490|         0|            0|            0|  0.00%|                # For other exit status, we show the exception unless
  2491|         0|            0|            0|  0.00%|                # explicitly silenced, but only in short form.
  2492|         0|            0|            0|  0.00%|                if status.code:
  2493|         0|            0|            0|  0.00%|                    if kw['raise_exceptions']:
  2494|         0|            0|            0|  0.00%|                        raise
  2495|         0|            0|            0|  0.00%|                    if not kw['exit_ignore']:
  2496|         0|            0|            0|  0.00%|                        self.showtraceback(exception_only=True)
  2497|         0|            0|            0|  0.00%|            except:
  2498|         0|            0|            0|  0.00%|                if kw['raise_exceptions']:
  2499|         0|            0|            0|  0.00%|                    raise
  2500|         0|            0|            0|  0.00%|                # tb offset is 2 because we wrap execfile
  2501|         0|            0|            0|  0.00%|                self.showtraceback(tb_offset=2)
  2502|         0|            0|            0|  0.00%|
  2503|         0|            0|            0|  0.00%|    def safe_execfile_ipy(self, fname, shell_futures=False, raise_exceptions=False):
  2504|         0|            0|            0|  0.00%|        """Like safe_execfile, but for .ipy or .ipynb files with IPython syntax.
  2505|         0|            0|            0|  0.00%|
  2506|         0|            0|            0|  0.00%|        Parameters
  2507|         0|            0|            0|  0.00%|        ----------
  2508|         0|            0|            0|  0.00%|        fname : str
  2509|         0|            0|            0|  0.00%|            The name of the file to execute.  The filename must have a
  2510|         0|            0|            0|  0.00%|            .ipy or .ipynb extension.
  2511|         0|            0|            0|  0.00%|        shell_futures : bool (False)
  2512|         0|            0|            0|  0.00%|            If True, the code will share future statements with the interactive
  2513|         0|            0|            0|  0.00%|            shell. It will both be affected by previous __future__ imports, and
  2514|         0|            0|            0|  0.00%|            any __future__ imports in the code will affect the shell. If False,
  2515|         0|            0|            0|  0.00%|            __future__ imports are not shared in either direction.
  2516|         0|            0|            0|  0.00%|        raise_exceptions : bool (False)
  2517|         0|            0|            0|  0.00%|            If True raise exceptions everywhere.  Meant for testing.
  2518|         0|            0|            0|  0.00%|        """
  2519|         0|            0|            0|  0.00%|        fname = os.path.abspath(os.path.expanduser(fname))
  2520|         0|            0|            0|  0.00%|
  2521|         0|            0|            0|  0.00%|        # Make sure we can open the file
  2522|         0|            0|            0|  0.00%|        try:
  2523|         0|            0|            0|  0.00%|            with open(fname):
  2524|         0|            0|            0|  0.00%|                pass
  2525|         0|            0|            0|  0.00%|        except:
  2526|         0|            0|            0|  0.00%|            warn('Could not open file <%s> for safe execution.' % fname)
  2527|         0|            0|            0|  0.00%|            return
  2528|         0|            0|            0|  0.00%|
  2529|         0|            0|            0|  0.00%|        # Find things also in current directory.  This is needed to mimic the
  2530|         0|            0|            0|  0.00%|        # behavior of running a script from the system command line, where
  2531|         0|            0|            0|  0.00%|        # Python inserts the script's directory into sys.path
  2532|         0|            0|            0|  0.00%|        dname = os.path.dirname(fname)
  2533|         0|            0|            0|  0.00%|
  2534|         0|            0|            0|  0.00%|        def get_cells():
  2535|         0|            0|            0|  0.00%|            """generator for sequence of code blocks to run"""
  2536|         0|            0|            0|  0.00%|            if fname.endswith('.ipynb'):
  2537|         0|            0|            0|  0.00%|                from nbformat import read
  2538|         0|            0|            0|  0.00%|                with io_open(fname) as f:
  2539|         0|            0|            0|  0.00%|                    nb = read(f, as_version=4)
  2540|         0|            0|            0|  0.00%|                    if not nb.cells:
  2541|         0|            0|            0|  0.00%|                        return
  2542|         0|            0|            0|  0.00%|                    for cell in nb.cells:
  2543|         0|            0|            0|  0.00%|                        if cell.cell_type == 'code':
  2544|         0|            0|            0|  0.00%|                            yield cell.source
  2545|         0|            0|            0|  0.00%|            else:
  2546|         0|            0|            0|  0.00%|                with open(fname) as f:
  2547|         0|            0|            0|  0.00%|                    yield f.read()
  2548|         0|            0|            0|  0.00%|
  2549|         0|            0|            0|  0.00%|        with prepended_to_syspath(dname):
  2550|         0|            0|            0|  0.00%|            try:
  2551|         0|            0|            0|  0.00%|                for cell in get_cells():
  2552|         0|            0|            0|  0.00%|                    result = self.run_cell(cell, silent=True, shell_futures=shell_futures)
  2553|         0|            0|            0|  0.00%|                    if raise_exceptions:
  2554|         0|            0|            0|  0.00%|                        result.raise_error()
  2555|         0|            0|            0|  0.00%|                    elif not result.success:
  2556|         0|            0|            0|  0.00%|                        break
  2557|         0|            0|            0|  0.00%|            except:
  2558|         0|            0|            0|  0.00%|                if raise_exceptions:
  2559|         0|            0|            0|  0.00%|                    raise
  2560|         0|            0|            0|  0.00%|                self.showtraceback()
  2561|         0|            0|            0|  0.00%|                warn('Unknown failure executing file: <%s>' % fname)
  2562|         0|            0|            0|  0.00%|
  2563|         0|            0|            0|  0.00%|    def safe_run_module(self, mod_name, where):
  2564|         0|            0|            0|  0.00%|        """A safe version of runpy.run_module().
  2565|         0|            0|            0|  0.00%|
  2566|         0|            0|            0|  0.00%|        This version will never throw an exception, but instead print
  2567|         0|            0|            0|  0.00%|        helpful error messages to the screen.
  2568|         0|            0|            0|  0.00%|
  2569|         0|            0|            0|  0.00%|        `SystemExit` exceptions with status code 0 or None are ignored.
  2570|         0|            0|            0|  0.00%|
  2571|         0|            0|            0|  0.00%|        Parameters
  2572|         0|            0|            0|  0.00%|        ----------
  2573|         0|            0|            0|  0.00%|        mod_name : string
  2574|         0|            0|            0|  0.00%|            The name of the module to be executed.
  2575|         0|            0|            0|  0.00%|        where : dict
  2576|         0|            0|            0|  0.00%|            The globals namespace.
  2577|         0|            0|            0|  0.00%|        """
  2578|         0|            0|            0|  0.00%|        try:
  2579|         0|            0|            0|  0.00%|            try:
  2580|         0|            0|            0|  0.00%|                where.update(
  2581|         0|            0|            0|  0.00%|                    runpy.run_module(str(mod_name), run_name="__main__",
  2582|         0|            0|            0|  0.00%|                                     alter_sys=True)
  2583|         0|            0|            0|  0.00%|                    )
  2584|         0|            0|            0|  0.00%|            except SystemExit as status:
  2585|         0|            0|            0|  0.00%|                if status.code:
  2586|         0|            0|            0|  0.00%|                    raise
  2587|         0|            0|            0|  0.00%|        except:
  2588|         0|            0|            0|  0.00%|            self.showtraceback()
  2589|         0|            0|            0|  0.00%|            warn('Unknown failure executing module: <%s>' % mod_name)
  2590|         0|            0|            0|  0.00%|
  2591|         0|            0|            0|  0.00%|    def run_cell(self, raw_cell, store_history=False, silent=False, shell_futures=True):
  2592|         0|            0|            0|  0.00%|        """Run a complete IPython cell.
  2593|         0|            0|            0|  0.00%|
  2594|         0|            0|            0|  0.00%|        Parameters
  2595|         0|            0|            0|  0.00%|        ----------
  2596|         0|            0|            0|  0.00%|        raw_cell : str
  2597|         0|            0|            0|  0.00%|          The code (including IPython code such as %magic functions) to run.
  2598|         0|            0|            0|  0.00%|        store_history : bool
  2599|         0|            0|            0|  0.00%|          If True, the raw and translated cell will be stored in IPython's
  2600|         0|            0|            0|  0.00%|          history. For user code calling back into IPython's machinery, this
  2601|         0|            0|            0|  0.00%|          should be set to False.
  2602|         0|            0|            0|  0.00%|        silent : bool
  2603|         0|            0|            0|  0.00%|          If True, avoid side-effects, such as implicit displayhooks and
  2604|         0|            0|            0|  0.00%|          and logging.  silent=True forces store_history=False.
  2605|         0|            0|            0|  0.00%|        shell_futures : bool
  2606|         0|            0|            0|  0.00%|          If True, the code will share future statements with the interactive
  2607|         0|            0|            0|  0.00%|          shell. It will both be affected by previous __future__ imports, and
  2608|         0|            0|            0|  0.00%|          any __future__ imports in the code will affect the shell. If False,
  2609|         0|            0|            0|  0.00%|          __future__ imports are not shared in either direction.
  2610|         0|            0|            0|  0.00%|
  2611|         0|            0|            0|  0.00%|        Returns
  2612|         0|            0|            0|  0.00%|        -------
  2613|         0|            0|            0|  0.00%|        result : :class:`ExecutionResult`
  2614|         0|            0|            0|  0.00%|        """
  2615|         0|            0|            0|  0.00%|        result = ExecutionResult()
  2616|         0|            0|            0|  0.00%|
  2617|         0|            0|            0|  0.00%|        if (not raw_cell) or raw_cell.isspace():
  2618|         0|            0|            0|  0.00%|            self.last_execution_succeeded = True
  2619|         0|            0|            0|  0.00%|            return result
  2620|         0|            0|            0|  0.00%|
  2621|         0|            0|            0|  0.00%|        if silent:
  2622|         0|            0|            0|  0.00%|            store_history = False
  2623|         0|            0|            0|  0.00%|
  2624|         0|            0|            0|  0.00%|        if store_history:
  2625|         0|            0|            0|  0.00%|            result.execution_count = self.execution_count
  2626|         0|            0|            0|  0.00%|
  2627|         0|            0|            0|  0.00%|        def error_before_exec(value):
  2628|         0|            0|            0|  0.00%|            result.error_before_exec = value
  2629|         0|            0|            0|  0.00%|            self.last_execution_succeeded = False
  2630|         0|            0|            0|  0.00%|            return result
  2631|         0|            0|            0|  0.00%|
  2632|         0|            0|            0|  0.00%|        self.events.trigger('pre_execute')
  2633|         0|            0|            0|  0.00%|        if not silent:
  2634|         0|            0|            0|  0.00%|            self.events.trigger('pre_run_cell')
  2635|         0|            0|            0|  0.00%|
  2636|         0|            0|            0|  0.00%|        # If any of our input transformation (input_transformer_manager or
  2637|         0|            0|            0|  0.00%|        # prefilter_manager) raises an exception, we store it in this variable
  2638|         0|            0|            0|  0.00%|        # so that we can display the error after logging the input and storing
  2639|         0|            0|            0|  0.00%|        # it in the history.
  2640|         0|            0|            0|  0.00%|        preprocessing_exc_tuple = None
  2641|         0|            0|            0|  0.00%|        try:
  2642|         0|            0|            0|  0.00%|            # Static input transformations
  2643|         0|            0|            0|  0.00%|            cell = self.input_transformer_manager.transform_cell(raw_cell)
  2644|         0|            0|            0|  0.00%|        except SyntaxError:
  2645|         0|            0|            0|  0.00%|            preprocessing_exc_tuple = sys.exc_info()
  2646|         0|            0|            0|  0.00%|            cell = raw_cell  # cell has to exist so it can be stored/logged
  2647|         0|            0|            0|  0.00%|        else:
  2648|         0|            0|            0|  0.00%|            if len(cell.splitlines()) == 1:
  2649|         0|            0|            0|  0.00%|                # Dynamic transformations - only applied for single line commands
  2650|         0|            0|            0|  0.00%|                with self.builtin_trap:
  2651|         0|            0|            0|  0.00%|                    try:
  2652|         0|            0|            0|  0.00%|                        # use prefilter_lines to handle trailing newlines
  2653|         0|            0|            0|  0.00%|                        # restore trailing newline for ast.parse
  2654|         0|            0|            0|  0.00%|                        cell = self.prefilter_manager.prefilter_lines(cell) + '\n'
  2655|         0|            0|            0|  0.00%|                    except Exception:
  2656|         0|            0|            0|  0.00%|                        # don't allow prefilter errors to crash IPython
  2657|         0|            0|            0|  0.00%|                        preprocessing_exc_tuple = sys.exc_info()
  2658|         0|            0|            0|  0.00%|
  2659|         0|            0|            0|  0.00%|        # Store raw and processed history
  2660|         0|            0|            0|  0.00%|        if store_history:
  2661|         0|            0|            0|  0.00%|            self.history_manager.store_inputs(self.execution_count,
  2662|         0|            0|            0|  0.00%|                                              cell, raw_cell)
  2663|         0|            0|            0|  0.00%|        if not silent:
  2664|         0|            0|            0|  0.00%|            self.logger.log(cell, raw_cell)
  2665|         0|            0|            0|  0.00%|
  2666|         0|            0|            0|  0.00%|        # Display the exception if input processing failed.
  2667|         0|            0|            0|  0.00%|        if preprocessing_exc_tuple is not None:
  2668|         0|            0|            0|  0.00%|            self.showtraceback(preprocessing_exc_tuple)
  2669|         0|            0|            0|  0.00%|            if store_history:
  2670|         0|            0|            0|  0.00%|                self.execution_count += 1
  2671|         0|            0|            0|  0.00%|            return error_before_exec(preprocessing_exc_tuple[2])
  2672|         0|            0|            0|  0.00%|
  2673|         0|            0|            0|  0.00%|        # Our own compiler remembers the __future__ environment. If we want to
  2674|         0|            0|            0|  0.00%|        # run code with a separate __future__ environment, use the default
  2675|         0|            0|            0|  0.00%|        # compiler
  2676|         0|            0|            0|  0.00%|        compiler = self.compile if shell_futures else CachingCompiler()
  2677|         0|            0|            0|  0.00%|
  2678|         0|            0|            0|  0.00%|        with self.builtin_trap:
  2679|         0|            0|            0|  0.00%|            cell_name = self.compile.cache(cell, self.execution_count)
  2680|         0|            0|            0|  0.00%|
  2681|         0|            0|            0|  0.00%|            with self.display_trap:
  2682|         0|            0|            0|  0.00%|                # Compile to bytecode
  2683|         0|            0|            0|  0.00%|                try:
  2684|         0|            0|            0|  0.00%|                    code_ast = compiler.ast_parse(cell, filename=cell_name)
  2685|         0|            0|            0|  0.00%|                except self.custom_exceptions as e:
  2686|         0|            0|            0|  0.00%|                    etype, value, tb = sys.exc_info()
  2687|         0|            0|            0|  0.00%|                    self.CustomTB(etype, value, tb)
  2688|         0|            0|            0|  0.00%|                    return error_before_exec(e)
  2689|         0|            0|            0|  0.00%|                except IndentationError as e:
  2690|         0|            0|            0|  0.00%|                    self.showindentationerror()
  2691|         0|            0|            0|  0.00%|                    if store_history:
  2692|         0|            0|            0|  0.00%|                        self.execution_count += 1
  2693|         0|            0|            0|  0.00%|                    return error_before_exec(e)
  2694|         0|            0|            0|  0.00%|                except (OverflowError, SyntaxError, ValueError, TypeError,
  2695|         0|            0|            0|  0.00%|                        MemoryError) as e:
  2696|         0|            0|            0|  0.00%|                    self.showsyntaxerror()
  2697|         0|            0|            0|  0.00%|                    if store_history:
  2698|         0|            0|            0|  0.00%|                        self.execution_count += 1
  2699|         0|            0|            0|  0.00%|                    return error_before_exec(e)
  2700|         0|            0|            0|  0.00%|
  2701|         0|            0|            0|  0.00%|                # Apply AST transformations
  2702|         0|            0|            0|  0.00%|                try:
  2703|         0|            0|            0|  0.00%|                    code_ast = self.transform_ast(code_ast)
  2704|         0|            0|            0|  0.00%|                except InputRejected as e:
  2705|         0|            0|            0|  0.00%|                    self.showtraceback()
  2706|         0|            0|            0|  0.00%|                    if store_history:
  2707|         0|            0|            0|  0.00%|                        self.execution_count += 1
  2708|         0|            0|            0|  0.00%|                    return error_before_exec(e)
  2709|         0|            0|            0|  0.00%|
  2710|         0|            0|            0|  0.00%|                # Give the displayhook a reference to our ExecutionResult so it
  2711|         0|            0|            0|  0.00%|                # can fill in the output value.
  2712|         0|            0|            0|  0.00%|                self.displayhook.exec_result = result
  2713|         0|            0|            0|  0.00%|
  2714|         0|            0|            0|  0.00%|                # Execute the user code
  2715|         0|            0|            0|  0.00%|                interactivity = "none" if silent else self.ast_node_interactivity
  2716|         0|            0|            0|  0.00%|                has_raised = self.run_ast_nodes(code_ast.body, cell_name,
  2717|         0|            0|            0|  0.00%|                   interactivity=interactivity, compiler=compiler, result=result)
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\IPython\core\interactiveshell.py:2770 run_ast_nodes
  2718|         0|            0|            0|  0.00%|
  2719|         0|            0|            0|  0.00%|                self.last_execution_succeeded = not has_raised
  2720|         0|            0|            0|  0.00%|
  2721|         0|            0|            0|  0.00%|                # Reset this so later displayed values do not modify the
  2722|         0|            0|            0|  0.00%|                # ExecutionResult
  2723|         0|            0|            0|  0.00%|                self.displayhook.exec_result = None
  2724|         0|            0|            0|  0.00%|
  2725|         0|            0|            0|  0.00%|                self.events.trigger('post_execute')
  2726|         0|            0|            0|  0.00%|                if not silent:
  2727|         0|            0|            0|  0.00%|                    self.events.trigger('post_run_cell')
  2728|         0|            0|            0|  0.00%|
  2729|         0|            0|            0|  0.00%|        if store_history:
  2730|         0|            0|            0|  0.00%|            # Write output to the database. Does nothing unless
  2731|         0|            0|            0|  0.00%|            # history output logging is enabled.
  2732|         0|            0|            0|  0.00%|            self.history_manager.store_output(self.execution_count)
  2733|         0|            0|            0|  0.00%|            # Each cell is a *single* input, regardless of how many lines it has
  2734|         0|            0|            0|  0.00%|            self.execution_count += 1
  2735|         0|            0|            0|  0.00%|
  2736|         0|            0|            0|  0.00%|        return result
  2737|         0|            0|            0|  0.00%|
  2738|         0|            0|            0|  0.00%|    def transform_ast(self, node):
  2739|         0|            0|            0|  0.00%|        """Apply the AST transformations from self.ast_transformers
  2740|         0|            0|            0|  0.00%|
  2741|         0|            0|            0|  0.00%|        Parameters
  2742|         0|            0|            0|  0.00%|        ----------
  2743|         0|            0|            0|  0.00%|        node : ast.Node
  2744|         0|            0|            0|  0.00%|          The root node to be transformed. Typically called with the ast.Module
  2745|         0|            0|            0|  0.00%|          produced by parsing user input.
  2746|         0|            0|            0|  0.00%|
  2747|         0|            0|            0|  0.00%|        Returns
  2748|         0|            0|            0|  0.00%|        -------
  2749|         0|            0|            0|  0.00%|        An ast.Node corresponding to the node it was called with. Note that it
  2750|         0|            0|            0|  0.00%|        may also modify the passed object, so don't rely on references to the
  2751|         0|            0|            0|  0.00%|        original AST.
  2752|         0|            0|            0|  0.00%|        """
  2753|         0|            0|            0|  0.00%|        for transformer in self.ast_transformers:
  2754|         0|            0|            0|  0.00%|            try:
  2755|         0|            0|            0|  0.00%|                node = transformer.visit(node)
  2756|         0|            0|            0|  0.00%|            except InputRejected:
  2757|         0|            0|            0|  0.00%|                # User-supplied AST transformers can reject an input by raising
  2758|         0|            0|            0|  0.00%|                # an InputRejected.  Short-circuit in this case so that we
  2759|         0|            0|            0|  0.00%|                # don't unregister the transform.
  2760|         0|            0|            0|  0.00%|                raise
  2761|         0|            0|            0|  0.00%|            except Exception:
  2762|         0|            0|            0|  0.00%|                warn("AST transformer %r threw an error. It will be unregistered." % transformer)
  2763|         0|            0|            0|  0.00%|                self.ast_transformers.remove(transformer)
  2764|         0|            0|            0|  0.00%|
  2765|         0|            0|            0|  0.00%|        if self.ast_transformers:
  2766|         0|            0|            0|  0.00%|            ast.fix_missing_locations(node)
  2767|         0|            0|            0|  0.00%|        return node
  2768|         0|            0|            0|  0.00%|
  2769|         0|            0|            0|  0.00%|
  2770|         0|            0|            0|  0.00%|    def run_ast_nodes(self, nodelist, cell_name, interactivity='last_expr',
  2771|         0|            0|            0|  0.00%|                        compiler=compile, result=None):
  2772|         0|            0|            0|  0.00%|        """Run a sequence of AST nodes. The execution mode depends on the
  2773|         0|            0|            0|  0.00%|        interactivity parameter.
  2774|         0|            0|            0|  0.00%|
  2775|         0|            0|            0|  0.00%|        Parameters
  2776|         0|            0|            0|  0.00%|        ----------
  2777|         0|            0|            0|  0.00%|        nodelist : list
  2778|         0|            0|            0|  0.00%|          A sequence of AST nodes to run.
  2779|         0|            0|            0|  0.00%|        cell_name : str
  2780|         0|            0|            0|  0.00%|          Will be passed to the compiler as the filename of the cell. Typically
  2781|         0|            0|            0|  0.00%|          the value returned by ip.compile.cache(cell).
  2782|         0|            0|            0|  0.00%|        interactivity : str
  2783|         0|            0|            0|  0.00%|          'all', 'last', 'last_expr' or 'none', specifying which nodes should be
  2784|         0|            0|            0|  0.00%|          run interactively (displaying output from expressions). 'last_expr'
  2785|         0|            0|            0|  0.00%|          will run the last node interactively only if it is an expression (i.e.
  2786|         0|            0|            0|  0.00%|          expressions in loops or other blocks are not displayed. Other values
  2787|         0|            0|            0|  0.00%|          for this parameter will raise a ValueError.
  2788|         0|            0|            0|  0.00%|        compiler : callable
  2789|         0|            0|            0|  0.00%|          A function with the same interface as the built-in compile(), to turn
  2790|         0|            0|            0|  0.00%|          the AST nodes into code objects. Default is the built-in compile().
  2791|         0|            0|            0|  0.00%|        result : ExecutionResult, optional
  2792|         0|            0|            0|  0.00%|          An object to store exceptions that occur during execution.
  2793|         0|            0|            0|  0.00%|
  2794|         0|            0|            0|  0.00%|        Returns
  2795|         0|            0|            0|  0.00%|        -------
  2796|         0|            0|            0|  0.00%|        True if an exception occurred while running code, False if it finished
  2797|         0|            0|            0|  0.00%|        running.
  2798|         0|            0|            0|  0.00%|        """
  2799|         0|            0|            0|  0.00%|        if not nodelist:
  2800|         0|            0|            0|  0.00%|            return
  2801|         0|            0|            0|  0.00%|
  2802|         0|            0|            0|  0.00%|        if interactivity == 'last_expr':
  2803|         0|            0|            0|  0.00%|            if isinstance(nodelist[-1], ast.Expr):
  2804|         0|            0|            0|  0.00%|                interactivity = "last"
  2805|         0|            0|            0|  0.00%|            else:
  2806|         0|            0|            0|  0.00%|                interactivity = "none"
  2807|         0|            0|            0|  0.00%|
  2808|         0|            0|            0|  0.00%|        if interactivity == 'none':
  2809|         0|            0|            0|  0.00%|            to_run_exec, to_run_interactive = nodelist, []
  2810|         0|            0|            0|  0.00%|        elif interactivity == 'last':
  2811|         0|            0|            0|  0.00%|            to_run_exec, to_run_interactive = nodelist[:-1], nodelist[-1:]
  2812|         0|            0|            0|  0.00%|        elif interactivity == 'all':
  2813|         0|            0|            0|  0.00%|            to_run_exec, to_run_interactive = [], nodelist
  2814|         0|            0|            0|  0.00%|        else:
  2815|         0|            0|            0|  0.00%|            raise ValueError("Interactivity was %r" % interactivity)
  2816|         0|            0|            0|  0.00%|
  2817|         0|            0|            0|  0.00%|        try:
  2818|         0|            0|            0|  0.00%|            for i, node in enumerate(to_run_exec):
  2819|         0|            0|            0|  0.00%|                mod = ast.Module([node])
  2820|         0|            0|            0|  0.00%|                code = compiler(mod, cell_name, "exec")
  2821|         0|            0|            0|  0.00%|                if self.run_code(code, result):
  2822|         0|            0|            0|  0.00%|                    return True
  2823|         0|            0|            0|  0.00%|
  2824|         0|            0|            0|  0.00%|            for i, node in enumerate(to_run_interactive):
  2825|         0|            0|            0|  0.00%|                mod = ast.Interactive([node])
  2826|         0|            0|            0|  0.00%|                code = compiler(mod, cell_name, "single")
  2827|         0|            0|            0|  0.00%|                if self.run_code(code, result):
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\IPython\core\interactiveshell.py:2851 run_code
  2828|         0|            0|            0|  0.00%|                    return True
  2829|         0|            0|            0|  0.00%|
  2830|         0|            0|            0|  0.00%|            # Flush softspace
  2831|         0|            0|            0|  0.00%|            if softspace(sys.stdout, 0):
  2832|         0|            0|            0|  0.00%|                print()
  2833|         0|            0|            0|  0.00%|
  2834|         0|            0|            0|  0.00%|        except:
  2835|         0|            0|            0|  0.00%|            # It's possible to have exceptions raised here, typically by
  2836|         0|            0|            0|  0.00%|            # compilation of odd code (such as a naked 'return' outside a
  2837|         0|            0|            0|  0.00%|            # function) that did parse but isn't valid. Typically the exception
  2838|         0|            0|            0|  0.00%|            # is a SyntaxError, but it's safest just to catch anything and show
  2839|         0|            0|            0|  0.00%|            # the user a traceback.
  2840|         0|            0|            0|  0.00%|
  2841|         0|            0|            0|  0.00%|            # We do only one try/except outside the loop to minimize the impact
  2842|         0|            0|            0|  0.00%|            # on runtime, and also because if any node in the node list is
  2843|         0|            0|            0|  0.00%|            # broken, we should stop execution completely.
  2844|         0|            0|            0|  0.00%|            if result:
  2845|         0|            0|            0|  0.00%|                result.error_before_exec = sys.exc_info()[1]
  2846|         0|            0|            0|  0.00%|            self.showtraceback()
  2847|         0|            0|            0|  0.00%|            return True
  2848|         0|            0|            0|  0.00%|
  2849|         0|            0|            0|  0.00%|        return False
  2850|         0|            0|            0|  0.00%|
  2851|         0|            0|            0|  0.00%|    def run_code(self, code_obj, result=None):
  2852|         0|            0|            0|  0.00%|        """Execute a code object.
  2853|         0|            0|            0|  0.00%|
  2854|         0|            0|            0|  0.00%|        When an exception occurs, self.showtraceback() is called to display a
  2855|         0|            0|            0|  0.00%|        traceback.
  2856|         0|            0|            0|  0.00%|
  2857|         0|            0|            0|  0.00%|        Parameters
  2858|         0|            0|            0|  0.00%|        ----------
  2859|         0|            0|            0|  0.00%|        code_obj : code object
  2860|         0|            0|            0|  0.00%|          A compiled code object, to be executed
  2861|         0|            0|            0|  0.00%|        result : ExecutionResult, optional
  2862|         0|            0|            0|  0.00%|          An object to store exceptions that occur during execution.
  2863|         0|            0|            0|  0.00%|
  2864|         0|            0|            0|  0.00%|        Returns
  2865|         0|            0|            0|  0.00%|        -------
  2866|         0|            0|            0|  0.00%|        False : successful execution.
  2867|         0|            0|            0|  0.00%|        True : an error occurred.
  2868|         0|            0|            0|  0.00%|        """
  2869|         0|            0|            0|  0.00%|        # Set our own excepthook in case the user code tries to call it
  2870|         0|            0|            0|  0.00%|        # directly, so that the IPython crash handler doesn't get triggered
  2871|         0|            0|            0|  0.00%|        old_excepthook, sys.excepthook = sys.excepthook, self.excepthook
  2872|         0|            0|            0|  0.00%|
  2873|         0|            0|            0|  0.00%|        # we save the original sys.excepthook in the instance, in case config
  2874|         0|            0|            0|  0.00%|        # code (such as magics) needs access to it.
  2875|         0|            0|            0|  0.00%|        self.sys_excepthook = old_excepthook
  2876|         0|            0|            0|  0.00%|        outflag = 1  # happens in more places, so it's easier as default
  2877|         0|            0|            0|  0.00%|        try:
  2878|         0|            0|            0|  0.00%|            try:
  2879|         0|            0|            0|  0.00%|                self.hooks.pre_run_code_hook()
  2880|         0|            0|            0|  0.00%|                #rprint('Running code', repr(code_obj)) # dbg
  2881|         0|            0|            0|  0.00%|                exec(code_obj, self.user_global_ns, self.user_ns)
(call)|       196|            0|            0|  0.00%|# D:/Users/JCHANGI/Jason Chang/Work/Project/Mix_Run_Ratio/Mix_Run_Ratio_caller_example.py:1 <module>
  2882|         0|            0|            0|  0.00%|            finally:
  2883|         0|            0|            0|  0.00%|                # Reset our crash handler in place
  2884|         0|            0|            0|  0.00%|                sys.excepthook = old_excepthook
  2885|         0|            0|            0|  0.00%|        except SystemExit as e:
  2886|         0|            0|            0|  0.00%|            if result is not None:
  2887|         0|            0|            0|  0.00%|                result.error_in_exec = e
  2888|         0|            0|            0|  0.00%|            self.showtraceback(exception_only=True)
  2889|         0|            0|            0|  0.00%|            warn("To exit: use 'exit', 'quit', or Ctrl-D.", stacklevel=1)
  2890|         0|            0|            0|  0.00%|        except self.custom_exceptions:
  2891|         0|            0|            0|  0.00%|            etype, value, tb = sys.exc_info()
  2892|         0|            0|            0|  0.00%|            if result is not None:
  2893|         0|            0|            0|  0.00%|                result.error_in_exec = value
  2894|         0|            0|            0|  0.00%|            self.CustomTB(etype, value, tb)
  2895|         0|            0|            0|  0.00%|        except:
  2896|         0|            0|            0|  0.00%|            if result is not None:
  2897|         0|            0|            0|  0.00%|                result.error_in_exec = sys.exc_info()[1]
  2898|         0|            0|            0|  0.00%|            self.showtraceback()
  2899|         0|            0|            0|  0.00%|        else:
  2900|         0|            0|            0|  0.00%|            outflag = 0
  2901|         0|            0|            0|  0.00%|        return outflag
  2902|         0|            0|            0|  0.00%|
  2903|         0|            0|            0|  0.00%|    # For backwards compatibility
  2904|         0|            0|            0|  0.00%|    runcode = run_code
  2905|         0|            0|            0|  0.00%|
  2906|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2907|         0|            0|            0|  0.00%|    # Things related to GUI support and pylab
  2908|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  2909|         0|            0|            0|  0.00%|
  2910|         0|            0|            0|  0.00%|    active_eventloop = None
  2911|         0|            0|            0|  0.00%|
  2912|         0|            0|            0|  0.00%|    def enable_gui(self, gui=None):
  2913|         0|            0|            0|  0.00%|        raise NotImplementedError('Implement enable_gui in a subclass')
  2914|         0|            0|            0|  0.00%|
  2915|         0|            0|            0|  0.00%|    def enable_matplotlib(self, gui=None):
  2916|         0|            0|            0|  0.00%|        """Enable interactive matplotlib and inline figure support.
  2917|         0|            0|            0|  0.00%|
  2918|         0|            0|            0|  0.00%|        This takes the following steps:
  2919|         0|            0|            0|  0.00%|
  2920|         0|            0|            0|  0.00%|        1. select the appropriate eventloop and matplotlib backend
  2921|         0|            0|            0|  0.00%|        2. set up matplotlib for interactive use with that backend
  2922|         0|            0|            0|  0.00%|        3. configure formatters for inline figure display
  2923|         0|            0|            0|  0.00%|        4. enable the selected gui eventloop
  2924|         0|            0|            0|  0.00%|
  2925|         0|            0|            0|  0.00%|        Parameters
  2926|         0|            0|            0|  0.00%|        ----------
  2927|         0|            0|            0|  0.00%|        gui : optional, string
  2928|         0|            0|            0|  0.00%|          If given, dictates the choice of matplotlib GUI backend to use
  2929|         0|            0|            0|  0.00%|          (should be one of IPython's supported backends, 'qt', 'osx', 'tk',
  2930|         0|            0|            0|  0.00%|          'gtk', 'wx' or 'inline'), otherwise we use the default chosen by
  2931|         0|            0|            0|  0.00%|          matplotlib (as dictated by the matplotlib build-time options plus the
  2932|         0|            0|            0|  0.00%|          user's matplotlibrc configuration file).  Note that not all backends
  2933|         0|            0|            0|  0.00%|          make sense in all contexts, for example a terminal ipython can't
  2934|         0|            0|            0|  0.00%|          display figures inline.
  2935|         0|            0|            0|  0.00%|        """
  2936|         0|            0|            0|  0.00%|        from IPython.core import pylabtools as pt
  2937|         0|            0|            0|  0.00%|        gui, backend = pt.find_gui_and_backend(gui, self.pylab_gui_select)
  2938|         0|            0|            0|  0.00%|
  2939|         0|            0|            0|  0.00%|        if gui != 'inline':
  2940|         0|            0|            0|  0.00%|            # If we have our first gui selection, store it
  2941|         0|            0|            0|  0.00%|            if self.pylab_gui_select is None:
  2942|         0|            0|            0|  0.00%|                self.pylab_gui_select = gui
  2943|         0|            0|            0|  0.00%|            # Otherwise if they are different
  2944|         0|            0|            0|  0.00%|            elif gui != self.pylab_gui_select:
  2945|         0|            0|            0|  0.00%|                print ('Warning: Cannot change to a different GUI toolkit: %s.'
  2946|         0|            0|            0|  0.00%|                        ' Using %s instead.' % (gui, self.pylab_gui_select))
  2947|         0|            0|            0|  0.00%|                gui, backend = pt.find_gui_and_backend(self.pylab_gui_select)
  2948|         0|            0|            0|  0.00%|
  2949|         0|            0|            0|  0.00%|        pt.activate_matplotlib(backend)
  2950|         0|            0|            0|  0.00%|        pt.configure_inline_support(self, backend)
  2951|         0|            0|            0|  0.00%|
  2952|         0|            0|            0|  0.00%|        # Now we must activate the gui pylab wants to use, and fix %run to take
  2953|         0|            0|            0|  0.00%|        # plot updates into account
  2954|         0|            0|            0|  0.00%|        self.enable_gui(gui)
  2955|         0|            0|            0|  0.00%|        self.magics_manager.registry['ExecutionMagics'].default_runner = \
  2956|         0|            0|            0|  0.00%|            pt.mpl_runner(self.safe_execfile)
  2957|         0|            0|            0|  0.00%|
  2958|         0|            0|            0|  0.00%|        return gui, backend
  2959|         0|            0|            0|  0.00%|
  2960|         0|            0|            0|  0.00%|    def enable_pylab(self, gui=None, import_all=True, welcome_message=False):
  2961|         0|            0|            0|  0.00%|        """Activate pylab support at runtime.
  2962|         0|            0|            0|  0.00%|
  2963|         0|            0|            0|  0.00%|        This turns on support for matplotlib, preloads into the interactive
  2964|         0|            0|            0|  0.00%|        namespace all of numpy and pylab, and configures IPython to correctly
  2965|         0|            0|            0|  0.00%|        interact with the GUI event loop.  The GUI backend to be used can be
  2966|         0|            0|            0|  0.00%|        optionally selected with the optional ``gui`` argument.
  2967|         0|            0|            0|  0.00%|
  2968|         0|            0|            0|  0.00%|        This method only adds preloading the namespace to InteractiveShell.enable_matplotlib.
  2969|         0|            0|            0|  0.00%|
  2970|         0|            0|            0|  0.00%|        Parameters
  2971|         0|            0|            0|  0.00%|        ----------
  2972|         0|            0|            0|  0.00%|        gui : optional, string
  2973|         0|            0|            0|  0.00%|          If given, dictates the choice of matplotlib GUI backend to use
  2974|         0|            0|            0|  0.00%|          (should be one of IPython's supported backends, 'qt', 'osx', 'tk',
  2975|         0|            0|            0|  0.00%|          'gtk', 'wx' or 'inline'), otherwise we use the default chosen by
  2976|         0|            0|            0|  0.00%|          matplotlib (as dictated by the matplotlib build-time options plus the
  2977|         0|            0|            0|  0.00%|          user's matplotlibrc configuration file).  Note that not all backends
  2978|         0|            0|            0|  0.00%|          make sense in all contexts, for example a terminal ipython can't
  2979|         0|            0|            0|  0.00%|          display figures inline.
  2980|         0|            0|            0|  0.00%|        import_all : optional, bool, default: True
  2981|         0|            0|            0|  0.00%|          Whether to do `from numpy import *` and `from pylab import *`
  2982|         0|            0|            0|  0.00%|          in addition to module imports.
  2983|         0|            0|            0|  0.00%|        welcome_message : deprecated
  2984|         0|            0|            0|  0.00%|          This argument is ignored, no welcome message will be displayed.
  2985|         0|            0|            0|  0.00%|        """
  2986|         0|            0|            0|  0.00%|        from IPython.core.pylabtools import import_pylab
  2987|         0|            0|            0|  0.00%|
  2988|         0|            0|            0|  0.00%|        gui, backend = self.enable_matplotlib(gui)
  2989|         0|            0|            0|  0.00%|
  2990|         0|            0|            0|  0.00%|        # We want to prevent the loading of pylab to pollute the user's
  2991|         0|            0|            0|  0.00%|        # namespace as shown by the %who* magics, so we execute the activation
  2992|         0|            0|            0|  0.00%|        # code in an empty namespace, and we update *both* user_ns and
  2993|         0|            0|            0|  0.00%|        # user_ns_hidden with this information.
  2994|         0|            0|            0|  0.00%|        ns = {}
  2995|         0|            0|            0|  0.00%|        import_pylab(ns, import_all)
  2996|         0|            0|            0|  0.00%|        # warn about clobbered names
  2997|         0|            0|            0|  0.00%|        ignored = {"__builtins__"}
  2998|         0|            0|            0|  0.00%|        both = set(ns).intersection(self.user_ns).difference(ignored)
  2999|         0|            0|            0|  0.00%|        clobbered = [ name for name in both if self.user_ns[name] is not ns[name] ]
  3000|         0|            0|            0|  0.00%|        self.user_ns.update(ns)
  3001|         0|            0|            0|  0.00%|        self.user_ns_hidden.update(ns)
  3002|         0|            0|            0|  0.00%|        return gui, backend, clobbered
  3003|         0|            0|            0|  0.00%|
  3004|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  3005|         0|            0|            0|  0.00%|    # Utilities
  3006|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  3007|         0|            0|            0|  0.00%|
  3008|         0|            0|            0|  0.00%|    def var_expand(self, cmd, depth=0, formatter=DollarFormatter()):
  3009|         0|            0|            0|  0.00%|        """Expand python variables in a string.
  3010|         0|            0|            0|  0.00%|
  3011|         0|            0|            0|  0.00%|        The depth argument indicates how many frames above the caller should
  3012|         0|            0|            0|  0.00%|        be walked to look for the local namespace where to expand variables.
  3013|         0|            0|            0|  0.00%|
  3014|         0|            0|            0|  0.00%|        The global namespace for expansion is always the user's interactive
  3015|         0|            0|            0|  0.00%|        namespace.
  3016|         0|            0|            0|  0.00%|        """
  3017|         0|            0|            0|  0.00%|        ns = self.user_ns.copy()
  3018|         0|            0|            0|  0.00%|        try:
  3019|         0|            0|            0|  0.00%|            frame = sys._getframe(depth+1)
  3020|         0|            0|            0|  0.00%|        except ValueError:
  3021|         0|            0|            0|  0.00%|            # This is thrown if there aren't that many frames on the stack,
  3022|         0|            0|            0|  0.00%|            # e.g. if a script called run_line_magic() directly.
  3023|         0|            0|            0|  0.00%|            pass
  3024|         0|            0|            0|  0.00%|        else:
  3025|         0|            0|            0|  0.00%|            ns.update(frame.f_locals)
  3026|         0|            0|            0|  0.00%|
  3027|         0|            0|            0|  0.00%|        try:
  3028|         0|            0|            0|  0.00%|            # We have to use .vformat() here, because 'self' is a valid and common
  3029|         0|            0|            0|  0.00%|            # name, and expanding **ns for .format() would make it collide with
  3030|         0|            0|            0|  0.00%|            # the 'self' argument of the method.
  3031|         0|            0|            0|  0.00%|            cmd = formatter.vformat(cmd, args=[], kwargs=ns)
  3032|         0|            0|            0|  0.00%|        except Exception:
  3033|         0|            0|            0|  0.00%|            # if formatter couldn't format, just let it go untransformed
  3034|         0|            0|            0|  0.00%|            pass
  3035|         0|            0|            0|  0.00%|        return cmd
  3036|         0|            0|            0|  0.00%|
  3037|         0|            0|            0|  0.00%|    def mktempfile(self, data=None, prefix='ipython_edit_'):
  3038|         0|            0|            0|  0.00%|        """Make a new tempfile and return its filename.
  3039|         0|            0|            0|  0.00%|
  3040|         0|            0|            0|  0.00%|        This makes a call to tempfile.mkstemp (created in a tempfile.mkdtemp),
  3041|         0|            0|            0|  0.00%|        but it registers the created filename internally so ipython cleans it up
  3042|         0|            0|            0|  0.00%|        at exit time.
  3043|         0|            0|            0|  0.00%|
  3044|         0|            0|            0|  0.00%|        Optional inputs:
  3045|         0|            0|            0|  0.00%|
  3046|         0|            0|            0|  0.00%|          - data(None): if data is given, it gets written out to the temp file
  3047|         0|            0|            0|  0.00%|            immediately, and the file is closed again."""
  3048|         0|            0|            0|  0.00%|
  3049|         0|            0|            0|  0.00%|        dirname = tempfile.mkdtemp(prefix=prefix)
  3050|         0|            0|            0|  0.00%|        self.tempdirs.append(dirname)
  3051|         0|            0|            0|  0.00%|
  3052|         0|            0|            0|  0.00%|        handle, filename = tempfile.mkstemp('.py', prefix, dir=dirname)
  3053|         0|            0|            0|  0.00%|        os.close(handle)  # On Windows, there can only be one open handle on a file
  3054|         0|            0|            0|  0.00%|        self.tempfiles.append(filename)
  3055|         0|            0|            0|  0.00%|
  3056|         0|            0|            0|  0.00%|        if data:
  3057|         0|            0|            0|  0.00%|            tmp_file = open(filename,'w')
  3058|         0|            0|            0|  0.00%|            tmp_file.write(data)
  3059|         0|            0|            0|  0.00%|            tmp_file.close()
  3060|         0|            0|            0|  0.00%|        return filename
  3061|         0|            0|            0|  0.00%|
  3062|         0|            0|            0|  0.00%|    @undoc
  3063|         0|            0|            0|  0.00%|    def write(self,data):
  3064|         0|            0|            0|  0.00%|        """DEPRECATED: Write a string to the default output"""
  3065|         0|            0|            0|  0.00%|        warn('InteractiveShell.write() is deprecated, use sys.stdout instead',
  3066|         0|            0|            0|  0.00%|             DeprecationWarning, stacklevel=2)
  3067|         0|            0|            0|  0.00%|        sys.stdout.write(data)
  3068|         0|            0|            0|  0.00%|
  3069|         0|            0|            0|  0.00%|    @undoc
  3070|         0|            0|            0|  0.00%|    def write_err(self,data):
  3071|         0|            0|            0|  0.00%|        """DEPRECATED: Write a string to the default error output"""
  3072|         0|            0|            0|  0.00%|        warn('InteractiveShell.write_err() is deprecated, use sys.stderr instead',
  3073|         0|            0|            0|  0.00%|             DeprecationWarning, stacklevel=2)
  3074|         0|            0|            0|  0.00%|        sys.stderr.write(data)
  3075|         0|            0|            0|  0.00%|
  3076|         0|            0|            0|  0.00%|    def ask_yes_no(self, prompt, default=None, interrupt=None):
  3077|         0|            0|            0|  0.00%|        if self.quiet:
  3078|         0|            0|            0|  0.00%|            return True
  3079|         0|            0|            0|  0.00%|        return ask_yes_no(prompt,default,interrupt)
  3080|         0|            0|            0|  0.00%|
  3081|         0|            0|            0|  0.00%|    def show_usage(self):
  3082|         0|            0|            0|  0.00%|        """Show a usage message"""
  3083|         0|            0|            0|  0.00%|        page.page(IPython.core.usage.interactive_usage)
  3084|         0|            0|            0|  0.00%|
  3085|         0|            0|            0|  0.00%|    def extract_input_lines(self, range_str, raw=False):
  3086|         0|            0|            0|  0.00%|        """Return as a string a set of input history slices.
  3087|         0|            0|            0|  0.00%|
  3088|         0|            0|            0|  0.00%|        Parameters
  3089|         0|            0|            0|  0.00%|        ----------
  3090|         0|            0|            0|  0.00%|        range_str : string
  3091|         0|            0|            0|  0.00%|            The set of slices is given as a string, like "~5/6-~4/2 4:8 9",
  3092|         0|            0|            0|  0.00%|            since this function is for use by magic functions which get their
  3093|         0|            0|            0|  0.00%|            arguments as strings. The number before the / is the session
  3094|         0|            0|            0|  0.00%|            number: ~n goes n back from the current session.
  3095|         0|            0|            0|  0.00%|
  3096|         0|            0|            0|  0.00%|        raw : bool, optional
  3097|         0|            0|            0|  0.00%|            By default, the processed input is used.  If this is true, the raw
  3098|         0|            0|            0|  0.00%|            input history is used instead.
  3099|         0|            0|            0|  0.00%|
  3100|         0|            0|            0|  0.00%|        Notes
  3101|         0|            0|            0|  0.00%|        -----
  3102|         0|            0|            0|  0.00%|
  3103|         0|            0|            0|  0.00%|        Slices can be described with two notations:
  3104|         0|            0|            0|  0.00%|
  3105|         0|            0|            0|  0.00%|        * ``N:M`` -> standard python form, means including items N...(M-1).
  3106|         0|            0|            0|  0.00%|        * ``N-M`` -> include items N..M (closed endpoint).
  3107|         0|            0|            0|  0.00%|        """
  3108|         0|            0|            0|  0.00%|        lines = self.history_manager.get_range_by_str(range_str, raw=raw)
  3109|         0|            0|            0|  0.00%|        return "\n".join(x for _, _, x in lines)
  3110|         0|            0|            0|  0.00%|
  3111|         0|            0|            0|  0.00%|    def find_user_code(self, target, raw=True, py_only=False, skip_encoding_cookie=True, search_ns=False):
  3112|         0|            0|            0|  0.00%|        """Get a code string from history, file, url, or a string or macro.
  3113|         0|            0|            0|  0.00%|
  3114|         0|            0|            0|  0.00%|        This is mainly used by magic functions.
  3115|         0|            0|            0|  0.00%|
  3116|         0|            0|            0|  0.00%|        Parameters
  3117|         0|            0|            0|  0.00%|        ----------
  3118|         0|            0|            0|  0.00%|
  3119|         0|            0|            0|  0.00%|        target : str
  3120|         0|            0|            0|  0.00%|
  3121|         0|            0|            0|  0.00%|          A string specifying code to retrieve. This will be tried respectively
  3122|         0|            0|            0|  0.00%|          as: ranges of input history (see %history for syntax), url,
  3123|         0|            0|            0|  0.00%|          corresponding .py file, filename, or an expression evaluating to a
  3124|         0|            0|            0|  0.00%|          string or Macro in the user namespace.
  3125|         0|            0|            0|  0.00%|
  3126|         0|            0|            0|  0.00%|        raw : bool
  3127|         0|            0|            0|  0.00%|          If true (default), retrieve raw history. Has no effect on the other
  3128|         0|            0|            0|  0.00%|          retrieval mechanisms.
  3129|         0|            0|            0|  0.00%|
  3130|         0|            0|            0|  0.00%|        py_only : bool (default False)
  3131|         0|            0|            0|  0.00%|          Only try to fetch python code, do not try alternative methods to decode file
  3132|         0|            0|            0|  0.00%|          if unicode fails.
  3133|         0|            0|            0|  0.00%|
  3134|         0|            0|            0|  0.00%|        Returns
  3135|         0|            0|            0|  0.00%|        -------
  3136|         0|            0|            0|  0.00%|        A string of code.
  3137|         0|            0|            0|  0.00%|
  3138|         0|            0|            0|  0.00%|        ValueError is raised if nothing is found, and TypeError if it evaluates
  3139|         0|            0|            0|  0.00%|        to an object of another type. In each case, .args[0] is a printable
  3140|         0|            0|            0|  0.00%|        message.
  3141|         0|            0|            0|  0.00%|        """
  3142|         0|            0|            0|  0.00%|        code = self.extract_input_lines(target, raw=raw)  # Grab history
  3143|         0|            0|            0|  0.00%|        if code:
  3144|         0|            0|            0|  0.00%|            return code
  3145|         0|            0|            0|  0.00%|        try:
  3146|         0|            0|            0|  0.00%|            if target.startswith(('http://', 'https://')):
  3147|         0|            0|            0|  0.00%|                return openpy.read_py_url(target, skip_encoding_cookie=skip_encoding_cookie)
  3148|         0|            0|            0|  0.00%|        except UnicodeDecodeError:
  3149|         0|            0|            0|  0.00%|            if not py_only :
  3150|         0|            0|            0|  0.00%|                # Deferred import
  3151|         0|            0|            0|  0.00%|                try:
  3152|         0|            0|            0|  0.00%|                    from urllib.request import urlopen  # Py3
  3153|         0|            0|            0|  0.00%|                except ImportError:
  3154|         0|            0|            0|  0.00%|                    from urllib import urlopen
  3155|         0|            0|            0|  0.00%|                response = urlopen(target)
  3156|         0|            0|            0|  0.00%|                return response.read().decode('latin1')
  3157|         0|            0|            0|  0.00%|            raise ValueError(("'%s' seem to be unreadable.") % target)
  3158|         0|            0|            0|  0.00%|
  3159|         0|            0|            0|  0.00%|        potential_target = [target]
  3160|         0|            0|            0|  0.00%|        try :
  3161|         0|            0|            0|  0.00%|            potential_target.insert(0,get_py_filename(target))
  3162|         0|            0|            0|  0.00%|        except IOError:
  3163|         0|            0|            0|  0.00%|            pass
  3164|         0|            0|            0|  0.00%|
  3165|         0|            0|            0|  0.00%|        for tgt in potential_target :
  3166|         0|            0|            0|  0.00%|            if os.path.isfile(tgt):                        # Read file
  3167|         0|            0|            0|  0.00%|                try :
  3168|         0|            0|            0|  0.00%|                    return openpy.read_py_file(tgt, skip_encoding_cookie=skip_encoding_cookie)
  3169|         0|            0|            0|  0.00%|                except UnicodeDecodeError :
  3170|         0|            0|            0|  0.00%|                    if not py_only :
  3171|         0|            0|            0|  0.00%|                        with io_open(tgt,'r', encoding='latin1') as f :
  3172|         0|            0|            0|  0.00%|                            return f.read()
  3173|         0|            0|            0|  0.00%|                    raise ValueError(("'%s' seem to be unreadable.") % target)
  3174|         0|            0|            0|  0.00%|            elif os.path.isdir(os.path.expanduser(tgt)):
  3175|         0|            0|            0|  0.00%|                raise ValueError("'%s' is a directory, not a regular file." % target)
  3176|         0|            0|            0|  0.00%|
  3177|         0|            0|            0|  0.00%|        if search_ns:
  3178|         0|            0|            0|  0.00%|            # Inspect namespace to load object source
  3179|         0|            0|            0|  0.00%|            object_info = self.object_inspect(target, detail_level=1)
  3180|         0|            0|            0|  0.00%|            if object_info['found'] and object_info['source']:
  3181|         0|            0|            0|  0.00%|                return object_info['source']
  3182|         0|            0|            0|  0.00%|
  3183|         0|            0|            0|  0.00%|        try:                                              # User namespace
  3184|         0|            0|            0|  0.00%|            codeobj = eval(target, self.user_ns)
  3185|         0|            0|            0|  0.00%|        except Exception:
  3186|         0|            0|            0|  0.00%|            raise ValueError(("'%s' was not found in history, as a file, url, "
  3187|         0|            0|            0|  0.00%|                                "nor in the user namespace.") % target)
  3188|         0|            0|            0|  0.00%|
  3189|         0|            0|            0|  0.00%|        if isinstance(codeobj, string_types):
  3190|         0|            0|            0|  0.00%|            return codeobj
  3191|         0|            0|            0|  0.00%|        elif isinstance(codeobj, Macro):
  3192|         0|            0|            0|  0.00%|            return codeobj.value
  3193|         0|            0|            0|  0.00%|
  3194|         0|            0|            0|  0.00%|        raise TypeError("%s is neither a string nor a macro." % target,
  3195|         0|            0|            0|  0.00%|                        codeobj)
  3196|         0|            0|            0|  0.00%|
  3197|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  3198|         0|            0|            0|  0.00%|    # Things related to IPython exiting
  3199|         0|            0|            0|  0.00%|    #-------------------------------------------------------------------------
  3200|         0|            0|            0|  0.00%|    def atexit_operations(self):
  3201|         0|            0|            0|  0.00%|        """This will be executed at the time of exit.
  3202|         0|            0|            0|  0.00%|
  3203|         0|            0|            0|  0.00%|        Cleanup operations and saving of persistent data that is done
  3204|         0|            0|            0|  0.00%|        unconditionally by IPython should be performed here.
  3205|         0|            0|            0|  0.00%|
  3206|         0|            0|            0|  0.00%|        For things that may depend on startup flags or platform specifics (such
  3207|         0|            0|            0|  0.00%|        as having readline or not), register a separate atexit function in the
  3208|         0|            0|            0|  0.00%|        code that has the appropriate information, rather than trying to
  3209|         0|            0|            0|  0.00%|        clutter
  3210|         0|            0|            0|  0.00%|        """
  3211|         0|            0|            0|  0.00%|        # Close the history session (this stores the end time and line count)
  3212|         0|            0|            0|  0.00%|        # this must be *before* the tempfile cleanup, in case of temporary
  3213|         0|            0|            0|  0.00%|        # history db
  3214|         0|            0|            0|  0.00%|        self.history_manager.end_session()
  3215|         0|            0|            0|  0.00%|
  3216|         0|            0|            0|  0.00%|        # Cleanup all tempfiles and folders left around
  3217|         0|            0|            0|  0.00%|        for tfile in self.tempfiles:
  3218|         0|            0|            0|  0.00%|            try:
  3219|         0|            0|            0|  0.00%|                os.unlink(tfile)
  3220|         0|            0|            0|  0.00%|            except OSError:
  3221|         0|            0|            0|  0.00%|                pass
  3222|         0|            0|            0|  0.00%|
  3223|         0|            0|            0|  0.00%|        for tdir in self.tempdirs:
  3224|         0|            0|            0|  0.00%|            try:
  3225|         0|            0|            0|  0.00%|                os.rmdir(tdir)
  3226|         0|            0|            0|  0.00%|            except OSError:
  3227|         0|            0|            0|  0.00%|                pass
  3228|         0|            0|            0|  0.00%|
  3229|         0|            0|            0|  0.00%|        # Clear all user namespaces to release all references cleanly.
  3230|         0|            0|            0|  0.00%|        self.reset(new_session=False)
  3231|         0|            0|            0|  0.00%|
  3232|         0|            0|            0|  0.00%|        # Run user hooks
  3233|         0|            0|            0|  0.00%|        self.hooks.shutdown_hook()
  3234|         0|            0|            0|  0.00%|
  3235|         0|            0|            0|  0.00%|    def cleanup(self):
  3236|         0|            0|            0|  0.00%|        self.restore_sys_module_state()
  3237|         0|            0|            0|  0.00%|
  3238|         0|            0|            0|  0.00%|
  3239|         0|            0|            0|  0.00%|    # Overridden in terminal subclass to change prompts
  3240|         0|            0|            0|  0.00%|    def switch_doctest_mode(self, mode):
  3241|         0|            0|            0|  0.00%|        pass
  3242|         0|            0|            0|  0.00%|
  3243|         0|            0|            0|  0.00%|
  3244|         0|            0|            0|  0.00%|class InteractiveShellABC(with_metaclass(abc.ABCMeta, object)):
  3245|         0|            0|            0|  0.00%|    """An abstract base class for InteractiveShell."""
  3246|         0|            0|            0|  0.00%|
  3247|         0|            0|            0|  0.00%|InteractiveShellABC.register(InteractiveShell)
File: D:\Application\Anaconda\lib\site-packages\pytz\lazy.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from threading import RLock
     2|         0|            0|            0|  0.00%|try:
     3|         0|            0|            0|  0.00%|    from UserDict import DictMixin
     4|         0|            0|            0|  0.00%|except ImportError:
     5|         0|            0|            0|  0.00%|    from collections import Mapping as DictMixin
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|# With lazy loading, we might end up with multiple threads triggering
     9|         0|            0|            0|  0.00%|# it at the same time. We need a lock.
    10|         0|            0|            0|  0.00%|_fill_lock = RLock()
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|class LazyDict(DictMixin):
    14|         0|            0|            0|  0.00%|    """Dictionary populated on first use."""
    15|         0|            0|            0|  0.00%|    data = None
    16|         0|            0|            0|  0.00%|    def __getitem__(self, key):
    17|         0|            0|            0|  0.00%|        if self.data is None:
    18|         0|            0|            0|  0.00%|            _fill_lock.acquire()
    19|         0|            0|            0|  0.00%|            try:
    20|         0|            0|            0|  0.00%|                if self.data is None:
    21|         0|            0|            0|  0.00%|                    self._fill()
    22|         0|            0|            0|  0.00%|            finally:
    23|         0|            0|            0|  0.00%|                _fill_lock.release()
    24|         0|            0|            0|  0.00%|        return self.data[key.upper()]
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|    def __contains__(self, key):
    27|         0|            0|            0|  0.00%|        if self.data is None:
    28|         0|            0|            0|  0.00%|            _fill_lock.acquire()
    29|         0|            0|            0|  0.00%|            try:
    30|         0|            0|            0|  0.00%|                if self.data is None:
    31|         0|            0|            0|  0.00%|                    self._fill()
    32|         0|            0|            0|  0.00%|            finally:
    33|         0|            0|            0|  0.00%|                _fill_lock.release()
    34|         0|            0|            0|  0.00%|        return key in self.data
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|    def __iter__(self):
    37|         0|            0|            0|  0.00%|        if self.data is None:
    38|         0|            0|            0|  0.00%|            _fill_lock.acquire()
    39|         0|            0|            0|  0.00%|            try:
    40|         0|            0|            0|  0.00%|                if self.data is None:
    41|         0|            0|            0|  0.00%|                    self._fill()
    42|         0|            0|            0|  0.00%|            finally:
    43|         0|            0|            0|  0.00%|                _fill_lock.release()
    44|         0|            0|            0|  0.00%|        return iter(self.data)
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|    def __len__(self):
    47|         0|            0|            0|  0.00%|        if self.data is None:
    48|         0|            0|            0|  0.00%|            _fill_lock.acquire()
    49|         0|            0|            0|  0.00%|            try:
    50|         0|            0|            0|  0.00%|                if self.data is None:
    51|         0|            0|            0|  0.00%|                    self._fill()
    52|         0|            0|            0|  0.00%|            finally:
    53|         0|            0|            0|  0.00%|                _fill_lock.release()
    54|         0|            0|            0|  0.00%|        return len(self.data)
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|    def keys(self):
    57|         0|            0|            0|  0.00%|        if self.data is None:
    58|         0|            0|            0|  0.00%|            _fill_lock.acquire()
    59|         0|            0|            0|  0.00%|            try:
    60|         0|            0|            0|  0.00%|                if self.data is None:
    61|         0|            0|            0|  0.00%|                    self._fill()
    62|         0|            0|            0|  0.00%|            finally:
    63|         0|            0|            0|  0.00%|                _fill_lock.release()
    64|         0|            0|            0|  0.00%|        return self.data.keys()
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|class LazyList(list):
    68|         0|            0|            0|  0.00%|    """List populated on first use."""
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|    _props = [
    71|         0|            0|            0|  0.00%|        '__str__', '__repr__', '__unicode__',
    72|         0|            0|            0|  0.00%|        '__hash__', '__sizeof__', '__cmp__',
    73|         0|            0|            0|  0.00%|        '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',
    74|         0|            0|            0|  0.00%|        'append', 'count', 'index', 'extend', 'insert', 'pop', 'remove',
    75|         0|            0|            0|  0.00%|        'reverse', 'sort', '__add__', '__radd__', '__iadd__', '__mul__',
    76|         0|            0|            0|  0.00%|        '__rmul__', '__imul__', '__contains__', '__len__', '__nonzero__',
    77|         0|            0|            0|  0.00%|        '__getitem__', '__setitem__', '__delitem__', '__iter__',
    78|         0|            0|            0|  0.00%|        '__reversed__', '__getslice__', '__setslice__', '__delslice__']
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|    def __new__(cls, fill_iter=None):
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|        if fill_iter is None:
    83|         0|            0|            0|  0.00%|            return list()
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|        # We need a new class as we will be dynamically messing with its
    86|         0|            0|            0|  0.00%|        # methods.
    87|         0|            0|            0|  0.00%|        class LazyList(list):
    88|         0|            0|            0|  0.00%|            pass
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|        fill_iter = [fill_iter]
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|        def lazy(name):
    93|         0|            0|            0|  0.00%|            def _lazy(self, *args, **kw):
    94|         0|            0|            0|  0.00%|                _fill_lock.acquire()
    95|         0|            0|            0|  0.00%|                try:
    96|         0|            0|            0|  0.00%|                    if len(fill_iter) > 0:
    97|         0|            0|            0|  0.00%|                        list.extend(self, fill_iter.pop())
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\pytz\__init__.py:1088 <genexpr>
    98|         0|            0|            0|  0.00%|                        for method_name in cls._props:
    99|         0|            0|            0|  0.00%|                            delattr(LazyList, method_name)
   100|         0|            0|            0|  0.00%|                finally:
   101|         0|            0|            0|  0.00%|                    _fill_lock.release()
   102|         0|            0|            0|  0.00%|                return getattr(list, name)(self, *args, **kw)
   103|         0|            0|            0|  0.00%|            return _lazy
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|        for name in cls._props:
   106|         0|            0|            0|  0.00%|            setattr(LazyList, name, lazy(name))
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|        new_list = LazyList()
   109|         0|            0|            0|  0.00%|        return new_list
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|# Not all versions of Python declare the same magic methods.
   112|         0|            0|            0|  0.00%|# Filter out properties that don't exist in this version of Python
   113|         0|            0|            0|  0.00%|# from the list.
   114|         0|            0|            0|  0.00%|LazyList._props = [prop for prop in LazyList._props if hasattr(list, prop)]
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|class LazySet(set):
   118|         0|            0|            0|  0.00%|    """Set populated on first use."""
   119|         0|            0|            0|  0.00%|
   120|         0|            0|            0|  0.00%|    _props = (
   121|         0|            0|            0|  0.00%|        '__str__', '__repr__', '__unicode__',
   122|         0|            0|            0|  0.00%|        '__hash__', '__sizeof__', '__cmp__',
   123|         0|            0|            0|  0.00%|        '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__',
   124|         0|            0|            0|  0.00%|        '__contains__', '__len__', '__nonzero__',
   125|         0|            0|            0|  0.00%|        '__getitem__', '__setitem__', '__delitem__', '__iter__',
   126|         0|            0|            0|  0.00%|        '__sub__', '__and__', '__xor__', '__or__',
   127|         0|            0|            0|  0.00%|        '__rsub__', '__rand__', '__rxor__', '__ror__',
   128|         0|            0|            0|  0.00%|        '__isub__', '__iand__', '__ixor__', '__ior__',
   129|         0|            0|            0|  0.00%|        'add', 'clear', 'copy', 'difference', 'difference_update',
   130|         0|            0|            0|  0.00%|        'discard', 'intersection', 'intersection_update', 'isdisjoint',
   131|         0|            0|            0|  0.00%|        'issubset', 'issuperset', 'pop', 'remove',
   132|         0|            0|            0|  0.00%|        'symmetric_difference', 'symmetric_difference_update',
   133|         0|            0|            0|  0.00%|        'union', 'update')
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|    def __new__(cls, fill_iter=None):
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|        if fill_iter is None:
   138|         0|            0|            0|  0.00%|            return set()
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|        class LazySet(set):
   141|         0|            0|            0|  0.00%|            pass
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|        fill_iter = [fill_iter]
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|        def lazy(name):
   146|         0|            0|            0|  0.00%|            def _lazy(self, *args, **kw):
   147|         0|            0|            0|  0.00%|                _fill_lock.acquire()
   148|         0|            0|            0|  0.00%|                try:
   149|         0|            0|            0|  0.00%|                    if len(fill_iter) > 0:
   150|         0|            0|            0|  0.00%|                        for i in fill_iter.pop():
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\pytz\lazy.py:93 _lazy
   151|         0|            0|            0|  0.00%|                            set.add(self, i)
   152|         0|            0|            0|  0.00%|                        for method_name in cls._props:
   153|         0|            0|            0|  0.00%|                            delattr(LazySet, method_name)
   154|         0|            0|            0|  0.00%|                finally:
   155|         0|            0|            0|  0.00%|                    _fill_lock.release()
   156|         0|            0|            0|  0.00%|                return getattr(set, name)(self, *args, **kw)
   157|         0|            0|            0|  0.00%|            return _lazy
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|        for name in cls._props:
   160|         0|            0|            0|  0.00%|            setattr(LazySet, name, lazy(name))
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|        new_set = LazySet()
   163|         0|            0|            0|  0.00%|        return new_set
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|# Not all versions of Python declare the same magic methods.
   166|         0|            0|            0|  0.00%|# Filter out properties that don't exist in this version of Python
   167|         0|            0|            0|  0.00%|# from the list.
   168|         0|            0|            0|  0.00%|LazySet._props = [prop for prop in LazySet._props if hasattr(set, prop)]
File: D:\Application\Anaconda\lib\site-packages\tornado\gen.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""``tornado.gen`` is a generator-based interface to make it easier to
     2|         0|            0|            0|  0.00%|work in an asynchronous environment.  Code using the ``gen`` module
     3|         0|            0|            0|  0.00%|is technically asynchronous, but it is written as a single generator
     4|         0|            0|            0|  0.00%|instead of a collection of separate functions.
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|For example, the following asynchronous handler:
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|.. testcode::
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|    class AsyncHandler(RequestHandler):
    11|         0|            0|            0|  0.00%|        @asynchronous
    12|         0|            0|            0|  0.00%|        def get(self):
    13|         0|            0|            0|  0.00%|            http_client = AsyncHTTPClient()
    14|         0|            0|            0|  0.00%|            http_client.fetch("http://example.com",
    15|         0|            0|            0|  0.00%|                              callback=self.on_fetch)
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|        def on_fetch(self, response):
    18|         0|            0|            0|  0.00%|            do_something_with_response(response)
    19|         0|            0|            0|  0.00%|            self.render("template.html")
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|.. testoutput::
    22|         0|            0|            0|  0.00%|   :hide:
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|could be written with ``gen`` as:
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|.. testcode::
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|    class GenAsyncHandler(RequestHandler):
    29|         0|            0|            0|  0.00%|        @gen.coroutine
    30|         0|            0|            0|  0.00%|        def get(self):
    31|         0|            0|            0|  0.00%|            http_client = AsyncHTTPClient()
    32|         0|            0|            0|  0.00%|            response = yield http_client.fetch("http://example.com")
    33|         0|            0|            0|  0.00%|            do_something_with_response(response)
    34|         0|            0|            0|  0.00%|            self.render("template.html")
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|.. testoutput::
    37|         0|            0|            0|  0.00%|   :hide:
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|Most asynchronous functions in Tornado return a `.Future`;
    40|         0|            0|            0|  0.00%|yielding this object returns its `~.Future.result`.
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|You can also yield a list or dict of ``Futures``, which will be
    43|         0|            0|            0|  0.00%|started at the same time and run in parallel; a list or dict of results will
    44|         0|            0|            0|  0.00%|be returned when they are all finished:
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|.. testcode::
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|    @gen.coroutine
    49|         0|            0|            0|  0.00%|    def get(self):
    50|         0|            0|            0|  0.00%|        http_client = AsyncHTTPClient()
    51|         0|            0|            0|  0.00%|        response1, response2 = yield [http_client.fetch(url1),
    52|         0|            0|            0|  0.00%|                                      http_client.fetch(url2)]
    53|         0|            0|            0|  0.00%|        response_dict = yield dict(response3=http_client.fetch(url3),
    54|         0|            0|            0|  0.00%|                                   response4=http_client.fetch(url4))
    55|         0|            0|            0|  0.00%|        response3 = response_dict['response3']
    56|         0|            0|            0|  0.00%|        response4 = response_dict['response4']
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|.. testoutput::
    59|         0|            0|            0|  0.00%|   :hide:
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|If the `~functools.singledispatch` library is available (standard in
    62|         0|            0|            0|  0.00%|Python 3.4, available via the `singledispatch
    63|         0|            0|            0|  0.00%|<https://pypi.python.org/pypi/singledispatch>`_ package on older
    64|         0|            0|            0|  0.00%|versions), additional types of objects may be yielded. Tornado includes
    65|         0|            0|            0|  0.00%|support for ``asyncio.Future`` and Twisted's ``Deferred`` class when
    66|         0|            0|            0|  0.00%|``tornado.platform.asyncio`` and ``tornado.platform.twisted`` are imported.
    67|         0|            0|            0|  0.00%|See the `convert_yielded` function to extend this mechanism.
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|.. versionchanged:: 3.2
    70|         0|            0|            0|  0.00%|   Dict support added.
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|.. versionchanged:: 4.1
    73|         0|            0|            0|  0.00%|   Support added for yielding ``asyncio`` Futures and Twisted Deferreds
    74|         0|            0|            0|  0.00%|   via ``singledispatch``.
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|"""
    77|         0|            0|            0|  0.00%|from __future__ import absolute_import, division, print_function
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|import collections
    80|         0|            0|            0|  0.00%|import functools
    81|         0|            0|            0|  0.00%|import itertools
    82|         0|            0|            0|  0.00%|import os
    83|         0|            0|            0|  0.00%|import sys
    84|         0|            0|            0|  0.00%|import textwrap
    85|         0|            0|            0|  0.00%|import types
    86|         0|            0|            0|  0.00%|import weakref
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|from tornado.concurrent import Future, TracebackFuture, is_future, chain_future
    89|         0|            0|            0|  0.00%|from tornado.ioloop import IOLoop
    90|         0|            0|            0|  0.00%|from tornado.log import app_log
    91|         0|            0|            0|  0.00%|from tornado import stack_context
    92|         0|            0|            0|  0.00%|from tornado.util import PY3, raise_exc_info
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|try:
    95|         0|            0|            0|  0.00%|    try:
    96|         0|            0|            0|  0.00%|        # py34+
    97|         0|            0|            0|  0.00%|        from functools import singledispatch  # type: ignore
    98|         0|            0|            0|  0.00%|    except ImportError:
    99|         0|            0|            0|  0.00%|        from singledispatch import singledispatch  # backport
   100|         0|            0|            0|  0.00%|except ImportError:
   101|         0|            0|            0|  0.00%|    # In most cases, singledispatch is required (to avoid
   102|         0|            0|            0|  0.00%|    # difficult-to-diagnose problems in which the functionality
   103|         0|            0|            0|  0.00%|    # available differs depending on which invisble packages are
   104|         0|            0|            0|  0.00%|    # installed). However, in Google App Engine third-party
   105|         0|            0|            0|  0.00%|    # dependencies are more trouble so we allow this module to be
   106|         0|            0|            0|  0.00%|    # imported without it.
   107|         0|            0|            0|  0.00%|    if 'APPENGINE_RUNTIME' not in os.environ:
   108|         0|            0|            0|  0.00%|        raise
   109|         0|            0|            0|  0.00%|    singledispatch = None
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|try:
   112|         0|            0|            0|  0.00%|    try:
   113|         0|            0|            0|  0.00%|        # py35+
   114|         0|            0|            0|  0.00%|        from collections.abc import Generator as GeneratorType  # type: ignore
   115|         0|            0|            0|  0.00%|    except ImportError:
   116|         0|            0|            0|  0.00%|        from backports_abc import Generator as GeneratorType  # type: ignore
   117|         0|            0|            0|  0.00%|
   118|         0|            0|            0|  0.00%|    try:
   119|         0|            0|            0|  0.00%|        # py35+
   120|         0|            0|            0|  0.00%|        from inspect import isawaitable  # type: ignore
   121|         0|            0|            0|  0.00%|    except ImportError:
   122|         0|            0|            0|  0.00%|        from backports_abc import isawaitable
   123|         0|            0|            0|  0.00%|except ImportError:
   124|         0|            0|            0|  0.00%|    if 'APPENGINE_RUNTIME' not in os.environ:
   125|         0|            0|            0|  0.00%|        raise
   126|         0|            0|            0|  0.00%|    from types import GeneratorType
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|    def isawaitable(x):  # type: ignore
   129|         0|            0|            0|  0.00%|        return False
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|if PY3:
   132|         0|            0|            0|  0.00%|    import builtins
   133|         0|            0|            0|  0.00%|else:
   134|         0|            0|            0|  0.00%|    import __builtin__ as builtins
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|class KeyReuseError(Exception):
   138|         0|            0|            0|  0.00%|    pass
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|class UnknownKeyError(Exception):
   142|         0|            0|            0|  0.00%|    pass
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|class LeakedCallbackError(Exception):
   146|         0|            0|            0|  0.00%|    pass
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|class BadYieldError(Exception):
   150|         0|            0|            0|  0.00%|    pass
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|class ReturnValueIgnoredError(Exception):
   154|         0|            0|            0|  0.00%|    pass
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|class TimeoutError(Exception):
   158|         0|            0|            0|  0.00%|    """Exception raised by ``with_timeout``."""
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|def _value_from_stopiteration(e):
   162|         0|            0|            0|  0.00%|    try:
   163|         0|            0|            0|  0.00%|        # StopIteration has a value attribute beginning in py33.
   164|         0|            0|            0|  0.00%|        # So does our Return class.
   165|         0|            0|            0|  0.00%|        return e.value
   166|         0|            0|            0|  0.00%|    except AttributeError:
   167|         0|            0|            0|  0.00%|        pass
   168|         0|            0|            0|  0.00%|    try:
   169|         0|            0|            0|  0.00%|        # Cython backports coroutine functionality by putting the value in
   170|         0|            0|            0|  0.00%|        # e.args[0].
   171|         0|            0|            0|  0.00%|        return e.args[0]
   172|         0|            0|            0|  0.00%|    except (AttributeError, IndexError):
   173|         0|            0|            0|  0.00%|        return None
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|def engine(func):
   177|         0|            0|            0|  0.00%|    """Callback-oriented decorator for asynchronous generators.
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|    This is an older interface; for new code that does not need to be
   180|         0|            0|            0|  0.00%|    compatible with versions of Tornado older than 3.0 the
   181|         0|            0|            0|  0.00%|    `coroutine` decorator is recommended instead.
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    This decorator is similar to `coroutine`, except it does not
   184|         0|            0|            0|  0.00%|    return a `.Future` and the ``callback`` argument is not treated
   185|         0|            0|            0|  0.00%|    specially.
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|    In most cases, functions decorated with `engine` should take
   188|         0|            0|            0|  0.00%|    a ``callback`` argument and invoke it with their result when
   189|         0|            0|            0|  0.00%|    they are finished.  One notable exception is the
   190|         0|            0|            0|  0.00%|    `~tornado.web.RequestHandler` :ref:`HTTP verb methods <verbs>`,
   191|         0|            0|            0|  0.00%|    which use ``self.finish()`` in place of a callback argument.
   192|         0|            0|            0|  0.00%|    """
   193|         0|            0|            0|  0.00%|    func = _make_coroutine_wrapper(func, replace_callback=False)
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|    @functools.wraps(func)
   196|         0|            0|            0|  0.00%|    def wrapper(*args, **kwargs):
   197|         0|            0|            0|  0.00%|        future = func(*args, **kwargs)
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|        def final_callback(future):
   200|         0|            0|            0|  0.00%|            if future.result() is not None:
   201|         0|            0|            0|  0.00%|                raise ReturnValueIgnoredError(
   202|         0|            0|            0|  0.00%|                    "@gen.engine functions cannot return values: %r" %
   203|         0|            0|            0|  0.00%|                    (future.result(),))
   204|         0|            0|            0|  0.00%|        # The engine interface doesn't give us any way to return
   205|         0|            0|            0|  0.00%|        # errors but to raise them into the stack context.
   206|         0|            0|            0|  0.00%|        # Save the stack context here to use when the Future has resolved.
   207|         0|            0|            0|  0.00%|        future.add_done_callback(stack_context.wrap(final_callback))
   208|         0|            0|            0|  0.00%|    return wrapper
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|def coroutine(func, replace_callback=True):
   212|         0|            0|            0|  0.00%|    """Decorator for asynchronous generators.
   213|         0|            0|            0|  0.00%|
   214|         0|            0|            0|  0.00%|    Any generator that yields objects from this module must be wrapped
   215|         0|            0|            0|  0.00%|    in either this decorator or `engine`.
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|    Coroutines may "return" by raising the special exception
   218|         0|            0|            0|  0.00%|    `Return(value) <Return>`.  In Python 3.3+, it is also possible for
   219|         0|            0|            0|  0.00%|    the function to simply use the ``return value`` statement (prior to
   220|         0|            0|            0|  0.00%|    Python 3.3 generators were not allowed to also return values).
   221|         0|            0|            0|  0.00%|    In all versions of Python a coroutine that simply wishes to exit
   222|         0|            0|            0|  0.00%|    early may use the ``return`` statement without a value.
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|    Functions with this decorator return a `.Future`.  Additionally,
   225|         0|            0|            0|  0.00%|    they may be called with a ``callback`` keyword argument, which
   226|         0|            0|            0|  0.00%|    will be invoked with the future's result when it resolves.  If the
   227|         0|            0|            0|  0.00%|    coroutine fails, the callback will not be run and an exception
   228|         0|            0|            0|  0.00%|    will be raised into the surrounding `.StackContext`.  The
   229|         0|            0|            0|  0.00%|    ``callback`` argument is not visible inside the decorated
   230|         0|            0|            0|  0.00%|    function; it is handled by the decorator itself.
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|    From the caller's perspective, ``@gen.coroutine`` is similar to
   233|         0|            0|            0|  0.00%|    the combination of ``@return_future`` and ``@gen.engine``.
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|    .. warning::
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|       When exceptions occur inside a coroutine, the exception
   238|         0|            0|            0|  0.00%|       information will be stored in the `.Future` object. You must
   239|         0|            0|            0|  0.00%|       examine the result of the `.Future` object, or the exception
   240|         0|            0|            0|  0.00%|       may go unnoticed by your code. This means yielding the function
   241|         0|            0|            0|  0.00%|       if called from another coroutine, using something like
   242|         0|            0|            0|  0.00%|       `.IOLoop.run_sync` for top-level calls, or passing the `.Future`
   243|         0|            0|            0|  0.00%|       to `.IOLoop.add_future`.
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|    """
   246|         0|            0|            0|  0.00%|    return _make_coroutine_wrapper(func, replace_callback=True)
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|# Ties lifetime of runners to their result futures. Github Issue #1769
   250|         0|            0|            0|  0.00%|# Generators, like any object in Python, must be strong referenced
   251|         0|            0|            0|  0.00%|# in order to not be cleaned up by the garbage collector. When using
   252|         0|            0|            0|  0.00%|# coroutines, the Runner object is what strong-refs the inner
   253|         0|            0|            0|  0.00%|# generator. However, the only item that strong-reffed the Runner
   254|         0|            0|            0|  0.00%|# was the last Future that the inner generator yielded (via the
   255|         0|            0|            0|  0.00%|# Future's internal done_callback list). Usually this is enough, but
   256|         0|            0|            0|  0.00%|# it is also possible for this Future to not have any strong references
   257|         0|            0|            0|  0.00%|# other than other objects referenced by the Runner object (usually
   258|         0|            0|            0|  0.00%|# when using other callback patterns and/or weakrefs). In this
   259|         0|            0|            0|  0.00%|# situation, if a garbage collection ran, a cycle would be detected and
   260|         0|            0|            0|  0.00%|# Runner objects could be destroyed along with their inner generators
   261|         0|            0|            0|  0.00%|# and everything in their local scope.
   262|         0|            0|            0|  0.00%|# This map provides strong references to Runner objects as long as
   263|         0|            0|            0|  0.00%|# their result future objects also have strong references (typically
   264|         0|            0|            0|  0.00%|# from the parent coroutine's Runner). This keeps the coroutine's
   265|         0|            0|            0|  0.00%|# Runner alive.
   266|         0|            0|            0|  0.00%|_futures_to_runners = weakref.WeakKeyDictionary()
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|def _make_coroutine_wrapper(func, replace_callback):
   270|         0|            0|            0|  0.00%|    """The inner workings of ``@gen.coroutine`` and ``@gen.engine``.
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|    The two decorators differ in their treatment of the ``callback``
   273|         0|            0|            0|  0.00%|    argument, so we cannot simply implement ``@engine`` in terms of
   274|         0|            0|            0|  0.00%|    ``@coroutine``.
   275|         0|            0|            0|  0.00%|    """
   276|         0|            0|            0|  0.00%|    # On Python 3.5, set the coroutine flag on our generator, to allow it
   277|         0|            0|            0|  0.00%|    # to be used with 'await'.
   278|         0|            0|            0|  0.00%|    wrapped = func
   279|         0|            0|            0|  0.00%|    if hasattr(types, 'coroutine'):
   280|         0|            0|            0|  0.00%|        func = types.coroutine(func)
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|    @functools.wraps(wrapped)
   283|         0|            0|            0|  0.00%|    def wrapper(*args, **kwargs):
   284|         0|            0|            0|  0.00%|        future = TracebackFuture()
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|        if replace_callback and 'callback' in kwargs:
   287|         0|            0|            0|  0.00%|            callback = kwargs.pop('callback')
   288|         0|            0|            0|  0.00%|            IOLoop.current().add_future(
   289|         0|            0|            0|  0.00%|                future, lambda future: callback(future.result()))
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|        try:
   292|         0|            0|            0|  0.00%|            result = func(*args, **kwargs)
   293|         0|            0|            0|  0.00%|        except (Return, StopIteration) as e:
   294|         0|            0|            0|  0.00%|            result = _value_from_stopiteration(e)
   295|         0|            0|            0|  0.00%|        except Exception:
   296|         0|            0|            0|  0.00%|            future.set_exc_info(sys.exc_info())
   297|         0|            0|            0|  0.00%|            return future
   298|         0|            0|            0|  0.00%|        else:
   299|         0|            0|            0|  0.00%|            if isinstance(result, GeneratorType):
   300|         0|            0|            0|  0.00%|                # Inline the first iteration of Runner.run.  This lets us
   301|         0|            0|            0|  0.00%|                # avoid the cost of creating a Runner when the coroutine
   302|         0|            0|            0|  0.00%|                # never actually yields, which in turn allows us to
   303|         0|            0|            0|  0.00%|                # use "optional" coroutines in critical path code without
   304|         0|            0|            0|  0.00%|                # performance penalty for the synchronous case.
   305|         0|            0|            0|  0.00%|                try:
   306|         0|            0|            0|  0.00%|                    orig_stack_contexts = stack_context._state.contexts
   307|         0|            0|            0|  0.00%|                    yielded = next(result)
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\ipykernel\ipkernel.py:256 do_execute
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\ipykernel\kernelbase.py:513 execute_request
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\ipykernel\kernelbase.py:225 dispatch_shell
   308|         0|            0|            0|  0.00%|                    if stack_context._state.contexts is not orig_stack_contexts:
   309|         0|            0|            0|  0.00%|                        yielded = TracebackFuture()
   310|         0|            0|            0|  0.00%|                        yielded.set_exception(
   311|         0|            0|            0|  0.00%|                            stack_context.StackContextInconsistentError(
   312|         0|            0|            0|  0.00%|                                'stack_context inconsistency (probably caused '
   313|         0|            0|            0|  0.00%|                                'by yield within a "with StackContext" block)'))
   314|         0|            0|            0|  0.00%|                except (StopIteration, Return) as e:
   315|         0|            0|            0|  0.00%|                    future.set_result(_value_from_stopiteration(e))
   316|         0|            0|            0|  0.00%|                except Exception:
   317|         0|            0|            0|  0.00%|                    future.set_exc_info(sys.exc_info())
   318|         0|            0|            0|  0.00%|                else:
   319|         0|            0|            0|  0.00%|                    _futures_to_runners[future] = Runner(result, future, yielded)
   320|         0|            0|            0|  0.00%|                yielded = None
   321|         0|            0|            0|  0.00%|                try:
   322|         0|            0|            0|  0.00%|                    return future
   323|         0|            0|            0|  0.00%|                finally:
   324|         0|            0|            0|  0.00%|                    # Subtle memory optimization: if next() raised an exception,
   325|         0|            0|            0|  0.00%|                    # the future's exc_info contains a traceback which
   326|         0|            0|            0|  0.00%|                    # includes this stack frame.  This creates a cycle,
   327|         0|            0|            0|  0.00%|                    # which will be collected at the next full GC but has
   328|         0|            0|            0|  0.00%|                    # been shown to greatly increase memory usage of
   329|         0|            0|            0|  0.00%|                    # benchmarks (relative to the refcount-based scheme
   330|         0|            0|            0|  0.00%|                    # used in the absence of cycles).  We can avoid the
   331|         0|            0|            0|  0.00%|                    # cycle by clearing the local variable after we return it.
   332|         0|            0|            0|  0.00%|                    future = None
   333|         0|            0|            0|  0.00%|        future.set_result(result)
   334|         0|            0|            0|  0.00%|        return future
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|    wrapper.__wrapped__ = wrapped
   337|         0|            0|            0|  0.00%|    wrapper.__tornado_coroutine__ = True
   338|         0|            0|            0|  0.00%|    return wrapper
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|def is_coroutine_function(func):
   342|         0|            0|            0|  0.00%|    """Return whether *func* is a coroutine function, i.e. a function
   343|         0|            0|            0|  0.00%|    wrapped with `~.gen.coroutine`.
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|    .. versionadded:: 4.5
   346|         0|            0|            0|  0.00%|    """
   347|         0|            0|            0|  0.00%|    return getattr(func, '__tornado_coroutine__', False)
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|class Return(Exception):
   351|         0|            0|            0|  0.00%|    """Special exception to return a value from a `coroutine`.
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|    If this exception is raised, its value argument is used as the
   354|         0|            0|            0|  0.00%|    result of the coroutine::
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|        @gen.coroutine
   357|         0|            0|            0|  0.00%|        def fetch_json(url):
   358|         0|            0|            0|  0.00%|            response = yield AsyncHTTPClient().fetch(url)
   359|         0|            0|            0|  0.00%|            raise gen.Return(json_decode(response.body))
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|    In Python 3.3, this exception is no longer necessary: the ``return``
   362|         0|            0|            0|  0.00%|    statement can be used directly to return a value (previously
   363|         0|            0|            0|  0.00%|    ``yield`` and ``return`` with a value could not be combined in the
   364|         0|            0|            0|  0.00%|    same function).
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|    By analogy with the return statement, the value argument is optional,
   367|         0|            0|            0|  0.00%|    but it is never necessary to ``raise gen.Return()``.  The ``return``
   368|         0|            0|            0|  0.00%|    statement can be used with no arguments instead.
   369|         0|            0|            0|  0.00%|    """
   370|         0|            0|            0|  0.00%|    def __init__(self, value=None):
   371|         0|            0|            0|  0.00%|        super(Return, self).__init__()
   372|         0|            0|            0|  0.00%|        self.value = value
   373|         0|            0|            0|  0.00%|        # Cython recognizes subclasses of StopIteration with a .args tuple.
   374|         0|            0|            0|  0.00%|        self.args = (value,)
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|class WaitIterator(object):
   378|         0|            0|            0|  0.00%|    """Provides an iterator to yield the results of futures as they finish.
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|    Yielding a set of futures like this:
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|    ``results = yield [future1, future2]``
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|    pauses the coroutine until both ``future1`` and ``future2``
   385|         0|            0|            0|  0.00%|    return, and then restarts the coroutine with the results of both
   386|         0|            0|            0|  0.00%|    futures. If either future is an exception, the expression will
   387|         0|            0|            0|  0.00%|    raise that exception and all the results will be lost.
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|    If you need to get the result of each future as soon as possible,
   390|         0|            0|            0|  0.00%|    or if you need the result of some futures even if others produce
   391|         0|            0|            0|  0.00%|    errors, you can use ``WaitIterator``::
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|      wait_iterator = gen.WaitIterator(future1, future2)
   394|         0|            0|            0|  0.00%|      while not wait_iterator.done():
   395|         0|            0|            0|  0.00%|          try:
   396|         0|            0|            0|  0.00%|              result = yield wait_iterator.next()
   397|         0|            0|            0|  0.00%|          except Exception as e:
   398|         0|            0|            0|  0.00%|              print("Error {} from {}".format(e, wait_iterator.current_future))
   399|         0|            0|            0|  0.00%|          else:
   400|         0|            0|            0|  0.00%|              print("Result {} received from {} at {}".format(
   401|         0|            0|            0|  0.00%|                  result, wait_iterator.current_future,
   402|         0|            0|            0|  0.00%|                  wait_iterator.current_index))
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|    Because results are returned as soon as they are available the
   405|         0|            0|            0|  0.00%|    output from the iterator *will not be in the same order as the
   406|         0|            0|            0|  0.00%|    input arguments*. If you need to know which future produced the
   407|         0|            0|            0|  0.00%|    current result, you can use the attributes
   408|         0|            0|            0|  0.00%|    ``WaitIterator.current_future``, or ``WaitIterator.current_index``
   409|         0|            0|            0|  0.00%|    to get the index of the future from the input list. (if keyword
   410|         0|            0|            0|  0.00%|    arguments were used in the construction of the `WaitIterator`,
   411|         0|            0|            0|  0.00%|    ``current_index`` will use the corresponding keyword).
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|    On Python 3.5, `WaitIterator` implements the async iterator
   414|         0|            0|            0|  0.00%|    protocol, so it can be used with the ``async for`` statement (note
   415|         0|            0|            0|  0.00%|    that in this version the entire iteration is aborted if any value
   416|         0|            0|            0|  0.00%|    raises an exception, while the previous example can continue past
   417|         0|            0|            0|  0.00%|    individual errors)::
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|      async for result in gen.WaitIterator(future1, future2):
   420|         0|            0|            0|  0.00%|          print("Result {} received from {} at {}".format(
   421|         0|            0|            0|  0.00%|              result, wait_iterator.current_future,
   422|         0|            0|            0|  0.00%|              wait_iterator.current_index))
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|    .. versionadded:: 4.1
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|    .. versionchanged:: 4.3
   427|         0|            0|            0|  0.00%|       Added ``async for`` support in Python 3.5.
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|    """
   430|         0|            0|            0|  0.00%|    def __init__(self, *args, **kwargs):
   431|         0|            0|            0|  0.00%|        if args and kwargs:
   432|         0|            0|            0|  0.00%|            raise ValueError(
   433|         0|            0|            0|  0.00%|                "You must provide args or kwargs, not both")
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|        if kwargs:
   436|         0|            0|            0|  0.00%|            self._unfinished = dict((f, k) for (k, f) in kwargs.items())
   437|         0|            0|            0|  0.00%|            futures = list(kwargs.values())
   438|         0|            0|            0|  0.00%|        else:
   439|         0|            0|            0|  0.00%|            self._unfinished = dict((f, i) for (i, f) in enumerate(args))
   440|         0|            0|            0|  0.00%|            futures = args
   441|         0|            0|            0|  0.00%|
   442|         0|            0|            0|  0.00%|        self._finished = collections.deque()
   443|         0|            0|            0|  0.00%|        self.current_index = self.current_future = None
   444|         0|            0|            0|  0.00%|        self._running_future = None
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|        for future in futures:
   447|         0|            0|            0|  0.00%|            future.add_done_callback(self._done_callback)
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|    def done(self):
   450|         0|            0|            0|  0.00%|        """Returns True if this iterator has no more results."""
   451|         0|            0|            0|  0.00%|        if self._finished or self._unfinished:
   452|         0|            0|            0|  0.00%|            return False
   453|         0|            0|            0|  0.00%|        # Clear the 'current' values when iteration is done.
   454|         0|            0|            0|  0.00%|        self.current_index = self.current_future = None
   455|         0|            0|            0|  0.00%|        return True
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|    def next(self):
   458|         0|            0|            0|  0.00%|        """Returns a `.Future` that will yield the next available result.
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|        Note that this `.Future` will not be the same object as any of
   461|         0|            0|            0|  0.00%|        the inputs.
   462|         0|            0|            0|  0.00%|        """
   463|         0|            0|            0|  0.00%|        self._running_future = TracebackFuture()
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|        if self._finished:
   466|         0|            0|            0|  0.00%|            self._return_result(self._finished.popleft())
   467|         0|            0|            0|  0.00%|
   468|         0|            0|            0|  0.00%|        return self._running_future
   469|         0|            0|            0|  0.00%|
   470|         0|            0|            0|  0.00%|    def _done_callback(self, done):
   471|         0|            0|            0|  0.00%|        if self._running_future and not self._running_future.done():
   472|         0|            0|            0|  0.00%|            self._return_result(done)
   473|         0|            0|            0|  0.00%|        else:
   474|         0|            0|            0|  0.00%|            self._finished.append(done)
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|    def _return_result(self, done):
   477|         0|            0|            0|  0.00%|        """Called set the returned future's state that of the future
   478|         0|            0|            0|  0.00%|        we yielded, and set the current future for the iterator.
   479|         0|            0|            0|  0.00%|        """
   480|         0|            0|            0|  0.00%|        chain_future(done, self._running_future)
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|        self.current_future = done
   483|         0|            0|            0|  0.00%|        self.current_index = self._unfinished.pop(done)
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|    @coroutine
   486|         0|            0|            0|  0.00%|    def __aiter__(self):
   487|         0|            0|            0|  0.00%|        raise Return(self)
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|    def __anext__(self):
   490|         0|            0|            0|  0.00%|        if self.done():
   491|         0|            0|            0|  0.00%|            # Lookup by name to silence pyflakes on older versions.
   492|         0|            0|            0|  0.00%|            raise getattr(builtins, 'StopAsyncIteration')()
   493|         0|            0|            0|  0.00%|        return self.next()
   494|         0|            0|            0|  0.00%|
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|class YieldPoint(object):
   497|         0|            0|            0|  0.00%|    """Base class for objects that may be yielded from the generator.
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|    .. deprecated:: 4.0
   500|         0|            0|            0|  0.00%|       Use `Futures <.Future>` instead.
   501|         0|            0|            0|  0.00%|    """
   502|         0|            0|            0|  0.00%|    def start(self, runner):
   503|         0|            0|            0|  0.00%|        """Called by the runner after the generator has yielded.
   504|         0|            0|            0|  0.00%|
   505|         0|            0|            0|  0.00%|        No other methods will be called on this object before ``start``.
   506|         0|            0|            0|  0.00%|        """
   507|         0|            0|            0|  0.00%|        raise NotImplementedError()
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|    def is_ready(self):
   510|         0|            0|            0|  0.00%|        """Called by the runner to determine whether to resume the generator.
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|        Returns a boolean; may be called more than once.
   513|         0|            0|            0|  0.00%|        """
   514|         0|            0|            0|  0.00%|        raise NotImplementedError()
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|    def get_result(self):
   517|         0|            0|            0|  0.00%|        """Returns the value to use as the result of the yield expression.
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|        This method will only be called once, and only after `is_ready`
   520|         0|            0|            0|  0.00%|        has returned true.
   521|         0|            0|            0|  0.00%|        """
   522|         0|            0|            0|  0.00%|        raise NotImplementedError()
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|class Callback(YieldPoint):
   526|         0|            0|            0|  0.00%|    """Returns a callable object that will allow a matching `Wait` to proceed.
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|    The key may be any value suitable for use as a dictionary key, and is
   529|         0|            0|            0|  0.00%|    used to match ``Callbacks`` to their corresponding ``Waits``.  The key
   530|         0|            0|            0|  0.00%|    must be unique among outstanding callbacks within a single run of the
   531|         0|            0|            0|  0.00%|    generator function, but may be reused across different runs of the same
   532|         0|            0|            0|  0.00%|    function (so constants generally work fine).
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|    The callback may be called with zero or one arguments; if an argument
   535|         0|            0|            0|  0.00%|    is given it will be returned by `Wait`.
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|    .. deprecated:: 4.0
   538|         0|            0|            0|  0.00%|       Use `Futures <.Future>` instead.
   539|         0|            0|            0|  0.00%|    """
   540|         0|            0|            0|  0.00%|    def __init__(self, key):
   541|         0|            0|            0|  0.00%|        self.key = key
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|    def start(self, runner):
   544|         0|            0|            0|  0.00%|        self.runner = runner
   545|         0|            0|            0|  0.00%|        runner.register_callback(self.key)
   546|         0|            0|            0|  0.00%|
   547|         0|            0|            0|  0.00%|    def is_ready(self):
   548|         0|            0|            0|  0.00%|        return True
   549|         0|            0|            0|  0.00%|
   550|         0|            0|            0|  0.00%|    def get_result(self):
   551|         0|            0|            0|  0.00%|        return self.runner.result_callback(self.key)
   552|         0|            0|            0|  0.00%|
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|class Wait(YieldPoint):
   555|         0|            0|            0|  0.00%|    """Returns the argument passed to the result of a previous `Callback`.
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|    .. deprecated:: 4.0
   558|         0|            0|            0|  0.00%|       Use `Futures <.Future>` instead.
   559|         0|            0|            0|  0.00%|    """
   560|         0|            0|            0|  0.00%|    def __init__(self, key):
   561|         0|            0|            0|  0.00%|        self.key = key
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|    def start(self, runner):
   564|         0|            0|            0|  0.00%|        self.runner = runner
   565|         0|            0|            0|  0.00%|
   566|         0|            0|            0|  0.00%|    def is_ready(self):
   567|         0|            0|            0|  0.00%|        return self.runner.is_ready(self.key)
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|    def get_result(self):
   570|         0|            0|            0|  0.00%|        return self.runner.pop_result(self.key)
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|
   573|         0|            0|            0|  0.00%|class WaitAll(YieldPoint):
   574|         0|            0|            0|  0.00%|    """Returns the results of multiple previous `Callbacks <Callback>`.
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|    The argument is a sequence of `Callback` keys, and the result is
   577|         0|            0|            0|  0.00%|    a list of results in the same order.
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|    `WaitAll` is equivalent to yielding a list of `Wait` objects.
   580|         0|            0|            0|  0.00%|
   581|         0|            0|            0|  0.00%|    .. deprecated:: 4.0
   582|         0|            0|            0|  0.00%|       Use `Futures <.Future>` instead.
   583|         0|            0|            0|  0.00%|    """
   584|         0|            0|            0|  0.00%|    def __init__(self, keys):
   585|         0|            0|            0|  0.00%|        self.keys = keys
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|    def start(self, runner):
   588|         0|            0|            0|  0.00%|        self.runner = runner
   589|         0|            0|            0|  0.00%|
   590|         0|            0|            0|  0.00%|    def is_ready(self):
   591|         0|            0|            0|  0.00%|        return all(self.runner.is_ready(key) for key in self.keys)
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|    def get_result(self):
   594|         0|            0|            0|  0.00%|        return [self.runner.pop_result(key) for key in self.keys]
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|def Task(func, *args, **kwargs):
   598|         0|            0|            0|  0.00%|    """Adapts a callback-based asynchronous function for use in coroutines.
   599|         0|            0|            0|  0.00%|
   600|         0|            0|            0|  0.00%|    Takes a function (and optional additional arguments) and runs it with
   601|         0|            0|            0|  0.00%|    those arguments plus a ``callback`` keyword argument.  The argument passed
   602|         0|            0|            0|  0.00%|    to the callback is returned as the result of the yield expression.
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|    .. versionchanged:: 4.0
   605|         0|            0|            0|  0.00%|       ``gen.Task`` is now a function that returns a `.Future`, instead of
   606|         0|            0|            0|  0.00%|       a subclass of `YieldPoint`.  It still behaves the same way when
   607|         0|            0|            0|  0.00%|       yielded.
   608|         0|            0|            0|  0.00%|    """
   609|         0|            0|            0|  0.00%|    future = Future()
   610|         0|            0|            0|  0.00%|
   611|         0|            0|            0|  0.00%|    def handle_exception(typ, value, tb):
   612|         0|            0|            0|  0.00%|        if future.done():
   613|         0|            0|            0|  0.00%|            return False
   614|         0|            0|            0|  0.00%|        future.set_exc_info((typ, value, tb))
   615|         0|            0|            0|  0.00%|        return True
   616|         0|            0|            0|  0.00%|
   617|         0|            0|            0|  0.00%|    def set_result(result):
   618|         0|            0|            0|  0.00%|        if future.done():
   619|         0|            0|            0|  0.00%|            return
   620|         0|            0|            0|  0.00%|        future.set_result(result)
   621|         0|            0|            0|  0.00%|    with stack_context.ExceptionStackContext(handle_exception):
   622|         0|            0|            0|  0.00%|        func(*args, callback=_argument_adapter(set_result), **kwargs)
   623|         0|            0|            0|  0.00%|    return future
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|class YieldFuture(YieldPoint):
   627|         0|            0|            0|  0.00%|    def __init__(self, future, io_loop=None):
   628|         0|            0|            0|  0.00%|        """Adapts a `.Future` to the `YieldPoint` interface.
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|        .. versionchanged:: 4.1
   631|         0|            0|            0|  0.00%|           The ``io_loop`` argument is deprecated.
   632|         0|            0|            0|  0.00%|        """
   633|         0|            0|            0|  0.00%|        self.future = future
   634|         0|            0|            0|  0.00%|        self.io_loop = io_loop or IOLoop.current()
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|    def start(self, runner):
   637|         0|            0|            0|  0.00%|        if not self.future.done():
   638|         0|            0|            0|  0.00%|            self.runner = runner
   639|         0|            0|            0|  0.00%|            self.key = object()
   640|         0|            0|            0|  0.00%|            runner.register_callback(self.key)
   641|         0|            0|            0|  0.00%|            self.io_loop.add_future(self.future, runner.result_callback(self.key))
   642|         0|            0|            0|  0.00%|        else:
   643|         0|            0|            0|  0.00%|            self.runner = None
   644|         0|            0|            0|  0.00%|            self.result_fn = self.future.result
   645|         0|            0|            0|  0.00%|
   646|         0|            0|            0|  0.00%|    def is_ready(self):
   647|         0|            0|            0|  0.00%|        if self.runner is not None:
   648|         0|            0|            0|  0.00%|            return self.runner.is_ready(self.key)
   649|         0|            0|            0|  0.00%|        else:
   650|         0|            0|            0|  0.00%|            return True
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|    def get_result(self):
   653|         0|            0|            0|  0.00%|        if self.runner is not None:
   654|         0|            0|            0|  0.00%|            return self.runner.pop_result(self.key).result()
   655|         0|            0|            0|  0.00%|        else:
   656|         0|            0|            0|  0.00%|            return self.result_fn()
   657|         0|            0|            0|  0.00%|
   658|         0|            0|            0|  0.00%|
   659|         0|            0|            0|  0.00%|def _contains_yieldpoint(children):
   660|         0|            0|            0|  0.00%|    """Returns True if ``children`` contains any YieldPoints.
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|    ``children`` may be a dict or a list, as used by `MultiYieldPoint`
   663|         0|            0|            0|  0.00%|    and `multi_future`.
   664|         0|            0|            0|  0.00%|    """
   665|         0|            0|            0|  0.00%|    if isinstance(children, dict):
   666|         0|            0|            0|  0.00%|        return any(isinstance(i, YieldPoint) for i in children.values())
   667|         0|            0|            0|  0.00%|    if isinstance(children, list):
   668|         0|            0|            0|  0.00%|        return any(isinstance(i, YieldPoint) for i in children)
   669|         0|            0|            0|  0.00%|    return False
   670|         0|            0|            0|  0.00%|
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|def multi(children, quiet_exceptions=()):
   673|         0|            0|            0|  0.00%|    """Runs multiple asynchronous operations in parallel.
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|    ``children`` may either be a list or a dict whose values are
   676|         0|            0|            0|  0.00%|    yieldable objects. ``multi()`` returns a new yieldable
   677|         0|            0|            0|  0.00%|    object that resolves to a parallel structure containing their
   678|         0|            0|            0|  0.00%|    results. If ``children`` is a list, the result is a list of
   679|         0|            0|            0|  0.00%|    results in the same order; if it is a dict, the result is a dict
   680|         0|            0|            0|  0.00%|    with the same keys.
   681|         0|            0|            0|  0.00%|
   682|         0|            0|            0|  0.00%|    That is, ``results = yield multi(list_of_futures)`` is equivalent
   683|         0|            0|            0|  0.00%|    to::
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|        results = []
   686|         0|            0|            0|  0.00%|        for future in list_of_futures:
   687|         0|            0|            0|  0.00%|            results.append(yield future)
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|    If any children raise exceptions, ``multi()`` will raise the first
   690|         0|            0|            0|  0.00%|    one. All others will be logged, unless they are of types
   691|         0|            0|            0|  0.00%|    contained in the ``quiet_exceptions`` argument.
   692|         0|            0|            0|  0.00%|
   693|         0|            0|            0|  0.00%|    If any of the inputs are `YieldPoints <YieldPoint>`, the returned
   694|         0|            0|            0|  0.00%|    yieldable object is a `YieldPoint`. Otherwise, returns a `.Future`.
   695|         0|            0|            0|  0.00%|    This means that the result of `multi` can be used in a native
   696|         0|            0|            0|  0.00%|    coroutine if and only if all of its children can be.
   697|         0|            0|            0|  0.00%|
   698|         0|            0|            0|  0.00%|    In a ``yield``-based coroutine, it is not normally necessary to
   699|         0|            0|            0|  0.00%|    call this function directly, since the coroutine runner will
   700|         0|            0|            0|  0.00%|    do it automatically when a list or dict is yielded. However,
   701|         0|            0|            0|  0.00%|    it is necessary in ``await``-based coroutines, or to pass
   702|         0|            0|            0|  0.00%|    the ``quiet_exceptions`` argument.
   703|         0|            0|            0|  0.00%|
   704|         0|            0|            0|  0.00%|    This function is available under the names ``multi()`` and ``Multi()``
   705|         0|            0|            0|  0.00%|    for historical reasons.
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|    .. versionchanged:: 4.2
   708|         0|            0|            0|  0.00%|       If multiple yieldables fail, any exceptions after the first
   709|         0|            0|            0|  0.00%|       (which is raised) will be logged. Added the ``quiet_exceptions``
   710|         0|            0|            0|  0.00%|       argument to suppress this logging for selected exception types.
   711|         0|            0|            0|  0.00%|
   712|         0|            0|            0|  0.00%|    .. versionchanged:: 4.3
   713|         0|            0|            0|  0.00%|       Replaced the class ``Multi`` and the function ``multi_future``
   714|         0|            0|            0|  0.00%|       with a unified function ``multi``. Added support for yieldables
   715|         0|            0|            0|  0.00%|       other than `YieldPoint` and `.Future`.
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|    """
   718|         0|            0|            0|  0.00%|    if _contains_yieldpoint(children):
   719|         0|            0|            0|  0.00%|        return MultiYieldPoint(children, quiet_exceptions=quiet_exceptions)
   720|         0|            0|            0|  0.00%|    else:
   721|         0|            0|            0|  0.00%|        return multi_future(children, quiet_exceptions=quiet_exceptions)
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|Multi = multi
   725|         0|            0|            0|  0.00%|
   726|         0|            0|            0|  0.00%|
   727|         0|            0|            0|  0.00%|class MultiYieldPoint(YieldPoint):
   728|         0|            0|            0|  0.00%|    """Runs multiple asynchronous operations in parallel.
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|    This class is similar to `multi`, but it always creates a stack
   731|         0|            0|            0|  0.00%|    context even when no children require it. It is not compatible with
   732|         0|            0|            0|  0.00%|    native coroutines.
   733|         0|            0|            0|  0.00%|
   734|         0|            0|            0|  0.00%|    .. versionchanged:: 4.2
   735|         0|            0|            0|  0.00%|       If multiple ``YieldPoints`` fail, any exceptions after the first
   736|         0|            0|            0|  0.00%|       (which is raised) will be logged. Added the ``quiet_exceptions``
   737|         0|            0|            0|  0.00%|       argument to suppress this logging for selected exception types.
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|    .. versionchanged:: 4.3
   740|         0|            0|            0|  0.00%|       Renamed from ``Multi`` to ``MultiYieldPoint``. The name ``Multi``
   741|         0|            0|            0|  0.00%|       remains as an alias for the equivalent `multi` function.
   742|         0|            0|            0|  0.00%|
   743|         0|            0|            0|  0.00%|    .. deprecated:: 4.3
   744|         0|            0|            0|  0.00%|       Use `multi` instead.
   745|         0|            0|            0|  0.00%|    """
   746|         0|            0|            0|  0.00%|    def __init__(self, children, quiet_exceptions=()):
   747|         0|            0|            0|  0.00%|        self.keys = None
   748|         0|            0|            0|  0.00%|        if isinstance(children, dict):
   749|         0|            0|            0|  0.00%|            self.keys = list(children.keys())
   750|         0|            0|            0|  0.00%|            children = children.values()
   751|         0|            0|            0|  0.00%|        self.children = []
   752|         0|            0|            0|  0.00%|        for i in children:
   753|         0|            0|            0|  0.00%|            if not isinstance(i, YieldPoint):
   754|         0|            0|            0|  0.00%|                i = convert_yielded(i)
   755|         0|            0|            0|  0.00%|            if is_future(i):
   756|         0|            0|            0|  0.00%|                i = YieldFuture(i)
   757|         0|            0|            0|  0.00%|            self.children.append(i)
   758|         0|            0|            0|  0.00%|        assert all(isinstance(i, YieldPoint) for i in self.children)
   759|         0|            0|            0|  0.00%|        self.unfinished_children = set(self.children)
   760|         0|            0|            0|  0.00%|        self.quiet_exceptions = quiet_exceptions
   761|         0|            0|            0|  0.00%|
   762|         0|            0|            0|  0.00%|    def start(self, runner):
   763|         0|            0|            0|  0.00%|        for i in self.children:
   764|         0|            0|            0|  0.00%|            i.start(runner)
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|    def is_ready(self):
   767|         0|            0|            0|  0.00%|        finished = list(itertools.takewhile(
   768|         0|            0|            0|  0.00%|            lambda i: i.is_ready(), self.unfinished_children))
   769|         0|            0|            0|  0.00%|        self.unfinished_children.difference_update(finished)
   770|         0|            0|            0|  0.00%|        return not self.unfinished_children
   771|         0|            0|            0|  0.00%|
   772|         0|            0|            0|  0.00%|    def get_result(self):
   773|         0|            0|            0|  0.00%|        result_list = []
   774|         0|            0|            0|  0.00%|        exc_info = None
   775|         0|            0|            0|  0.00%|        for f in self.children:
   776|         0|            0|            0|  0.00%|            try:
   777|         0|            0|            0|  0.00%|                result_list.append(f.get_result())
   778|         0|            0|            0|  0.00%|            except Exception as e:
   779|         0|            0|            0|  0.00%|                if exc_info is None:
   780|         0|            0|            0|  0.00%|                    exc_info = sys.exc_info()
   781|         0|            0|            0|  0.00%|                else:
   782|         0|            0|            0|  0.00%|                    if not isinstance(e, self.quiet_exceptions):
   783|         0|            0|            0|  0.00%|                        app_log.error("Multiple exceptions in yield list",
   784|         0|            0|            0|  0.00%|                                      exc_info=True)
   785|         0|            0|            0|  0.00%|        if exc_info is not None:
   786|         0|            0|            0|  0.00%|            raise_exc_info(exc_info)
   787|         0|            0|            0|  0.00%|        if self.keys is not None:
   788|         0|            0|            0|  0.00%|            return dict(zip(self.keys, result_list))
   789|         0|            0|            0|  0.00%|        else:
   790|         0|            0|            0|  0.00%|            return list(result_list)
   791|         0|            0|            0|  0.00%|
   792|         0|            0|            0|  0.00%|
   793|         0|            0|            0|  0.00%|def multi_future(children, quiet_exceptions=()):
   794|         0|            0|            0|  0.00%|    """Wait for multiple asynchronous futures in parallel.
   795|         0|            0|            0|  0.00%|
   796|         0|            0|            0|  0.00%|    This function is similar to `multi`, but does not support
   797|         0|            0|            0|  0.00%|    `YieldPoints <YieldPoint>`.
   798|         0|            0|            0|  0.00%|
   799|         0|            0|            0|  0.00%|    .. versionadded:: 4.0
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|    .. versionchanged:: 4.2
   802|         0|            0|            0|  0.00%|       If multiple ``Futures`` fail, any exceptions after the first (which is
   803|         0|            0|            0|  0.00%|       raised) will be logged. Added the ``quiet_exceptions``
   804|         0|            0|            0|  0.00%|       argument to suppress this logging for selected exception types.
   805|         0|            0|            0|  0.00%|
   806|         0|            0|            0|  0.00%|    .. deprecated:: 4.3
   807|         0|            0|            0|  0.00%|       Use `multi` instead.
   808|         0|            0|            0|  0.00%|    """
   809|         0|            0|            0|  0.00%|    if isinstance(children, dict):
   810|         0|            0|            0|  0.00%|        keys = list(children.keys())
   811|         0|            0|            0|  0.00%|        children = children.values()
   812|         0|            0|            0|  0.00%|    else:
   813|         0|            0|            0|  0.00%|        keys = None
   814|         0|            0|            0|  0.00%|    children = list(map(convert_yielded, children))
   815|         0|            0|            0|  0.00%|    assert all(is_future(i) for i in children)
   816|         0|            0|            0|  0.00%|    unfinished_children = set(children)
   817|         0|            0|            0|  0.00%|
   818|         0|            0|            0|  0.00%|    future = Future()
   819|         0|            0|            0|  0.00%|    if not children:
   820|         0|            0|            0|  0.00%|        future.set_result({} if keys is not None else [])
   821|         0|            0|            0|  0.00%|
   822|         0|            0|            0|  0.00%|    def callback(f):
   823|         0|            0|            0|  0.00%|        unfinished_children.remove(f)
   824|         0|            0|            0|  0.00%|        if not unfinished_children:
   825|         0|            0|            0|  0.00%|            result_list = []
   826|         0|            0|            0|  0.00%|            for f in children:
   827|         0|            0|            0|  0.00%|                try:
   828|         0|            0|            0|  0.00%|                    result_list.append(f.result())
   829|         0|            0|            0|  0.00%|                except Exception as e:
   830|         0|            0|            0|  0.00%|                    if future.done():
   831|         0|            0|            0|  0.00%|                        if not isinstance(e, quiet_exceptions):
   832|         0|            0|            0|  0.00%|                            app_log.error("Multiple exceptions in yield list",
   833|         0|            0|            0|  0.00%|                                          exc_info=True)
   834|         0|            0|            0|  0.00%|                    else:
   835|         0|            0|            0|  0.00%|                        future.set_exc_info(sys.exc_info())
   836|         0|            0|            0|  0.00%|            if not future.done():
   837|         0|            0|            0|  0.00%|                if keys is not None:
   838|         0|            0|            0|  0.00%|                    future.set_result(dict(zip(keys, result_list)))
   839|         0|            0|            0|  0.00%|                else:
   840|         0|            0|            0|  0.00%|                    future.set_result(result_list)
   841|         0|            0|            0|  0.00%|
   842|         0|            0|            0|  0.00%|    listening = set()
   843|         0|            0|            0|  0.00%|    for f in children:
   844|         0|            0|            0|  0.00%|        if f not in listening:
   845|         0|            0|            0|  0.00%|            listening.add(f)
   846|         0|            0|            0|  0.00%|            f.add_done_callback(callback)
   847|         0|            0|            0|  0.00%|    return future
   848|         0|            0|            0|  0.00%|
   849|         0|            0|            0|  0.00%|
   850|         0|            0|            0|  0.00%|def maybe_future(x):
   851|         0|            0|            0|  0.00%|    """Converts ``x`` into a `.Future`.
   852|         0|            0|            0|  0.00%|
   853|         0|            0|            0|  0.00%|    If ``x`` is already a `.Future`, it is simply returned; otherwise
   854|         0|            0|            0|  0.00%|    it is wrapped in a new `.Future`.  This is suitable for use as
   855|         0|            0|            0|  0.00%|    ``result = yield gen.maybe_future(f())`` when you don't know whether
   856|         0|            0|            0|  0.00%|    ``f()`` returns a `.Future` or not.
   857|         0|            0|            0|  0.00%|
   858|         0|            0|            0|  0.00%|    .. deprecated:: 4.3
   859|         0|            0|            0|  0.00%|       This function only handles ``Futures``, not other yieldable objects.
   860|         0|            0|            0|  0.00%|       Instead of `maybe_future`, check for the non-future result types
   861|         0|            0|            0|  0.00%|       you expect (often just ``None``), and ``yield`` anything unknown.
   862|         0|            0|            0|  0.00%|    """
   863|         0|            0|            0|  0.00%|    if is_future(x):
   864|         0|            0|            0|  0.00%|        return x
   865|         0|            0|            0|  0.00%|    else:
   866|         0|            0|            0|  0.00%|        fut = Future()
   867|         0|            0|            0|  0.00%|        fut.set_result(x)
   868|         0|            0|            0|  0.00%|        return fut
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|
   871|         0|            0|            0|  0.00%|def with_timeout(timeout, future, io_loop=None, quiet_exceptions=()):
   872|         0|            0|            0|  0.00%|    """Wraps a `.Future` (or other yieldable object) in a timeout.
   873|         0|            0|            0|  0.00%|
   874|         0|            0|            0|  0.00%|    Raises `TimeoutError` if the input future does not complete before
   875|         0|            0|            0|  0.00%|    ``timeout``, which may be specified in any form allowed by
   876|         0|            0|            0|  0.00%|    `.IOLoop.add_timeout` (i.e. a `datetime.timedelta` or an absolute time
   877|         0|            0|            0|  0.00%|    relative to `.IOLoop.time`)
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|    If the wrapped `.Future` fails after it has timed out, the exception
   880|         0|            0|            0|  0.00%|    will be logged unless it is of a type contained in ``quiet_exceptions``
   881|         0|            0|            0|  0.00%|    (which may be an exception type or a sequence of types).
   882|         0|            0|            0|  0.00%|
   883|         0|            0|            0|  0.00%|    Does not support `YieldPoint` subclasses.
   884|         0|            0|            0|  0.00%|
   885|         0|            0|            0|  0.00%|    .. versionadded:: 4.0
   886|         0|            0|            0|  0.00%|
   887|         0|            0|            0|  0.00%|    .. versionchanged:: 4.1
   888|         0|            0|            0|  0.00%|       Added the ``quiet_exceptions`` argument and the logging of unhandled
   889|         0|            0|            0|  0.00%|       exceptions.
   890|         0|            0|            0|  0.00%|
   891|         0|            0|            0|  0.00%|    .. versionchanged:: 4.4
   892|         0|            0|            0|  0.00%|       Added support for yieldable objects other than `.Future`.
   893|         0|            0|            0|  0.00%|    """
   894|         0|            0|            0|  0.00%|    # TODO: allow YieldPoints in addition to other yieldables?
   895|         0|            0|            0|  0.00%|    # Tricky to do with stack_context semantics.
   896|         0|            0|            0|  0.00%|    #
   897|         0|            0|            0|  0.00%|    # It's tempting to optimize this by cancelling the input future on timeout
   898|         0|            0|            0|  0.00%|    # instead of creating a new one, but A) we can't know if we are the only
   899|         0|            0|            0|  0.00%|    # one waiting on the input future, so cancelling it might disrupt other
   900|         0|            0|            0|  0.00%|    # callers and B) concurrent futures can only be cancelled while they are
   901|         0|            0|            0|  0.00%|    # in the queue, so cancellation cannot reliably bound our waiting time.
   902|         0|            0|            0|  0.00%|    future = convert_yielded(future)
   903|         0|            0|            0|  0.00%|    result = Future()
   904|         0|            0|            0|  0.00%|    chain_future(future, result)
   905|         0|            0|            0|  0.00%|    if io_loop is None:
   906|         0|            0|            0|  0.00%|        io_loop = IOLoop.current()
   907|         0|            0|            0|  0.00%|
   908|         0|            0|            0|  0.00%|    def error_callback(future):
   909|         0|            0|            0|  0.00%|        try:
   910|         0|            0|            0|  0.00%|            future.result()
   911|         0|            0|            0|  0.00%|        except Exception as e:
   912|         0|            0|            0|  0.00%|            if not isinstance(e, quiet_exceptions):
   913|         0|            0|            0|  0.00%|                app_log.error("Exception in Future %r after timeout",
   914|         0|            0|            0|  0.00%|                              future, exc_info=True)
   915|         0|            0|            0|  0.00%|
   916|         0|            0|            0|  0.00%|    def timeout_callback():
   917|         0|            0|            0|  0.00%|        result.set_exception(TimeoutError("Timeout"))
   918|         0|            0|            0|  0.00%|        # In case the wrapped future goes on to fail, log it.
   919|         0|            0|            0|  0.00%|        future.add_done_callback(error_callback)
   920|         0|            0|            0|  0.00%|    timeout_handle = io_loop.add_timeout(
   921|         0|            0|            0|  0.00%|        timeout, timeout_callback)
   922|         0|            0|            0|  0.00%|    if isinstance(future, Future):
   923|         0|            0|            0|  0.00%|        # We know this future will resolve on the IOLoop, so we don't
   924|         0|            0|            0|  0.00%|        # need the extra thread-safety of IOLoop.add_future (and we also
   925|         0|            0|            0|  0.00%|        # don't care about StackContext here.
   926|         0|            0|            0|  0.00%|        future.add_done_callback(
   927|         0|            0|            0|  0.00%|            lambda future: io_loop.remove_timeout(timeout_handle))
   928|         0|            0|            0|  0.00%|    else:
   929|         0|            0|            0|  0.00%|        # concurrent.futures.Futures may resolve on any thread, so we
   930|         0|            0|            0|  0.00%|        # need to route them back to the IOLoop.
   931|         0|            0|            0|  0.00%|        io_loop.add_future(
   932|         0|            0|            0|  0.00%|            future, lambda future: io_loop.remove_timeout(timeout_handle))
   933|         0|            0|            0|  0.00%|    return result
   934|         0|            0|            0|  0.00%|
   935|         0|            0|            0|  0.00%|
   936|         0|            0|            0|  0.00%|def sleep(duration):
   937|         0|            0|            0|  0.00%|    """Return a `.Future` that resolves after the given number of seconds.
   938|         0|            0|            0|  0.00%|
   939|         0|            0|            0|  0.00%|    When used with ``yield`` in a coroutine, this is a non-blocking
   940|         0|            0|            0|  0.00%|    analogue to `time.sleep` (which should not be used in coroutines
   941|         0|            0|            0|  0.00%|    because it is blocking)::
   942|         0|            0|            0|  0.00%|
   943|         0|            0|            0|  0.00%|        yield gen.sleep(0.5)
   944|         0|            0|            0|  0.00%|
   945|         0|            0|            0|  0.00%|    Note that calling this function on its own does nothing; you must
   946|         0|            0|            0|  0.00%|    wait on the `.Future` it returns (usually by yielding it).
   947|         0|            0|            0|  0.00%|
   948|         0|            0|            0|  0.00%|    .. versionadded:: 4.1
   949|         0|            0|            0|  0.00%|    """
   950|         0|            0|            0|  0.00%|    f = Future()
   951|         0|            0|            0|  0.00%|    IOLoop.current().call_later(duration, lambda: f.set_result(None))
   952|         0|            0|            0|  0.00%|    return f
   953|         0|            0|            0|  0.00%|
   954|         0|            0|            0|  0.00%|
   955|         0|            0|            0|  0.00%|_null_future = Future()
   956|         0|            0|            0|  0.00%|_null_future.set_result(None)
   957|         0|            0|            0|  0.00%|
   958|         0|            0|            0|  0.00%|moment = Future()
   959|         0|            0|            0|  0.00%|moment.__doc__ = \
   960|         0|            0|            0|  0.00%|    """A special object which may be yielded to allow the IOLoop to run for
   961|         0|            0|            0|  0.00%|one iteration.
   962|         0|            0|            0|  0.00%|
   963|         0|            0|            0|  0.00%|This is not needed in normal use but it can be helpful in long-running
   964|         0|            0|            0|  0.00%|coroutines that are likely to yield Futures that are ready instantly.
   965|         0|            0|            0|  0.00%|
   966|         0|            0|            0|  0.00%|Usage: ``yield gen.moment``
   967|         0|            0|            0|  0.00%|
   968|         0|            0|            0|  0.00%|.. versionadded:: 4.0
   969|         0|            0|            0|  0.00%|
   970|         0|            0|            0|  0.00%|.. deprecated:: 4.5
   971|         0|            0|            0|  0.00%|   ``yield None`` is now equivalent to ``yield gen.moment``.
   972|         0|            0|            0|  0.00%|"""
   973|         0|            0|            0|  0.00%|moment.set_result(None)
   974|         0|            0|            0|  0.00%|
   975|         0|            0|            0|  0.00%|
   976|         0|            0|            0|  0.00%|class Runner(object):
   977|         0|            0|            0|  0.00%|    """Internal implementation of `tornado.gen.engine`.
   978|         0|            0|            0|  0.00%|
   979|         0|            0|            0|  0.00%|    Maintains information about pending callbacks and their results.
   980|         0|            0|            0|  0.00%|
   981|         0|            0|            0|  0.00%|    The results of the generator are stored in ``result_future`` (a
   982|         0|            0|            0|  0.00%|    `.TracebackFuture`)
   983|         0|            0|            0|  0.00%|    """
   984|         0|            0|            0|  0.00%|    def __init__(self, gen, result_future, first_yielded):
   985|         0|            0|            0|  0.00%|        self.gen = gen
   986|         0|            0|            0|  0.00%|        self.result_future = result_future
   987|         0|            0|            0|  0.00%|        self.future = _null_future
   988|         0|            0|            0|  0.00%|        self.yield_point = None
   989|         0|            0|            0|  0.00%|        self.pending_callbacks = None
   990|         0|            0|            0|  0.00%|        self.results = None
   991|         0|            0|            0|  0.00%|        self.running = False
   992|         0|            0|            0|  0.00%|        self.finished = False
   993|         0|            0|            0|  0.00%|        self.had_exception = False
   994|         0|            0|            0|  0.00%|        self.io_loop = IOLoop.current()
   995|         0|            0|            0|  0.00%|        # For efficiency, we do not create a stack context until we
   996|         0|            0|            0|  0.00%|        # reach a YieldPoint (stack contexts are required for the historical
   997|         0|            0|            0|  0.00%|        # semantics of YieldPoints, but not for Futures).  When we have
   998|         0|            0|            0|  0.00%|        # done so, this field will be set and must be called at the end
   999|         0|            0|            0|  0.00%|        # of the coroutine.
  1000|         0|            0|            0|  0.00%|        self.stack_context_deactivate = None
  1001|         0|            0|            0|  0.00%|        if self.handle_yield(first_yielded):
  1002|         0|            0|            0|  0.00%|            gen = result_future = first_yielded = None
  1003|         0|            0|            0|  0.00%|            self.run()
  1004|         0|            0|            0|  0.00%|
  1005|         0|            0|            0|  0.00%|    def register_callback(self, key):
  1006|         0|            0|            0|  0.00%|        """Adds ``key`` to the list of callbacks."""
  1007|         0|            0|            0|  0.00%|        if self.pending_callbacks is None:
  1008|         0|            0|            0|  0.00%|            # Lazily initialize the old-style YieldPoint data structures.
  1009|         0|            0|            0|  0.00%|            self.pending_callbacks = set()
  1010|         0|            0|            0|  0.00%|            self.results = {}
  1011|         0|            0|            0|  0.00%|        if key in self.pending_callbacks:
  1012|         0|            0|            0|  0.00%|            raise KeyReuseError("key %r is already pending" % (key,))
  1013|         0|            0|            0|  0.00%|        self.pending_callbacks.add(key)
  1014|         0|            0|            0|  0.00%|
  1015|         0|            0|            0|  0.00%|    def is_ready(self, key):
  1016|         0|            0|            0|  0.00%|        """Returns true if a result is available for ``key``."""
  1017|         0|            0|            0|  0.00%|        if self.pending_callbacks is None or key not in self.pending_callbacks:
  1018|         0|            0|            0|  0.00%|            raise UnknownKeyError("key %r is not pending" % (key,))
  1019|         0|            0|            0|  0.00%|        return key in self.results
  1020|         0|            0|            0|  0.00%|
  1021|         0|            0|            0|  0.00%|    def set_result(self, key, result):
  1022|         0|            0|            0|  0.00%|        """Sets the result for ``key`` and attempts to resume the generator."""
  1023|         0|            0|            0|  0.00%|        self.results[key] = result
  1024|         0|            0|            0|  0.00%|        if self.yield_point is not None and self.yield_point.is_ready():
  1025|         0|            0|            0|  0.00%|            try:
  1026|         0|            0|            0|  0.00%|                self.future.set_result(self.yield_point.get_result())
  1027|         0|            0|            0|  0.00%|            except:
  1028|         0|            0|            0|  0.00%|                self.future.set_exc_info(sys.exc_info())
  1029|         0|            0|            0|  0.00%|            self.yield_point = None
  1030|         0|            0|            0|  0.00%|            self.run()
  1031|         0|            0|            0|  0.00%|
  1032|         0|            0|            0|  0.00%|    def pop_result(self, key):
  1033|         0|            0|            0|  0.00%|        """Returns the result for ``key`` and unregisters it."""
  1034|         0|            0|            0|  0.00%|        self.pending_callbacks.remove(key)
  1035|         0|            0|            0|  0.00%|        return self.results.pop(key)
  1036|         0|            0|            0|  0.00%|
  1037|         0|            0|            0|  0.00%|    def run(self):
  1038|         0|            0|            0|  0.00%|        """Starts or resumes the generator, running until it reaches a
  1039|         0|            0|            0|  0.00%|        yield point that is not ready.
  1040|         0|            0|            0|  0.00%|        """
  1041|         0|            0|            0|  0.00%|        if self.running or self.finished:
  1042|         0|            0|            0|  0.00%|            return
  1043|         0|            0|            0|  0.00%|        try:
  1044|         0|            0|            0|  0.00%|            self.running = True
  1045|         0|            0|            0|  0.00%|            while True:
  1046|         0|            0|            0|  0.00%|                future = self.future
  1047|         0|            0|            0|  0.00%|                if not future.done():
  1048|         0|            0|            0|  0.00%|                    return
  1049|         0|            0|            0|  0.00%|                self.future = None
  1050|         0|            0|            0|  0.00%|                try:
  1051|         0|            0|            0|  0.00%|                    orig_stack_contexts = stack_context._state.contexts
  1052|         0|            0|            0|  0.00%|                    exc_info = None
  1053|         0|            0|            0|  0.00%|
  1054|         0|            0|            0|  0.00%|                    try:
  1055|         0|            0|            0|  0.00%|                        value = future.result()
  1056|         0|            0|            0|  0.00%|                    except Exception:
  1057|         0|            0|            0|  0.00%|                        self.had_exception = True
  1058|         0|            0|            0|  0.00%|                        exc_info = sys.exc_info()
  1059|         0|            0|            0|  0.00%|                    future = None
  1060|         0|            0|            0|  0.00%|
  1061|         0|            0|            0|  0.00%|                    if exc_info is not None:
  1062|         0|            0|            0|  0.00%|                        try:
  1063|         0|            0|            0|  0.00%|                            yielded = self.gen.throw(*exc_info)
  1064|         0|            0|            0|  0.00%|                        finally:
  1065|         0|            0|            0|  0.00%|                            # Break up a reference to itself
  1066|         0|            0|            0|  0.00%|                            # for faster GC on CPython.
  1067|         0|            0|            0|  0.00%|                            exc_info = None
  1068|         0|            0|            0|  0.00%|                    else:
  1069|         0|            0|            0|  0.00%|                        yielded = self.gen.send(value)
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\ipykernel\kernelbase.py:351 process_one
  1070|         0|            0|            0|  0.00%|
  1071|         0|            0|            0|  0.00%|                    if stack_context._state.contexts is not orig_stack_contexts:
  1072|         0|            0|            0|  0.00%|                        self.gen.throw(
  1073|         0|            0|            0|  0.00%|                            stack_context.StackContextInconsistentError(
  1074|         0|            0|            0|  0.00%|                                'stack_context inconsistency (probably caused '
  1075|         0|            0|            0|  0.00%|                                'by yield within a "with StackContext" block)'))
  1076|         0|            0|            0|  0.00%|                except (StopIteration, Return) as e:
  1077|         0|            0|            0|  0.00%|                    self.finished = True
  1078|         0|            0|            0|  0.00%|                    self.future = _null_future
  1079|         0|            0|            0|  0.00%|                    if self.pending_callbacks and not self.had_exception:
  1080|         0|            0|            0|  0.00%|                        # If we ran cleanly without waiting on all callbacks
  1081|         0|            0|            0|  0.00%|                        # raise an error (really more of a warning).  If we
  1082|         0|            0|            0|  0.00%|                        # had an exception then some callbacks may have been
  1083|         0|            0|            0|  0.00%|                        # orphaned, so skip the check in that case.
  1084|         0|            0|            0|  0.00%|                        raise LeakedCallbackError(
  1085|         0|            0|            0|  0.00%|                            "finished without waiting for callbacks %r" %
  1086|         0|            0|            0|  0.00%|                            self.pending_callbacks)
  1087|         0|            0|            0|  0.00%|                    self.result_future.set_result(_value_from_stopiteration(e))
  1088|         0|            0|            0|  0.00%|                    self.result_future = None
  1089|         0|            0|            0|  0.00%|                    self._deactivate_stack_context()
  1090|         0|            0|            0|  0.00%|                    return
  1091|         0|            0|            0|  0.00%|                except Exception:
  1092|         0|            0|            0|  0.00%|                    self.finished = True
  1093|         0|            0|            0|  0.00%|                    self.future = _null_future
  1094|         0|            0|            0|  0.00%|                    self.result_future.set_exc_info(sys.exc_info())
  1095|         0|            0|            0|  0.00%|                    self.result_future = None
  1096|         0|            0|            0|  0.00%|                    self._deactivate_stack_context()
  1097|         0|            0|            0|  0.00%|                    return
  1098|         0|            0|            0|  0.00%|                if not self.handle_yield(yielded):
  1099|         0|            0|            0|  0.00%|                    return
  1100|         0|            0|            0|  0.00%|                yielded = None
  1101|         0|            0|            0|  0.00%|        finally:
  1102|         0|            0|            0|  0.00%|            self.running = False
  1103|         0|            0|            0|  0.00%|
  1104|         0|            0|            0|  0.00%|    def handle_yield(self, yielded):
  1105|         0|            0|            0|  0.00%|        # Lists containing YieldPoints require stack contexts;
  1106|         0|            0|            0|  0.00%|        # other lists are handled in convert_yielded.
  1107|         0|            0|            0|  0.00%|        if _contains_yieldpoint(yielded):
  1108|         0|            0|            0|  0.00%|            yielded = multi(yielded)
  1109|         0|            0|            0|  0.00%|
  1110|         0|            0|            0|  0.00%|        if isinstance(yielded, YieldPoint):
  1111|         0|            0|            0|  0.00%|            # YieldPoints are too closely coupled to the Runner to go
  1112|         0|            0|            0|  0.00%|            # through the generic convert_yielded mechanism.
  1113|         0|            0|            0|  0.00%|            self.future = TracebackFuture()
  1114|         0|            0|            0|  0.00%|
  1115|         0|            0|            0|  0.00%|            def start_yield_point():
  1116|         0|            0|            0|  0.00%|                try:
  1117|         0|            0|            0|  0.00%|                    yielded.start(self)
  1118|         0|            0|            0|  0.00%|                    if yielded.is_ready():
  1119|         0|            0|            0|  0.00%|                        self.future.set_result(
  1120|         0|            0|            0|  0.00%|                            yielded.get_result())
  1121|         0|            0|            0|  0.00%|                    else:
  1122|         0|            0|            0|  0.00%|                        self.yield_point = yielded
  1123|         0|            0|            0|  0.00%|                except Exception:
  1124|         0|            0|            0|  0.00%|                    self.future = TracebackFuture()
  1125|         0|            0|            0|  0.00%|                    self.future.set_exc_info(sys.exc_info())
  1126|         0|            0|            0|  0.00%|
  1127|         0|            0|            0|  0.00%|            if self.stack_context_deactivate is None:
  1128|         0|            0|            0|  0.00%|                # Start a stack context if this is the first
  1129|         0|            0|            0|  0.00%|                # YieldPoint we've seen.
  1130|         0|            0|            0|  0.00%|                with stack_context.ExceptionStackContext(
  1131|         0|            0|            0|  0.00%|                        self.handle_exception) as deactivate:
  1132|         0|            0|            0|  0.00%|                    self.stack_context_deactivate = deactivate
  1133|         0|            0|            0|  0.00%|
  1134|         0|            0|            0|  0.00%|                    def cb():
  1135|         0|            0|            0|  0.00%|                        start_yield_point()
  1136|         0|            0|            0|  0.00%|                        self.run()
  1137|         0|            0|            0|  0.00%|                    self.io_loop.add_callback(cb)
  1138|         0|            0|            0|  0.00%|                    return False
  1139|         0|            0|            0|  0.00%|            else:
  1140|         0|            0|            0|  0.00%|                start_yield_point()
  1141|         0|            0|            0|  0.00%|        else:
  1142|         0|            0|            0|  0.00%|            try:
  1143|         0|            0|            0|  0.00%|                self.future = convert_yielded(yielded)
  1144|         0|            0|            0|  0.00%|            except BadYieldError:
  1145|         0|            0|            0|  0.00%|                self.future = TracebackFuture()
  1146|         0|            0|            0|  0.00%|                self.future.set_exc_info(sys.exc_info())
  1147|         0|            0|            0|  0.00%|
  1148|         0|            0|            0|  0.00%|        if not self.future.done() or self.future is moment:
  1149|         0|            0|            0|  0.00%|            def inner(f):
  1150|         0|            0|            0|  0.00%|                # Break a reference cycle to speed GC.
  1151|         0|            0|            0|  0.00%|                f = None # noqa
  1152|         0|            0|            0|  0.00%|                self.run()
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\tornado\gen.py:1037 run
  1153|         0|            0|            0|  0.00%|            self.io_loop.add_future(
  1154|         0|            0|            0|  0.00%|                self.future, inner)
  1155|         0|            0|            0|  0.00%|            return False
  1156|         0|            0|            0|  0.00%|        return True
  1157|         0|            0|            0|  0.00%|
  1158|         0|            0|            0|  0.00%|    def result_callback(self, key):
  1159|         0|            0|            0|  0.00%|        return stack_context.wrap(_argument_adapter(
  1160|         0|            0|            0|  0.00%|            functools.partial(self.set_result, key)))
  1161|         0|            0|            0|  0.00%|
  1162|         0|            0|            0|  0.00%|    def handle_exception(self, typ, value, tb):
  1163|         0|            0|            0|  0.00%|        if not self.running and not self.finished:
  1164|         0|            0|            0|  0.00%|            self.future = TracebackFuture()
  1165|         0|            0|            0|  0.00%|            self.future.set_exc_info((typ, value, tb))
  1166|         0|            0|            0|  0.00%|            self.run()
  1167|         0|            0|            0|  0.00%|            return True
  1168|         0|            0|            0|  0.00%|        else:
  1169|         0|            0|            0|  0.00%|            return False
  1170|         0|            0|            0|  0.00%|
  1171|         0|            0|            0|  0.00%|    def _deactivate_stack_context(self):
  1172|         0|            0|            0|  0.00%|        if self.stack_context_deactivate is not None:
  1173|         0|            0|            0|  0.00%|            self.stack_context_deactivate()
  1174|         0|            0|            0|  0.00%|            self.stack_context_deactivate = None
  1175|         0|            0|            0|  0.00%|
  1176|         0|            0|            0|  0.00%|
  1177|         0|            0|            0|  0.00%|Arguments = collections.namedtuple('Arguments', ['args', 'kwargs'])
  1178|         0|            0|            0|  0.00%|
  1179|         0|            0|            0|  0.00%|
  1180|         0|            0|            0|  0.00%|def _argument_adapter(callback):
  1181|         0|            0|            0|  0.00%|    """Returns a function that when invoked runs ``callback`` with one arg.
  1182|         0|            0|            0|  0.00%|
  1183|         0|            0|            0|  0.00%|    If the function returned by this function is called with exactly
  1184|         0|            0|            0|  0.00%|    one argument, that argument is passed to ``callback``.  Otherwise
  1185|         0|            0|            0|  0.00%|    the args tuple and kwargs dict are wrapped in an `Arguments` object.
  1186|         0|            0|            0|  0.00%|    """
  1187|         0|            0|            0|  0.00%|    def wrapper(*args, **kwargs):
  1188|         0|            0|            0|  0.00%|        if kwargs or len(args) > 1:
  1189|         0|            0|            0|  0.00%|            callback(Arguments(args, kwargs))
  1190|         0|            0|            0|  0.00%|        elif args:
  1191|         0|            0|            0|  0.00%|            callback(args[0])
  1192|         0|            0|            0|  0.00%|        else:
  1193|         0|            0|            0|  0.00%|            callback(None)
  1194|         0|            0|            0|  0.00%|    return wrapper
  1195|         0|            0|            0|  0.00%|
  1196|         0|            0|            0|  0.00%|
  1197|         0|            0|            0|  0.00%|# Convert Awaitables into Futures. It is unfortunately possible
  1198|         0|            0|            0|  0.00%|# to have infinite recursion here if those Awaitables assume that
  1199|         0|            0|            0|  0.00%|# we're using a different coroutine runner and yield objects
  1200|         0|            0|            0|  0.00%|# we don't understand. If that happens, the solution is to
  1201|         0|            0|            0|  0.00%|# register that runner's yieldable objects with convert_yielded.
  1202|         0|            0|            0|  0.00%|if sys.version_info >= (3, 3):
  1203|         0|            0|            0|  0.00%|    exec(textwrap.dedent("""
  1204|         0|            0|            0|  0.00%|    @coroutine
  1205|         0|            0|            0|  0.00%|    def _wrap_awaitable(x):
  1206|         0|            0|            0|  0.00%|        if hasattr(x, '__await__'):
  1207|         0|            0|            0|  0.00%|            x = x.__await__()
  1208|         0|            0|            0|  0.00%|        return (yield from x)
  1209|         0|            0|            0|  0.00%|    """))
  1210|         0|            0|            0|  0.00%|else:
  1211|         0|            0|            0|  0.00%|    # Py2-compatible version for use with Cython.
  1212|         0|            0|            0|  0.00%|    # Copied from PEP 380.
  1213|         0|            0|            0|  0.00%|    @coroutine
  1214|         0|            0|            0|  0.00%|    def _wrap_awaitable(x):
  1215|         0|            0|            0|  0.00%|        if hasattr(x, '__await__'):
  1216|         0|            0|            0|  0.00%|            _i = x.__await__()
  1217|         0|            0|            0|  0.00%|        else:
  1218|         0|            0|            0|  0.00%|            _i = iter(x)
  1219|         0|            0|            0|  0.00%|        try:
  1220|         0|            0|            0|  0.00%|            _y = next(_i)
  1221|         0|            0|            0|  0.00%|        except StopIteration as _e:
  1222|         0|            0|            0|  0.00%|            _r = _value_from_stopiteration(_e)
  1223|         0|            0|            0|  0.00%|        else:
  1224|         0|            0|            0|  0.00%|            while 1:
  1225|         0|            0|            0|  0.00%|                try:
  1226|         0|            0|            0|  0.00%|                    _s = yield _y
  1227|         0|            0|            0|  0.00%|                except GeneratorExit as _e:
  1228|         0|            0|            0|  0.00%|                    try:
  1229|         0|            0|            0|  0.00%|                        _m = _i.close
  1230|         0|            0|            0|  0.00%|                    except AttributeError:
  1231|         0|            0|            0|  0.00%|                        pass
  1232|         0|            0|            0|  0.00%|                    else:
  1233|         0|            0|            0|  0.00%|                        _m()
  1234|         0|            0|            0|  0.00%|                    raise _e
  1235|         0|            0|            0|  0.00%|                except BaseException as _e:
  1236|         0|            0|            0|  0.00%|                    _x = sys.exc_info()
  1237|         0|            0|            0|  0.00%|                    try:
  1238|         0|            0|            0|  0.00%|                        _m = _i.throw
  1239|         0|            0|            0|  0.00%|                    except AttributeError:
  1240|         0|            0|            0|  0.00%|                        raise _e
  1241|         0|            0|            0|  0.00%|                    else:
  1242|         0|            0|            0|  0.00%|                        try:
  1243|         0|            0|            0|  0.00%|                            _y = _m(*_x)
  1244|         0|            0|            0|  0.00%|                        except StopIteration as _e:
  1245|         0|            0|            0|  0.00%|                            _r = _value_from_stopiteration(_e)
  1246|         0|            0|            0|  0.00%|                            break
  1247|         0|            0|            0|  0.00%|                else:
  1248|         0|            0|            0|  0.00%|                    try:
  1249|         0|            0|            0|  0.00%|                        if _s is None:
  1250|         0|            0|            0|  0.00%|                            _y = next(_i)
  1251|         0|            0|            0|  0.00%|                        else:
  1252|         0|            0|            0|  0.00%|                            _y = _i.send(_s)
  1253|         0|            0|            0|  0.00%|                    except StopIteration as _e:
  1254|         0|            0|            0|  0.00%|                        _r = _value_from_stopiteration(_e)
  1255|         0|            0|            0|  0.00%|                        break
  1256|         0|            0|            0|  0.00%|        raise Return(_r)
  1257|         0|            0|            0|  0.00%|
  1258|         0|            0|            0|  0.00%|
  1259|         0|            0|            0|  0.00%|def convert_yielded(yielded):
  1260|         0|            0|            0|  0.00%|    """Convert a yielded object into a `.Future`.
  1261|         0|            0|            0|  0.00%|
  1262|         0|            0|            0|  0.00%|    The default implementation accepts lists, dictionaries, and Futures.
  1263|         0|            0|            0|  0.00%|
  1264|         0|            0|            0|  0.00%|    If the `~functools.singledispatch` library is available, this function
  1265|         0|            0|            0|  0.00%|    may be extended to support additional types. For example::
  1266|         0|            0|            0|  0.00%|
  1267|         0|            0|            0|  0.00%|        @convert_yielded.register(asyncio.Future)
  1268|         0|            0|            0|  0.00%|        def _(asyncio_future):
  1269|         0|            0|            0|  0.00%|            return tornado.platform.asyncio.to_tornado_future(asyncio_future)
  1270|         0|            0|            0|  0.00%|
  1271|         0|            0|            0|  0.00%|    .. versionadded:: 4.1
  1272|         0|            0|            0|  0.00%|    """
  1273|         0|            0|            0|  0.00%|    # Lists and dicts containing YieldPoints were handled earlier.
  1274|         0|            0|            0|  0.00%|    if yielded is None:
  1275|         0|            0|            0|  0.00%|        return moment
  1276|         0|            0|            0|  0.00%|    elif isinstance(yielded, (list, dict)):
  1277|         0|            0|            0|  0.00%|        return multi(yielded)
  1278|         0|            0|            0|  0.00%|    elif is_future(yielded):
  1279|         0|            0|            0|  0.00%|        return yielded
  1280|         0|            0|            0|  0.00%|    elif isawaitable(yielded):
  1281|         0|            0|            0|  0.00%|        return _wrap_awaitable(yielded)
  1282|         0|            0|            0|  0.00%|    else:
  1283|         0|            0|            0|  0.00%|        raise BadYieldError("yielded unknown object %r" % (yielded,))
  1284|         0|            0|            0|  0.00%|
  1285|         0|            0|            0|  0.00%|
  1286|         0|            0|            0|  0.00%|if singledispatch is not None:
  1287|         0|            0|            0|  0.00%|    convert_yielded = singledispatch(convert_yielded)
  1288|         0|            0|            0|  0.00%|
  1289|         0|            0|            0|  0.00%|    try:
  1290|         0|            0|            0|  0.00%|        # If we can import t.p.asyncio, do it for its side effect
  1291|         0|            0|            0|  0.00%|        # (registering asyncio.Future with convert_yielded).
  1292|         0|            0|            0|  0.00%|        # It's ugly to do this here, but it prevents a cryptic
  1293|         0|            0|            0|  0.00%|        # infinite recursion in _wrap_awaitable.
  1294|         0|            0|            0|  0.00%|        # Note that even with this, asyncio integration is unlikely
  1295|         0|            0|            0|  0.00%|        # to work unless the application also configures AsyncIOLoop,
  1296|         0|            0|            0|  0.00%|        # but at least the error messages in that case are more
  1297|         0|            0|            0|  0.00%|        # comprehensible than a stack overflow.
  1298|         0|            0|            0|  0.00%|        import tornado.platform.asyncio
  1299|         0|            0|            0|  0.00%|    except ImportError:
  1300|         0|            0|            0|  0.00%|        pass
  1301|         0|            0|            0|  0.00%|    else:
  1302|         0|            0|            0|  0.00%|        # Reference the imported module to make pyflakes happy.
  1303|         0|            0|            0|  0.00%|        tornado
File: D:\Application\Anaconda\lib\site-packages\pytz\__init__.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|'''
     2|         0|            0|            0|  0.00%|datetime.tzinfo timezone definitions generated from the
     3|         0|            0|            0|  0.00%|Olson timezone database:
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|    ftp://elsie.nci.nih.gov/pub/tz*.tar.gz
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|See the datetime section of the Python Library Reference for information
     8|         0|            0|            0|  0.00%|on how to use these modules.
     9|         0|            0|            0|  0.00%|'''
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|# The IANA (nee Olson) database is updated several times a year.
    12|         0|            0|            0|  0.00%|OLSON_VERSION = '2017b'
    13|         0|            0|            0|  0.00%|VERSION = '2017.2'  # Switching to pip compatible version numbering.
    14|         0|            0|            0|  0.00%|__version__ = VERSION
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|OLSEN_VERSION = OLSON_VERSION # Old releases had this misspelling
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|__all__ = [
    19|         0|            0|            0|  0.00%|    'timezone', 'utc', 'country_timezones', 'country_names',
    20|         0|            0|            0|  0.00%|    'AmbiguousTimeError', 'InvalidTimeError',
    21|         0|            0|            0|  0.00%|    'NonExistentTimeError', 'UnknownTimeZoneError',
    22|         0|            0|            0|  0.00%|    'all_timezones', 'all_timezones_set',
    23|         0|            0|            0|  0.00%|    'common_timezones', 'common_timezones_set',
    24|         0|            0|            0|  0.00%|    ]
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|import sys, datetime, os.path, gettext
    27|         0|            0|            0|  0.00%|
    28|         0|            0|            0|  0.00%|from pytz.exceptions import AmbiguousTimeError
    29|         0|            0|            0|  0.00%|from pytz.exceptions import InvalidTimeError
    30|         0|            0|            0|  0.00%|from pytz.exceptions import NonExistentTimeError
    31|         0|            0|            0|  0.00%|from pytz.exceptions import UnknownTimeZoneError
    32|         0|            0|            0|  0.00%|from pytz.lazy import LazyDict, LazyList, LazySet
    33|         0|            0|            0|  0.00%|from pytz.tzinfo import unpickler
    34|         0|            0|            0|  0.00%|from pytz.tzfile import build_tzinfo, _byte_string
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|try:
    38|         0|            0|            0|  0.00%|    unicode
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|except NameError: # Python 3.x
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|    # Python 3.x doesn't have unicode(), making writing code
    43|         0|            0|            0|  0.00%|    # for Python 2.3 and Python 3.x a pain.
    44|         0|            0|            0|  0.00%|    unicode = str
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|    def ascii(s):
    47|         0|            0|            0|  0.00%|        r"""
    48|         0|            0|            0|  0.00%|        >>> ascii('Hello')
    49|         0|            0|            0|  0.00%|        'Hello'
    50|         0|            0|            0|  0.00%|        >>> ascii('\N{TRADE MARK SIGN}') #doctest: +IGNORE_EXCEPTION_DETAIL
    51|         0|            0|            0|  0.00%|        Traceback (most recent call last):
    52|         0|            0|            0|  0.00%|            ...
    53|         0|            0|            0|  0.00%|        UnicodeEncodeError: ...
    54|         0|            0|            0|  0.00%|        """
    55|         0|            0|            0|  0.00%|        s.encode('ASCII') # Raise an exception if not ASCII
    56|         0|            0|            0|  0.00%|        return s # But return the original string - not a byte string.
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|else: # Python 2.x
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|    def ascii(s):
    61|         0|            0|            0|  0.00%|        r"""
    62|         0|            0|            0|  0.00%|        >>> ascii('Hello')
    63|         0|            0|            0|  0.00%|        'Hello'
    64|         0|            0|            0|  0.00%|        >>> ascii(u'Hello')
    65|         0|            0|            0|  0.00%|        'Hello'
    66|         0|            0|            0|  0.00%|        >>> ascii(u'\N{TRADE MARK SIGN}') #doctest: +IGNORE_EXCEPTION_DETAIL
    67|         0|            0|            0|  0.00%|        Traceback (most recent call last):
    68|         0|            0|            0|  0.00%|            ...
    69|         0|            0|            0|  0.00%|        UnicodeEncodeError: ...
    70|         0|            0|            0|  0.00%|        """
    71|         0|            0|            0|  0.00%|        return s.encode('ASCII')
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|def open_resource(name):
    75|         0|            0|            0|  0.00%|    """Open a resource from the zoneinfo subdir for reading.
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|    Uses the pkg_resources module if available and no standard file
    78|         0|            0|            0|  0.00%|    found at the calculated location.
    79|         0|            0|            0|  0.00%|    """
    80|         0|            0|            0|  0.00%|    name_parts = name.lstrip('/').split('/')
    81|         0|            0|            0|  0.00%|    for part in name_parts:
    82|         0|            0|            0|  0.00%|        if part == os.path.pardir or os.path.sep in part:
    83|         0|            0|            0|  0.00%|            raise ValueError('Bad path segment: %r' % part)
    84|         0|            0|            0|  0.00%|    filename = os.path.join(os.path.dirname(__file__),
    85|         0|            0|            0|  0.00%|                            'zoneinfo', *name_parts)
    86|         0|            0|            0|  0.00%|    if not os.path.exists(filename):
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\genericpath.py:16 exists
    87|         0|            0|            0|  0.00%|        # http://bugs.launchpad.net/bugs/383171 - we avoid using this
    88|         0|            0|            0|  0.00%|        # unless absolutely necessary to help when a broken version of
    89|         0|            0|            0|  0.00%|        # pkg_resources is installed.
    90|         0|            0|            0|  0.00%|        try:
    91|         0|            0|            0|  0.00%|            from pkg_resources import resource_stream
    92|         0|            0|            0|  0.00%|        except ImportError:
    93|         0|            0|            0|  0.00%|            resource_stream = None
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|        if resource_stream is not None:
    96|         0|            0|            0|  0.00%|            return resource_stream(__name__, 'zoneinfo/' + name)
    97|         0|            0|            0|  0.00%|    return open(filename, 'rb')
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|
   100|         0|            0|            0|  0.00%|def resource_exists(name):
   101|         0|            0|            0|  0.00%|    """Return true if the given resource exists"""
   102|         0|            0|            0|  0.00%|    try:
   103|         0|            0|            0|  0.00%|        open_resource(name).close()
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\pytz\__init__.py:74 open_resource
   104|         0|            0|            0|  0.00%|        return True
   105|         0|            0|            0|  0.00%|    except IOError:
   106|         0|            0|            0|  0.00%|        return False
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|# Enable this when we get some translations?
   110|         0|            0|            0|  0.00%|# We want an i18n API that is useful to programs using Python's gettext
   111|         0|            0|            0|  0.00%|# module, as well as the Zope3 i18n package. Perhaps we should just provide
   112|         0|            0|            0|  0.00%|# the POT file and translations, and leave it up to callers to make use
   113|         0|            0|            0|  0.00%|# of them.
   114|         0|            0|            0|  0.00%|#
   115|         0|            0|            0|  0.00%|# t = gettext.translation(
   116|         0|            0|            0|  0.00%|#         'pytz', os.path.join(os.path.dirname(__file__), 'locales'),
   117|         0|            0|            0|  0.00%|#         fallback=True
   118|         0|            0|            0|  0.00%|#         )
   119|         0|            0|            0|  0.00%|# def _(timezone_name):
   120|         0|            0|            0|  0.00%|#     """Translate a timezone name using the current locale, returning Unicode"""
   121|         0|            0|            0|  0.00%|#     return t.ugettext(timezone_name)
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|_tzinfo_cache = {}
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|def timezone(zone):
   127|         0|            0|            0|  0.00%|    r''' Return a datetime.tzinfo implementation for the given timezone
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|    >>> from datetime import datetime, timedelta
   130|         0|            0|            0|  0.00%|    >>> utc = timezone('UTC')
   131|         0|            0|            0|  0.00%|    >>> eastern = timezone('US/Eastern')
   132|         0|            0|            0|  0.00%|    >>> eastern.zone
   133|         0|            0|            0|  0.00%|    'US/Eastern'
   134|         0|            0|            0|  0.00%|    >>> timezone(unicode('US/Eastern')) is eastern
   135|         0|            0|            0|  0.00%|    True
   136|         0|            0|            0|  0.00%|    >>> utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)
   137|         0|            0|            0|  0.00%|    >>> loc_dt = utc_dt.astimezone(eastern)
   138|         0|            0|            0|  0.00%|    >>> fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'
   139|         0|            0|            0|  0.00%|    >>> loc_dt.strftime(fmt)
   140|         0|            0|            0|  0.00%|    '2002-10-27 01:00:00 EST (-0500)'
   141|         0|            0|            0|  0.00%|    >>> (loc_dt - timedelta(minutes=10)).strftime(fmt)
   142|         0|            0|            0|  0.00%|    '2002-10-27 00:50:00 EST (-0500)'
   143|         0|            0|            0|  0.00%|    >>> eastern.normalize(loc_dt - timedelta(minutes=10)).strftime(fmt)
   144|         0|            0|            0|  0.00%|    '2002-10-27 01:50:00 EDT (-0400)'
   145|         0|            0|            0|  0.00%|    >>> (loc_dt + timedelta(minutes=10)).strftime(fmt)
   146|         0|            0|            0|  0.00%|    '2002-10-27 01:10:00 EST (-0500)'
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|    Raises UnknownTimeZoneError if passed an unknown zone.
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|    >>> try:
   151|         0|            0|            0|  0.00%|    ...     timezone('Asia/Shangri-La')
   152|         0|            0|            0|  0.00%|    ... except UnknownTimeZoneError:
   153|         0|            0|            0|  0.00%|    ...     print('Unknown')
   154|         0|            0|            0|  0.00%|    Unknown
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|    >>> try:
   157|         0|            0|            0|  0.00%|    ...     timezone(unicode('\N{TRADE MARK SIGN}'))
   158|         0|            0|            0|  0.00%|    ... except UnknownTimeZoneError:
   159|         0|            0|            0|  0.00%|    ...     print('Unknown')
   160|         0|            0|            0|  0.00%|    Unknown
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|    '''
   163|         0|            0|            0|  0.00%|    if zone.upper() == 'UTC':
   164|         0|            0|            0|  0.00%|        return utc
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|    try:
   167|         0|            0|            0|  0.00%|        zone = ascii(zone)
   168|         0|            0|            0|  0.00%|    except UnicodeEncodeError:
   169|         0|            0|            0|  0.00%|        # All valid timezones are ASCII
   170|         0|            0|            0|  0.00%|        raise UnknownTimeZoneError(zone)
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|    zone = _unmunge_zone(zone)
   173|         0|            0|            0|  0.00%|    if zone not in _tzinfo_cache:
   174|         0|            0|            0|  0.00%|        if zone in all_timezones_set:
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\pytz\lazy.py:146 _lazy
   175|         0|            0|            0|  0.00%|            fp = open_resource(zone)
   176|         0|            0|            0|  0.00%|            try:
   177|         0|            0|            0|  0.00%|                _tzinfo_cache[zone] = build_tzinfo(zone, fp)
   178|         0|            0|            0|  0.00%|            finally:
   179|         0|            0|            0|  0.00%|                fp.close()
   180|         0|            0|            0|  0.00%|        else:
   181|         0|            0|            0|  0.00%|            raise UnknownTimeZoneError(zone)
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    return _tzinfo_cache[zone]
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|def _unmunge_zone(zone):
   187|         0|            0|            0|  0.00%|    """Undo the time zone name munging done by older versions of pytz."""
   188|         0|            0|            0|  0.00%|    return zone.replace('_plus_', '+').replace('_minus_', '-')
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|ZERO = datetime.timedelta(0)
   192|         0|            0|            0|  0.00%|HOUR = datetime.timedelta(hours=1)
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|class UTC(datetime.tzinfo):
   196|         0|            0|            0|  0.00%|    """UTC
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    Optimized UTC implementation. It unpickles using the single module global
   199|         0|            0|            0|  0.00%|    instance defined beneath this class declaration.
   200|         0|            0|            0|  0.00%|    """
   201|         0|            0|            0|  0.00%|    zone = "UTC"
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|    _utcoffset = ZERO
   204|         0|            0|            0|  0.00%|    _dst = ZERO
   205|         0|            0|            0|  0.00%|    _tzname = zone
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|    def fromutc(self, dt):
   208|         0|            0|            0|  0.00%|        if dt.tzinfo is None:
   209|         0|            0|            0|  0.00%|            return self.localize(dt)
   210|         0|            0|            0|  0.00%|        return super(utc.__class__, self).fromutc(dt)
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|    def utcoffset(self, dt):
   213|         0|            0|            0|  0.00%|        return ZERO
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|    def tzname(self, dt):
   216|         0|            0|            0|  0.00%|        return "UTC"
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|    def dst(self, dt):
   219|         0|            0|            0|  0.00%|        return ZERO
   220|         0|            0|            0|  0.00%|
   221|         0|            0|            0|  0.00%|    def __reduce__(self):
   222|         0|            0|            0|  0.00%|        return _UTC, ()
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|    def localize(self, dt, is_dst=False):
   225|         0|            0|            0|  0.00%|        '''Convert naive time to local time'''
   226|         0|            0|            0|  0.00%|        if dt.tzinfo is not None:
   227|         0|            0|            0|  0.00%|            raise ValueError('Not naive datetime (tzinfo is already set)')
   228|         0|            0|            0|  0.00%|        return dt.replace(tzinfo=self)
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|    def normalize(self, dt, is_dst=False):
   231|         0|            0|            0|  0.00%|        '''Correct the timezone information on the given datetime'''
   232|         0|            0|            0|  0.00%|        if dt.tzinfo is self:
   233|         0|            0|            0|  0.00%|            return dt
   234|         0|            0|            0|  0.00%|        if dt.tzinfo is None:
   235|         0|            0|            0|  0.00%|            raise ValueError('Naive time - no tzinfo set')
   236|         0|            0|            0|  0.00%|        return dt.astimezone(self)
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|    def __repr__(self):
   239|         0|            0|            0|  0.00%|        return "<UTC>"
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|    def __str__(self):
   242|         0|            0|            0|  0.00%|        return "UTC"
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|UTC = utc = UTC()  # UTC is a singleton
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|def _UTC():
   249|         0|            0|            0|  0.00%|    """Factory function for utc unpickling.
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|    Makes sure that unpickling a utc instance always returns the same
   252|         0|            0|            0|  0.00%|    module global.
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|    These examples belong in the UTC class above, but it is obscured; or in
   255|         0|            0|            0|  0.00%|    the README.txt, but we are not depending on Python 2.4 so integrating
   256|         0|            0|            0|  0.00%|    the README.txt examples with the unit tests is not trivial.
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|    >>> import datetime, pickle
   259|         0|            0|            0|  0.00%|    >>> dt = datetime.datetime(2005, 3, 1, 14, 13, 21, tzinfo=utc)
   260|         0|            0|            0|  0.00%|    >>> naive = dt.replace(tzinfo=None)
   261|         0|            0|            0|  0.00%|    >>> p = pickle.dumps(dt, 1)
   262|         0|            0|            0|  0.00%|    >>> naive_p = pickle.dumps(naive, 1)
   263|         0|            0|            0|  0.00%|    >>> len(p) - len(naive_p)
   264|         0|            0|            0|  0.00%|    17
   265|         0|            0|            0|  0.00%|    >>> new = pickle.loads(p)
   266|         0|            0|            0|  0.00%|    >>> new == dt
   267|         0|            0|            0|  0.00%|    True
   268|         0|            0|            0|  0.00%|    >>> new is dt
   269|         0|            0|            0|  0.00%|    False
   270|         0|            0|            0|  0.00%|    >>> new.tzinfo is dt.tzinfo
   271|         0|            0|            0|  0.00%|    True
   272|         0|            0|            0|  0.00%|    >>> utc is UTC is timezone('UTC')
   273|         0|            0|            0|  0.00%|    True
   274|         0|            0|            0|  0.00%|    >>> utc is timezone('GMT')
   275|         0|            0|            0|  0.00%|    False
   276|         0|            0|            0|  0.00%|    """
   277|         0|            0|            0|  0.00%|    return utc
   278|         0|            0|            0|  0.00%|_UTC.__safe_for_unpickling__ = True
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|def _p(*args):
   282|         0|            0|            0|  0.00%|    """Factory function for unpickling pytz tzinfo instances.
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|    Just a wrapper around tzinfo.unpickler to save a few bytes in each pickle
   285|         0|            0|            0|  0.00%|    by shortening the path.
   286|         0|            0|            0|  0.00%|    """
   287|         0|            0|            0|  0.00%|    return unpickler(*args)
   288|         0|            0|            0|  0.00%|_p.__safe_for_unpickling__ = True
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|class _CountryTimezoneDict(LazyDict):
   293|         0|            0|            0|  0.00%|    """Map ISO 3166 country code to a list of timezone names commonly used
   294|         0|            0|            0|  0.00%|    in that country.
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|    iso3166_code is the two letter code used to identify the country.
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|    >>> def print_list(list_of_strings):
   299|         0|            0|            0|  0.00%|    ...     'We use a helper so doctests work under Python 2.3 -> 3.x'
   300|         0|            0|            0|  0.00%|    ...     for s in list_of_strings:
   301|         0|            0|            0|  0.00%|    ...         print(s)
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|    >>> print_list(country_timezones['nz'])
   304|         0|            0|            0|  0.00%|    Pacific/Auckland
   305|         0|            0|            0|  0.00%|    Pacific/Chatham
   306|         0|            0|            0|  0.00%|    >>> print_list(country_timezones['ch'])
   307|         0|            0|            0|  0.00%|    Europe/Zurich
   308|         0|            0|            0|  0.00%|    >>> print_list(country_timezones['CH'])
   309|         0|            0|            0|  0.00%|    Europe/Zurich
   310|         0|            0|            0|  0.00%|    >>> print_list(country_timezones[unicode('ch')])
   311|         0|            0|            0|  0.00%|    Europe/Zurich
   312|         0|            0|            0|  0.00%|    >>> print_list(country_timezones['XXX'])
   313|         0|            0|            0|  0.00%|    Traceback (most recent call last):
   314|         0|            0|            0|  0.00%|    ...
   315|         0|            0|            0|  0.00%|    KeyError: 'XXX'
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|    Previously, this information was exposed as a function rather than a
   318|         0|            0|            0|  0.00%|    dictionary. This is still supported::
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|    >>> print_list(country_timezones('nz'))
   321|         0|            0|            0|  0.00%|    Pacific/Auckland
   322|         0|            0|            0|  0.00%|    Pacific/Chatham
   323|         0|            0|            0|  0.00%|    """
   324|         0|            0|            0|  0.00%|    def __call__(self, iso3166_code):
   325|         0|            0|            0|  0.00%|        """Backwards compatibility."""
   326|         0|            0|            0|  0.00%|        return self[iso3166_code]
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|    def _fill(self):
   329|         0|            0|            0|  0.00%|        data = {}
   330|         0|            0|            0|  0.00%|        zone_tab = open_resource('zone.tab')
   331|         0|            0|            0|  0.00%|        try:
   332|         0|            0|            0|  0.00%|            for line in zone_tab:
   333|         0|            0|            0|  0.00%|                line = line.decode('UTF-8')
   334|         0|            0|            0|  0.00%|                if line.startswith('#'):
   335|         0|            0|            0|  0.00%|                    continue
   336|         0|            0|            0|  0.00%|                code, coordinates, zone = line.split(None, 4)[:3]
   337|         0|            0|            0|  0.00%|                if zone not in all_timezones_set:
   338|         0|            0|            0|  0.00%|                    continue
   339|         0|            0|            0|  0.00%|                try:
   340|         0|            0|            0|  0.00%|                    data[code].append(zone)
   341|         0|            0|            0|  0.00%|                except KeyError:
   342|         0|            0|            0|  0.00%|                    data[code] = [zone]
   343|         0|            0|            0|  0.00%|            self.data = data
   344|         0|            0|            0|  0.00%|        finally:
   345|         0|            0|            0|  0.00%|            zone_tab.close()
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|country_timezones = _CountryTimezoneDict()
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|class _CountryNameDict(LazyDict):
   351|         0|            0|            0|  0.00%|    '''Dictionary proving ISO3166 code -> English name.
   352|         0|            0|            0|  0.00%|
   353|         0|            0|            0|  0.00%|    >>> print(country_names['au'])
   354|         0|            0|            0|  0.00%|    Australia
   355|         0|            0|            0|  0.00%|    '''
   356|         0|            0|            0|  0.00%|    def _fill(self):
   357|         0|            0|            0|  0.00%|        data = {}
   358|         0|            0|            0|  0.00%|        zone_tab = open_resource('iso3166.tab')
   359|         0|            0|            0|  0.00%|        try:
   360|         0|            0|            0|  0.00%|            for line in zone_tab.readlines():
   361|         0|            0|            0|  0.00%|                line = line.decode('UTF-8')
   362|         0|            0|            0|  0.00%|                if line.startswith('#'):
   363|         0|            0|            0|  0.00%|                    continue
   364|         0|            0|            0|  0.00%|                code, name = line.split(None, 1)
   365|         0|            0|            0|  0.00%|                data[code] = name.strip()
   366|         0|            0|            0|  0.00%|            self.data = data
   367|         0|            0|            0|  0.00%|        finally:
   368|         0|            0|            0|  0.00%|            zone_tab.close()
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|country_names = _CountryNameDict()
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|# Time-zone info based solely on fixed offsets
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|class _FixedOffset(datetime.tzinfo):
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|    zone = None # to match the standard pytz API
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|    def __init__(self, minutes):
   380|         0|            0|            0|  0.00%|        if abs(minutes) >= 1440:
   381|         0|            0|            0|  0.00%|            raise ValueError("absolute offset is too large", minutes)
   382|         0|            0|            0|  0.00%|        self._minutes = minutes
   383|         0|            0|            0|  0.00%|        self._offset = datetime.timedelta(minutes=minutes)
   384|         0|            0|            0|  0.00%|
   385|         0|            0|            0|  0.00%|    def utcoffset(self, dt):
   386|         0|            0|            0|  0.00%|        return self._offset
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|    def __reduce__(self):
   389|         0|            0|            0|  0.00%|        return FixedOffset, (self._minutes, )
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|    def dst(self, dt):
   392|         0|            0|            0|  0.00%|        return ZERO
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|    def tzname(self, dt):
   395|         0|            0|            0|  0.00%|        return None
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|    def __repr__(self):
   398|         0|            0|            0|  0.00%|        return 'pytz.FixedOffset(%d)' % self._minutes
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|    def localize(self, dt, is_dst=False):
   401|         0|            0|            0|  0.00%|        '''Convert naive time to local time'''
   402|         0|            0|            0|  0.00%|        if dt.tzinfo is not None:
   403|         0|            0|            0|  0.00%|            raise ValueError('Not naive datetime (tzinfo is already set)')
   404|         0|            0|            0|  0.00%|        return dt.replace(tzinfo=self)
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|    def normalize(self, dt, is_dst=False):
   407|         0|            0|            0|  0.00%|        '''Correct the timezone information on the given datetime'''
   408|         0|            0|            0|  0.00%|        if dt.tzinfo is self:
   409|         0|            0|            0|  0.00%|            return dt
   410|         0|            0|            0|  0.00%|        if dt.tzinfo is None:
   411|         0|            0|            0|  0.00%|            raise ValueError('Naive time - no tzinfo set')
   412|         0|            0|            0|  0.00%|        return dt.astimezone(self)
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|def FixedOffset(offset, _tzinfos = {}):
   416|         0|            0|            0|  0.00%|    """return a fixed-offset timezone based off a number of minutes.
   417|         0|            0|            0|  0.00%|
   418|         0|            0|            0|  0.00%|        >>> one = FixedOffset(-330)
   419|         0|            0|            0|  0.00%|        >>> one
   420|         0|            0|            0|  0.00%|        pytz.FixedOffset(-330)
   421|         0|            0|            0|  0.00%|        >>> one.utcoffset(datetime.datetime.now())
   422|         0|            0|            0|  0.00%|        datetime.timedelta(-1, 66600)
   423|         0|            0|            0|  0.00%|        >>> one.dst(datetime.datetime.now())
   424|         0|            0|            0|  0.00%|        datetime.timedelta(0)
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|        >>> two = FixedOffset(1380)
   427|         0|            0|            0|  0.00%|        >>> two
   428|         0|            0|            0|  0.00%|        pytz.FixedOffset(1380)
   429|         0|            0|            0|  0.00%|        >>> two.utcoffset(datetime.datetime.now())
   430|         0|            0|            0|  0.00%|        datetime.timedelta(0, 82800)
   431|         0|            0|            0|  0.00%|        >>> two.dst(datetime.datetime.now())
   432|         0|            0|            0|  0.00%|        datetime.timedelta(0)
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|    The datetime.timedelta must be between the range of -1 and 1 day,
   435|         0|            0|            0|  0.00%|    non-inclusive.
   436|         0|            0|            0|  0.00%|
   437|         0|            0|            0|  0.00%|        >>> FixedOffset(1440)
   438|         0|            0|            0|  0.00%|        Traceback (most recent call last):
   439|         0|            0|            0|  0.00%|        ...
   440|         0|            0|            0|  0.00%|        ValueError: ('absolute offset is too large', 1440)
   441|         0|            0|            0|  0.00%|
   442|         0|            0|            0|  0.00%|        >>> FixedOffset(-1440)
   443|         0|            0|            0|  0.00%|        Traceback (most recent call last):
   444|         0|            0|            0|  0.00%|        ...
   445|         0|            0|            0|  0.00%|        ValueError: ('absolute offset is too large', -1440)
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|    An offset of 0 is special-cased to return UTC.
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|        >>> FixedOffset(0) is UTC
   450|         0|            0|            0|  0.00%|        True
   451|         0|            0|            0|  0.00%|
   452|         0|            0|            0|  0.00%|    There should always be only one instance of a FixedOffset per timedelta.
   453|         0|            0|            0|  0.00%|    This should be true for multiple creation calls.
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|        >>> FixedOffset(-330) is one
   456|         0|            0|            0|  0.00%|        True
   457|         0|            0|            0|  0.00%|        >>> FixedOffset(1380) is two
   458|         0|            0|            0|  0.00%|        True
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|    It should also be true for pickling.
   461|         0|            0|            0|  0.00%|
   462|         0|            0|            0|  0.00%|        >>> import pickle
   463|         0|            0|            0|  0.00%|        >>> pickle.loads(pickle.dumps(one)) is one
   464|         0|            0|            0|  0.00%|        True
   465|         0|            0|            0|  0.00%|        >>> pickle.loads(pickle.dumps(two)) is two
   466|         0|            0|            0|  0.00%|        True
   467|         0|            0|            0|  0.00%|    """
   468|         0|            0|            0|  0.00%|    if offset == 0:
   469|         0|            0|            0|  0.00%|        return UTC
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|    info = _tzinfos.get(offset)
   472|         0|            0|            0|  0.00%|    if info is None:
   473|         0|            0|            0|  0.00%|        # We haven't seen this one before. we need to save it.
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|        # Use setdefault to avoid a race condition and make sure we have
   476|         0|            0|            0|  0.00%|        # only one
   477|         0|            0|            0|  0.00%|        info = _tzinfos.setdefault(offset, _FixedOffset(offset))
   478|         0|            0|            0|  0.00%|
   479|         0|            0|            0|  0.00%|    return info
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|FixedOffset.__safe_for_unpickling__ = True
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|def _test():
   485|         0|            0|            0|  0.00%|    import doctest, os, sys
   486|         0|            0|            0|  0.00%|    sys.path.insert(0, os.pardir)
   487|         0|            0|            0|  0.00%|    import pytz
   488|         0|            0|            0|  0.00%|    return doctest.testmod(pytz)
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|if __name__ == '__main__':
   491|         0|            0|            0|  0.00%|    _test()
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|all_timezones = \
   494|         0|            0|            0|  0.00%|['Africa/Abidjan',
   495|         0|            0|            0|  0.00%| 'Africa/Accra',
   496|         0|            0|            0|  0.00%| 'Africa/Addis_Ababa',
   497|         0|            0|            0|  0.00%| 'Africa/Algiers',
   498|         0|            0|            0|  0.00%| 'Africa/Asmara',
   499|         0|            0|            0|  0.00%| 'Africa/Asmera',
   500|         0|            0|            0|  0.00%| 'Africa/Bamako',
   501|         0|            0|            0|  0.00%| 'Africa/Bangui',
   502|         0|            0|            0|  0.00%| 'Africa/Banjul',
   503|         0|            0|            0|  0.00%| 'Africa/Bissau',
   504|         0|            0|            0|  0.00%| 'Africa/Blantyre',
   505|         0|            0|            0|  0.00%| 'Africa/Brazzaville',
   506|         0|            0|            0|  0.00%| 'Africa/Bujumbura',
   507|         0|            0|            0|  0.00%| 'Africa/Cairo',
   508|         0|            0|            0|  0.00%| 'Africa/Casablanca',
   509|         0|            0|            0|  0.00%| 'Africa/Ceuta',
   510|         0|            0|            0|  0.00%| 'Africa/Conakry',
   511|         0|            0|            0|  0.00%| 'Africa/Dakar',
   512|         0|            0|            0|  0.00%| 'Africa/Dar_es_Salaam',
   513|         0|            0|            0|  0.00%| 'Africa/Djibouti',
   514|         0|            0|            0|  0.00%| 'Africa/Douala',
   515|         0|            0|            0|  0.00%| 'Africa/El_Aaiun',
   516|         0|            0|            0|  0.00%| 'Africa/Freetown',
   517|         0|            0|            0|  0.00%| 'Africa/Gaborone',
   518|         0|            0|            0|  0.00%| 'Africa/Harare',
   519|         0|            0|            0|  0.00%| 'Africa/Johannesburg',
   520|         0|            0|            0|  0.00%| 'Africa/Juba',
   521|         0|            0|            0|  0.00%| 'Africa/Kampala',
   522|         0|            0|            0|  0.00%| 'Africa/Khartoum',
   523|         0|            0|            0|  0.00%| 'Africa/Kigali',
   524|         0|            0|            0|  0.00%| 'Africa/Kinshasa',
   525|         0|            0|            0|  0.00%| 'Africa/Lagos',
   526|         0|            0|            0|  0.00%| 'Africa/Libreville',
   527|         0|            0|            0|  0.00%| 'Africa/Lome',
   528|         0|            0|            0|  0.00%| 'Africa/Luanda',
   529|         0|            0|            0|  0.00%| 'Africa/Lubumbashi',
   530|         0|            0|            0|  0.00%| 'Africa/Lusaka',
   531|         0|            0|            0|  0.00%| 'Africa/Malabo',
   532|         0|            0|            0|  0.00%| 'Africa/Maputo',
   533|         0|            0|            0|  0.00%| 'Africa/Maseru',
   534|         0|            0|            0|  0.00%| 'Africa/Mbabane',
   535|         0|            0|            0|  0.00%| 'Africa/Mogadishu',
   536|         0|            0|            0|  0.00%| 'Africa/Monrovia',
   537|         0|            0|            0|  0.00%| 'Africa/Nairobi',
   538|         0|            0|            0|  0.00%| 'Africa/Ndjamena',
   539|         0|            0|            0|  0.00%| 'Africa/Niamey',
   540|         0|            0|            0|  0.00%| 'Africa/Nouakchott',
   541|         0|            0|            0|  0.00%| 'Africa/Ouagadougou',
   542|         0|            0|            0|  0.00%| 'Africa/Porto-Novo',
   543|         0|            0|            0|  0.00%| 'Africa/Sao_Tome',
   544|         0|            0|            0|  0.00%| 'Africa/Timbuktu',
   545|         0|            0|            0|  0.00%| 'Africa/Tripoli',
   546|         0|            0|            0|  0.00%| 'Africa/Tunis',
   547|         0|            0|            0|  0.00%| 'Africa/Windhoek',
   548|         0|            0|            0|  0.00%| 'America/Adak',
   549|         0|            0|            0|  0.00%| 'America/Anchorage',
   550|         0|            0|            0|  0.00%| 'America/Anguilla',
   551|         0|            0|            0|  0.00%| 'America/Antigua',
   552|         0|            0|            0|  0.00%| 'America/Araguaina',
   553|         0|            0|            0|  0.00%| 'America/Argentina/Buenos_Aires',
   554|         0|            0|            0|  0.00%| 'America/Argentina/Catamarca',
   555|         0|            0|            0|  0.00%| 'America/Argentina/ComodRivadavia',
   556|         0|            0|            0|  0.00%| 'America/Argentina/Cordoba',
   557|         0|            0|            0|  0.00%| 'America/Argentina/Jujuy',
   558|         0|            0|            0|  0.00%| 'America/Argentina/La_Rioja',
   559|         0|            0|            0|  0.00%| 'America/Argentina/Mendoza',
   560|         0|            0|            0|  0.00%| 'America/Argentina/Rio_Gallegos',
   561|         0|            0|            0|  0.00%| 'America/Argentina/Salta',
   562|         0|            0|            0|  0.00%| 'America/Argentina/San_Juan',
   563|         0|            0|            0|  0.00%| 'America/Argentina/San_Luis',
   564|         0|            0|            0|  0.00%| 'America/Argentina/Tucuman',
   565|         0|            0|            0|  0.00%| 'America/Argentina/Ushuaia',
   566|         0|            0|            0|  0.00%| 'America/Aruba',
   567|         0|            0|            0|  0.00%| 'America/Asuncion',
   568|         0|            0|            0|  0.00%| 'America/Atikokan',
   569|         0|            0|            0|  0.00%| 'America/Atka',
   570|         0|            0|            0|  0.00%| 'America/Bahia',
   571|         0|            0|            0|  0.00%| 'America/Bahia_Banderas',
   572|         0|            0|            0|  0.00%| 'America/Barbados',
   573|         0|            0|            0|  0.00%| 'America/Belem',
   574|         0|            0|            0|  0.00%| 'America/Belize',
   575|         0|            0|            0|  0.00%| 'America/Blanc-Sablon',
   576|         0|            0|            0|  0.00%| 'America/Boa_Vista',
   577|         0|            0|            0|  0.00%| 'America/Bogota',
   578|         0|            0|            0|  0.00%| 'America/Boise',
   579|         0|            0|            0|  0.00%| 'America/Buenos_Aires',
   580|         0|            0|            0|  0.00%| 'America/Cambridge_Bay',
   581|         0|            0|            0|  0.00%| 'America/Campo_Grande',
   582|         0|            0|            0|  0.00%| 'America/Cancun',
   583|         0|            0|            0|  0.00%| 'America/Caracas',
   584|         0|            0|            0|  0.00%| 'America/Catamarca',
   585|         0|            0|            0|  0.00%| 'America/Cayenne',
   586|         0|            0|            0|  0.00%| 'America/Cayman',
   587|         0|            0|            0|  0.00%| 'America/Chicago',
   588|         0|            0|            0|  0.00%| 'America/Chihuahua',
   589|         0|            0|            0|  0.00%| 'America/Coral_Harbour',
   590|         0|            0|            0|  0.00%| 'America/Cordoba',
   591|         0|            0|            0|  0.00%| 'America/Costa_Rica',
   592|         0|            0|            0|  0.00%| 'America/Creston',
   593|         0|            0|            0|  0.00%| 'America/Cuiaba',
   594|         0|            0|            0|  0.00%| 'America/Curacao',
   595|         0|            0|            0|  0.00%| 'America/Danmarkshavn',
   596|         0|            0|            0|  0.00%| 'America/Dawson',
   597|         0|            0|            0|  0.00%| 'America/Dawson_Creek',
   598|         0|            0|            0|  0.00%| 'America/Denver',
   599|         0|            0|            0|  0.00%| 'America/Detroit',
   600|         0|            0|            0|  0.00%| 'America/Dominica',
   601|         0|            0|            0|  0.00%| 'America/Edmonton',
   602|         0|            0|            0|  0.00%| 'America/Eirunepe',
   603|         0|            0|            0|  0.00%| 'America/El_Salvador',
   604|         0|            0|            0|  0.00%| 'America/Ensenada',
   605|         0|            0|            0|  0.00%| 'America/Fort_Nelson',
   606|         0|            0|            0|  0.00%| 'America/Fort_Wayne',
   607|         0|            0|            0|  0.00%| 'America/Fortaleza',
   608|         0|            0|            0|  0.00%| 'America/Glace_Bay',
   609|         0|            0|            0|  0.00%| 'America/Godthab',
   610|         0|            0|            0|  0.00%| 'America/Goose_Bay',
   611|         0|            0|            0|  0.00%| 'America/Grand_Turk',
   612|         0|            0|            0|  0.00%| 'America/Grenada',
   613|         0|            0|            0|  0.00%| 'America/Guadeloupe',
   614|         0|            0|            0|  0.00%| 'America/Guatemala',
   615|         0|            0|            0|  0.00%| 'America/Guayaquil',
   616|         0|            0|            0|  0.00%| 'America/Guyana',
   617|         0|            0|            0|  0.00%| 'America/Halifax',
   618|         0|            0|            0|  0.00%| 'America/Havana',
   619|         0|            0|            0|  0.00%| 'America/Hermosillo',
   620|         0|            0|            0|  0.00%| 'America/Indiana/Indianapolis',
   621|         0|            0|            0|  0.00%| 'America/Indiana/Knox',
   622|         0|            0|            0|  0.00%| 'America/Indiana/Marengo',
   623|         0|            0|            0|  0.00%| 'America/Indiana/Petersburg',
   624|         0|            0|            0|  0.00%| 'America/Indiana/Tell_City',
   625|         0|            0|            0|  0.00%| 'America/Indiana/Vevay',
   626|         0|            0|            0|  0.00%| 'America/Indiana/Vincennes',
   627|         0|            0|            0|  0.00%| 'America/Indiana/Winamac',
   628|         0|            0|            0|  0.00%| 'America/Indianapolis',
   629|         0|            0|            0|  0.00%| 'America/Inuvik',
   630|         0|            0|            0|  0.00%| 'America/Iqaluit',
   631|         0|            0|            0|  0.00%| 'America/Jamaica',
   632|         0|            0|            0|  0.00%| 'America/Jujuy',
   633|         0|            0|            0|  0.00%| 'America/Juneau',
   634|         0|            0|            0|  0.00%| 'America/Kentucky/Louisville',
   635|         0|            0|            0|  0.00%| 'America/Kentucky/Monticello',
   636|         0|            0|            0|  0.00%| 'America/Knox_IN',
   637|         0|            0|            0|  0.00%| 'America/Kralendijk',
   638|         0|            0|            0|  0.00%| 'America/La_Paz',
   639|         0|            0|            0|  0.00%| 'America/Lima',
   640|         0|            0|            0|  0.00%| 'America/Los_Angeles',
   641|         0|            0|            0|  0.00%| 'America/Louisville',
   642|         0|            0|            0|  0.00%| 'America/Lower_Princes',
   643|         0|            0|            0|  0.00%| 'America/Maceio',
   644|         0|            0|            0|  0.00%| 'America/Managua',
   645|         0|            0|            0|  0.00%| 'America/Manaus',
   646|         0|            0|            0|  0.00%| 'America/Marigot',
   647|         0|            0|            0|  0.00%| 'America/Martinique',
   648|         0|            0|            0|  0.00%| 'America/Matamoros',
   649|         0|            0|            0|  0.00%| 'America/Mazatlan',
   650|         0|            0|            0|  0.00%| 'America/Mendoza',
   651|         0|            0|            0|  0.00%| 'America/Menominee',
   652|         0|            0|            0|  0.00%| 'America/Merida',
   653|         0|            0|            0|  0.00%| 'America/Metlakatla',
   654|         0|            0|            0|  0.00%| 'America/Mexico_City',
   655|         0|            0|            0|  0.00%| 'America/Miquelon',
   656|         0|            0|            0|  0.00%| 'America/Moncton',
   657|         0|            0|            0|  0.00%| 'America/Monterrey',
   658|         0|            0|            0|  0.00%| 'America/Montevideo',
   659|         0|            0|            0|  0.00%| 'America/Montreal',
   660|         0|            0|            0|  0.00%| 'America/Montserrat',
   661|         0|            0|            0|  0.00%| 'America/Nassau',
   662|         0|            0|            0|  0.00%| 'America/New_York',
   663|         0|            0|            0|  0.00%| 'America/Nipigon',
   664|         0|            0|            0|  0.00%| 'America/Nome',
   665|         0|            0|            0|  0.00%| 'America/Noronha',
   666|         0|            0|            0|  0.00%| 'America/North_Dakota/Beulah',
   667|         0|            0|            0|  0.00%| 'America/North_Dakota/Center',
   668|         0|            0|            0|  0.00%| 'America/North_Dakota/New_Salem',
   669|         0|            0|            0|  0.00%| 'America/Ojinaga',
   670|         0|            0|            0|  0.00%| 'America/Panama',
   671|         0|            0|            0|  0.00%| 'America/Pangnirtung',
   672|         0|            0|            0|  0.00%| 'America/Paramaribo',
   673|         0|            0|            0|  0.00%| 'America/Phoenix',
   674|         0|            0|            0|  0.00%| 'America/Port-au-Prince',
   675|         0|            0|            0|  0.00%| 'America/Port_of_Spain',
   676|         0|            0|            0|  0.00%| 'America/Porto_Acre',
   677|         0|            0|            0|  0.00%| 'America/Porto_Velho',
   678|         0|            0|            0|  0.00%| 'America/Puerto_Rico',
   679|         0|            0|            0|  0.00%| 'America/Punta_Arenas',
   680|         0|            0|            0|  0.00%| 'America/Rainy_River',
   681|         0|            0|            0|  0.00%| 'America/Rankin_Inlet',
   682|         0|            0|            0|  0.00%| 'America/Recife',
   683|         0|            0|            0|  0.00%| 'America/Regina',
   684|         0|            0|            0|  0.00%| 'America/Resolute',
   685|         0|            0|            0|  0.00%| 'America/Rio_Branco',
   686|         0|            0|            0|  0.00%| 'America/Rosario',
   687|         0|            0|            0|  0.00%| 'America/Santa_Isabel',
   688|         0|            0|            0|  0.00%| 'America/Santarem',
   689|         0|            0|            0|  0.00%| 'America/Santiago',
   690|         0|            0|            0|  0.00%| 'America/Santo_Domingo',
   691|         0|            0|            0|  0.00%| 'America/Sao_Paulo',
   692|         0|            0|            0|  0.00%| 'America/Scoresbysund',
   693|         0|            0|            0|  0.00%| 'America/Shiprock',
   694|         0|            0|            0|  0.00%| 'America/Sitka',
   695|         0|            0|            0|  0.00%| 'America/St_Barthelemy',
   696|         0|            0|            0|  0.00%| 'America/St_Johns',
   697|         0|            0|            0|  0.00%| 'America/St_Kitts',
   698|         0|            0|            0|  0.00%| 'America/St_Lucia',
   699|         0|            0|            0|  0.00%| 'America/St_Thomas',
   700|         0|            0|            0|  0.00%| 'America/St_Vincent',
   701|         0|            0|            0|  0.00%| 'America/Swift_Current',
   702|         0|            0|            0|  0.00%| 'America/Tegucigalpa',
   703|         0|            0|            0|  0.00%| 'America/Thule',
   704|         0|            0|            0|  0.00%| 'America/Thunder_Bay',
   705|         0|            0|            0|  0.00%| 'America/Tijuana',
   706|         0|            0|            0|  0.00%| 'America/Toronto',
   707|         0|            0|            0|  0.00%| 'America/Tortola',
   708|         0|            0|            0|  0.00%| 'America/Vancouver',
   709|         0|            0|            0|  0.00%| 'America/Virgin',
   710|         0|            0|            0|  0.00%| 'America/Whitehorse',
   711|         0|            0|            0|  0.00%| 'America/Winnipeg',
   712|         0|            0|            0|  0.00%| 'America/Yakutat',
   713|         0|            0|            0|  0.00%| 'America/Yellowknife',
   714|         0|            0|            0|  0.00%| 'Antarctica/Casey',
   715|         0|            0|            0|  0.00%| 'Antarctica/Davis',
   716|         0|            0|            0|  0.00%| 'Antarctica/DumontDUrville',
   717|         0|            0|            0|  0.00%| 'Antarctica/Macquarie',
   718|         0|            0|            0|  0.00%| 'Antarctica/Mawson',
   719|         0|            0|            0|  0.00%| 'Antarctica/McMurdo',
   720|         0|            0|            0|  0.00%| 'Antarctica/Palmer',
   721|         0|            0|            0|  0.00%| 'Antarctica/Rothera',
   722|         0|            0|            0|  0.00%| 'Antarctica/South_Pole',
   723|         0|            0|            0|  0.00%| 'Antarctica/Syowa',
   724|         0|            0|            0|  0.00%| 'Antarctica/Troll',
   725|         0|            0|            0|  0.00%| 'Antarctica/Vostok',
   726|         0|            0|            0|  0.00%| 'Arctic/Longyearbyen',
   727|         0|            0|            0|  0.00%| 'Asia/Aden',
   728|         0|            0|            0|  0.00%| 'Asia/Almaty',
   729|         0|            0|            0|  0.00%| 'Asia/Amman',
   730|         0|            0|            0|  0.00%| 'Asia/Anadyr',
   731|         0|            0|            0|  0.00%| 'Asia/Aqtau',
   732|         0|            0|            0|  0.00%| 'Asia/Aqtobe',
   733|         0|            0|            0|  0.00%| 'Asia/Ashgabat',
   734|         0|            0|            0|  0.00%| 'Asia/Ashkhabad',
   735|         0|            0|            0|  0.00%| 'Asia/Atyrau',
   736|         0|            0|            0|  0.00%| 'Asia/Baghdad',
   737|         0|            0|            0|  0.00%| 'Asia/Bahrain',
   738|         0|            0|            0|  0.00%| 'Asia/Baku',
   739|         0|            0|            0|  0.00%| 'Asia/Bangkok',
   740|         0|            0|            0|  0.00%| 'Asia/Barnaul',
   741|         0|            0|            0|  0.00%| 'Asia/Beirut',
   742|         0|            0|            0|  0.00%| 'Asia/Bishkek',
   743|         0|            0|            0|  0.00%| 'Asia/Brunei',
   744|         0|            0|            0|  0.00%| 'Asia/Calcutta',
   745|         0|            0|            0|  0.00%| 'Asia/Chita',
   746|         0|            0|            0|  0.00%| 'Asia/Choibalsan',
   747|         0|            0|            0|  0.00%| 'Asia/Chongqing',
   748|         0|            0|            0|  0.00%| 'Asia/Chungking',
   749|         0|            0|            0|  0.00%| 'Asia/Colombo',
   750|         0|            0|            0|  0.00%| 'Asia/Dacca',
   751|         0|            0|            0|  0.00%| 'Asia/Damascus',
   752|         0|            0|            0|  0.00%| 'Asia/Dhaka',
   753|         0|            0|            0|  0.00%| 'Asia/Dili',
   754|         0|            0|            0|  0.00%| 'Asia/Dubai',
   755|         0|            0|            0|  0.00%| 'Asia/Dushanbe',
   756|         0|            0|            0|  0.00%| 'Asia/Famagusta',
   757|         0|            0|            0|  0.00%| 'Asia/Gaza',
   758|         0|            0|            0|  0.00%| 'Asia/Harbin',
   759|         0|            0|            0|  0.00%| 'Asia/Hebron',
   760|         0|            0|            0|  0.00%| 'Asia/Ho_Chi_Minh',
   761|         0|            0|            0|  0.00%| 'Asia/Hong_Kong',
   762|         0|            0|            0|  0.00%| 'Asia/Hovd',
   763|         0|            0|            0|  0.00%| 'Asia/Irkutsk',
   764|         0|            0|            0|  0.00%| 'Asia/Istanbul',
   765|         0|            0|            0|  0.00%| 'Asia/Jakarta',
   766|         0|            0|            0|  0.00%| 'Asia/Jayapura',
   767|         0|            0|            0|  0.00%| 'Asia/Jerusalem',
   768|         0|            0|            0|  0.00%| 'Asia/Kabul',
   769|         0|            0|            0|  0.00%| 'Asia/Kamchatka',
   770|         0|            0|            0|  0.00%| 'Asia/Karachi',
   771|         0|            0|            0|  0.00%| 'Asia/Kashgar',
   772|         0|            0|            0|  0.00%| 'Asia/Kathmandu',
   773|         0|            0|            0|  0.00%| 'Asia/Katmandu',
   774|         0|            0|            0|  0.00%| 'Asia/Khandyga',
   775|         0|            0|            0|  0.00%| 'Asia/Kolkata',
   776|         0|            0|            0|  0.00%| 'Asia/Krasnoyarsk',
   777|         0|            0|            0|  0.00%| 'Asia/Kuala_Lumpur',
   778|         0|            0|            0|  0.00%| 'Asia/Kuching',
   779|         0|            0|            0|  0.00%| 'Asia/Kuwait',
   780|         0|            0|            0|  0.00%| 'Asia/Macao',
   781|         0|            0|            0|  0.00%| 'Asia/Macau',
   782|         0|            0|            0|  0.00%| 'Asia/Magadan',
   783|         0|            0|            0|  0.00%| 'Asia/Makassar',
   784|         0|            0|            0|  0.00%| 'Asia/Manila',
   785|         0|            0|            0|  0.00%| 'Asia/Muscat',
   786|         0|            0|            0|  0.00%| 'Asia/Nicosia',
   787|         0|            0|            0|  0.00%| 'Asia/Novokuznetsk',
   788|         0|            0|            0|  0.00%| 'Asia/Novosibirsk',
   789|         0|            0|            0|  0.00%| 'Asia/Omsk',
   790|         0|            0|            0|  0.00%| 'Asia/Oral',
   791|         0|            0|            0|  0.00%| 'Asia/Phnom_Penh',
   792|         0|            0|            0|  0.00%| 'Asia/Pontianak',
   793|         0|            0|            0|  0.00%| 'Asia/Pyongyang',
   794|         0|            0|            0|  0.00%| 'Asia/Qatar',
   795|         0|            0|            0|  0.00%| 'Asia/Qyzylorda',
   796|         0|            0|            0|  0.00%| 'Asia/Rangoon',
   797|         0|            0|            0|  0.00%| 'Asia/Riyadh',
   798|         0|            0|            0|  0.00%| 'Asia/Saigon',
   799|         0|            0|            0|  0.00%| 'Asia/Sakhalin',
   800|         0|            0|            0|  0.00%| 'Asia/Samarkand',
   801|         0|            0|            0|  0.00%| 'Asia/Seoul',
   802|         0|            0|            0|  0.00%| 'Asia/Shanghai',
   803|         0|            0|            0|  0.00%| 'Asia/Singapore',
   804|         0|            0|            0|  0.00%| 'Asia/Srednekolymsk',
   805|         0|            0|            0|  0.00%| 'Asia/Taipei',
   806|         0|            0|            0|  0.00%| 'Asia/Tashkent',
   807|         0|            0|            0|  0.00%| 'Asia/Tbilisi',
   808|         0|            0|            0|  0.00%| 'Asia/Tehran',
   809|         0|            0|            0|  0.00%| 'Asia/Tel_Aviv',
   810|         0|            0|            0|  0.00%| 'Asia/Thimbu',
   811|         0|            0|            0|  0.00%| 'Asia/Thimphu',
   812|         0|            0|            0|  0.00%| 'Asia/Tokyo',
   813|         0|            0|            0|  0.00%| 'Asia/Tomsk',
   814|         0|            0|            0|  0.00%| 'Asia/Ujung_Pandang',
   815|         0|            0|            0|  0.00%| 'Asia/Ulaanbaatar',
   816|         0|            0|            0|  0.00%| 'Asia/Ulan_Bator',
   817|         0|            0|            0|  0.00%| 'Asia/Urumqi',
   818|         0|            0|            0|  0.00%| 'Asia/Ust-Nera',
   819|         0|            0|            0|  0.00%| 'Asia/Vientiane',
   820|         0|            0|            0|  0.00%| 'Asia/Vladivostok',
   821|         0|            0|            0|  0.00%| 'Asia/Yakutsk',
   822|         0|            0|            0|  0.00%| 'Asia/Yangon',
   823|         0|            0|            0|  0.00%| 'Asia/Yekaterinburg',
   824|         0|            0|            0|  0.00%| 'Asia/Yerevan',
   825|         0|            0|            0|  0.00%| 'Atlantic/Azores',
   826|         0|            0|            0|  0.00%| 'Atlantic/Bermuda',
   827|         0|            0|            0|  0.00%| 'Atlantic/Canary',
   828|         0|            0|            0|  0.00%| 'Atlantic/Cape_Verde',
   829|         0|            0|            0|  0.00%| 'Atlantic/Faeroe',
   830|         0|            0|            0|  0.00%| 'Atlantic/Faroe',
   831|         0|            0|            0|  0.00%| 'Atlantic/Jan_Mayen',
   832|         0|            0|            0|  0.00%| 'Atlantic/Madeira',
   833|         0|            0|            0|  0.00%| 'Atlantic/Reykjavik',
   834|         0|            0|            0|  0.00%| 'Atlantic/South_Georgia',
   835|         0|            0|            0|  0.00%| 'Atlantic/St_Helena',
   836|         0|            0|            0|  0.00%| 'Atlantic/Stanley',
   837|         0|            0|            0|  0.00%| 'Australia/ACT',
   838|         0|            0|            0|  0.00%| 'Australia/Adelaide',
   839|         0|            0|            0|  0.00%| 'Australia/Brisbane',
   840|         0|            0|            0|  0.00%| 'Australia/Broken_Hill',
   841|         0|            0|            0|  0.00%| 'Australia/Canberra',
   842|         0|            0|            0|  0.00%| 'Australia/Currie',
   843|         0|            0|            0|  0.00%| 'Australia/Darwin',
   844|         0|            0|            0|  0.00%| 'Australia/Eucla',
   845|         0|            0|            0|  0.00%| 'Australia/Hobart',
   846|         0|            0|            0|  0.00%| 'Australia/LHI',
   847|         0|            0|            0|  0.00%| 'Australia/Lindeman',
   848|         0|            0|            0|  0.00%| 'Australia/Lord_Howe',
   849|         0|            0|            0|  0.00%| 'Australia/Melbourne',
   850|         0|            0|            0|  0.00%| 'Australia/NSW',
   851|         0|            0|            0|  0.00%| 'Australia/North',
   852|         0|            0|            0|  0.00%| 'Australia/Perth',
   853|         0|            0|            0|  0.00%| 'Australia/Queensland',
   854|         0|            0|            0|  0.00%| 'Australia/South',
   855|         0|            0|            0|  0.00%| 'Australia/Sydney',
   856|         0|            0|            0|  0.00%| 'Australia/Tasmania',
   857|         0|            0|            0|  0.00%| 'Australia/Victoria',
   858|         0|            0|            0|  0.00%| 'Australia/West',
   859|         0|            0|            0|  0.00%| 'Australia/Yancowinna',
   860|         0|            0|            0|  0.00%| 'Brazil/Acre',
   861|         0|            0|            0|  0.00%| 'Brazil/DeNoronha',
   862|         0|            0|            0|  0.00%| 'Brazil/East',
   863|         0|            0|            0|  0.00%| 'Brazil/West',
   864|         0|            0|            0|  0.00%| 'CET',
   865|         0|            0|            0|  0.00%| 'CST6CDT',
   866|         0|            0|            0|  0.00%| 'Canada/Atlantic',
   867|         0|            0|            0|  0.00%| 'Canada/Central',
   868|         0|            0|            0|  0.00%| 'Canada/East-Saskatchewan',
   869|         0|            0|            0|  0.00%| 'Canada/Eastern',
   870|         0|            0|            0|  0.00%| 'Canada/Mountain',
   871|         0|            0|            0|  0.00%| 'Canada/Newfoundland',
   872|         0|            0|            0|  0.00%| 'Canada/Pacific',
   873|         0|            0|            0|  0.00%| 'Canada/Saskatchewan',
   874|         0|            0|            0|  0.00%| 'Canada/Yukon',
   875|         0|            0|            0|  0.00%| 'Chile/Continental',
   876|         0|            0|            0|  0.00%| 'Chile/EasterIsland',
   877|         0|            0|            0|  0.00%| 'Cuba',
   878|         0|            0|            0|  0.00%| 'EET',
   879|         0|            0|            0|  0.00%| 'EST',
   880|         0|            0|            0|  0.00%| 'EST5EDT',
   881|         0|            0|            0|  0.00%| 'Egypt',
   882|         0|            0|            0|  0.00%| 'Eire',
   883|         0|            0|            0|  0.00%| 'Etc/GMT',
   884|         0|            0|            0|  0.00%| 'Etc/GMT+0',
   885|         0|            0|            0|  0.00%| 'Etc/GMT+1',
   886|         0|            0|            0|  0.00%| 'Etc/GMT+10',
   887|         0|            0|            0|  0.00%| 'Etc/GMT+11',
   888|         0|            0|            0|  0.00%| 'Etc/GMT+12',
   889|         0|            0|            0|  0.00%| 'Etc/GMT+2',
   890|         0|            0|            0|  0.00%| 'Etc/GMT+3',
   891|         0|            0|            0|  0.00%| 'Etc/GMT+4',
   892|         0|            0|            0|  0.00%| 'Etc/GMT+5',
   893|         0|            0|            0|  0.00%| 'Etc/GMT+6',
   894|         0|            0|            0|  0.00%| 'Etc/GMT+7',
   895|         0|            0|            0|  0.00%| 'Etc/GMT+8',
   896|         0|            0|            0|  0.00%| 'Etc/GMT+9',
   897|         0|            0|            0|  0.00%| 'Etc/GMT-0',
   898|         0|            0|            0|  0.00%| 'Etc/GMT-1',
   899|         0|            0|            0|  0.00%| 'Etc/GMT-10',
   900|         0|            0|            0|  0.00%| 'Etc/GMT-11',
   901|         0|            0|            0|  0.00%| 'Etc/GMT-12',
   902|         0|            0|            0|  0.00%| 'Etc/GMT-13',
   903|         0|            0|            0|  0.00%| 'Etc/GMT-14',
   904|         0|            0|            0|  0.00%| 'Etc/GMT-2',
   905|         0|            0|            0|  0.00%| 'Etc/GMT-3',
   906|         0|            0|            0|  0.00%| 'Etc/GMT-4',
   907|         0|            0|            0|  0.00%| 'Etc/GMT-5',
   908|         0|            0|            0|  0.00%| 'Etc/GMT-6',
   909|         0|            0|            0|  0.00%| 'Etc/GMT-7',
   910|         0|            0|            0|  0.00%| 'Etc/GMT-8',
   911|         0|            0|            0|  0.00%| 'Etc/GMT-9',
   912|         0|            0|            0|  0.00%| 'Etc/GMT0',
   913|         0|            0|            0|  0.00%| 'Etc/Greenwich',
   914|         0|            0|            0|  0.00%| 'Etc/UCT',
   915|         0|            0|            0|  0.00%| 'Etc/UTC',
   916|         0|            0|            0|  0.00%| 'Etc/Universal',
   917|         0|            0|            0|  0.00%| 'Etc/Zulu',
   918|         0|            0|            0|  0.00%| 'Europe/Amsterdam',
   919|         0|            0|            0|  0.00%| 'Europe/Andorra',
   920|         0|            0|            0|  0.00%| 'Europe/Astrakhan',
   921|         0|            0|            0|  0.00%| 'Europe/Athens',
   922|         0|            0|            0|  0.00%| 'Europe/Belfast',
   923|         0|            0|            0|  0.00%| 'Europe/Belgrade',
   924|         0|            0|            0|  0.00%| 'Europe/Berlin',
   925|         0|            0|            0|  0.00%| 'Europe/Bratislava',
   926|         0|            0|            0|  0.00%| 'Europe/Brussels',
   927|         0|            0|            0|  0.00%| 'Europe/Bucharest',
   928|         0|            0|            0|  0.00%| 'Europe/Budapest',
   929|         0|            0|            0|  0.00%| 'Europe/Busingen',
   930|         0|            0|            0|  0.00%| 'Europe/Chisinau',
   931|         0|            0|            0|  0.00%| 'Europe/Copenhagen',
   932|         0|            0|            0|  0.00%| 'Europe/Dublin',
   933|         0|            0|            0|  0.00%| 'Europe/Gibraltar',
   934|         0|            0|            0|  0.00%| 'Europe/Guernsey',
   935|         0|            0|            0|  0.00%| 'Europe/Helsinki',
   936|         0|            0|            0|  0.00%| 'Europe/Isle_of_Man',
   937|         0|            0|            0|  0.00%| 'Europe/Istanbul',
   938|         0|            0|            0|  0.00%| 'Europe/Jersey',
   939|         0|            0|            0|  0.00%| 'Europe/Kaliningrad',
   940|         0|            0|            0|  0.00%| 'Europe/Kiev',
   941|         0|            0|            0|  0.00%| 'Europe/Kirov',
   942|         0|            0|            0|  0.00%| 'Europe/Lisbon',
   943|         0|            0|            0|  0.00%| 'Europe/Ljubljana',
   944|         0|            0|            0|  0.00%| 'Europe/London',
   945|         0|            0|            0|  0.00%| 'Europe/Luxembourg',
   946|         0|            0|            0|  0.00%| 'Europe/Madrid',
   947|         0|            0|            0|  0.00%| 'Europe/Malta',
   948|         0|            0|            0|  0.00%| 'Europe/Mariehamn',
   949|         0|            0|            0|  0.00%| 'Europe/Minsk',
   950|         0|            0|            0|  0.00%| 'Europe/Monaco',
   951|         0|            0|            0|  0.00%| 'Europe/Moscow',
   952|         0|            0|            0|  0.00%| 'Europe/Nicosia',
   953|         0|            0|            0|  0.00%| 'Europe/Oslo',
   954|         0|            0|            0|  0.00%| 'Europe/Paris',
   955|         0|            0|            0|  0.00%| 'Europe/Podgorica',
   956|         0|            0|            0|  0.00%| 'Europe/Prague',
   957|         0|            0|            0|  0.00%| 'Europe/Riga',
   958|         0|            0|            0|  0.00%| 'Europe/Rome',
   959|         0|            0|            0|  0.00%| 'Europe/Samara',
   960|         0|            0|            0|  0.00%| 'Europe/San_Marino',
   961|         0|            0|            0|  0.00%| 'Europe/Sarajevo',
   962|         0|            0|            0|  0.00%| 'Europe/Saratov',
   963|         0|            0|            0|  0.00%| 'Europe/Simferopol',
   964|         0|            0|            0|  0.00%| 'Europe/Skopje',
   965|         0|            0|            0|  0.00%| 'Europe/Sofia',
   966|         0|            0|            0|  0.00%| 'Europe/Stockholm',
   967|         0|            0|            0|  0.00%| 'Europe/Tallinn',
   968|         0|            0|            0|  0.00%| 'Europe/Tirane',
   969|         0|            0|            0|  0.00%| 'Europe/Tiraspol',
   970|         0|            0|            0|  0.00%| 'Europe/Ulyanovsk',
   971|         0|            0|            0|  0.00%| 'Europe/Uzhgorod',
   972|         0|            0|            0|  0.00%| 'Europe/Vaduz',
   973|         0|            0|            0|  0.00%| 'Europe/Vatican',
   974|         0|            0|            0|  0.00%| 'Europe/Vienna',
   975|         0|            0|            0|  0.00%| 'Europe/Vilnius',
   976|         0|            0|            0|  0.00%| 'Europe/Volgograd',
   977|         0|            0|            0|  0.00%| 'Europe/Warsaw',
   978|         0|            0|            0|  0.00%| 'Europe/Zagreb',
   979|         0|            0|            0|  0.00%| 'Europe/Zaporozhye',
   980|         0|            0|            0|  0.00%| 'Europe/Zurich',
   981|         0|            0|            0|  0.00%| 'GB',
   982|         0|            0|            0|  0.00%| 'GB-Eire',
   983|         0|            0|            0|  0.00%| 'GMT',
   984|         0|            0|            0|  0.00%| 'GMT+0',
   985|         0|            0|            0|  0.00%| 'GMT-0',
   986|         0|            0|            0|  0.00%| 'GMT0',
   987|         0|            0|            0|  0.00%| 'Greenwich',
   988|         0|            0|            0|  0.00%| 'HST',
   989|         0|            0|            0|  0.00%| 'Hongkong',
   990|         0|            0|            0|  0.00%| 'Iceland',
   991|         0|            0|            0|  0.00%| 'Indian/Antananarivo',
   992|         0|            0|            0|  0.00%| 'Indian/Chagos',
   993|         0|            0|            0|  0.00%| 'Indian/Christmas',
   994|         0|            0|            0|  0.00%| 'Indian/Cocos',
   995|         0|            0|            0|  0.00%| 'Indian/Comoro',
   996|         0|            0|            0|  0.00%| 'Indian/Kerguelen',
   997|         0|            0|            0|  0.00%| 'Indian/Mahe',
   998|         0|            0|            0|  0.00%| 'Indian/Maldives',
   999|         0|            0|            0|  0.00%| 'Indian/Mauritius',
  1000|         0|            0|            0|  0.00%| 'Indian/Mayotte',
  1001|         0|            0|            0|  0.00%| 'Indian/Reunion',
  1002|         0|            0|            0|  0.00%| 'Iran',
  1003|         0|            0|            0|  0.00%| 'Israel',
  1004|         0|            0|            0|  0.00%| 'Jamaica',
  1005|         0|            0|            0|  0.00%| 'Japan',
  1006|         0|            0|            0|  0.00%| 'Kwajalein',
  1007|         0|            0|            0|  0.00%| 'Libya',
  1008|         0|            0|            0|  0.00%| 'MET',
  1009|         0|            0|            0|  0.00%| 'MST',
  1010|         0|            0|            0|  0.00%| 'MST7MDT',
  1011|         0|            0|            0|  0.00%| 'Mexico/BajaNorte',
  1012|         0|            0|            0|  0.00%| 'Mexico/BajaSur',
  1013|         0|            0|            0|  0.00%| 'Mexico/General',
  1014|         0|            0|            0|  0.00%| 'NZ',
  1015|         0|            0|            0|  0.00%| 'NZ-CHAT',
  1016|         0|            0|            0|  0.00%| 'Navajo',
  1017|         0|            0|            0|  0.00%| 'PRC',
  1018|         0|            0|            0|  0.00%| 'PST8PDT',
  1019|         0|            0|            0|  0.00%| 'Pacific/Apia',
  1020|         0|            0|            0|  0.00%| 'Pacific/Auckland',
  1021|         0|            0|            0|  0.00%| 'Pacific/Bougainville',
  1022|         0|            0|            0|  0.00%| 'Pacific/Chatham',
  1023|         0|            0|            0|  0.00%| 'Pacific/Chuuk',
  1024|         0|            0|            0|  0.00%| 'Pacific/Easter',
  1025|         0|            0|            0|  0.00%| 'Pacific/Efate',
  1026|         0|            0|            0|  0.00%| 'Pacific/Enderbury',
  1027|         0|            0|            0|  0.00%| 'Pacific/Fakaofo',
  1028|         0|            0|            0|  0.00%| 'Pacific/Fiji',
  1029|         0|            0|            0|  0.00%| 'Pacific/Funafuti',
  1030|         0|            0|            0|  0.00%| 'Pacific/Galapagos',
  1031|         0|            0|            0|  0.00%| 'Pacific/Gambier',
  1032|         0|            0|            0|  0.00%| 'Pacific/Guadalcanal',
  1033|         0|            0|            0|  0.00%| 'Pacific/Guam',
  1034|         0|            0|            0|  0.00%| 'Pacific/Honolulu',
  1035|         0|            0|            0|  0.00%| 'Pacific/Johnston',
  1036|         0|            0|            0|  0.00%| 'Pacific/Kiritimati',
  1037|         0|            0|            0|  0.00%| 'Pacific/Kosrae',
  1038|         0|            0|            0|  0.00%| 'Pacific/Kwajalein',
  1039|         0|            0|            0|  0.00%| 'Pacific/Majuro',
  1040|         0|            0|            0|  0.00%| 'Pacific/Marquesas',
  1041|         0|            0|            0|  0.00%| 'Pacific/Midway',
  1042|         0|            0|            0|  0.00%| 'Pacific/Nauru',
  1043|         0|            0|            0|  0.00%| 'Pacific/Niue',
  1044|         0|            0|            0|  0.00%| 'Pacific/Norfolk',
  1045|         0|            0|            0|  0.00%| 'Pacific/Noumea',
  1046|         0|            0|            0|  0.00%| 'Pacific/Pago_Pago',
  1047|         0|            0|            0|  0.00%| 'Pacific/Palau',
  1048|         0|            0|            0|  0.00%| 'Pacific/Pitcairn',
  1049|         0|            0|            0|  0.00%| 'Pacific/Pohnpei',
  1050|         0|            0|            0|  0.00%| 'Pacific/Ponape',
  1051|         0|            0|            0|  0.00%| 'Pacific/Port_Moresby',
  1052|         0|            0|            0|  0.00%| 'Pacific/Rarotonga',
  1053|         0|            0|            0|  0.00%| 'Pacific/Saipan',
  1054|         0|            0|            0|  0.00%| 'Pacific/Samoa',
  1055|         0|            0|            0|  0.00%| 'Pacific/Tahiti',
  1056|         0|            0|            0|  0.00%| 'Pacific/Tarawa',
  1057|         0|            0|            0|  0.00%| 'Pacific/Tongatapu',
  1058|         0|            0|            0|  0.00%| 'Pacific/Truk',
  1059|         0|            0|            0|  0.00%| 'Pacific/Wake',
  1060|         0|            0|            0|  0.00%| 'Pacific/Wallis',
  1061|         0|            0|            0|  0.00%| 'Pacific/Yap',
  1062|         0|            0|            0|  0.00%| 'Poland',
  1063|         0|            0|            0|  0.00%| 'Portugal',
  1064|         0|            0|            0|  0.00%| 'ROC',
  1065|         0|            0|            0|  0.00%| 'ROK',
  1066|         0|            0|            0|  0.00%| 'Singapore',
  1067|         0|            0|            0|  0.00%| 'Turkey',
  1068|         0|            0|            0|  0.00%| 'UCT',
  1069|         0|            0|            0|  0.00%| 'US/Alaska',
  1070|         0|            0|            0|  0.00%| 'US/Aleutian',
  1071|         0|            0|            0|  0.00%| 'US/Arizona',
  1072|         0|            0|            0|  0.00%| 'US/Central',
  1073|         0|            0|            0|  0.00%| 'US/East-Indiana',
  1074|         0|            0|            0|  0.00%| 'US/Eastern',
  1075|         0|            0|            0|  0.00%| 'US/Hawaii',
  1076|         0|            0|            0|  0.00%| 'US/Indiana-Starke',
  1077|         0|            0|            0|  0.00%| 'US/Michigan',
  1078|         0|            0|            0|  0.00%| 'US/Mountain',
  1079|         0|            0|            0|  0.00%| 'US/Pacific',
  1080|         0|            0|            0|  0.00%| 'US/Pacific-New',
  1081|         0|            0|            0|  0.00%| 'US/Samoa',
  1082|         0|            0|            0|  0.00%| 'UTC',
  1083|         0|            0|            0|  0.00%| 'Universal',
  1084|         0|            0|            0|  0.00%| 'W-SU',
  1085|         0|            0|            0|  0.00%| 'WET',
  1086|         0|            0|            0|  0.00%| 'Zulu']
  1087|         0|            0|            0|  0.00%|all_timezones = LazyList(
  1088|         0|            0|            0|  0.00%|        tz for tz in all_timezones if resource_exists(tz))
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\pytz\__init__.py:100 resource_exists
  1089|         0|            0|            0|  0.00%|
  1090|         0|            0|            0|  0.00%|all_timezones_set = LazySet(all_timezones)
  1091|         0|            0|            0|  0.00%|common_timezones = \
  1092|         0|            0|            0|  0.00%|['Africa/Abidjan',
  1093|         0|            0|            0|  0.00%| 'Africa/Accra',
  1094|         0|            0|            0|  0.00%| 'Africa/Addis_Ababa',
  1095|         0|            0|            0|  0.00%| 'Africa/Algiers',
  1096|         0|            0|            0|  0.00%| 'Africa/Asmara',
  1097|         0|            0|            0|  0.00%| 'Africa/Bamako',
  1098|         0|            0|            0|  0.00%| 'Africa/Bangui',
  1099|         0|            0|            0|  0.00%| 'Africa/Banjul',
  1100|         0|            0|            0|  0.00%| 'Africa/Bissau',
  1101|         0|            0|            0|  0.00%| 'Africa/Blantyre',
  1102|         0|            0|            0|  0.00%| 'Africa/Brazzaville',
  1103|         0|            0|            0|  0.00%| 'Africa/Bujumbura',
  1104|         0|            0|            0|  0.00%| 'Africa/Cairo',
  1105|         0|            0|            0|  0.00%| 'Africa/Casablanca',
  1106|         0|            0|            0|  0.00%| 'Africa/Ceuta',
  1107|         0|            0|            0|  0.00%| 'Africa/Conakry',
  1108|         0|            0|            0|  0.00%| 'Africa/Dakar',
  1109|         0|            0|            0|  0.00%| 'Africa/Dar_es_Salaam',
  1110|         0|            0|            0|  0.00%| 'Africa/Djibouti',
  1111|         0|            0|            0|  0.00%| 'Africa/Douala',
  1112|         0|            0|            0|  0.00%| 'Africa/El_Aaiun',
  1113|         0|            0|            0|  0.00%| 'Africa/Freetown',
  1114|         0|            0|            0|  0.00%| 'Africa/Gaborone',
  1115|         0|            0|            0|  0.00%| 'Africa/Harare',
  1116|         0|            0|            0|  0.00%| 'Africa/Johannesburg',
  1117|         0|            0|            0|  0.00%| 'Africa/Juba',
  1118|         0|            0|            0|  0.00%| 'Africa/Kampala',
  1119|         0|            0|            0|  0.00%| 'Africa/Khartoum',
  1120|         0|            0|            0|  0.00%| 'Africa/Kigali',
  1121|         0|            0|            0|  0.00%| 'Africa/Kinshasa',
  1122|         0|            0|            0|  0.00%| 'Africa/Lagos',
  1123|         0|            0|            0|  0.00%| 'Africa/Libreville',
  1124|         0|            0|            0|  0.00%| 'Africa/Lome',
  1125|         0|            0|            0|  0.00%| 'Africa/Luanda',
  1126|         0|            0|            0|  0.00%| 'Africa/Lubumbashi',
  1127|         0|            0|            0|  0.00%| 'Africa/Lusaka',
  1128|         0|            0|            0|  0.00%| 'Africa/Malabo',
  1129|         0|            0|            0|  0.00%| 'Africa/Maputo',
  1130|         0|            0|            0|  0.00%| 'Africa/Maseru',
  1131|         0|            0|            0|  0.00%| 'Africa/Mbabane',
  1132|         0|            0|            0|  0.00%| 'Africa/Mogadishu',
  1133|         0|            0|            0|  0.00%| 'Africa/Monrovia',
  1134|         0|            0|            0|  0.00%| 'Africa/Nairobi',
  1135|         0|            0|            0|  0.00%| 'Africa/Ndjamena',
  1136|         0|            0|            0|  0.00%| 'Africa/Niamey',
  1137|         0|            0|            0|  0.00%| 'Africa/Nouakchott',
  1138|         0|            0|            0|  0.00%| 'Africa/Ouagadougou',
  1139|         0|            0|            0|  0.00%| 'Africa/Porto-Novo',
  1140|         0|            0|            0|  0.00%| 'Africa/Sao_Tome',
  1141|         0|            0|            0|  0.00%| 'Africa/Tripoli',
  1142|         0|            0|            0|  0.00%| 'Africa/Tunis',
  1143|         0|            0|            0|  0.00%| 'Africa/Windhoek',
  1144|         0|            0|            0|  0.00%| 'America/Adak',
  1145|         0|            0|            0|  0.00%| 'America/Anchorage',
  1146|         0|            0|            0|  0.00%| 'America/Anguilla',
  1147|         0|            0|            0|  0.00%| 'America/Antigua',
  1148|         0|            0|            0|  0.00%| 'America/Araguaina',
  1149|         0|            0|            0|  0.00%| 'America/Argentina/Buenos_Aires',
  1150|         0|            0|            0|  0.00%| 'America/Argentina/Catamarca',
  1151|         0|            0|            0|  0.00%| 'America/Argentina/Cordoba',
  1152|         0|            0|            0|  0.00%| 'America/Argentina/Jujuy',
  1153|         0|            0|            0|  0.00%| 'America/Argentina/La_Rioja',
  1154|         0|            0|            0|  0.00%| 'America/Argentina/Mendoza',
  1155|         0|            0|            0|  0.00%| 'America/Argentina/Rio_Gallegos',
  1156|         0|            0|            0|  0.00%| 'America/Argentina/Salta',
  1157|         0|            0|            0|  0.00%| 'America/Argentina/San_Juan',
  1158|         0|            0|            0|  0.00%| 'America/Argentina/San_Luis',
  1159|         0|            0|            0|  0.00%| 'America/Argentina/Tucuman',
  1160|         0|            0|            0|  0.00%| 'America/Argentina/Ushuaia',
  1161|         0|            0|            0|  0.00%| 'America/Aruba',
  1162|         0|            0|            0|  0.00%| 'America/Asuncion',
  1163|         0|            0|            0|  0.00%| 'America/Atikokan',
  1164|         0|            0|            0|  0.00%| 'America/Bahia',
  1165|         0|            0|            0|  0.00%| 'America/Bahia_Banderas',
  1166|         0|            0|            0|  0.00%| 'America/Barbados',
  1167|         0|            0|            0|  0.00%| 'America/Belem',
  1168|         0|            0|            0|  0.00%| 'America/Belize',
  1169|         0|            0|            0|  0.00%| 'America/Blanc-Sablon',
  1170|         0|            0|            0|  0.00%| 'America/Boa_Vista',
  1171|         0|            0|            0|  0.00%| 'America/Bogota',
  1172|         0|            0|            0|  0.00%| 'America/Boise',
  1173|         0|            0|            0|  0.00%| 'America/Cambridge_Bay',
  1174|         0|            0|            0|  0.00%| 'America/Campo_Grande',
  1175|         0|            0|            0|  0.00%| 'America/Cancun',
  1176|         0|            0|            0|  0.00%| 'America/Caracas',
  1177|         0|            0|            0|  0.00%| 'America/Cayenne',
  1178|         0|            0|            0|  0.00%| 'America/Cayman',
  1179|         0|            0|            0|  0.00%| 'America/Chicago',
  1180|         0|            0|            0|  0.00%| 'America/Chihuahua',
  1181|         0|            0|            0|  0.00%| 'America/Costa_Rica',
  1182|         0|            0|            0|  0.00%| 'America/Creston',
  1183|         0|            0|            0|  0.00%| 'America/Cuiaba',
  1184|         0|            0|            0|  0.00%| 'America/Curacao',
  1185|         0|            0|            0|  0.00%| 'America/Danmarkshavn',
  1186|         0|            0|            0|  0.00%| 'America/Dawson',
  1187|         0|            0|            0|  0.00%| 'America/Dawson_Creek',
  1188|         0|            0|            0|  0.00%| 'America/Denver',
  1189|         0|            0|            0|  0.00%| 'America/Detroit',
  1190|         0|            0|            0|  0.00%| 'America/Dominica',
  1191|         0|            0|            0|  0.00%| 'America/Edmonton',
  1192|         0|            0|            0|  0.00%| 'America/Eirunepe',
  1193|         0|            0|            0|  0.00%| 'America/El_Salvador',
  1194|         0|            0|            0|  0.00%| 'America/Fort_Nelson',
  1195|         0|            0|            0|  0.00%| 'America/Fortaleza',
  1196|         0|            0|            0|  0.00%| 'America/Glace_Bay',
  1197|         0|            0|            0|  0.00%| 'America/Godthab',
  1198|         0|            0|            0|  0.00%| 'America/Goose_Bay',
  1199|         0|            0|            0|  0.00%| 'America/Grand_Turk',
  1200|         0|            0|            0|  0.00%| 'America/Grenada',
  1201|         0|            0|            0|  0.00%| 'America/Guadeloupe',
  1202|         0|            0|            0|  0.00%| 'America/Guatemala',
  1203|         0|            0|            0|  0.00%| 'America/Guayaquil',
  1204|         0|            0|            0|  0.00%| 'America/Guyana',
  1205|         0|            0|            0|  0.00%| 'America/Halifax',
  1206|         0|            0|            0|  0.00%| 'America/Havana',
  1207|         0|            0|            0|  0.00%| 'America/Hermosillo',
  1208|         0|            0|            0|  0.00%| 'America/Indiana/Indianapolis',
  1209|         0|            0|            0|  0.00%| 'America/Indiana/Knox',
  1210|         0|            0|            0|  0.00%| 'America/Indiana/Marengo',
  1211|         0|            0|            0|  0.00%| 'America/Indiana/Petersburg',
  1212|         0|            0|            0|  0.00%| 'America/Indiana/Tell_City',
  1213|         0|            0|            0|  0.00%| 'America/Indiana/Vevay',
  1214|         0|            0|            0|  0.00%| 'America/Indiana/Vincennes',
  1215|         0|            0|            0|  0.00%| 'America/Indiana/Winamac',
  1216|         0|            0|            0|  0.00%| 'America/Inuvik',
  1217|         0|            0|            0|  0.00%| 'America/Iqaluit',
  1218|         0|            0|            0|  0.00%| 'America/Jamaica',
  1219|         0|            0|            0|  0.00%| 'America/Juneau',
  1220|         0|            0|            0|  0.00%| 'America/Kentucky/Louisville',
  1221|         0|            0|            0|  0.00%| 'America/Kentucky/Monticello',
  1222|         0|            0|            0|  0.00%| 'America/Kralendijk',
  1223|         0|            0|            0|  0.00%| 'America/La_Paz',
  1224|         0|            0|            0|  0.00%| 'America/Lima',
  1225|         0|            0|            0|  0.00%| 'America/Los_Angeles',
  1226|         0|            0|            0|  0.00%| 'America/Lower_Princes',
  1227|         0|            0|            0|  0.00%| 'America/Maceio',
  1228|         0|            0|            0|  0.00%| 'America/Managua',
  1229|         0|            0|            0|  0.00%| 'America/Manaus',
  1230|         0|            0|            0|  0.00%| 'America/Marigot',
  1231|         0|            0|            0|  0.00%| 'America/Martinique',
  1232|         0|            0|            0|  0.00%| 'America/Matamoros',
  1233|         0|            0|            0|  0.00%| 'America/Mazatlan',
  1234|         0|            0|            0|  0.00%| 'America/Menominee',
  1235|         0|            0|            0|  0.00%| 'America/Merida',
  1236|         0|            0|            0|  0.00%| 'America/Metlakatla',
  1237|         0|            0|            0|  0.00%| 'America/Mexico_City',
  1238|         0|            0|            0|  0.00%| 'America/Miquelon',
  1239|         0|            0|            0|  0.00%| 'America/Moncton',
  1240|         0|            0|            0|  0.00%| 'America/Monterrey',
  1241|         0|            0|            0|  0.00%| 'America/Montevideo',
  1242|         0|            0|            0|  0.00%| 'America/Montserrat',
  1243|         0|            0|            0|  0.00%| 'America/Nassau',
  1244|         0|            0|            0|  0.00%| 'America/New_York',
  1245|         0|            0|            0|  0.00%| 'America/Nipigon',
  1246|         0|            0|            0|  0.00%| 'America/Nome',
  1247|         0|            0|            0|  0.00%| 'America/Noronha',
  1248|         0|            0|            0|  0.00%| 'America/North_Dakota/Beulah',
  1249|         0|            0|            0|  0.00%| 'America/North_Dakota/Center',
  1250|         0|            0|            0|  0.00%| 'America/North_Dakota/New_Salem',
  1251|         0|            0|            0|  0.00%| 'America/Ojinaga',
  1252|         0|            0|            0|  0.00%| 'America/Panama',
  1253|         0|            0|            0|  0.00%| 'America/Pangnirtung',
  1254|         0|            0|            0|  0.00%| 'America/Paramaribo',
  1255|         0|            0|            0|  0.00%| 'America/Phoenix',
  1256|         0|            0|            0|  0.00%| 'America/Port-au-Prince',
  1257|         0|            0|            0|  0.00%| 'America/Port_of_Spain',
  1258|         0|            0|            0|  0.00%| 'America/Porto_Velho',
  1259|         0|            0|            0|  0.00%| 'America/Puerto_Rico',
  1260|         0|            0|            0|  0.00%| 'America/Punta_Arenas',
  1261|         0|            0|            0|  0.00%| 'America/Rainy_River',
  1262|         0|            0|            0|  0.00%| 'America/Rankin_Inlet',
  1263|         0|            0|            0|  0.00%| 'America/Recife',
  1264|         0|            0|            0|  0.00%| 'America/Regina',
  1265|         0|            0|            0|  0.00%| 'America/Resolute',
  1266|         0|            0|            0|  0.00%| 'America/Rio_Branco',
  1267|         0|            0|            0|  0.00%| 'America/Santarem',
  1268|         0|            0|            0|  0.00%| 'America/Santiago',
  1269|         0|            0|            0|  0.00%| 'America/Santo_Domingo',
  1270|         0|            0|            0|  0.00%| 'America/Sao_Paulo',
  1271|         0|            0|            0|  0.00%| 'America/Scoresbysund',
  1272|         0|            0|            0|  0.00%| 'America/Sitka',
  1273|         0|            0|            0|  0.00%| 'America/St_Barthelemy',
  1274|         0|            0|            0|  0.00%| 'America/St_Johns',
  1275|         0|            0|            0|  0.00%| 'America/St_Kitts',
  1276|         0|            0|            0|  0.00%| 'America/St_Lucia',
  1277|         0|            0|            0|  0.00%| 'America/St_Thomas',
  1278|         0|            0|            0|  0.00%| 'America/St_Vincent',
  1279|         0|            0|            0|  0.00%| 'America/Swift_Current',
  1280|         0|            0|            0|  0.00%| 'America/Tegucigalpa',
  1281|         0|            0|            0|  0.00%| 'America/Thule',
  1282|         0|            0|            0|  0.00%| 'America/Thunder_Bay',
  1283|         0|            0|            0|  0.00%| 'America/Tijuana',
  1284|         0|            0|            0|  0.00%| 'America/Toronto',
  1285|         0|            0|            0|  0.00%| 'America/Tortola',
  1286|         0|            0|            0|  0.00%| 'America/Vancouver',
  1287|         0|            0|            0|  0.00%| 'America/Whitehorse',
  1288|         0|            0|            0|  0.00%| 'America/Winnipeg',
  1289|         0|            0|            0|  0.00%| 'America/Yakutat',
  1290|         0|            0|            0|  0.00%| 'America/Yellowknife',
  1291|         0|            0|            0|  0.00%| 'Antarctica/Casey',
  1292|         0|            0|            0|  0.00%| 'Antarctica/Davis',
  1293|         0|            0|            0|  0.00%| 'Antarctica/DumontDUrville',
  1294|         0|            0|            0|  0.00%| 'Antarctica/Macquarie',
  1295|         0|            0|            0|  0.00%| 'Antarctica/Mawson',
  1296|         0|            0|            0|  0.00%| 'Antarctica/McMurdo',
  1297|         0|            0|            0|  0.00%| 'Antarctica/Palmer',
  1298|         0|            0|            0|  0.00%| 'Antarctica/Rothera',
  1299|         0|            0|            0|  0.00%| 'Antarctica/Syowa',
  1300|         0|            0|            0|  0.00%| 'Antarctica/Troll',
  1301|         0|            0|            0|  0.00%| 'Antarctica/Vostok',
  1302|         0|            0|            0|  0.00%| 'Arctic/Longyearbyen',
  1303|         0|            0|            0|  0.00%| 'Asia/Aden',
  1304|         0|            0|            0|  0.00%| 'Asia/Almaty',
  1305|         0|            0|            0|  0.00%| 'Asia/Amman',
  1306|         0|            0|            0|  0.00%| 'Asia/Anadyr',
  1307|         0|            0|            0|  0.00%| 'Asia/Aqtau',
  1308|         0|            0|            0|  0.00%| 'Asia/Aqtobe',
  1309|         0|            0|            0|  0.00%| 'Asia/Ashgabat',
  1310|         0|            0|            0|  0.00%| 'Asia/Atyrau',
  1311|         0|            0|            0|  0.00%| 'Asia/Baghdad',
  1312|         0|            0|            0|  0.00%| 'Asia/Bahrain',
  1313|         0|            0|            0|  0.00%| 'Asia/Baku',
  1314|         0|            0|            0|  0.00%| 'Asia/Bangkok',
  1315|         0|            0|            0|  0.00%| 'Asia/Barnaul',
  1316|         0|            0|            0|  0.00%| 'Asia/Beirut',
  1317|         0|            0|            0|  0.00%| 'Asia/Bishkek',
  1318|         0|            0|            0|  0.00%| 'Asia/Brunei',
  1319|         0|            0|            0|  0.00%| 'Asia/Chita',
  1320|         0|            0|            0|  0.00%| 'Asia/Choibalsan',
  1321|         0|            0|            0|  0.00%| 'Asia/Colombo',
  1322|         0|            0|            0|  0.00%| 'Asia/Damascus',
  1323|         0|            0|            0|  0.00%| 'Asia/Dhaka',
  1324|         0|            0|            0|  0.00%| 'Asia/Dili',
  1325|         0|            0|            0|  0.00%| 'Asia/Dubai',
  1326|         0|            0|            0|  0.00%| 'Asia/Dushanbe',
  1327|         0|            0|            0|  0.00%| 'Asia/Famagusta',
  1328|         0|            0|            0|  0.00%| 'Asia/Gaza',
  1329|         0|            0|            0|  0.00%| 'Asia/Hebron',
  1330|         0|            0|            0|  0.00%| 'Asia/Ho_Chi_Minh',
  1331|         0|            0|            0|  0.00%| 'Asia/Hong_Kong',
  1332|         0|            0|            0|  0.00%| 'Asia/Hovd',
  1333|         0|            0|            0|  0.00%| 'Asia/Irkutsk',
  1334|         0|            0|            0|  0.00%| 'Asia/Jakarta',
  1335|         0|            0|            0|  0.00%| 'Asia/Jayapura',
  1336|         0|            0|            0|  0.00%| 'Asia/Jerusalem',
  1337|         0|            0|            0|  0.00%| 'Asia/Kabul',
  1338|         0|            0|            0|  0.00%| 'Asia/Kamchatka',
  1339|         0|            0|            0|  0.00%| 'Asia/Karachi',
  1340|         0|            0|            0|  0.00%| 'Asia/Kathmandu',
  1341|         0|            0|            0|  0.00%| 'Asia/Khandyga',
  1342|         0|            0|            0|  0.00%| 'Asia/Kolkata',
  1343|         0|            0|            0|  0.00%| 'Asia/Krasnoyarsk',
  1344|         0|            0|            0|  0.00%| 'Asia/Kuala_Lumpur',
  1345|         0|            0|            0|  0.00%| 'Asia/Kuching',
  1346|         0|            0|            0|  0.00%| 'Asia/Kuwait',
  1347|         0|            0|            0|  0.00%| 'Asia/Macau',
  1348|         0|            0|            0|  0.00%| 'Asia/Magadan',
  1349|         0|            0|            0|  0.00%| 'Asia/Makassar',
  1350|         0|            0|            0|  0.00%| 'Asia/Manila',
  1351|         0|            0|            0|  0.00%| 'Asia/Muscat',
  1352|         0|            0|            0|  0.00%| 'Asia/Nicosia',
  1353|         0|            0|            0|  0.00%| 'Asia/Novokuznetsk',
  1354|         0|            0|            0|  0.00%| 'Asia/Novosibirsk',
  1355|         0|            0|            0|  0.00%| 'Asia/Omsk',
  1356|         0|            0|            0|  0.00%| 'Asia/Oral',
  1357|         0|            0|            0|  0.00%| 'Asia/Phnom_Penh',
  1358|         0|            0|            0|  0.00%| 'Asia/Pontianak',
  1359|         0|            0|            0|  0.00%| 'Asia/Pyongyang',
  1360|         0|            0|            0|  0.00%| 'Asia/Qatar',
  1361|         0|            0|            0|  0.00%| 'Asia/Qyzylorda',
  1362|         0|            0|            0|  0.00%| 'Asia/Riyadh',
  1363|         0|            0|            0|  0.00%| 'Asia/Sakhalin',
  1364|         0|            0|            0|  0.00%| 'Asia/Samarkand',
  1365|         0|            0|            0|  0.00%| 'Asia/Seoul',
  1366|         0|            0|            0|  0.00%| 'Asia/Shanghai',
  1367|         0|            0|            0|  0.00%| 'Asia/Singapore',
  1368|         0|            0|            0|  0.00%| 'Asia/Srednekolymsk',
  1369|         0|            0|            0|  0.00%| 'Asia/Taipei',
  1370|         0|            0|            0|  0.00%| 'Asia/Tashkent',
  1371|         0|            0|            0|  0.00%| 'Asia/Tbilisi',
  1372|         0|            0|            0|  0.00%| 'Asia/Tehran',
  1373|         0|            0|            0|  0.00%| 'Asia/Thimphu',
  1374|         0|            0|            0|  0.00%| 'Asia/Tokyo',
  1375|         0|            0|            0|  0.00%| 'Asia/Tomsk',
  1376|         0|            0|            0|  0.00%| 'Asia/Ulaanbaatar',
  1377|         0|            0|            0|  0.00%| 'Asia/Urumqi',
  1378|         0|            0|            0|  0.00%| 'Asia/Ust-Nera',
  1379|         0|            0|            0|  0.00%| 'Asia/Vientiane',
  1380|         0|            0|            0|  0.00%| 'Asia/Vladivostok',
  1381|         0|            0|            0|  0.00%| 'Asia/Yakutsk',
  1382|         0|            0|            0|  0.00%| 'Asia/Yangon',
  1383|         0|            0|            0|  0.00%| 'Asia/Yekaterinburg',
  1384|         0|            0|            0|  0.00%| 'Asia/Yerevan',
  1385|         0|            0|            0|  0.00%| 'Atlantic/Azores',
  1386|         0|            0|            0|  0.00%| 'Atlantic/Bermuda',
  1387|         0|            0|            0|  0.00%| 'Atlantic/Canary',
  1388|         0|            0|            0|  0.00%| 'Atlantic/Cape_Verde',
  1389|         0|            0|            0|  0.00%| 'Atlantic/Faroe',
  1390|         0|            0|            0|  0.00%| 'Atlantic/Madeira',
  1391|         0|            0|            0|  0.00%| 'Atlantic/Reykjavik',
  1392|         0|            0|            0|  0.00%| 'Atlantic/South_Georgia',
  1393|         0|            0|            0|  0.00%| 'Atlantic/St_Helena',
  1394|         0|            0|            0|  0.00%| 'Atlantic/Stanley',
  1395|         0|            0|            0|  0.00%| 'Australia/Adelaide',
  1396|         0|            0|            0|  0.00%| 'Australia/Brisbane',
  1397|         0|            0|            0|  0.00%| 'Australia/Broken_Hill',
  1398|         0|            0|            0|  0.00%| 'Australia/Currie',
  1399|         0|            0|            0|  0.00%| 'Australia/Darwin',
  1400|         0|            0|            0|  0.00%| 'Australia/Eucla',
  1401|         0|            0|            0|  0.00%| 'Australia/Hobart',
  1402|         0|            0|            0|  0.00%| 'Australia/Lindeman',
  1403|         0|            0|            0|  0.00%| 'Australia/Lord_Howe',
  1404|         0|            0|            0|  0.00%| 'Australia/Melbourne',
  1405|         0|            0|            0|  0.00%| 'Australia/Perth',
  1406|         0|            0|            0|  0.00%| 'Australia/Sydney',
  1407|         0|            0|            0|  0.00%| 'Canada/Atlantic',
  1408|         0|            0|            0|  0.00%| 'Canada/Central',
  1409|         0|            0|            0|  0.00%| 'Canada/Eastern',
  1410|         0|            0|            0|  0.00%| 'Canada/Mountain',
  1411|         0|            0|            0|  0.00%| 'Canada/Newfoundland',
  1412|         0|            0|            0|  0.00%| 'Canada/Pacific',
  1413|         0|            0|            0|  0.00%| 'Europe/Amsterdam',
  1414|         0|            0|            0|  0.00%| 'Europe/Andorra',
  1415|         0|            0|            0|  0.00%| 'Europe/Astrakhan',
  1416|         0|            0|            0|  0.00%| 'Europe/Athens',
  1417|         0|            0|            0|  0.00%| 'Europe/Belgrade',
  1418|         0|            0|            0|  0.00%| 'Europe/Berlin',
  1419|         0|            0|            0|  0.00%| 'Europe/Bratislava',
  1420|         0|            0|            0|  0.00%| 'Europe/Brussels',
  1421|         0|            0|            0|  0.00%| 'Europe/Bucharest',
  1422|         0|            0|            0|  0.00%| 'Europe/Budapest',
  1423|         0|            0|            0|  0.00%| 'Europe/Busingen',
  1424|         0|            0|            0|  0.00%| 'Europe/Chisinau',
  1425|         0|            0|            0|  0.00%| 'Europe/Copenhagen',
  1426|         0|            0|            0|  0.00%| 'Europe/Dublin',
  1427|         0|            0|            0|  0.00%| 'Europe/Gibraltar',
  1428|         0|            0|            0|  0.00%| 'Europe/Guernsey',
  1429|         0|            0|            0|  0.00%| 'Europe/Helsinki',
  1430|         0|            0|            0|  0.00%| 'Europe/Isle_of_Man',
  1431|         0|            0|            0|  0.00%| 'Europe/Istanbul',
  1432|         0|            0|            0|  0.00%| 'Europe/Jersey',
  1433|         0|            0|            0|  0.00%| 'Europe/Kaliningrad',
  1434|         0|            0|            0|  0.00%| 'Europe/Kiev',
  1435|         0|            0|            0|  0.00%| 'Europe/Kirov',
  1436|         0|            0|            0|  0.00%| 'Europe/Lisbon',
  1437|         0|            0|            0|  0.00%| 'Europe/Ljubljana',
  1438|         0|            0|            0|  0.00%| 'Europe/London',
  1439|         0|            0|            0|  0.00%| 'Europe/Luxembourg',
  1440|         0|            0|            0|  0.00%| 'Europe/Madrid',
  1441|         0|            0|            0|  0.00%| 'Europe/Malta',
  1442|         0|            0|            0|  0.00%| 'Europe/Mariehamn',
  1443|         0|            0|            0|  0.00%| 'Europe/Minsk',
  1444|         0|            0|            0|  0.00%| 'Europe/Monaco',
  1445|         0|            0|            0|  0.00%| 'Europe/Moscow',
  1446|         0|            0|            0|  0.00%| 'Europe/Oslo',
  1447|         0|            0|            0|  0.00%| 'Europe/Paris',
  1448|         0|            0|            0|  0.00%| 'Europe/Podgorica',
  1449|         0|            0|            0|  0.00%| 'Europe/Prague',
  1450|         0|            0|            0|  0.00%| 'Europe/Riga',
  1451|         0|            0|            0|  0.00%| 'Europe/Rome',
  1452|         0|            0|            0|  0.00%| 'Europe/Samara',
  1453|         0|            0|            0|  0.00%| 'Europe/San_Marino',
  1454|         0|            0|            0|  0.00%| 'Europe/Sarajevo',
  1455|         0|            0|            0|  0.00%| 'Europe/Saratov',
  1456|         0|            0|            0|  0.00%| 'Europe/Simferopol',
  1457|         0|            0|            0|  0.00%| 'Europe/Skopje',
  1458|         0|            0|            0|  0.00%| 'Europe/Sofia',
  1459|         0|            0|            0|  0.00%| 'Europe/Stockholm',
  1460|         0|            0|            0|  0.00%| 'Europe/Tallinn',
  1461|         0|            0|            0|  0.00%| 'Europe/Tirane',
  1462|         0|            0|            0|  0.00%| 'Europe/Ulyanovsk',
  1463|         0|            0|            0|  0.00%| 'Europe/Uzhgorod',
  1464|         0|            0|            0|  0.00%| 'Europe/Vaduz',
  1465|         0|            0|            0|  0.00%| 'Europe/Vatican',
  1466|         0|            0|            0|  0.00%| 'Europe/Vienna',
  1467|         0|            0|            0|  0.00%| 'Europe/Vilnius',
  1468|         0|            0|            0|  0.00%| 'Europe/Volgograd',
  1469|         0|            0|            0|  0.00%| 'Europe/Warsaw',
  1470|         0|            0|            0|  0.00%| 'Europe/Zagreb',
  1471|         0|            0|            0|  0.00%| 'Europe/Zaporozhye',
  1472|         0|            0|            0|  0.00%| 'Europe/Zurich',
  1473|         0|            0|            0|  0.00%| 'GMT',
  1474|         0|            0|            0|  0.00%| 'Indian/Antananarivo',
  1475|         0|            0|            0|  0.00%| 'Indian/Chagos',
  1476|         0|            0|            0|  0.00%| 'Indian/Christmas',
  1477|         0|            0|            0|  0.00%| 'Indian/Cocos',
  1478|         0|            0|            0|  0.00%| 'Indian/Comoro',
  1479|         0|            0|            0|  0.00%| 'Indian/Kerguelen',
  1480|         0|            0|            0|  0.00%| 'Indian/Mahe',
  1481|         0|            0|            0|  0.00%| 'Indian/Maldives',
  1482|         0|            0|            0|  0.00%| 'Indian/Mauritius',
  1483|         0|            0|            0|  0.00%| 'Indian/Mayotte',
  1484|         0|            0|            0|  0.00%| 'Indian/Reunion',
  1485|         0|            0|            0|  0.00%| 'Pacific/Apia',
  1486|         0|            0|            0|  0.00%| 'Pacific/Auckland',
  1487|         0|            0|            0|  0.00%| 'Pacific/Bougainville',
  1488|         0|            0|            0|  0.00%| 'Pacific/Chatham',
  1489|         0|            0|            0|  0.00%| 'Pacific/Chuuk',
  1490|         0|            0|            0|  0.00%| 'Pacific/Easter',
  1491|         0|            0|            0|  0.00%| 'Pacific/Efate',
  1492|         0|            0|            0|  0.00%| 'Pacific/Enderbury',
  1493|         0|            0|            0|  0.00%| 'Pacific/Fakaofo',
  1494|         0|            0|            0|  0.00%| 'Pacific/Fiji',
  1495|         0|            0|            0|  0.00%| 'Pacific/Funafuti',
  1496|         0|            0|            0|  0.00%| 'Pacific/Galapagos',
  1497|         0|            0|            0|  0.00%| 'Pacific/Gambier',
  1498|         0|            0|            0|  0.00%| 'Pacific/Guadalcanal',
  1499|         0|            0|            0|  0.00%| 'Pacific/Guam',
  1500|         0|            0|            0|  0.00%| 'Pacific/Honolulu',
  1501|         0|            0|            0|  0.00%| 'Pacific/Kiritimati',
  1502|         0|            0|            0|  0.00%| 'Pacific/Kosrae',
  1503|         0|            0|            0|  0.00%| 'Pacific/Kwajalein',
  1504|         0|            0|            0|  0.00%| 'Pacific/Majuro',
  1505|         0|            0|            0|  0.00%| 'Pacific/Marquesas',
  1506|         0|            0|            0|  0.00%| 'Pacific/Midway',
  1507|         0|            0|            0|  0.00%| 'Pacific/Nauru',
  1508|         0|            0|            0|  0.00%| 'Pacific/Niue',
  1509|         0|            0|            0|  0.00%| 'Pacific/Norfolk',
  1510|         0|            0|            0|  0.00%| 'Pacific/Noumea',
  1511|         0|            0|            0|  0.00%| 'Pacific/Pago_Pago',
  1512|         0|            0|            0|  0.00%| 'Pacific/Palau',
  1513|         0|            0|            0|  0.00%| 'Pacific/Pitcairn',
  1514|         0|            0|            0|  0.00%| 'Pacific/Pohnpei',
  1515|         0|            0|            0|  0.00%| 'Pacific/Port_Moresby',
  1516|         0|            0|            0|  0.00%| 'Pacific/Rarotonga',
  1517|         0|            0|            0|  0.00%| 'Pacific/Saipan',
  1518|         0|            0|            0|  0.00%| 'Pacific/Tahiti',
  1519|         0|            0|            0|  0.00%| 'Pacific/Tarawa',
  1520|         0|            0|            0|  0.00%| 'Pacific/Tongatapu',
  1521|         0|            0|            0|  0.00%| 'Pacific/Wake',
  1522|         0|            0|            0|  0.00%| 'Pacific/Wallis',
  1523|         0|            0|            0|  0.00%| 'US/Alaska',
  1524|         0|            0|            0|  0.00%| 'US/Arizona',
  1525|         0|            0|            0|  0.00%| 'US/Central',
  1526|         0|            0|            0|  0.00%| 'US/Eastern',
  1527|         0|            0|            0|  0.00%| 'US/Hawaii',
  1528|         0|            0|            0|  0.00%| 'US/Mountain',
  1529|         0|            0|            0|  0.00%| 'US/Pacific',
  1530|         0|            0|            0|  0.00%| 'UTC']
  1531|         0|            0|            0|  0.00%|common_timezones = LazyList(
  1532|         0|            0|            0|  0.00%|            tz for tz in common_timezones if tz in all_timezones)
  1533|         0|            0|            0|  0.00%|
  1534|         0|            0|            0|  0.00%|common_timezones_set = LazySet(common_timezones)
File: D:\Application\Anaconda\lib\site-packages\DBSrv5ConnPy\db_object.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# coding=UTF-8
     2|         0|            0|            0|  0.00%|"""
     3|         0|            0|            0|  0.00%|This module is 3-tier sql connection module using CIM DBsrv5 webservice
     4|         0|            0|            0|  0.00%|"""
     5|         0|            0|            0|  0.00%|import os
     6|         0|            0|            0|  0.00%|import socket
     7|         0|            0|            0|  0.00%|import urllib
     8|         0|            0|            0|  0.00%|import urllib.request
     9|         0|            0|            0|  0.00%|import json
    10|         0|            0|            0|  0.00%|import re
    11|         0|            0|            0|  0.00%|import pandas as pd
    12|         0|            0|            0|  0.00%|import numpy as np
    13|         0|            0|            0|  0.00%|import string
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|class ReturnError(Exception):
    17|         0|            0|            0|  0.00%|    """Return Error Exception extend from Exception"""
    18|         0|            0|            0|  0.00%|    def __init__(self, value):
    19|         0|            0|            0|  0.00%|        self.value = value
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|    def __str__(self):
    22|         0|            0|            0|  0.00%|        return repr(self.value)
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|class DBSrvConnError(Exception):
    26|         0|            0|            0|  0.00%|    """DB server connection error extend from  Exception"""
    27|         0|            0|            0|  0.00%|    def __init__(self, value):
    28|         0|            0|            0|  0.00%|        self.value = value
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|    def __str__(self):
    31|         0|            0|            0|  0.00%|        return repr(self.value)
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|class FuncNotSupportError(Exception):
    35|         0|            0|            0|  0.00%|    """Some Func will cause query fail in DBsrv5"""
    36|         0|            0|            0|  0.00%|    def __init__(self, value):
    37|         0|            0|            0|  0.00%|        self.value = value
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|    def __str__(self):
    40|         0|            0|            0|  0.00%|        return repr(self.value)
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|class DBObject(object):
    44|         0|            0|            0|  0.00%|    """Create connection to query database or execute update/insert SQL.
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|    Parameters
    47|         0|            0|            0|  0.00%|    ----------
    48|         0|            0|            0|  0.00%|    fab : str, F12|F12A|F12B|F14|F14A|F14B|F14AP7|F15|F15A|F15B|F16
    49|         0|            0|            0|  0.00%|        The target fab database for SQL execution.
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    db : str, MES|EES|SPC|ODY, 'MES' by default
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|    query_url : str, ``None`` by default
    54|         0|            0|            0|  0.00%|        The target query web service url.
    55|         0|            0|            0|  0.00%|        If ``None`` query_url will set automatically.
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|    n_query_url : str, ``None`` by default
    58|         0|            0|            0|  0.00%|        The target non query web service url.
    59|         0|            0|            0|  0.00%|        If ``None`` n_query_url will set automatically.
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|    db_name : str, ``None`` by default
    62|         0|            0|            0|  0.00%|        The target database name that is recognized by DBSrv5.
    63|         0|            0|            0|  0.00%|        If ``None`` db_name will set default database automatically
    64|         0|            0|            0|  0.00%|        If your target database is not in default database list,
    65|         0|            0|            0|  0.00%|        (MES|EES|SPC|ODY) you can pass the specific dabase name.
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|    ap_name : str, ``None`` by default
    68|         0|            0|            0|  0.00%|        The AP name of your python project.
    69|         0|            0|            0|  0.00%|        If ``None`` ap_name will set default automatically.
    70|         0|            0|            0|  0.00%|        AP name will provide to DBSrv5 to recognize your project.
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|    Attributes
    73|         0|            0|            0|  0.00%|    ----------
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|    Examples
    76|         0|            0|            0|  0.00%|    --------
    77|         0|            0|            0|  0.00%|    >>> from DBSrv5ConnPy.db_object import DBObject
    78|         0|            0|            0|  0.00%|    >>>
    79|         0|            0|            0|  0.00%|    >>> mes_obj = DBObject(fab='f12', db='mes')
    80|         0|            0|            0|  0.00%|    >>> sql = 'SELECT * FROM GLOBAL_NAME'
    81|         0|            0|            0|  0.00%|    >>> df = mes_obj.query(sql=sql, debug=True)
    82|         0|            0|            0|  0.00%|    """
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|    # Database server name
    85|         0|            0|            0|  0.00%|    _db_cols = ['MES', 'EES', 'SPC', 'ODY']
    86|         0|            0|            0|  0.00%|    _db_idx = ['F12', 'F12A', 'F12B', 'F14', 'F14A', 'F14B', 'F14AP7', 'F15', 'F15A', 'F15B', 'F16', 'F18']
    87|         0|            0|            0|  0.00%|    _db_name = [['MES12N', 'NEWAEC12', 'SPC12N', 'ODY12M'],
    88|         0|            0|            0|  0.00%|                ['MES12N', 'NEWAEC12', 'SPC12N', 'ODY12M'],
    89|         0|            0|            0|  0.00%|                ['MES12N', 'NEWAEC12', 'SPC12N', 'ODY12M'],
    90|         0|            0|            0|  0.00%|                ['MES14N', 'EESF14', 'SPC14', 'ODYSSEY'],
    91|         0|            0|            0|  0.00%|                ['MES14N', 'EESF14', 'SPC14', 'ODYSSEY'],
    92|         0|            0|            0|  0.00%|                ['MES14G2', 'EESF14', 'SPC14', 'ODYSSEY'],
    93|         0|            0|            0|  0.00%|                ['MES14N', 'EESF14', 'SPC14', 'ODYSSEY'],
    94|         0|            0|            0|  0.00%|                ['MES15', 'EESF15', 'SPCMGR', 'ODY15'],
    95|         0|            0|            0|  0.00%|                ['MES15', 'EESF15', 'SPCMGR', 'ODY15'],
    96|         0|            0|            0|  0.00%|                ['MES15', 'EESF15', 'SPCMGR', 'ODY15'],
    97|         0|            0|            0|  0.00%|                ['MES16', 'EESF16', 'SPC16', 'ODY16'],
    98|         0|            0|            0|  0.00%|                ['MES18G1', 'EES18G1', 'SPC18G1', 'ODY18']]
    99|         0|            0|            0|  0.00%|    _db_name_df = pd.DataFrame(_db_name, index=_db_idx, columns=_db_cols)
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|    _default_query_url = {
   102|         0|            0|            0|  0.00%|        'F12': 'http://f12webservice/DBSrv/DBSrv5/RPT/TDBSVR/select',
   103|         0|            0|            0|  0.00%|        'F12A': 'http://f12webservice/DBSrv/DBSrv5/RPT/TDBSVR/select',
   104|         0|            0|            0|  0.00%|        'F12B': 'http://f12webservice/DBSrv/DBSrv5/RPT/TDBSVR/select',
   105|         0|            0|            0|  0.00%|        'F12_HEAVY': 'http://f12webservice/DBSrv/DBSrv5/HEAVY/TDBSVR/SELECT',
   106|         0|            0|            0|  0.00%|        'F14': 'http://f14websa/TDBSVR/select',
   107|         0|            0|            0|  0.00%|        'F14A': 'http://f14websa/TDBSVR/select',
   108|         0|            0|            0|  0.00%|        'F14B': 'http://f14websb/TDBSVR/select',
   109|         0|            0|            0|  0.00%|        'F14AP7': 'http://f14websa/14AP7/TDBSVR/select',
   110|         0|            0|            0|  0.00%|        'F15': 'http://F15CIMWEBS/TDBSVR/select',
   111|         0|            0|            0|  0.00%|        'F15A': 'http://F15CIMWEBS/TDBSVR/select',
   112|         0|            0|            0|  0.00%|        'F15B': 'http://f15cimwebt/TDBSVR/select',
   113|         0|            0|            0|  0.00%|        'F16': 'http://F16CIM/TDBSVR/select',
   114|         0|            0|            0|  0.00%|        'F18': 'http://F18G1CIM2/TDBSVR/select'
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|    }
   117|         0|            0|            0|  0.00%|    _default_non_query_url = {
   118|         0|            0|            0|  0.00%|        'F12': 'http://f12webservice/DBSrv/DBSrv5/RPT/TDBSVR/EXECSQL',
   119|         0|            0|            0|  0.00%|        'F12A': 'http://f12webservice/DBSrv/DBSrv5/RPT/TDBSVR/EXECSQL',
   120|         0|            0|            0|  0.00%|        'F12B': 'http://f12webservice/DBSrv/DBSrv5/RPT/TDBSVR/EXECSQL',
   121|         0|            0|            0|  0.00%|        'F12_HEAVY': 'http://f12webservice/DBSrv/DBSrv5/HEAVY/TDBSVR/EXECSQL',
   122|         0|            0|            0|  0.00%|        'F14': 'http://f14websa/TDBSVR/EXECSQL',
   123|         0|            0|            0|  0.00%|        'F14A': 'http://f14websa/TDBSVR/EXECSQL',
   124|         0|            0|            0|  0.00%|        'F14B': 'http://f14websb/TDBSVR/EXECSQL',
   125|         0|            0|            0|  0.00%|        'F14AP7': 'http://f14websa/14AP7/TDBSVR/EXECSQL',
   126|         0|            0|            0|  0.00%|        'F15': 'http://F15CIMWEBS/TDBSVR/EXECSQL',
   127|         0|            0|            0|  0.00%|        'F15A': 'http://F15CIMWEBS/TDBSVR/EXECSQL',
   128|         0|            0|            0|  0.00%|        'F15B': 'http://f15cimwebt/TDBSVR/EXECSQL',
   129|         0|            0|            0|  0.00%|        'F16': 'http://F16CIM/TDBSVR/EXECSQL',
   130|         0|            0|            0|  0.00%|        'F18': 'http://F18G1CIM2/TDBSVR/EXECSQL'
   131|         0|            0|            0|  0.00%|    }
   132|         0|            0|            0|  0.00%|    _app_info = '--BR_EXE {component} for {account}@{host}[{ip}] -System_Sponsor {account} -Buz_Sponsor {account} -App_Name {ap_name} at db={db_name}@{server} -Tag'
   133|         0|            0|            0|  0.00%|    _col_type = {
   134|         0|            0|            0|  0.00%|        'System.String': 'object',
   135|         0|            0|            0|  0.00%|        'System.Decimal': 'float64',
   136|         0|            0|            0|  0.00%|        'System.Integer': 'int64',
   137|         0|            0|            0|  0.00%|        'System.DateTime': 'datetime64[ns]'
   138|         0|            0|            0|  0.00%|    }
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|    def __init__(self, fab='', db='MES',
   141|         0|            0|            0|  0.00%|                 query_url=None, n_query_url=None,
   142|         0|            0|            0|  0.00%|                 db_name=None, ap_name=None, middle=None, heavy=False):
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|        middle = middle if middle else fab
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|        # dJfabMdbO_
   147|         0|            0|            0|  0.00%|        if fab.upper() not in DBObject._db_idx:
   148|         0|            0|            0|  0.00%|            raise FuncNotSupportError('Fab {} Not Found'.format(fab))
   149|         0|            0|            0|  0.00%|        elif middle and middle.upper() not in DBObject._db_idx:
   150|         0|            0|            0|  0.00%|            raise FuncNotSupportError('Middle Fab {} Not Found'.format(middle))
   151|         0|            0|            0|  0.00%|        elif db.upper() not in DBObject._db_cols:
   152|         0|            0|            0|  0.00%|            raise FuncNotSupportError('DB Name {} Not Found'.format(db))
   153|         0|            0|            0|  0.00%|        elif DBObject._db_name_df.loc[fab.upper()][db.upper()] == '':
   154|         0|            0|            0|  0.00%|            raise FuncNotSupportError('The Database is not support')
   155|         0|            0|            0|  0.00%|        elif middle and not middle.upper()[:3] == 'F12' and heavy:
   156|         0|            0|            0|  0.00%|            raise FuncNotSupportError('Heavy Group Only Support in F12')
   157|         0|            0|            0|  0.00%|        else:
   158|         0|            0|            0|  0.00%|            pass
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|        self.db_name = db_name if db_name else self._db_name_df.loc[fab.upper()][db.upper()]
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|        # middle_fab = middle.upper() if middle else fab
   163|         0|            0|            0|  0.00%|        middle_fab = 'F12_Heavy' if heavy else middle
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|        self.query_url = query_url if query_url else self._default_query_url[middle_fab.upper()]
   166|         0|            0|            0|  0.00%|        self.n_query_url = n_query_url if n_query_url else self._default_non_query_url[middle_fab.upper()]
   167|         0|            0|            0|  0.00%|        self.component = 'python.exe (DBSrv5ConnPy)'
   168|         0|            0|            0|  0.00%|        self.account = os.getlogin()
   169|         0|            0|            0|  0.00%|        self.host = os.environ['COMPUTERNAME']
   170|         0|            0|            0|  0.00%|        self.ip = socket.gethostbyname(self.host)
   171|         0|            0|            0|  0.00%|        self.ap_name = ap_name if ap_name else os.getcwd()[os.getcwd().index(':')+3:].replace('\\', '_')
   172|         0|            0|            0|  0.00%|        self.server = 'WebService'
   173|         0|            0|            0|  0.00%|        DBObject._app_info = DBObject._app_info.format(
   174|         0|            0|            0|  0.00%|            component=self.component, account=self.account, host=self.host, ip=self.ip, ap_name=self.ap_name, db_name=self.db_name, server=self.server)
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|    def _execute(self, sql, url, params, debug):
   177|         0|            0|            0|  0.00%|        """Private function used to query/nonquery function."""
   178|         0|            0|            0|  0.00%|
   179|         0|            0|            0|  0.00%|        if debug:  # debugnprintXSQL
   180|         0|            0|            0|  0.00%|            self._print_sql(sql, params)
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|        # 2019.03.14 SQLa (safe=string.printable) sXA percentage sign (%)  (%%)C[python 3.5]
   183|         0|            0|            0|  0.00%|        # https://stackoverflow.com/questions/10678229/how-can-i-selectively-escape-percent-in-python-strings
   184|         0|            0|            0|  0.00%|        # sql = sql.replace('%', '%%')
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|        # nWh}
   187|         0|            0|            0|  0.00%|        sql = self._app_info + '\n' + sql
   188|         0|            0|            0|  0.00%|
   189|         0|            0|            0|  0.00%|        headers = {
   190|         0|            0|            0|  0.00%|            "Content-type": "application/x-www-form-urlencoded",
   191|         0|            0|            0|  0.00%|            "Accept": "*/*"
   192|         0|            0|            0|  0.00%|        }
   193|         0|            0|            0|  0.00%|        if params:
   194|         0|            0|            0|  0.00%|            values = {
   195|         0|            0|            0|  0.00%|                'DB': self.db_name,
   196|         0|            0|            0|  0.00%|                'SQL': urllib.parse.quote_plus(sql, encoding='big5'),
   197|         0|            0|            0|  0.00%|                'Export': 'fastJSON',
   198|         0|            0|            0|  0.00%|                'Params': urllib.parse.quote_plus(str(params).replace("'", '"'), encoding='big5')
   199|         0|            0|            0|  0.00%|            }
   200|         0|            0|            0|  0.00%|        else:
   201|         0|            0|            0|  0.00%|            values = {
   202|         0|            0|            0|  0.00%|                'DB': self.db_name,
   203|         0|            0|            0|  0.00%|                'SQL': urllib.parse.quote_plus(sql, encoding='big5'),
   204|         0|            0|            0|  0.00%|                'Export': 'fastJSON'
   205|         0|            0|            0|  0.00%|            }
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|        data = urllib.parse.urlencode(values)
   208|         0|            0|            0|  0.00%|        binary_data = data.encode('big5')
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|        # POST and decode result
   211|         0|            0|            0|  0.00%|        req = urllib.request.Request(url, binary_data, headers)
   212|         0|            0|            0|  0.00%|        count = 0
   213|         0|            0|            0|  0.00%|        while True:  # suDBSrv5su5failN
   214|         0|            0|            0|  0.00%|            try:
   215|         0|            0|            0|  0.00%|                result = urllib.request.urlopen(req).read()
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\urllib\request.py:140 urlopen
   216|         0|            0|            0|  0.00%|            except urllib.error.HTTPError as err:
   217|         0|            0|            0|  0.00%|                if count > 4:
   218|         0|            0|            0|  0.00%|                    raise DBSrvConnError(err)
   219|         0|            0|            0|  0.00%|                count += 1
   220|         0|            0|            0|  0.00%|            else:
   221|         0|            0|            0|  0.00%|                result_decode = urllib.parse.unquote_plus(result.decode('big5'), encoding='big5')
   222|         0|            0|            0|  0.00%|                return result_decode
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|    def query(self, sql, params=None, df_return=True, debug=False):
   225|         0|            0|            0|  0.00%|        """Query database to retrieve data.
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|            Parameters
   228|         0|            0|            0|  0.00%|            ----------
   229|         0|            0|            0|  0.00%|            sql : str
   230|         0|            0|            0|  0.00%|                The SQL string you want to execute
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|            params : str, ``None`` by default
   233|         0|            0|            0|  0.00%|                The bind variable dictionary.
   234|         0|            0|            0|  0.00%|                If ``None`` will execute sql not in bind variable mode.
   235|         0|            0|            0|  0.00%|                You must have a space before parameter
   236|         0|            0|            0|  0.00%|                like 'TO_DATE( :DT, 'yyyy/mm/dd)'.
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|            df_return: boolean, ``True`` by default
   239|         0|            0|            0|  0.00%|                Which data structure you want to store for your query results.
   240|         0|            0|            0|  0.00%|                If ``True``, return pandas DataFrame object.
   241|         0|            0|            0|  0.00%|                If ``False``, return python list of tuple object.
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|            debug : boolean, ``False`` by default
   244|         0|            0|            0|  0.00%|                Print your SQL string for SQL string debug.
   245|         0|            0|            0|  0.00%|                If ``True``, print SQL string in console.
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|            Returns
   248|         0|            0|            0|  0.00%|            -------
   249|         0|            0|            0|  0.00%|            data :
   250|         0|            0|            0|  0.00%|                If df_return == ``True`` return pandas DataFrame object.
   251|         0|            0|            0|  0.00%|                If ``False``, return python list of tuple object.
   252|         0|            0|            0|  0.00%|                The SQL query result return from DBSrv5.
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|            Examples
   256|         0|            0|            0|  0.00%|            --------
   257|         0|            0|            0|  0.00%|            >>> from DBSrv5ConnPy.db_object import DBObject
   258|         0|            0|            0|  0.00%|            >>>
   259|         0|            0|            0|  0.00%|            >>> mes_obj = DBObject(fab='f12', db='mes')
   260|         0|            0|            0|  0.00%|            >>> sql = 'SELECT FILED1, VALUE FROM MFGDEV3.INFRA_TEST'
   261|         0|            0|            0|  0.00%|            >>> df = mes_obj.query(sql=sql, debug=False)
   262|         0|            0|            0|  0.00%|                    FILED1     VALUE
   263|         0|            0|            0|  0.00%|                0   PyTest4    7.0
   264|         0|            0|            0|  0.00%|                1              NaN
   265|         0|            0|            0|  0.00%|                2   PyTest4    7.0
   266|         0|            0|            0|  0.00%|                3              NaN
   267|         0|            0|            0|  0.00%|                4   PyTest4    7.0
   268|         0|            0|            0|  0.00%|                5              NaN
   269|         0|            0|            0|  0.00%|                6         g    5.0
   270|         0|            0|            0|  0.00%|            >>> data_tuple = mes_obj.query(sql=sql,  df_return=False, debug=False)
   271|         0|            0|            0|  0.00%|                (['FILED1', 'VALUE'], [('PyTest4', 7.0), ('', nan), ....])
   272|         0|            0|            0|  0.00%|            """
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|        result = self._execute(sql, self.query_url, params, debug)
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\DBSrv5ConnPy\db_object.py:176 _execute
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|        try:  # P_O_T^
   277|         0|            0|            0|  0.00%|            result = re.search('(?<=result":\[").+(?="]})', result, re.MULTILINE | re.DOTALL).group(0)
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|            # N_NN
   280|         0|            0|            0|  0.00%|            json_str = "<br thIsfOrrEplAcE/>".join(result.splitlines())
   281|         0|            0|            0|  0.00%|            json_str = json_str.replace('\t', "<br thIsfOrrEplAcE tab/>")
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|            # BzADBSrv5|^4u
   284|         0|            0|            0|  0.00%|            json_str = json_str.replace('\\\\"', '\\"')
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|            obj = json.loads(json_str)
   287|         0|            0|            0|  0.00%|        except Exception as err:  # pGSNOReturn Failo
   288|         0|            0|            0|  0.00%|            # pGOracle~TNIX
   289|         0|            0|            0|  0.00%|            if 'ORA-' in err.doc:
   290|         0|            0|            0|  0.00%|                err_msg = re.search('(?<=Fail : ).+(?=<br thIsfOrrEplAcE/><<Param>><<SQL>>)', err.doc).group(0)
   291|         0|            0|            0|  0.00%|            else:
   292|         0|            0|            0|  0.00%|                err_msg = err.doc
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|            err_str = "Parsing return message fail, return error is [ {0} ]".format(err_msg)
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|            raise ReturnError(err_str)
   297|         0|            0|            0|  0.00%|        else:  # T^N^
   298|         0|            0|            0|  0.00%|            cols = [col for col in obj['$schema']['Info'] if not col == "" and 'System' not in col]
   299|         0|            0|            0|  0.00%|            col_type = [col for col in obj['$schema']['Info'] if 'System' in col]
   300|         0|            0|            0|  0.00%|            data_type = dict(zip(cols, col_type))
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|            # N_NN^
   303|         0|            0|            0|  0.00%|            data = [[cell.replace("<br thIsfOrrEplAcE/>", "\n").replace("<br thIsfOrrEplAcE tab/>", "\t") for cell in row]
   304|         0|            0|            0|  0.00%|                    for row in obj[""]]
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|            df = pd.DataFrame(data, columns=cols)
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|            # ^NULLrNNaN
   309|         0|            0|            0|  0.00%|            df = df.replace('NULL', np.nan)
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|            # P_service^OdfO
   312|         0|            0|            0|  0.00%|            df = self._data_type_convert(df, data_type)
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\DBSrv5ConnPy\db_object.py:605 _data_type_convert
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|            # ^DataFrameO^@Tuple
   315|         0|            0|            0|  0.00%|            if df_return:
   316|         0|            0|            0|  0.00%|                return df
   317|         0|            0|            0|  0.00%|            else:
   318|         0|            0|            0|  0.00%|                dtype = [col for col in df.columns]
   319|         0|            0|            0|  0.00%|                dvalue = [tuple(x) for x in df.values]
   320|         0|            0|            0|  0.00%|                return (dtype, dvalue,)
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|    def non_query(self, sql=None, params=None, df=None,
   323|         0|            0|            0|  0.00%|                  pri_cols=None, cols=None, table=None,
   324|         0|            0|            0|  0.00%|                  nqtype=None, chunksize=100, debug=False):
   325|         0|            0|            0|  0.00%|        """Execute update/insert SQL string in database.
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|            Parameters
   328|         0|            0|            0|  0.00%|            ----------
   329|         0|            0|            0|  0.00%|            sql : str, ``None`` by default
   330|         0|            0|            0|  0.00%|                The SQL string you want to execute.
   331|         0|            0|            0|  0.00%|                If sql is not ``None``, will execute SQL string directly.
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|            params : str, ``None`` by default
   334|         0|            0|            0|  0.00%|                The bind variable dictionary.
   335|         0|            0|            0|  0.00%|                If ``None`` will not execute sql in bind variable mode.
   336|         0|            0|            0|  0.00%|                Bind variable is not support in DataFrame insert/update
   337|         0|            0|            0|  0.00%|                function.
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|            df : DataFrame, ``None`` by default
   340|         0|            0|            0|  0.00%|                The DataFrame generate update/insert SQL string and
   341|         0|            0|            0|  0.00%|                execute directly by DBSrv5.
   342|         0|            0|            0|  0.00%|                If df is ``None``, will generate SQL string from df
   343|         0|            0|            0|  0.00%|                and execute directly.
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|            pri_cols : list, ``None`` by default
   346|         0|            0|            0|  0.00%|                The where condition columns in auto-generated SQL.
   347|         0|            0|            0|  0.00%|                If sql is ``None`` and nqtype == ``update`` will generate SQL
   348|         0|            0|            0|  0.00%|                string from df and where condition columns of update SQL
   349|         0|            0|            0|  0.00%|                string will composite by pri_cols.
   350|         0|            0|            0|  0.00%|
   351|         0|            0|            0|  0.00%|            cols : list, ``None`` by default
   352|         0|            0|            0|  0.00%|                The where condition columns with all select columns in update
   353|         0|            0|            0|  0.00%|                command or all insert columns in insert command.
   354|         0|            0|            0|  0.00%|                If sql is ``None`` and nqtype == ``update`` will generate SQL
   355|         0|            0|            0|  0.00%|                string from df and the where condition columns of update SQL
   356|         0|            0|            0|  0.00%|                string will composite by pri_cols.
   357|         0|            0|            0|  0.00%|                The remain columns will be select columns.
   358|         0|            0|            0|  0.00%|                If sql is ``None`` and nqtype == ``insert`` will generate SQL
   359|         0|            0|            0|  0.00%|                string from df and all insert columns will be cols.
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|            table : str, ``None`` by default
   362|         0|            0|            0|  0.00%|                The table name you want to execute insert/update command.
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|            nqtype : str, ``None`` by default
   365|         0|            0|            0|  0.00%|                insert / update command you want to execute.
   366|         0|            0|            0|  0.00%|                If nqtype == ``insert`` will generate insert SQL string.
   367|         0|            0|            0|  0.00%|                If nqtype == ``update`` will generate update SQL string.
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|            chunksize : int, ``100`` by default
   370|         0|            0|            0|  0.00%|                The records in one commit
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|            debug : boolean, ``False`` by default
   373|         0|            0|            0|  0.00%|                Print your SQL string for SQL string debug.
   374|         0|            0|            0|  0.00%|                If ``True``, print SQL string in console.
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|            Examples
   378|         0|            0|            0|  0.00%|            --------
   379|         0|            0|            0|  0.00%|            >>> from DBSrv5ConnPy.db_object import DBObject
   380|         0|            0|            0|  0.00%|            >>>
   381|         0|            0|            0|  0.00%|            >>> mes_obj = DBObject(fab='f12', db='mes')
   382|         0|            0|            0|  0.00%|            >>> feature = {}
   383|         0|            0|            0|  0.00%|            >>> feature['FILED1'] = ['test', 'PyTest1', 'PyTest2',
   384|         0|            0|            0|  0.00%|            >>>                      'PyTest3', 'PyTest4', np.nan]
   385|         0|            0|            0|  0.00%|            >>> feature['VALUE'] = [0, np.nan, 5, 6, 7, np.nan]
   386|         0|            0|            0|  0.00%|            >>> feature['RECTIME'] = [pd.Timestamp('20141213'),
   387|         0|            0|            0|  0.00%|            >>>                       np.datetime64('NaT'),
   388|         0|            0|            0|  0.00%|            >>>                       np.nan, np.nan, np.nan, np.nan]
   389|         0|            0|            0|  0.00%|            >>> df = pd.DataFrame(feature,
   390|         0|            0|            0|  0.00%|            >>>                   columns=['FILED1', 'VALUE', 'RECTIME'])
   391|         0|            0|            0|  0.00%|            >>> mes_obj.non_query(df=df, cols=['FILED1', 'VALUE', 'RECTIME'],
   392|         0|            0|            0|  0.00%|            >>>                   table='MFGDEV3.INFRA_TEST', chunksize=4,
   393|         0|            0|            0|  0.00%|            >>>                   nqtype='insert', debug=True)
   394|         0|            0|            0|  0.00%|                OK, 4 row(s) affected
   395|         0|            0|            0|  0.00%|            """
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|        if sql:  # USQLsu
   398|         0|            0|            0|  0.00%|            result = self._execute(sql, self.n_query_url, params, debug)
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|            # P_insert/updateSoReturn Fail
   401|         0|            0|            0|  0.00%|            status = json.loads(result.replace('\n', ''))
   402|         0|            0|            0|  0.00%|            success = True if status['result'][0][0:2] == 'OK' else False
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|            if success:
   405|         0|            0|            0|  0.00%|                msg = status['result'][0]
   406|         0|            0|            0|  0.00%|                if debug:
   407|         0|            0|            0|  0.00%|                    print(status['result'][0])
   408|         0|            0|            0|  0.00%|            else:
   409|         0|            0|            0|  0.00%|                raise ReturnError(status['result'][0])
   410|         0|            0|            0|  0.00%|        else:  # DataFrameinsertOupdate
   411|         0|            0|            0|  0.00%|            if nqtype:
   412|         0|            0|            0|  0.00%|                if nqtype.lower() == 'insert':
   413|         0|            0|            0|  0.00%|                    self._to_insert_sql(df, cols, table, params, chunksize, debug)
   414|         0|            0|            0|  0.00%|                if nqtype.lower() == 'update':
   415|         0|            0|            0|  0.00%|                    self._to_update_sql(df, pri_cols, cols, table, params, chunksize, debug)
   416|         0|            0|            0|  0.00%|            else:
   417|         0|            0|            0|  0.00%|                raise FuncNotSupportError('Please select non query type when using DataFrame to manipulate table')
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|    def _to_insert_sql(self, df, cols, table, params, chunksize, debug):
   420|         0|            0|            0|  0.00%|        """Private function used to non_query function."""
   421|         0|            0|            0|  0.00%|        if params:
   422|         0|            0|            0|  0.00%|            raise FuncNotSupportError('Not support in current version. DataFrame with bind variable will cause DBsrv5 fail')
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|        template_sql = """
   425|         0|            0|            0|  0.00%|        INSERT INTO {table} ({column})
   426|         0|            0|            0|  0.00%|        VALUES ( {value});"""
   427|         0|            0|            0|  0.00%|        insert_sql = """        BEGIN{all_insert}
   428|         0|            0|            0|  0.00%|        END;"""
   429|         0|            0|            0|  0.00%|
   430|         0|            0|            0|  0.00%|        all_insert = ''
   431|         0|            0|            0|  0.00%|        # ncol nameA_AKcol name
   432|         0|            0|            0|  0.00%|        cols_str = ', '.join(['"' + col + '"' for col in cols])
   433|         0|            0|            0|  0.00%|        for idx, row in enumerate(df[cols].itertuples(index=False, name=False)):
   434|         0|            0|            0|  0.00%|            if params:
   435|         0|            0|            0|  0.00%|                bind_val_str = ', '.join([':' + x for x in cols])
   436|         0|            0|            0|  0.00%|                bind_var = dict(zip(cols, row))
   437|         0|            0|            0|  0.00%|                # nanNNULL
   438|         0|            0|            0|  0.00%|                for col, value in bind_var.items():
   439|         0|            0|            0|  0.00%|                    if 'TIMESTAMP' in repr(value).upper():
   440|         0|            0|            0|  0.00%|                        bind_var[col] = repr(value).replace("(", '').replace(")", '')
   441|         0|            0|            0|  0.00%|                    elif 'nan' in str(value):
   442|         0|            0|            0|  0.00%|                        bind_var[col] = 'NULL'
   443|         0|            0|            0|  0.00%|                    elif 'NaT' in str(value):
   444|         0|            0|            0|  0.00%|                        bind_var[col] = 'NULL'
   445|         0|            0|            0|  0.00%|                    else:
   446|         0|            0|            0|  0.00%|                        bind_var[col] = value
   447|         0|            0|            0|  0.00%|
   448|         0|            0|            0|  0.00%|                all_insert = template_sql.format(table=table, column=cols_str, value=bind_val_str)
   449|         0|            0|            0|  0.00%|                insert_sql = insert_sql.format(all_insert=all_insert)
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|                result = self._execute(insert_sql, self.n_query_url, bind_var, debug)
   452|         0|            0|            0|  0.00%|                # P_insert/updateSoReturn Fail
   453|         0|            0|            0|  0.00%|                status = json.loads(result.replace('\n', ''))
   454|         0|            0|            0|  0.00%|                success = True if status['result'][0][0:2] == 'OK' else False
   455|         0|            0|            0|  0.00%|                if success:
   456|         0|            0|            0|  0.00%|                    msg = status['result'][0]
   457|         0|            0|            0|  0.00%|                    if debug:
   458|         0|            0|            0|  0.00%|                        print(status['result'][0])
   459|         0|            0|            0|  0.00%|                else:
   460|         0|            0|            0|  0.00%|                    raise ReturnError(status['result'][0])
   461|         0|            0|            0|  0.00%|
   462|         0|            0|            0|  0.00%|            else:
   463|         0|            0|            0|  0.00%|                val_list = []
   464|         0|            0|            0|  0.00%|                for val_str in '<br thIsfOrrEplAcE/>'.join(repr(_) for _ in row).split('<br thIsfOrrEplAcE/>'):
   465|         0|            0|            0|  0.00%|                    if 'TIMESTAMP' in val_str.upper():
   466|         0|            0|            0|  0.00%|                        val_list.append(val_str.replace("(", '').replace(")", ''))
   467|         0|            0|            0|  0.00%|                    elif 'nan' in val_str:
   468|         0|            0|            0|  0.00%|                        val_list.append('NULL')
   469|         0|            0|            0|  0.00%|                    elif 'NaT' in val_str:
   470|         0|            0|            0|  0.00%|                        val_list.append('NULL')
   471|         0|            0|            0|  0.00%|                    else:
   472|         0|            0|            0|  0.00%|                        val_list.append(val_str)
   473|         0|            0|            0|  0.00%|
   474|         0|            0|            0|  0.00%|                pur_val_str = ', '.join(val_list)
   475|         0|            0|            0|  0.00%|
   476|         0|            0|            0|  0.00%|                all_insert += template_sql.format(table=table, column=cols_str, value=pur_val_str)
   477|         0|            0|            0|  0.00%|                insert_sql_str = insert_sql.format(all_insert=all_insert)
   478|         0|            0|            0|  0.00%|                if (idx+1) % chunksize == 0 or idx == len(df.index)-1:
   479|         0|            0|            0|  0.00%|                    result = self._execute(insert_sql_str, self.n_query_url, params, debug)
   480|         0|            0|            0|  0.00%|                    # P_insert/updateSoReturn Fail
   481|         0|            0|            0|  0.00%|                    status = json.loads(result.replace('\n', ''))
   482|         0|            0|            0|  0.00%|                    success = True if status['result'][0][0:2] == 'OK' else False
   483|         0|            0|            0|  0.00%|                    if success:
   484|         0|            0|            0|  0.00%|                        msg = status['result'][0]
   485|         0|            0|            0|  0.00%|                        if debug:
   486|         0|            0|            0|  0.00%|                            print(status['result'][0])
   487|         0|            0|            0|  0.00%|                    else:
   488|         0|            0|            0|  0.00%|                        raise ReturnError(status['result'][0])
   489|         0|            0|            0|  0.00%|                    all_insert = ''
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|    def _to_update_sql(self, df, pri_cols, cols, table, params, chunksize, debug):
   492|         0|            0|            0|  0.00%|        """Private function used to non_query function."""
   493|         0|            0|            0|  0.00%|        if params:
   494|         0|            0|            0|  0.00%|            raise FuncNotSupportError('Not support in current version. DataFrame with bind variable will cause DBsrv5 fail')
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|        # Kpri_colsSQ]tbcolsywhereS
   497|         0|            0|            0|  0.00%|        cols = list(set(cols + pri_cols))
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|        template_sql = """
   500|         0|            0|            0|  0.00%|        UPDATE {table}
   501|         0|            0|            0|  0.00%|           SET {cols}
   502|         0|            0|            0|  0.00%|         WHERE 1=1
   503|         0|            0|            0|  0.00%|        {pri_key};"""
   504|         0|            0|            0|  0.00%|        update_sql = """        BEGIN{all_update}
   505|         0|            0|            0|  0.00%|        END;"""
   506|         0|            0|            0|  0.00%|        all_update = ''
   507|         0|            0|            0|  0.00%|        for idx, row in enumerate(df[cols].itertuples(index=False)):
   508|         0|            0|            0|  0.00%|            row_dict = row._asdict()
   509|         0|            0|            0|  0.00%|            pri_cols = {k: v for k, v in row_dict.items() if k in pri_cols}
   510|         0|            0|            0|  0.00%|            set_cols = {k: v for k, v in row_dict.items() if k not in pri_cols}
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|            # setnstrMwherenstr
   513|         0|            0|            0|  0.00%|            pri_key_str = ''
   514|         0|            0|            0|  0.00%|            for pri_idx, pri_data in enumerate(pri_cols.items()):
   515|         0|            0|            0|  0.00%|                pri_col = pri_data[0]
   516|         0|            0|            0|  0.00%|                pri_val = "'{}'".format(pri_data[1]) if isinstance(pri_data[1], str) else pri_data[1]
   517|         0|            0|            0|  0.00%|                select_pri_val = ':' + pri_col if params else pri_val
   518|         0|            0|            0|  0.00%|                # pGOTimestampAnreprXk
   519|         0|            0|            0|  0.00%|                if 'TIMESTAMP' in repr(select_pri_val).upper():
   520|         0|            0|            0|  0.00%|                    partial_key = '  AND {} = {}'.format(pri_col, repr(select_pri_val).replace('(', '').replace(')', ''))
   521|         0|            0|            0|  0.00%|                else:
   522|         0|            0|            0|  0.00%|                    partial_key = '  AND {} = {}'.format(pri_col, select_pri_val)
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|                # BznanMNaTNULL
   525|         0|            0|            0|  0.00%|                if 'nan' in partial_key:
   526|         0|            0|            0|  0.00%|                    partial_key = partial_key.replace('nan', 'NULL')
   527|         0|            0|            0|  0.00%|                    partial_key = partial_key.replace('= NULL', 'IS NULL')
   528|         0|            0|            0|  0.00%|                if 'NaT' in partial_key:
   529|         0|            0|            0|  0.00%|                    partial_key = partial_key.replace('NaT', 'NULL')
   530|         0|            0|            0|  0.00%|                    partial_key = partial_key.replace('= NULL', 'IS NULL')
   531|         0|            0|            0|  0.00%|                pri_key_str += partial_key
   532|         0|            0|            0|  0.00%|                pri_key_str += '\n     ' if pri_idx + 1 != len(pri_cols) else ''
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|            set_val_str = ''
   535|         0|            0|            0|  0.00%|            for set_idx, set_data in enumerate(set_cols.items()):
   536|         0|            0|            0|  0.00%|                set_col = set_data[0]
   537|         0|            0|            0|  0.00%|                set_val = "'{}'".format(set_data[1].replace("'", "''")) if isinstance(set_data[1], str) else set_data[1]
   538|         0|            0|            0|  0.00%|                select_set_val = ':' + set_col if params else set_val
   539|         0|            0|            0|  0.00%|                # pGOTimestampAnreprXk
   540|         0|            0|            0|  0.00%|                if 'TIMESTAMP' in repr(select_set_val).upper():
   541|         0|            0|            0|  0.00%|                    partial_set = '{} = {}'.format(set_col, repr(select_set_val).replace('(', '').replace(')', ''))
   542|         0|            0|            0|  0.00%|                else:
   543|         0|            0|            0|  0.00%|                    partial_set = '{} = {}'.format(set_col, select_set_val)
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|                # BznanMNaTNULL
   546|         0|            0|            0|  0.00%|                if 'nan' in partial_set or 'NaT' in partial_set:
   547|         0|            0|            0|  0.00%|                    partial_set = partial_set.replace('nan', 'NULL')
   548|         0|            0|            0|  0.00%|                    partial_set = partial_set.replace('NaT', 'NULL')
   549|         0|            0|            0|  0.00%|                set_val_str += partial_set
   550|         0|            0|            0|  0.00%|                set_val_str += ',\n           ' if set_idx + 1 != len(set_cols) else ''
   551|         0|            0|            0|  0.00%|
   552|         0|            0|            0|  0.00%|            if params:
   553|         0|            0|            0|  0.00%|                all_update = template_sql.format(table=table, cols=set_val_str, pri_key=pri_key_str)
   554|         0|            0|            0|  0.00%|                update_sql = update_sql.format(all_update=all_update)
   555|         0|            0|            0|  0.00%|                bind_var = dict(row_dict)
   556|         0|            0|            0|  0.00%|                # nanNNULL
   557|         0|            0|            0|  0.00%|                for col, value in bind_var.items():
   558|         0|            0|            0|  0.00%|                    bind_var[col] = '' if str(value) == 'nan' else value
   559|         0|            0|            0|  0.00%|
   560|         0|            0|            0|  0.00%|                result = self._execute(update_sql, self.n_query_url, bind_var, debug)
   561|         0|            0|            0|  0.00%|                # P_insert/updateSoReturn Fail
   562|         0|            0|            0|  0.00%|                status = json.loads(result.replace('\n', ''))
   563|         0|            0|            0|  0.00%|                success = True if status['result'][0][0:2] == 'OK' else False
   564|         0|            0|            0|  0.00%|                if success:
   565|         0|            0|            0|  0.00%|                    msg = status['result'][0]
   566|         0|            0|            0|  0.00%|                    if debug:
   567|         0|            0|            0|  0.00%|                        print(status['result'][0])
   568|         0|            0|            0|  0.00%|                else:
   569|         0|            0|            0|  0.00%|                    raise ReturnError(status['result'][0])
   570|         0|            0|            0|  0.00%|            else:
   571|         0|            0|            0|  0.00%|                all_update += template_sql.format(table=table, cols=set_val_str, pri_key=pri_key_str)
   572|         0|            0|            0|  0.00%|                if (idx+1) % chunksize == 0 or idx == len(df.index)-1:
   573|         0|            0|            0|  0.00%|                    update_sql_str = update_sql.format(all_update=all_update)
   574|         0|            0|            0|  0.00%|                    all_update = ''
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|                    result = self._execute(update_sql_str, self.n_query_url, params, debug)
   577|         0|            0|            0|  0.00%|                    # P_insert/updateSoReturn Fail
   578|         0|            0|            0|  0.00%|                    status = json.loads(result.replace('\n', ''))
   579|         0|            0|            0|  0.00%|                    success = True if status['result'][0][0:2] == 'OK' else False
   580|         0|            0|            0|  0.00%|                    if success:
   581|         0|            0|            0|  0.00%|                        msg = status['result'][0]
   582|         0|            0|            0|  0.00%|                        if debug:
   583|         0|            0|            0|  0.00%|                            print(status['result'][0])
   584|         0|            0|            0|  0.00%|                    else:
   585|         0|            0|            0|  0.00%|                        raise ReturnError(status['result'][0])
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|    def _get_sql_str(self, sql, params):
   588|         0|            0|            0|  0.00%|        """Private function used to _print_sql function."""
   589|         0|            0|            0|  0.00%|        params = {k: "'" + v + "'" if isinstance(v, str) and 'TIMESTAMP' not in v.upper() else v
   590|         0|            0|            0|  0.00%|                  for k, v in params.items()}
   591|         0|            0|            0|  0.00%|        params_loc = re.findall('(?<= ):(?!MI|SS|mi|ss)\w+', sql)
   592|         0|            0|            0|  0.00%|        for loc in params_loc:
   593|         0|            0|            0|  0.00%|            sql = sql.replace(loc, '{' + loc[1:] + '}')
   594|         0|            0|            0|  0.00%|        sql = sql.format(**params)
   595|         0|            0|            0|  0.00%|        return sql
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|    def _print_sql(self, sql, params):
   598|         0|            0|            0|  0.00%|        """Private function used to _execute function."""
   599|         0|            0|            0|  0.00%|        if not params:
   600|         0|            0|            0|  0.00%|            print(sql)
   601|         0|            0|            0|  0.00%|        else:
   602|         0|            0|            0|  0.00%|            sql = self._get_sql_str(sql, params)
   603|         0|            0|            0|  0.00%|            print(sql)
   604|         0|            0|            0|  0.00%|
   605|         0|            0|            0|  0.00%|    def _data_type_convert(self, data_set, data_type):
   606|         0|            0|            0|  0.00%|        """Private function used to query function."""
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|        # Ndata_typesnumpyO
   609|         0|            0|            0|  0.00%|        for col, col_type in data_type.items():
   610|         0|            0|            0|  0.00%|            data_type[col] = DBObject._col_type[col_type]
   611|         0|            0|            0|  0.00%|        # v@NCDataFrameTnumpyO
   612|         0|            0|            0|  0.00%|        for col in data_set.columns:
   613|         0|            0|            0|  0.00%|            if data_type[col] == 'datetime64[ns]':
   614|         0|            0|            0|  0.00%|                data_set[col] = pd.to_datetime(data_set[col])
   615|         0|            0|            0|  0.00%|                data_set[col] = data_set[col].apply(self._tz_convert)  # Bz
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\pandas\core\series.py:2230 apply
   616|         0|            0|            0|  0.00%|            else:
   617|         0|            0|            0|  0.00%|                data_set[col] = data_set[col].astype(data_type[col])
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|        return data_set
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|    def _tz_convert(self, dt):
   622|         0|            0|            0|  0.00%|        """Private function used to _data_type_convert function."""
   623|         0|            0|            0|  0.00%|        import pytz
   624|         0|            0|            0|  0.00%|        if str(dt) == str(np.datetime64('nat')):
   625|         0|            0|            0|  0.00%|            return dt
   626|         0|            0|            0|  0.00%|        local_tz = pytz.timezone('Asia/Taipei')
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\pytz\__init__.py:126 timezone
   627|         0|            0|            0|  0.00%|        return dt.replace(tzinfo=pytz.utc).astimezone(local_tz).replace(tzinfo=None)
File: D:\Application\Anaconda\lib\urllib\request.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""An extensible library for opening URLs using a variety of protocols
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|The simplest way to use this module is to call the urlopen function,
     4|         0|            0|            0|  0.00%|which accepts a string containing a URL or a Request object (described
     5|         0|            0|            0|  0.00%|below).  It opens the URL and returns the results as file-like
     6|         0|            0|            0|  0.00%|object; the returned object has some extra methods described below.
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|The OpenerDirector manages a collection of Handler objects that do
     9|         0|            0|            0|  0.00%|all the actual work.  Each Handler implements a particular protocol or
    10|         0|            0|            0|  0.00%|option.  The OpenerDirector is a composite object that invokes the
    11|         0|            0|            0|  0.00%|Handlers needed to open the requested URL.  For example, the
    12|         0|            0|            0|  0.00%|HTTPHandler performs HTTP GET and POST requests and deals with
    13|         0|            0|            0|  0.00%|non-error returns.  The HTTPRedirectHandler automatically deals with
    14|         0|            0|            0|  0.00%|HTTP 301, 302, 303 and 307 redirect errors, and the HTTPDigestAuthHandler
    15|         0|            0|            0|  0.00%|deals with digest authentication.
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|urlopen(url, data=None) -- Basic usage is the same as original
    18|         0|            0|            0|  0.00%|urllib.  pass the url and optionally data to post to an HTTP URL, and
    19|         0|            0|            0|  0.00%|get a file-like object back.  One difference is that you can also pass
    20|         0|            0|            0|  0.00%|a Request instance instead of URL.  Raises a URLError (subclass of
    21|         0|            0|            0|  0.00%|OSError); for HTTP errors, raises an HTTPError, which can also be
    22|         0|            0|            0|  0.00%|treated as a valid response.
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|build_opener -- Function that creates a new OpenerDirector instance.
    25|         0|            0|            0|  0.00%|Will install the default handlers.  Accepts one or more Handlers as
    26|         0|            0|            0|  0.00%|arguments, either instances or Handler classes that it will
    27|         0|            0|            0|  0.00%|instantiate.  If one of the argument is a subclass of the default
    28|         0|            0|            0|  0.00%|handler, the argument will be installed instead of the default.
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|install_opener -- Installs a new opener as the default opener.
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|objects of interest:
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|OpenerDirector -- Sets up the User Agent as the Python-urllib client and manages
    35|         0|            0|            0|  0.00%|the Handler classes, while dealing with requests and responses.
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|Request -- An object that encapsulates the state of a request.  The
    38|         0|            0|            0|  0.00%|state can be as simple as the URL.  It can also include extra HTTP
    39|         0|            0|            0|  0.00%|headers, e.g. a User-Agent.
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|BaseHandler --
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|internals:
    44|         0|            0|            0|  0.00%|BaseHandler and parent
    45|         0|            0|            0|  0.00%|_call_chain conventions
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|Example usage:
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|import urllib.request
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|# set up authentication info
    52|         0|            0|            0|  0.00%|authinfo = urllib.request.HTTPBasicAuthHandler()
    53|         0|            0|            0|  0.00%|authinfo.add_password(realm='PDQ Application',
    54|         0|            0|            0|  0.00%|                      uri='https://mahler:8092/site-updates.py',
    55|         0|            0|            0|  0.00%|                      user='klem',
    56|         0|            0|            0|  0.00%|                      passwd='geheim$parole')
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|proxy_support = urllib.request.ProxyHandler({"http" : "http://ahad-haam:3128"})
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|# build a new opener that adds authentication and caching FTP handlers
    61|         0|            0|            0|  0.00%|opener = urllib.request.build_opener(proxy_support, authinfo,
    62|         0|            0|            0|  0.00%|                                     urllib.request.CacheFTPHandler)
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|# install it
    65|         0|            0|            0|  0.00%|urllib.request.install_opener(opener)
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|f = urllib.request.urlopen('http://www.python.org/')
    68|         0|            0|            0|  0.00%|"""
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|# XXX issues:
    71|         0|            0|            0|  0.00%|# If an authentication error handler that tries to perform
    72|         0|            0|            0|  0.00%|# authentication for some reason but fails, how should the error be
    73|         0|            0|            0|  0.00%|# signalled?  The client needs to know the HTTP error code.  But if
    74|         0|            0|            0|  0.00%|# the handler knows that the problem was, e.g., that it didn't know
    75|         0|            0|            0|  0.00%|# that hash algo that requested in the challenge, it would be good to
    76|         0|            0|            0|  0.00%|# pass that information along to the client, too.
    77|         0|            0|            0|  0.00%|# ftp errors aren't handled cleanly
    78|         0|            0|            0|  0.00%|# check digest against correct (i.e. non-apache) implementation
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|# Possible extensions:
    81|         0|            0|            0|  0.00%|# complex proxies  XXX not sure what exactly was meant by this
    82|         0|            0|            0|  0.00%|# abstract factory for opener
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|import base64
    85|         0|            0|            0|  0.00%|import bisect
    86|         0|            0|            0|  0.00%|import email
    87|         0|            0|            0|  0.00%|import hashlib
    88|         0|            0|            0|  0.00%|import http.client
    89|         0|            0|            0|  0.00%|import io
    90|         0|            0|            0|  0.00%|import os
    91|         0|            0|            0|  0.00%|import posixpath
    92|         0|            0|            0|  0.00%|import re
    93|         0|            0|            0|  0.00%|import socket
    94|         0|            0|            0|  0.00%|import string
    95|         0|            0|            0|  0.00%|import sys
    96|         0|            0|            0|  0.00%|import time
    97|         0|            0|            0|  0.00%|import collections
    98|         0|            0|            0|  0.00%|import tempfile
    99|         0|            0|            0|  0.00%|import contextlib
   100|         0|            0|            0|  0.00%|import warnings
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|from urllib.error import URLError, HTTPError, ContentTooShortError
   104|         0|            0|            0|  0.00%|from urllib.parse import (
   105|         0|            0|            0|  0.00%|    urlparse, urlsplit, urljoin, unwrap, quote, unquote,
   106|         0|            0|            0|  0.00%|    splittype, splithost, splitport, splituser, splitpasswd,
   107|         0|            0|            0|  0.00%|    splitattr, splitquery, splitvalue, splittag, to_bytes,
   108|         0|            0|            0|  0.00%|    unquote_to_bytes, urlunparse)
   109|         0|            0|            0|  0.00%|from urllib.response import addinfourl, addclosehook
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|# check for SSL
   112|         0|            0|            0|  0.00%|try:
   113|         0|            0|            0|  0.00%|    import ssl
   114|         0|            0|            0|  0.00%|except ImportError:
   115|         0|            0|            0|  0.00%|    _have_ssl = False
   116|         0|            0|            0|  0.00%|else:
   117|         0|            0|            0|  0.00%|    _have_ssl = True
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|__all__ = [
   120|         0|            0|            0|  0.00%|    # Classes
   121|         0|            0|            0|  0.00%|    'Request', 'OpenerDirector', 'BaseHandler', 'HTTPDefaultErrorHandler',
   122|         0|            0|            0|  0.00%|    'HTTPRedirectHandler', 'HTTPCookieProcessor', 'ProxyHandler',
   123|         0|            0|            0|  0.00%|    'HTTPPasswordMgr', 'HTTPPasswordMgrWithDefaultRealm',
   124|         0|            0|            0|  0.00%|    'HTTPPasswordMgrWithPriorAuth', 'AbstractBasicAuthHandler',
   125|         0|            0|            0|  0.00%|    'HTTPBasicAuthHandler', 'ProxyBasicAuthHandler', 'AbstractDigestAuthHandler',
   126|         0|            0|            0|  0.00%|    'HTTPDigestAuthHandler', 'ProxyDigestAuthHandler', 'HTTPHandler',
   127|         0|            0|            0|  0.00%|    'FileHandler', 'FTPHandler', 'CacheFTPHandler', 'DataHandler',
   128|         0|            0|            0|  0.00%|    'UnknownHandler', 'HTTPErrorProcessor',
   129|         0|            0|            0|  0.00%|    # Functions
   130|         0|            0|            0|  0.00%|    'urlopen', 'install_opener', 'build_opener',
   131|         0|            0|            0|  0.00%|    'pathname2url', 'url2pathname', 'getproxies',
   132|         0|            0|            0|  0.00%|    # Legacy interface
   133|         0|            0|            0|  0.00%|    'urlretrieve', 'urlcleanup', 'URLopener', 'FancyURLopener',
   134|         0|            0|            0|  0.00%|]
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|# used in User-Agent header sent
   137|         0|            0|            0|  0.00%|__version__ = '%d.%d' % sys.version_info[:2]
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|_opener = None
   140|         0|            0|            0|  0.00%|def urlopen(url, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
   141|         0|            0|            0|  0.00%|            *, cafile=None, capath=None, cadefault=False, context=None):
   142|         0|            0|            0|  0.00%|    '''Open the URL url, which can be either a string or a Request object.
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    *data* must be an object specifying additional data to be sent to
   145|         0|            0|            0|  0.00%|    the server, or None if no such data is needed.  See Request for
   146|         0|            0|            0|  0.00%|    details.
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|    urllib.request module uses HTTP/1.1 and includes a "Connection:close"
   149|         0|            0|            0|  0.00%|    header in its HTTP requests.
   150|         0|            0|            0|  0.00%|
   151|         0|            0|            0|  0.00%|    The optional *timeout* parameter specifies a timeout in seconds for
   152|         0|            0|            0|  0.00%|    blocking operations like the connection attempt (if not specified, the
   153|         0|            0|            0|  0.00%|    global default timeout setting will be used). This only works for HTTP,
   154|         0|            0|            0|  0.00%|    HTTPS and FTP connections.
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|    If *context* is specified, it must be a ssl.SSLContext instance describing
   157|         0|            0|            0|  0.00%|    the various SSL options. See HTTPSConnection for more details.
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|    The optional *cafile* and *capath* parameters specify a set of trusted CA
   160|         0|            0|            0|  0.00%|    certificates for HTTPS requests. cafile should point to a single file
   161|         0|            0|            0|  0.00%|    containing a bundle of CA certificates, whereas capath should point to a
   162|         0|            0|            0|  0.00%|    directory of hashed certificate files. More information can be found in
   163|         0|            0|            0|  0.00%|    ssl.SSLContext.load_verify_locations().
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|    The *cadefault* parameter is ignored.
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|    This function always returns an object which can work as a context
   168|         0|            0|            0|  0.00%|    manager and has methods such as
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    * geturl() - return the URL of the resource retrieved, commonly used to
   171|         0|            0|            0|  0.00%|      determine if a redirect was followed
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|    * info() - return the meta-information of the page, such as headers, in the
   174|         0|            0|            0|  0.00%|      form of an email.message_from_string() instance (see Quick Reference to
   175|         0|            0|            0|  0.00%|      HTTP Headers)
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|    * getcode() - return the HTTP status code of the response.  Raises URLError
   178|         0|            0|            0|  0.00%|      on errors.
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|    For HTTP and HTTPS URLs, this function returns a http.client.HTTPResponse
   181|         0|            0|            0|  0.00%|    object slightly modified. In addition to the three new methods above, the
   182|         0|            0|            0|  0.00%|    msg attribute contains the same information as the reason attribute ---
   183|         0|            0|            0|  0.00%|    the reason phrase returned by the server --- instead of the response
   184|         0|            0|            0|  0.00%|    headers as it is specified in the documentation for HTTPResponse.
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|    For FTP, file, and data URLs and requests explicitly handled by legacy
   187|         0|            0|            0|  0.00%|    URLopener and FancyURLopener classes, this function returns a
   188|         0|            0|            0|  0.00%|    urllib.response.addinfourl object.
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|    Note that None may be returned if no handler handles the request (though
   191|         0|            0|            0|  0.00%|    the default installed global OpenerDirector uses UnknownHandler to ensure
   192|         0|            0|            0|  0.00%|    this never happens).
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|    In addition, if proxy settings are detected (for example, when a *_proxy
   195|         0|            0|            0|  0.00%|    environment variable like http_proxy is set), ProxyHandler is default
   196|         0|            0|            0|  0.00%|    installed and makes sure the requests are handled through the proxy.
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    '''
   199|         0|            0|            0|  0.00%|    global _opener
   200|         0|            0|            0|  0.00%|    if cafile or capath or cadefault:
   201|         0|            0|            0|  0.00%|        import warnings
   202|         0|            0|            0|  0.00%|        warnings.warn("cafile, cpath and cadefault are deprecated, use a "
   203|         0|            0|            0|  0.00%|                      "custom context instead.", DeprecationWarning, 2)
   204|         0|            0|            0|  0.00%|        if context is not None:
   205|         0|            0|            0|  0.00%|            raise ValueError(
   206|         0|            0|            0|  0.00%|                "You can't pass both context and any of cafile, capath, and "
   207|         0|            0|            0|  0.00%|                "cadefault"
   208|         0|            0|            0|  0.00%|            )
   209|         0|            0|            0|  0.00%|        if not _have_ssl:
   210|         0|            0|            0|  0.00%|            raise ValueError('SSL support not available')
   211|         0|            0|            0|  0.00%|        context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,
   212|         0|            0|            0|  0.00%|                                             cafile=cafile,
   213|         0|            0|            0|  0.00%|                                             capath=capath)
   214|         0|            0|            0|  0.00%|        https_handler = HTTPSHandler(context=context)
   215|         0|            0|            0|  0.00%|        opener = build_opener(https_handler)
   216|         0|            0|            0|  0.00%|    elif context:
   217|         0|            0|            0|  0.00%|        https_handler = HTTPSHandler(context=context)
   218|         0|            0|            0|  0.00%|        opener = build_opener(https_handler)
   219|         0|            0|            0|  0.00%|    elif _opener is None:
   220|         0|            0|            0|  0.00%|        _opener = opener = build_opener()
   221|         0|            0|            0|  0.00%|    else:
   222|         0|            0|            0|  0.00%|        opener = _opener
   223|         0|            0|            0|  0.00%|    return opener.open(url, data, timeout)
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\urllib\request.py:508 open
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|def install_opener(opener):
   226|         0|            0|            0|  0.00%|    global _opener
   227|         0|            0|            0|  0.00%|    _opener = opener
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|_url_tempfiles = []
   230|         0|            0|            0|  0.00%|def urlretrieve(url, filename=None, reporthook=None, data=None):
   231|         0|            0|            0|  0.00%|    """
   232|         0|            0|            0|  0.00%|    Retrieve a URL into a temporary location on disk.
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|    Requires a URL argument. If a filename is passed, it is used as
   235|         0|            0|            0|  0.00%|    the temporary file location. The reporthook argument should be
   236|         0|            0|            0|  0.00%|    a callable that accepts a block number, a read size, and the
   237|         0|            0|            0|  0.00%|    total file size of the URL target. The data argument should be
   238|         0|            0|            0|  0.00%|    valid URL encoded data.
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|    If a filename is passed and the URL points to a local resource,
   241|         0|            0|            0|  0.00%|    the result is a copy from local file to new file.
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|    Returns a tuple containing the path to the newly created
   244|         0|            0|            0|  0.00%|    data file as well as the resulting HTTPMessage object.
   245|         0|            0|            0|  0.00%|    """
   246|         0|            0|            0|  0.00%|    url_type, path = splittype(url)
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|    with contextlib.closing(urlopen(url, data)) as fp:
   249|         0|            0|            0|  0.00%|        headers = fp.info()
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|        # Just return the local path and the "headers" for file://
   252|         0|            0|            0|  0.00%|        # URLs. No sense in performing a copy unless requested.
   253|         0|            0|            0|  0.00%|        if url_type == "file" and not filename:
   254|         0|            0|            0|  0.00%|            return os.path.normpath(path), headers
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|        # Handle temporary file setup.
   257|         0|            0|            0|  0.00%|        if filename:
   258|         0|            0|            0|  0.00%|            tfp = open(filename, 'wb')
   259|         0|            0|            0|  0.00%|        else:
   260|         0|            0|            0|  0.00%|            tfp = tempfile.NamedTemporaryFile(delete=False)
   261|         0|            0|            0|  0.00%|            filename = tfp.name
   262|         0|            0|            0|  0.00%|            _url_tempfiles.append(filename)
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|        with tfp:
   265|         0|            0|            0|  0.00%|            result = filename, headers
   266|         0|            0|            0|  0.00%|            bs = 1024*8
   267|         0|            0|            0|  0.00%|            size = -1
   268|         0|            0|            0|  0.00%|            read = 0
   269|         0|            0|            0|  0.00%|            blocknum = 0
   270|         0|            0|            0|  0.00%|            if "content-length" in headers:
   271|         0|            0|            0|  0.00%|                size = int(headers["Content-Length"])
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|            if reporthook:
   274|         0|            0|            0|  0.00%|                reporthook(blocknum, bs, size)
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|            while True:
   277|         0|            0|            0|  0.00%|                block = fp.read(bs)
   278|         0|            0|            0|  0.00%|                if not block:
   279|         0|            0|            0|  0.00%|                    break
   280|         0|            0|            0|  0.00%|                read += len(block)
   281|         0|            0|            0|  0.00%|                tfp.write(block)
   282|         0|            0|            0|  0.00%|                blocknum += 1
   283|         0|            0|            0|  0.00%|                if reporthook:
   284|         0|            0|            0|  0.00%|                    reporthook(blocknum, bs, size)
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|    if size >= 0 and read < size:
   287|         0|            0|            0|  0.00%|        raise ContentTooShortError(
   288|         0|            0|            0|  0.00%|            "retrieval incomplete: got only %i out of %i bytes"
   289|         0|            0|            0|  0.00%|            % (read, size), result)
   290|         0|            0|            0|  0.00%|
   291|         0|            0|            0|  0.00%|    return result
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|def urlcleanup():
   294|         0|            0|            0|  0.00%|    """Clean up temporary files from urlretrieve calls."""
   295|         0|            0|            0|  0.00%|    for temp_file in _url_tempfiles:
   296|         0|            0|            0|  0.00%|        try:
   297|         0|            0|            0|  0.00%|            os.unlink(temp_file)
   298|         0|            0|            0|  0.00%|        except OSError:
   299|         0|            0|            0|  0.00%|            pass
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|    del _url_tempfiles[:]
   302|         0|            0|            0|  0.00%|    global _opener
   303|         0|            0|            0|  0.00%|    if _opener:
   304|         0|            0|            0|  0.00%|        _opener = None
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|# copied from cookielib.py
   307|         0|            0|            0|  0.00%|_cut_port_re = re.compile(r":\d+$", re.ASCII)
   308|         0|            0|            0|  0.00%|def request_host(request):
   309|         0|            0|            0|  0.00%|    """Return request-host, as defined by RFC 2965.
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|    Variation from RFC: returned value is lowercased, for convenient
   312|         0|            0|            0|  0.00%|    comparison.
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|    """
   315|         0|            0|            0|  0.00%|    url = request.full_url
   316|         0|            0|            0|  0.00%|    host = urlparse(url)[1]
   317|         0|            0|            0|  0.00%|    if host == "":
   318|         0|            0|            0|  0.00%|        host = request.get_header("Host", "")
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|    # remove port, if present
   321|         0|            0|            0|  0.00%|    host = _cut_port_re.sub("", host, 1)
   322|         0|            0|            0|  0.00%|    return host.lower()
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|class Request:
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|    def __init__(self, url, data=None, headers={},
   327|         0|            0|            0|  0.00%|                 origin_req_host=None, unverifiable=False,
   328|         0|            0|            0|  0.00%|                 method=None):
   329|         0|            0|            0|  0.00%|        self.full_url = url
   330|         0|            0|            0|  0.00%|        self.headers = {}
   331|         0|            0|            0|  0.00%|        self.unredirected_hdrs = {}
   332|         0|            0|            0|  0.00%|        self._data = None
   333|         0|            0|            0|  0.00%|        self.data = data
   334|         0|            0|            0|  0.00%|        self._tunnel_host = None
   335|         0|            0|            0|  0.00%|        for key, value in headers.items():
   336|         0|            0|            0|  0.00%|            self.add_header(key, value)
   337|         0|            0|            0|  0.00%|        if origin_req_host is None:
   338|         0|            0|            0|  0.00%|            origin_req_host = request_host(self)
   339|         0|            0|            0|  0.00%|        self.origin_req_host = origin_req_host
   340|         0|            0|            0|  0.00%|        self.unverifiable = unverifiable
   341|         0|            0|            0|  0.00%|        if method:
   342|         0|            0|            0|  0.00%|            self.method = method
   343|         0|            0|            0|  0.00%|
   344|         0|            0|            0|  0.00%|    @property
   345|         0|            0|            0|  0.00%|    def full_url(self):
   346|         0|            0|            0|  0.00%|        if self.fragment:
   347|         0|            0|            0|  0.00%|            return '{}#{}'.format(self._full_url, self.fragment)
   348|         0|            0|            0|  0.00%|        return self._full_url
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|    @full_url.setter
   351|         0|            0|            0|  0.00%|    def full_url(self, url):
   352|         0|            0|            0|  0.00%|        # unwrap('<URL:type://host/path>') --> 'type://host/path'
   353|         0|            0|            0|  0.00%|        self._full_url = unwrap(url)
   354|         0|            0|            0|  0.00%|        self._full_url, self.fragment = splittag(self._full_url)
   355|         0|            0|            0|  0.00%|        self._parse()
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|    @full_url.deleter
   358|         0|            0|            0|  0.00%|    def full_url(self):
   359|         0|            0|            0|  0.00%|        self._full_url = None
   360|         0|            0|            0|  0.00%|        self.fragment = None
   361|         0|            0|            0|  0.00%|        self.selector = ''
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|    @property
   364|         0|            0|            0|  0.00%|    def data(self):
   365|         0|            0|            0|  0.00%|        return self._data
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|    @data.setter
   368|         0|            0|            0|  0.00%|    def data(self, data):
   369|         0|            0|            0|  0.00%|        if data != self._data:
   370|         0|            0|            0|  0.00%|            self._data = data
   371|         0|            0|            0|  0.00%|            # issue 16464
   372|         0|            0|            0|  0.00%|            # if we change data we need to remove content-length header
   373|         0|            0|            0|  0.00%|            # (cause it's most probably calculated for previous value)
   374|         0|            0|            0|  0.00%|            if self.has_header("Content-length"):
   375|         0|            0|            0|  0.00%|                self.remove_header("Content-length")
   376|         0|            0|            0|  0.00%|
   377|         0|            0|            0|  0.00%|    @data.deleter
   378|         0|            0|            0|  0.00%|    def data(self):
   379|         0|            0|            0|  0.00%|        self.data = None
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|    def _parse(self):
   382|         0|            0|            0|  0.00%|        self.type, rest = splittype(self._full_url)
   383|         0|            0|            0|  0.00%|        if self.type is None:
   384|         0|            0|            0|  0.00%|            raise ValueError("unknown url type: %r" % self.full_url)
   385|         0|            0|            0|  0.00%|        self.host, self.selector = splithost(rest)
   386|         0|            0|            0|  0.00%|        if self.host:
   387|         0|            0|            0|  0.00%|            self.host = unquote(self.host)
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|    def get_method(self):
   390|         0|            0|            0|  0.00%|        """Return a string indicating the HTTP request method."""
   391|         0|            0|            0|  0.00%|        default_method = "POST" if self.data is not None else "GET"
   392|         0|            0|            0|  0.00%|        return getattr(self, 'method', default_method)
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|    def get_full_url(self):
   395|         0|            0|            0|  0.00%|        return self.full_url
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|    def set_proxy(self, host, type):
   398|         0|            0|            0|  0.00%|        if self.type == 'https' and not self._tunnel_host:
   399|         0|            0|            0|  0.00%|            self._tunnel_host = self.host
   400|         0|            0|            0|  0.00%|        else:
   401|         0|            0|            0|  0.00%|            self.type= type
   402|         0|            0|            0|  0.00%|            self.selector = self.full_url
   403|         0|            0|            0|  0.00%|        self.host = host
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|    def has_proxy(self):
   406|         0|            0|            0|  0.00%|        return self.selector == self.full_url
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|    def add_header(self, key, val):
   409|         0|            0|            0|  0.00%|        # useful for something like authentication
   410|         0|            0|            0|  0.00%|        self.headers[key.capitalize()] = val
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|    def add_unredirected_header(self, key, val):
   413|         0|            0|            0|  0.00%|        # will not be added to a redirected request
   414|         0|            0|            0|  0.00%|        self.unredirected_hdrs[key.capitalize()] = val
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|    def has_header(self, header_name):
   417|         0|            0|            0|  0.00%|        return (header_name in self.headers or
   418|         0|            0|            0|  0.00%|                header_name in self.unredirected_hdrs)
   419|         0|            0|            0|  0.00%|
   420|         0|            0|            0|  0.00%|    def get_header(self, header_name, default=None):
   421|         0|            0|            0|  0.00%|        return self.headers.get(
   422|         0|            0|            0|  0.00%|            header_name,
   423|         0|            0|            0|  0.00%|            self.unredirected_hdrs.get(header_name, default))
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|    def remove_header(self, header_name):
   426|         0|            0|            0|  0.00%|        self.headers.pop(header_name, None)
   427|         0|            0|            0|  0.00%|        self.unredirected_hdrs.pop(header_name, None)
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|    def header_items(self):
   430|         0|            0|            0|  0.00%|        hdrs = self.unredirected_hdrs.copy()
   431|         0|            0|            0|  0.00%|        hdrs.update(self.headers)
   432|         0|            0|            0|  0.00%|        return list(hdrs.items())
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|class OpenerDirector:
   435|         0|            0|            0|  0.00%|    def __init__(self):
   436|         0|            0|            0|  0.00%|        client_version = "Python-urllib/%s" % __version__
   437|         0|            0|            0|  0.00%|        self.addheaders = [('User-agent', client_version)]
   438|         0|            0|            0|  0.00%|        # self.handlers is retained only for backward compatibility
   439|         0|            0|            0|  0.00%|        self.handlers = []
   440|         0|            0|            0|  0.00%|        # manage the individual handlers
   441|         0|            0|            0|  0.00%|        self.handle_open = {}
   442|         0|            0|            0|  0.00%|        self.handle_error = {}
   443|         0|            0|            0|  0.00%|        self.process_response = {}
   444|         0|            0|            0|  0.00%|        self.process_request = {}
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|    def add_handler(self, handler):
   447|         0|            0|            0|  0.00%|        if not hasattr(handler, "add_parent"):
   448|         0|            0|            0|  0.00%|            raise TypeError("expected BaseHandler instance, got %r" %
   449|         0|            0|            0|  0.00%|                            type(handler))
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|        added = False
   452|         0|            0|            0|  0.00%|        for meth in dir(handler):
   453|         0|            0|            0|  0.00%|            if meth in ["redirect_request", "do_open", "proxy_open"]:
   454|         0|            0|            0|  0.00%|                # oops, coincidental match
   455|         0|            0|            0|  0.00%|                continue
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|            i = meth.find("_")
   458|         0|            0|            0|  0.00%|            protocol = meth[:i]
   459|         0|            0|            0|  0.00%|            condition = meth[i+1:]
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|            if condition.startswith("error"):
   462|         0|            0|            0|  0.00%|                j = condition.find("_") + i + 1
   463|         0|            0|            0|  0.00%|                kind = meth[j+1:]
   464|         0|            0|            0|  0.00%|                try:
   465|         0|            0|            0|  0.00%|                    kind = int(kind)
   466|         0|            0|            0|  0.00%|                except ValueError:
   467|         0|            0|            0|  0.00%|                    pass
   468|         0|            0|            0|  0.00%|                lookup = self.handle_error.get(protocol, {})
   469|         0|            0|            0|  0.00%|                self.handle_error[protocol] = lookup
   470|         0|            0|            0|  0.00%|            elif condition == "open":
   471|         0|            0|            0|  0.00%|                kind = protocol
   472|         0|            0|            0|  0.00%|                lookup = self.handle_open
   473|         0|            0|            0|  0.00%|            elif condition == "response":
   474|         0|            0|            0|  0.00%|                kind = protocol
   475|         0|            0|            0|  0.00%|                lookup = self.process_response
   476|         0|            0|            0|  0.00%|            elif condition == "request":
   477|         0|            0|            0|  0.00%|                kind = protocol
   478|         0|            0|            0|  0.00%|                lookup = self.process_request
   479|         0|            0|            0|  0.00%|            else:
   480|         0|            0|            0|  0.00%|                continue
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|            handlers = lookup.setdefault(kind, [])
   483|         0|            0|            0|  0.00%|            if handlers:
   484|         0|            0|            0|  0.00%|                bisect.insort(handlers, handler)
   485|         0|            0|            0|  0.00%|            else:
   486|         0|            0|            0|  0.00%|                handlers.append(handler)
   487|         0|            0|            0|  0.00%|            added = True
   488|         0|            0|            0|  0.00%|
   489|         0|            0|            0|  0.00%|        if added:
   490|         0|            0|            0|  0.00%|            bisect.insort(self.handlers, handler)
   491|         0|            0|            0|  0.00%|            handler.add_parent(self)
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|    def close(self):
   494|         0|            0|            0|  0.00%|        # Only exists for backwards compatibility.
   495|         0|            0|            0|  0.00%|        pass
   496|         0|            0|            0|  0.00%|
   497|         0|            0|            0|  0.00%|    def _call_chain(self, chain, kind, meth_name, *args):
   498|         0|            0|            0|  0.00%|        # Handlers raise an exception if no one else should try to handle
   499|         0|            0|            0|  0.00%|        # the request, or return None if they can't but another handler
   500|         0|            0|            0|  0.00%|        # could.  Otherwise, they return the response.
   501|         0|            0|            0|  0.00%|        handlers = chain.get(kind, ())
   502|         0|            0|            0|  0.00%|        for handler in handlers:
   503|         0|            0|            0|  0.00%|            func = getattr(handler, meth_name)
   504|         0|            0|            0|  0.00%|            result = func(*args)
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\urllib\request.py:1345 http_open
   505|         0|            0|            0|  0.00%|            if result is not None:
   506|         0|            0|            0|  0.00%|                return result
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
   509|         0|            0|            0|  0.00%|        # accept a URL or a Request object
   510|         0|            0|            0|  0.00%|        if isinstance(fullurl, str):
   511|         0|            0|            0|  0.00%|            req = Request(fullurl, data)
   512|         0|            0|            0|  0.00%|        else:
   513|         0|            0|            0|  0.00%|            req = fullurl
   514|         0|            0|            0|  0.00%|            if data is not None:
   515|         0|            0|            0|  0.00%|                req.data = data
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|        req.timeout = timeout
   518|         0|            0|            0|  0.00%|        protocol = req.type
   519|         0|            0|            0|  0.00%|
   520|         0|            0|            0|  0.00%|        # pre-process request
   521|         0|            0|            0|  0.00%|        meth_name = protocol+"_request"
   522|         0|            0|            0|  0.00%|        for processor in self.process_request.get(protocol, []):
   523|         0|            0|            0|  0.00%|            meth = getattr(processor, meth_name)
   524|         0|            0|            0|  0.00%|            req = meth(req)
   525|         0|            0|            0|  0.00%|
   526|         0|            0|            0|  0.00%|        response = self._open(req, data)
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\urllib\request.py:536 _open
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|        # post-process response
   529|         0|            0|            0|  0.00%|        meth_name = protocol+"_response"
   530|         0|            0|            0|  0.00%|        for processor in self.process_response.get(protocol, []):
   531|         0|            0|            0|  0.00%|            meth = getattr(processor, meth_name)
   532|         0|            0|            0|  0.00%|            response = meth(req, response)
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|        return response
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|    def _open(self, req, data=None):
   537|         0|            0|            0|  0.00%|        result = self._call_chain(self.handle_open, 'default',
   538|         0|            0|            0|  0.00%|                                  'default_open', req)
   539|         0|            0|            0|  0.00%|        if result:
   540|         0|            0|            0|  0.00%|            return result
   541|         0|            0|            0|  0.00%|
   542|         0|            0|            0|  0.00%|        protocol = req.type
   543|         0|            0|            0|  0.00%|        result = self._call_chain(self.handle_open, protocol, protocol +
   544|         0|            0|            0|  0.00%|                                  '_open', req)
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\urllib\request.py:497 _call_chain
   545|         0|            0|            0|  0.00%|        if result:
   546|         0|            0|            0|  0.00%|            return result
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|        return self._call_chain(self.handle_open, 'unknown',
   549|         0|            0|            0|  0.00%|                                'unknown_open', req)
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|    def error(self, proto, *args):
   552|         0|            0|            0|  0.00%|        if proto in ('http', 'https'):
   553|         0|            0|            0|  0.00%|            # XXX http[s] protocols are special-cased
   554|         0|            0|            0|  0.00%|            dict = self.handle_error['http'] # https is not different than http
   555|         0|            0|            0|  0.00%|            proto = args[2]  # YUCK!
   556|         0|            0|            0|  0.00%|            meth_name = 'http_error_%s' % proto
   557|         0|            0|            0|  0.00%|            http_err = 1
   558|         0|            0|            0|  0.00%|            orig_args = args
   559|         0|            0|            0|  0.00%|        else:
   560|         0|            0|            0|  0.00%|            dict = self.handle_error
   561|         0|            0|            0|  0.00%|            meth_name = proto + '_error'
   562|         0|            0|            0|  0.00%|            http_err = 0
   563|         0|            0|            0|  0.00%|        args = (dict, proto, meth_name) + args
   564|         0|            0|            0|  0.00%|        result = self._call_chain(*args)
   565|         0|            0|            0|  0.00%|        if result:
   566|         0|            0|            0|  0.00%|            return result
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|        if http_err:
   569|         0|            0|            0|  0.00%|            args = (dict, 'default', 'http_error_default') + orig_args
   570|         0|            0|            0|  0.00%|            return self._call_chain(*args)
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|# XXX probably also want an abstract factory that knows when it makes
   573|         0|            0|            0|  0.00%|# sense to skip a superclass in favor of a subclass and when it might
   574|         0|            0|            0|  0.00%|# make sense to include both
   575|         0|            0|            0|  0.00%|
   576|         0|            0|            0|  0.00%|def build_opener(*handlers):
   577|         0|            0|            0|  0.00%|    """Create an opener object from a list of handlers.
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|    The opener will use several default handlers, including support
   580|         0|            0|            0|  0.00%|    for HTTP, FTP and when applicable HTTPS.
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|    If any of the handlers passed as arguments are subclasses of the
   583|         0|            0|            0|  0.00%|    default handlers, the default handlers will not be used.
   584|         0|            0|            0|  0.00%|    """
   585|         0|            0|            0|  0.00%|    opener = OpenerDirector()
   586|         0|            0|            0|  0.00%|    default_classes = [ProxyHandler, UnknownHandler, HTTPHandler,
   587|         0|            0|            0|  0.00%|                       HTTPDefaultErrorHandler, HTTPRedirectHandler,
   588|         0|            0|            0|  0.00%|                       FTPHandler, FileHandler, HTTPErrorProcessor,
   589|         0|            0|            0|  0.00%|                       DataHandler]
   590|         0|            0|            0|  0.00%|    if hasattr(http.client, "HTTPSConnection"):
   591|         0|            0|            0|  0.00%|        default_classes.append(HTTPSHandler)
   592|         0|            0|            0|  0.00%|    skip = set()
   593|         0|            0|            0|  0.00%|    for klass in default_classes:
   594|         0|            0|            0|  0.00%|        for check in handlers:
   595|         0|            0|            0|  0.00%|            if isinstance(check, type):
   596|         0|            0|            0|  0.00%|                if issubclass(check, klass):
   597|         0|            0|            0|  0.00%|                    skip.add(klass)
   598|         0|            0|            0|  0.00%|            elif isinstance(check, klass):
   599|         0|            0|            0|  0.00%|                skip.add(klass)
   600|         0|            0|            0|  0.00%|    for klass in skip:
   601|         0|            0|            0|  0.00%|        default_classes.remove(klass)
   602|         0|            0|            0|  0.00%|
   603|         0|            0|            0|  0.00%|    for klass in default_classes:
   604|         0|            0|            0|  0.00%|        opener.add_handler(klass())
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|    for h in handlers:
   607|         0|            0|            0|  0.00%|        if isinstance(h, type):
   608|         0|            0|            0|  0.00%|            h = h()
   609|         0|            0|            0|  0.00%|        opener.add_handler(h)
   610|         0|            0|            0|  0.00%|    return opener
   611|         0|            0|            0|  0.00%|
   612|         0|            0|            0|  0.00%|class BaseHandler:
   613|         0|            0|            0|  0.00%|    handler_order = 500
   614|         0|            0|            0|  0.00%|
   615|         0|            0|            0|  0.00%|    def add_parent(self, parent):
   616|         0|            0|            0|  0.00%|        self.parent = parent
   617|         0|            0|            0|  0.00%|
   618|         0|            0|            0|  0.00%|    def close(self):
   619|         0|            0|            0|  0.00%|        # Only exists for backwards compatibility
   620|         0|            0|            0|  0.00%|        pass
   621|         0|            0|            0|  0.00%|
   622|         0|            0|            0|  0.00%|    def __lt__(self, other):
   623|         0|            0|            0|  0.00%|        if not hasattr(other, "handler_order"):
   624|         0|            0|            0|  0.00%|            # Try to preserve the old behavior of having custom classes
   625|         0|            0|            0|  0.00%|            # inserted after default ones (works only for custom user
   626|         0|            0|            0|  0.00%|            # classes which are not aware of handler_order).
   627|         0|            0|            0|  0.00%|            return True
   628|         0|            0|            0|  0.00%|        return self.handler_order < other.handler_order
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|
   631|         0|            0|            0|  0.00%|class HTTPErrorProcessor(BaseHandler):
   632|         0|            0|            0|  0.00%|    """Process HTTP error responses."""
   633|         0|            0|            0|  0.00%|    handler_order = 1000  # after all other processing
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|    def http_response(self, request, response):
   636|         0|            0|            0|  0.00%|        code, msg, hdrs = response.code, response.msg, response.info()
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|        # According to RFC 2616, "2xx" code indicates that the client's
   639|         0|            0|            0|  0.00%|        # request was successfully received, understood, and accepted.
   640|         0|            0|            0|  0.00%|        if not (200 <= code < 300):
   641|         0|            0|            0|  0.00%|            response = self.parent.error(
   642|         0|            0|            0|  0.00%|                'http', request, response, code, msg, hdrs)
   643|         0|            0|            0|  0.00%|
   644|         0|            0|            0|  0.00%|        return response
   645|         0|            0|            0|  0.00%|
   646|         0|            0|            0|  0.00%|    https_response = http_response
   647|         0|            0|            0|  0.00%|
   648|         0|            0|            0|  0.00%|class HTTPDefaultErrorHandler(BaseHandler):
   649|         0|            0|            0|  0.00%|    def http_error_default(self, req, fp, code, msg, hdrs):
   650|         0|            0|            0|  0.00%|        raise HTTPError(req.full_url, code, msg, hdrs, fp)
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|class HTTPRedirectHandler(BaseHandler):
   653|         0|            0|            0|  0.00%|    # maximum number of redirections to any single URL
   654|         0|            0|            0|  0.00%|    # this is needed because of the state that cookies introduce
   655|         0|            0|            0|  0.00%|    max_repeats = 4
   656|         0|            0|            0|  0.00%|    # maximum total number of redirections (regardless of URL) before
   657|         0|            0|            0|  0.00%|    # assuming we're in a loop
   658|         0|            0|            0|  0.00%|    max_redirections = 10
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|    def redirect_request(self, req, fp, code, msg, headers, newurl):
   661|         0|            0|            0|  0.00%|        """Return a Request or None in response to a redirect.
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|        This is called by the http_error_30x methods when a
   664|         0|            0|            0|  0.00%|        redirection response is received.  If a redirection should
   665|         0|            0|            0|  0.00%|        take place, return a new Request to allow http_error_30x to
   666|         0|            0|            0|  0.00%|        perform the redirect.  Otherwise, raise HTTPError if no-one
   667|         0|            0|            0|  0.00%|        else should try to handle this url.  Return None if you can't
   668|         0|            0|            0|  0.00%|        but another Handler might.
   669|         0|            0|            0|  0.00%|        """
   670|         0|            0|            0|  0.00%|        m = req.get_method()
   671|         0|            0|            0|  0.00%|        if (not (code in (301, 302, 303, 307) and m in ("GET", "HEAD")
   672|         0|            0|            0|  0.00%|            or code in (301, 302, 303) and m == "POST")):
   673|         0|            0|            0|  0.00%|            raise HTTPError(req.full_url, code, msg, headers, fp)
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|        # Strictly (according to RFC 2616), 301 or 302 in response to
   676|         0|            0|            0|  0.00%|        # a POST MUST NOT cause a redirection without confirmation
   677|         0|            0|            0|  0.00%|        # from the user (of urllib.request, in this case).  In practice,
   678|         0|            0|            0|  0.00%|        # essentially all clients do redirect in this case, so we do
   679|         0|            0|            0|  0.00%|        # the same.
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|        # Be conciliant with URIs containing a space.  This is mainly
   682|         0|            0|            0|  0.00%|        # redundant with the more complete encoding done in http_error_302(),
   683|         0|            0|            0|  0.00%|        # but it is kept for compatibility with other callers.
   684|         0|            0|            0|  0.00%|        newurl = newurl.replace(' ', '%20')
   685|         0|            0|            0|  0.00%|
   686|         0|            0|            0|  0.00%|        CONTENT_HEADERS = ("content-length", "content-type")
   687|         0|            0|            0|  0.00%|        newheaders = dict((k, v) for k, v in req.headers.items()
   688|         0|            0|            0|  0.00%|                          if k.lower() not in CONTENT_HEADERS)
   689|         0|            0|            0|  0.00%|        return Request(newurl,
   690|         0|            0|            0|  0.00%|                       headers=newheaders,
   691|         0|            0|            0|  0.00%|                       origin_req_host=req.origin_req_host,
   692|         0|            0|            0|  0.00%|                       unverifiable=True)
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|    # Implementation note: To avoid the server sending us into an
   695|         0|            0|            0|  0.00%|    # infinite loop, the request object needs to track what URLs we
   696|         0|            0|            0|  0.00%|    # have already seen.  Do this by adding a handler-specific
   697|         0|            0|            0|  0.00%|    # attribute to the Request object.
   698|         0|            0|            0|  0.00%|    def http_error_302(self, req, fp, code, msg, headers):
   699|         0|            0|            0|  0.00%|        # Some servers (incorrectly) return multiple Location headers
   700|         0|            0|            0|  0.00%|        # (so probably same goes for URI).  Use first header.
   701|         0|            0|            0|  0.00%|        if "location" in headers:
   702|         0|            0|            0|  0.00%|            newurl = headers["location"]
   703|         0|            0|            0|  0.00%|        elif "uri" in headers:
   704|         0|            0|            0|  0.00%|            newurl = headers["uri"]
   705|         0|            0|            0|  0.00%|        else:
   706|         0|            0|            0|  0.00%|            return
   707|         0|            0|            0|  0.00%|
   708|         0|            0|            0|  0.00%|        # fix a possible malformed URL
   709|         0|            0|            0|  0.00%|        urlparts = urlparse(newurl)
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|        # For security reasons we don't allow redirection to anything other
   712|         0|            0|            0|  0.00%|        # than http, https or ftp.
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|        if urlparts.scheme not in ('http', 'https', 'ftp', ''):
   715|         0|            0|            0|  0.00%|            raise HTTPError(
   716|         0|            0|            0|  0.00%|                newurl, code,
   717|         0|            0|            0|  0.00%|                "%s - Redirection to url '%s' is not allowed" % (msg, newurl),
   718|         0|            0|            0|  0.00%|                headers, fp)
   719|         0|            0|            0|  0.00%|
   720|         0|            0|            0|  0.00%|        if not urlparts.path and urlparts.netloc:
   721|         0|            0|            0|  0.00%|            urlparts = list(urlparts)
   722|         0|            0|            0|  0.00%|            urlparts[2] = "/"
   723|         0|            0|            0|  0.00%|        newurl = urlunparse(urlparts)
   724|         0|            0|            0|  0.00%|
   725|         0|            0|            0|  0.00%|        # http.client.parse_headers() decodes as ISO-8859-1.  Recover the
   726|         0|            0|            0|  0.00%|        # original bytes and percent-encode non-ASCII bytes, and any special
   727|         0|            0|            0|  0.00%|        # characters such as the space.
   728|         0|            0|            0|  0.00%|        newurl = quote(
   729|         0|            0|            0|  0.00%|            newurl, encoding="iso-8859-1", safe=string.punctuation)
   730|         0|            0|            0|  0.00%|        newurl = urljoin(req.full_url, newurl)
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|        # XXX Probably want to forget about the state of the current
   733|         0|            0|            0|  0.00%|        # request, although that might interact poorly with other
   734|         0|            0|            0|  0.00%|        # handlers that also use handler-specific request attributes
   735|         0|            0|            0|  0.00%|        new = self.redirect_request(req, fp, code, msg, headers, newurl)
   736|         0|            0|            0|  0.00%|        if new is None:
   737|         0|            0|            0|  0.00%|            return
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|        # loop detection
   740|         0|            0|            0|  0.00%|        # .redirect_dict has a key url if url was previously visited.
   741|         0|            0|            0|  0.00%|        if hasattr(req, 'redirect_dict'):
   742|         0|            0|            0|  0.00%|            visited = new.redirect_dict = req.redirect_dict
   743|         0|            0|            0|  0.00%|            if (visited.get(newurl, 0) >= self.max_repeats or
   744|         0|            0|            0|  0.00%|                len(visited) >= self.max_redirections):
   745|         0|            0|            0|  0.00%|                raise HTTPError(req.full_url, code,
   746|         0|            0|            0|  0.00%|                                self.inf_msg + msg, headers, fp)
   747|         0|            0|            0|  0.00%|        else:
   748|         0|            0|            0|  0.00%|            visited = new.redirect_dict = req.redirect_dict = {}
   749|         0|            0|            0|  0.00%|        visited[newurl] = visited.get(newurl, 0) + 1
   750|         0|            0|            0|  0.00%|
   751|         0|            0|            0|  0.00%|        # Don't close the fp until we are sure that we won't use it
   752|         0|            0|            0|  0.00%|        # with HTTPError.
   753|         0|            0|            0|  0.00%|        fp.read()
   754|         0|            0|            0|  0.00%|        fp.close()
   755|         0|            0|            0|  0.00%|
   756|         0|            0|            0|  0.00%|        return self.parent.open(new, timeout=req.timeout)
   757|         0|            0|            0|  0.00%|
   758|         0|            0|            0|  0.00%|    http_error_301 = http_error_303 = http_error_307 = http_error_302
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|    inf_msg = "The HTTP server returned a redirect error that would " \
   761|         0|            0|            0|  0.00%|              "lead to an infinite loop.\n" \
   762|         0|            0|            0|  0.00%|              "The last 30x error message was:\n"
   763|         0|            0|            0|  0.00%|
   764|         0|            0|            0|  0.00%|
   765|         0|            0|            0|  0.00%|def _parse_proxy(proxy):
   766|         0|            0|            0|  0.00%|    """Return (scheme, user, password, host/port) given a URL or an authority.
   767|         0|            0|            0|  0.00%|
   768|         0|            0|            0|  0.00%|    If a URL is supplied, it must have an authority (host:port) component.
   769|         0|            0|            0|  0.00%|    According to RFC 3986, having an authority component means the URL must
   770|         0|            0|            0|  0.00%|    have two slashes after the scheme.
   771|         0|            0|            0|  0.00%|    """
   772|         0|            0|            0|  0.00%|    scheme, r_scheme = splittype(proxy)
   773|         0|            0|            0|  0.00%|    if not r_scheme.startswith("/"):
   774|         0|            0|            0|  0.00%|        # authority
   775|         0|            0|            0|  0.00%|        scheme = None
   776|         0|            0|            0|  0.00%|        authority = proxy
   777|         0|            0|            0|  0.00%|    else:
   778|         0|            0|            0|  0.00%|        # URL
   779|         0|            0|            0|  0.00%|        if not r_scheme.startswith("//"):
   780|         0|            0|            0|  0.00%|            raise ValueError("proxy URL with no authority: %r" % proxy)
   781|         0|            0|            0|  0.00%|        # We have an authority, so for RFC 3986-compliant URLs (by ss 3.
   782|         0|            0|            0|  0.00%|        # and 3.3.), path is empty or starts with '/'
   783|         0|            0|            0|  0.00%|        end = r_scheme.find("/", 2)
   784|         0|            0|            0|  0.00%|        if end == -1:
   785|         0|            0|            0|  0.00%|            end = None
   786|         0|            0|            0|  0.00%|        authority = r_scheme[2:end]
   787|         0|            0|            0|  0.00%|    userinfo, hostport = splituser(authority)
   788|         0|            0|            0|  0.00%|    if userinfo is not None:
   789|         0|            0|            0|  0.00%|        user, password = splitpasswd(userinfo)
   790|         0|            0|            0|  0.00%|    else:
   791|         0|            0|            0|  0.00%|        user = password = None
   792|         0|            0|            0|  0.00%|    return scheme, user, password, hostport
   793|         0|            0|            0|  0.00%|
   794|         0|            0|            0|  0.00%|class ProxyHandler(BaseHandler):
   795|         0|            0|            0|  0.00%|    # Proxies must be in front
   796|         0|            0|            0|  0.00%|    handler_order = 100
   797|         0|            0|            0|  0.00%|
   798|         0|            0|            0|  0.00%|    def __init__(self, proxies=None):
   799|         0|            0|            0|  0.00%|        if proxies is None:
   800|         0|            0|            0|  0.00%|            proxies = getproxies()
   801|         0|            0|            0|  0.00%|        assert hasattr(proxies, 'keys'), "proxies must be a mapping"
   802|         0|            0|            0|  0.00%|        self.proxies = proxies
   803|         0|            0|            0|  0.00%|        for type, url in proxies.items():
   804|         0|            0|            0|  0.00%|            setattr(self, '%s_open' % type,
   805|         0|            0|            0|  0.00%|                    lambda r, proxy=url, type=type, meth=self.proxy_open:
   806|         0|            0|            0|  0.00%|                        meth(r, proxy, type))
   807|         0|            0|            0|  0.00%|
   808|         0|            0|            0|  0.00%|    def proxy_open(self, req, proxy, type):
   809|         0|            0|            0|  0.00%|        orig_type = req.type
   810|         0|            0|            0|  0.00%|        proxy_type, user, password, hostport = _parse_proxy(proxy)
   811|         0|            0|            0|  0.00%|        if proxy_type is None:
   812|         0|            0|            0|  0.00%|            proxy_type = orig_type
   813|         0|            0|            0|  0.00%|
   814|         0|            0|            0|  0.00%|        if req.host and proxy_bypass(req.host):
   815|         0|            0|            0|  0.00%|            return None
   816|         0|            0|            0|  0.00%|
   817|         0|            0|            0|  0.00%|        if user and password:
   818|         0|            0|            0|  0.00%|            user_pass = '%s:%s' % (unquote(user),
   819|         0|            0|            0|  0.00%|                                   unquote(password))
   820|         0|            0|            0|  0.00%|            creds = base64.b64encode(user_pass.encode()).decode("ascii")
   821|         0|            0|            0|  0.00%|            req.add_header('Proxy-authorization', 'Basic ' + creds)
   822|         0|            0|            0|  0.00%|        hostport = unquote(hostport)
   823|         0|            0|            0|  0.00%|        req.set_proxy(hostport, proxy_type)
   824|         0|            0|            0|  0.00%|        if orig_type == proxy_type or orig_type == 'https':
   825|         0|            0|            0|  0.00%|            # let other handlers take care of it
   826|         0|            0|            0|  0.00%|            return None
   827|         0|            0|            0|  0.00%|        else:
   828|         0|            0|            0|  0.00%|            # need to start over, because the other handlers don't
   829|         0|            0|            0|  0.00%|            # grok the proxy's URL type
   830|         0|            0|            0|  0.00%|            # e.g. if we have a constructor arg proxies like so:
   831|         0|            0|            0|  0.00%|            # {'http': 'ftp://proxy.example.com'}, we may end up turning
   832|         0|            0|            0|  0.00%|            # a request for http://acme.example.com/a into one for
   833|         0|            0|            0|  0.00%|            # ftp://proxy.example.com/a
   834|         0|            0|            0|  0.00%|            return self.parent.open(req, timeout=req.timeout)
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|class HTTPPasswordMgr:
   837|         0|            0|            0|  0.00%|
   838|         0|            0|            0|  0.00%|    def __init__(self):
   839|         0|            0|            0|  0.00%|        self.passwd = {}
   840|         0|            0|            0|  0.00%|
   841|         0|            0|            0|  0.00%|    def add_password(self, realm, uri, user, passwd):
   842|         0|            0|            0|  0.00%|        # uri could be a single URI or a sequence
   843|         0|            0|            0|  0.00%|        if isinstance(uri, str):
   844|         0|            0|            0|  0.00%|            uri = [uri]
   845|         0|            0|            0|  0.00%|        if realm not in self.passwd:
   846|         0|            0|            0|  0.00%|            self.passwd[realm] = {}
   847|         0|            0|            0|  0.00%|        for default_port in True, False:
   848|         0|            0|            0|  0.00%|            reduced_uri = tuple(
   849|         0|            0|            0|  0.00%|                [self.reduce_uri(u, default_port) for u in uri])
   850|         0|            0|            0|  0.00%|            self.passwd[realm][reduced_uri] = (user, passwd)
   851|         0|            0|            0|  0.00%|
   852|         0|            0|            0|  0.00%|    def find_user_password(self, realm, authuri):
   853|         0|            0|            0|  0.00%|        domains = self.passwd.get(realm, {})
   854|         0|            0|            0|  0.00%|        for default_port in True, False:
   855|         0|            0|            0|  0.00%|            reduced_authuri = self.reduce_uri(authuri, default_port)
   856|         0|            0|            0|  0.00%|            for uris, authinfo in domains.items():
   857|         0|            0|            0|  0.00%|                for uri in uris:
   858|         0|            0|            0|  0.00%|                    if self.is_suburi(uri, reduced_authuri):
   859|         0|            0|            0|  0.00%|                        return authinfo
   860|         0|            0|            0|  0.00%|        return None, None
   861|         0|            0|            0|  0.00%|
   862|         0|            0|            0|  0.00%|    def reduce_uri(self, uri, default_port=True):
   863|         0|            0|            0|  0.00%|        """Accept authority or URI and extract only the authority and path."""
   864|         0|            0|            0|  0.00%|        # note HTTP URLs do not have a userinfo component
   865|         0|            0|            0|  0.00%|        parts = urlsplit(uri)
   866|         0|            0|            0|  0.00%|        if parts[1]:
   867|         0|            0|            0|  0.00%|            # URI
   868|         0|            0|            0|  0.00%|            scheme = parts[0]
   869|         0|            0|            0|  0.00%|            authority = parts[1]
   870|         0|            0|            0|  0.00%|            path = parts[2] or '/'
   871|         0|            0|            0|  0.00%|        else:
   872|         0|            0|            0|  0.00%|            # host or host:port
   873|         0|            0|            0|  0.00%|            scheme = None
   874|         0|            0|            0|  0.00%|            authority = uri
   875|         0|            0|            0|  0.00%|            path = '/'
   876|         0|            0|            0|  0.00%|        host, port = splitport(authority)
   877|         0|            0|            0|  0.00%|        if default_port and port is None and scheme is not None:
   878|         0|            0|            0|  0.00%|            dport = {"http": 80,
   879|         0|            0|            0|  0.00%|                     "https": 443,
   880|         0|            0|            0|  0.00%|                     }.get(scheme)
   881|         0|            0|            0|  0.00%|            if dport is not None:
   882|         0|            0|            0|  0.00%|                authority = "%s:%d" % (host, dport)
   883|         0|            0|            0|  0.00%|        return authority, path
   884|         0|            0|            0|  0.00%|
   885|         0|            0|            0|  0.00%|    def is_suburi(self, base, test):
   886|         0|            0|            0|  0.00%|        """Check if test is below base in a URI tree
   887|         0|            0|            0|  0.00%|
   888|         0|            0|            0|  0.00%|        Both args must be URIs in reduced form.
   889|         0|            0|            0|  0.00%|        """
   890|         0|            0|            0|  0.00%|        if base == test:
   891|         0|            0|            0|  0.00%|            return True
   892|         0|            0|            0|  0.00%|        if base[0] != test[0]:
   893|         0|            0|            0|  0.00%|            return False
   894|         0|            0|            0|  0.00%|        common = posixpath.commonprefix((base[1], test[1]))
   895|         0|            0|            0|  0.00%|        if len(common) == len(base[1]):
   896|         0|            0|            0|  0.00%|            return True
   897|         0|            0|            0|  0.00%|        return False
   898|         0|            0|            0|  0.00%|
   899|         0|            0|            0|  0.00%|
   900|         0|            0|            0|  0.00%|class HTTPPasswordMgrWithDefaultRealm(HTTPPasswordMgr):
   901|         0|            0|            0|  0.00%|
   902|         0|            0|            0|  0.00%|    def find_user_password(self, realm, authuri):
   903|         0|            0|            0|  0.00%|        user, password = HTTPPasswordMgr.find_user_password(self, realm,
   904|         0|            0|            0|  0.00%|                                                            authuri)
   905|         0|            0|            0|  0.00%|        if user is not None:
   906|         0|            0|            0|  0.00%|            return user, password
   907|         0|            0|            0|  0.00%|        return HTTPPasswordMgr.find_user_password(self, None, authuri)
   908|         0|            0|            0|  0.00%|
   909|         0|            0|            0|  0.00%|
   910|         0|            0|            0|  0.00%|class HTTPPasswordMgrWithPriorAuth(HTTPPasswordMgrWithDefaultRealm):
   911|         0|            0|            0|  0.00%|
   912|         0|            0|            0|  0.00%|    def __init__(self, *args, **kwargs):
   913|         0|            0|            0|  0.00%|        self.authenticated = {}
   914|         0|            0|            0|  0.00%|        super().__init__(*args, **kwargs)
   915|         0|            0|            0|  0.00%|
   916|         0|            0|            0|  0.00%|    def add_password(self, realm, uri, user, passwd, is_authenticated=False):
   917|         0|            0|            0|  0.00%|        self.update_authenticated(uri, is_authenticated)
   918|         0|            0|            0|  0.00%|        # Add a default for prior auth requests
   919|         0|            0|            0|  0.00%|        if realm is not None:
   920|         0|            0|            0|  0.00%|            super().add_password(None, uri, user, passwd)
   921|         0|            0|            0|  0.00%|        super().add_password(realm, uri, user, passwd)
   922|         0|            0|            0|  0.00%|
   923|         0|            0|            0|  0.00%|    def update_authenticated(self, uri, is_authenticated=False):
   924|         0|            0|            0|  0.00%|        # uri could be a single URI or a sequence
   925|         0|            0|            0|  0.00%|        if isinstance(uri, str):
   926|         0|            0|            0|  0.00%|            uri = [uri]
   927|         0|            0|            0|  0.00%|
   928|         0|            0|            0|  0.00%|        for default_port in True, False:
   929|         0|            0|            0|  0.00%|            for u in uri:
   930|         0|            0|            0|  0.00%|                reduced_uri = self.reduce_uri(u, default_port)
   931|         0|            0|            0|  0.00%|                self.authenticated[reduced_uri] = is_authenticated
   932|         0|            0|            0|  0.00%|
   933|         0|            0|            0|  0.00%|    def is_authenticated(self, authuri):
   934|         0|            0|            0|  0.00%|        for default_port in True, False:
   935|         0|            0|            0|  0.00%|            reduced_authuri = self.reduce_uri(authuri, default_port)
   936|         0|            0|            0|  0.00%|            for uri in self.authenticated:
   937|         0|            0|            0|  0.00%|                if self.is_suburi(uri, reduced_authuri):
   938|         0|            0|            0|  0.00%|                    return self.authenticated[uri]
   939|         0|            0|            0|  0.00%|
   940|         0|            0|            0|  0.00%|
   941|         0|            0|            0|  0.00%|class AbstractBasicAuthHandler:
   942|         0|            0|            0|  0.00%|
   943|         0|            0|            0|  0.00%|    # XXX this allows for multiple auth-schemes, but will stupidly pick
   944|         0|            0|            0|  0.00%|    # the last one with a realm specified.
   945|         0|            0|            0|  0.00%|
   946|         0|            0|            0|  0.00%|    # allow for double- and single-quoted realm values
   947|         0|            0|            0|  0.00%|    # (single quotes are a violation of the RFC, but appear in the wild)
   948|         0|            0|            0|  0.00%|    rx = re.compile('(?:.*,)*[ \t]*([^ \t]+)[ \t]+'
   949|         0|            0|            0|  0.00%|                    'realm=(["\']?)([^"\']*)\\2', re.I)
   950|         0|            0|            0|  0.00%|
   951|         0|            0|            0|  0.00%|    # XXX could pre-emptively send auth info already accepted (RFC 2617,
   952|         0|            0|            0|  0.00%|    # end of section 2, and section 1.2 immediately after "credentials"
   953|         0|            0|            0|  0.00%|    # production).
   954|         0|            0|            0|  0.00%|
   955|         0|            0|            0|  0.00%|    def __init__(self, password_mgr=None):
   956|         0|            0|            0|  0.00%|        if password_mgr is None:
   957|         0|            0|            0|  0.00%|            password_mgr = HTTPPasswordMgr()
   958|         0|            0|            0|  0.00%|        self.passwd = password_mgr
   959|         0|            0|            0|  0.00%|        self.add_password = self.passwd.add_password
   960|         0|            0|            0|  0.00%|
   961|         0|            0|            0|  0.00%|    def http_error_auth_reqed(self, authreq, host, req, headers):
   962|         0|            0|            0|  0.00%|        # host may be an authority (without userinfo) or a URL with an
   963|         0|            0|            0|  0.00%|        # authority
   964|         0|            0|            0|  0.00%|        # XXX could be multiple headers
   965|         0|            0|            0|  0.00%|        authreq = headers.get(authreq, None)
   966|         0|            0|            0|  0.00%|
   967|         0|            0|            0|  0.00%|        if authreq:
   968|         0|            0|            0|  0.00%|            scheme = authreq.split()[0]
   969|         0|            0|            0|  0.00%|            if scheme.lower() != 'basic':
   970|         0|            0|            0|  0.00%|                raise ValueError("AbstractBasicAuthHandler does not"
   971|         0|            0|            0|  0.00%|                                 " support the following scheme: '%s'" %
   972|         0|            0|            0|  0.00%|                                 scheme)
   973|         0|            0|            0|  0.00%|            else:
   974|         0|            0|            0|  0.00%|                mo = AbstractBasicAuthHandler.rx.search(authreq)
   975|         0|            0|            0|  0.00%|                if mo:
   976|         0|            0|            0|  0.00%|                    scheme, quote, realm = mo.groups()
   977|         0|            0|            0|  0.00%|                    if quote not in ['"',"'"]:
   978|         0|            0|            0|  0.00%|                        warnings.warn("Basic Auth Realm was unquoted",
   979|         0|            0|            0|  0.00%|                                      UserWarning, 2)
   980|         0|            0|            0|  0.00%|                    if scheme.lower() == 'basic':
   981|         0|            0|            0|  0.00%|                        return self.retry_http_basic_auth(host, req, realm)
   982|         0|            0|            0|  0.00%|
   983|         0|            0|            0|  0.00%|    def retry_http_basic_auth(self, host, req, realm):
   984|         0|            0|            0|  0.00%|        user, pw = self.passwd.find_user_password(realm, host)
   985|         0|            0|            0|  0.00%|        if pw is not None:
   986|         0|            0|            0|  0.00%|            raw = "%s:%s" % (user, pw)
   987|         0|            0|            0|  0.00%|            auth = "Basic " + base64.b64encode(raw.encode()).decode("ascii")
   988|         0|            0|            0|  0.00%|            if req.get_header(self.auth_header, None) == auth:
   989|         0|            0|            0|  0.00%|                return None
   990|         0|            0|            0|  0.00%|            req.add_unredirected_header(self.auth_header, auth)
   991|         0|            0|            0|  0.00%|            return self.parent.open(req, timeout=req.timeout)
   992|         0|            0|            0|  0.00%|        else:
   993|         0|            0|            0|  0.00%|            return None
   994|         0|            0|            0|  0.00%|
   995|         0|            0|            0|  0.00%|    def http_request(self, req):
   996|         0|            0|            0|  0.00%|        if (not hasattr(self.passwd, 'is_authenticated') or
   997|         0|            0|            0|  0.00%|           not self.passwd.is_authenticated(req.full_url)):
   998|         0|            0|            0|  0.00%|            return req
   999|         0|            0|            0|  0.00%|
  1000|         0|            0|            0|  0.00%|        if not req.has_header('Authorization'):
  1001|         0|            0|            0|  0.00%|            user, passwd = self.passwd.find_user_password(None, req.full_url)
  1002|         0|            0|            0|  0.00%|            credentials = '{0}:{1}'.format(user, passwd).encode()
  1003|         0|            0|            0|  0.00%|            auth_str = base64.standard_b64encode(credentials).decode()
  1004|         0|            0|            0|  0.00%|            req.add_unredirected_header('Authorization',
  1005|         0|            0|            0|  0.00%|                                        'Basic {}'.format(auth_str.strip()))
  1006|         0|            0|            0|  0.00%|        return req
  1007|         0|            0|            0|  0.00%|
  1008|         0|            0|            0|  0.00%|    def http_response(self, req, response):
  1009|         0|            0|            0|  0.00%|        if hasattr(self.passwd, 'is_authenticated'):
  1010|         0|            0|            0|  0.00%|            if 200 <= response.code < 300:
  1011|         0|            0|            0|  0.00%|                self.passwd.update_authenticated(req.full_url, True)
  1012|         0|            0|            0|  0.00%|            else:
  1013|         0|            0|            0|  0.00%|                self.passwd.update_authenticated(req.full_url, False)
  1014|         0|            0|            0|  0.00%|        return response
  1015|         0|            0|            0|  0.00%|
  1016|         0|            0|            0|  0.00%|    https_request = http_request
  1017|         0|            0|            0|  0.00%|    https_response = http_response
  1018|         0|            0|            0|  0.00%|
  1019|         0|            0|            0|  0.00%|
  1020|         0|            0|            0|  0.00%|
  1021|         0|            0|            0|  0.00%|class HTTPBasicAuthHandler(AbstractBasicAuthHandler, BaseHandler):
  1022|         0|            0|            0|  0.00%|
  1023|         0|            0|            0|  0.00%|    auth_header = 'Authorization'
  1024|         0|            0|            0|  0.00%|
  1025|         0|            0|            0|  0.00%|    def http_error_401(self, req, fp, code, msg, headers):
  1026|         0|            0|            0|  0.00%|        url = req.full_url
  1027|         0|            0|            0|  0.00%|        response = self.http_error_auth_reqed('www-authenticate',
  1028|         0|            0|            0|  0.00%|                                          url, req, headers)
  1029|         0|            0|            0|  0.00%|        return response
  1030|         0|            0|            0|  0.00%|
  1031|         0|            0|            0|  0.00%|
  1032|         0|            0|            0|  0.00%|class ProxyBasicAuthHandler(AbstractBasicAuthHandler, BaseHandler):
  1033|         0|            0|            0|  0.00%|
  1034|         0|            0|            0|  0.00%|    auth_header = 'Proxy-authorization'
  1035|         0|            0|            0|  0.00%|
  1036|         0|            0|            0|  0.00%|    def http_error_407(self, req, fp, code, msg, headers):
  1037|         0|            0|            0|  0.00%|        # http_error_auth_reqed requires that there is no userinfo component in
  1038|         0|            0|            0|  0.00%|        # authority.  Assume there isn't one, since urllib.request does not (and
  1039|         0|            0|            0|  0.00%|        # should not, RFC 3986 s. 3.2.1) support requests for URLs containing
  1040|         0|            0|            0|  0.00%|        # userinfo.
  1041|         0|            0|            0|  0.00%|        authority = req.host
  1042|         0|            0|            0|  0.00%|        response = self.http_error_auth_reqed('proxy-authenticate',
  1043|         0|            0|            0|  0.00%|                                          authority, req, headers)
  1044|         0|            0|            0|  0.00%|        return response
  1045|         0|            0|            0|  0.00%|
  1046|         0|            0|            0|  0.00%|
  1047|         0|            0|            0|  0.00%|# Return n random bytes.
  1048|         0|            0|            0|  0.00%|_randombytes = os.urandom
  1049|         0|            0|            0|  0.00%|
  1050|         0|            0|            0|  0.00%|
  1051|         0|            0|            0|  0.00%|class AbstractDigestAuthHandler:
  1052|         0|            0|            0|  0.00%|    # Digest authentication is specified in RFC 2617.
  1053|         0|            0|            0|  0.00%|
  1054|         0|            0|            0|  0.00%|    # XXX The client does not inspect the Authentication-Info header
  1055|         0|            0|            0|  0.00%|    # in a successful response.
  1056|         0|            0|            0|  0.00%|
  1057|         0|            0|            0|  0.00%|    # XXX It should be possible to test this implementation against
  1058|         0|            0|            0|  0.00%|    # a mock server that just generates a static set of challenges.
  1059|         0|            0|            0|  0.00%|
  1060|         0|            0|            0|  0.00%|    # XXX qop="auth-int" supports is shaky
  1061|         0|            0|            0|  0.00%|
  1062|         0|            0|            0|  0.00%|    def __init__(self, passwd=None):
  1063|         0|            0|            0|  0.00%|        if passwd is None:
  1064|         0|            0|            0|  0.00%|            passwd = HTTPPasswordMgr()
  1065|         0|            0|            0|  0.00%|        self.passwd = passwd
  1066|         0|            0|            0|  0.00%|        self.add_password = self.passwd.add_password
  1067|         0|            0|            0|  0.00%|        self.retried = 0
  1068|         0|            0|            0|  0.00%|        self.nonce_count = 0
  1069|         0|            0|            0|  0.00%|        self.last_nonce = None
  1070|         0|            0|            0|  0.00%|
  1071|         0|            0|            0|  0.00%|    def reset_retry_count(self):
  1072|         0|            0|            0|  0.00%|        self.retried = 0
  1073|         0|            0|            0|  0.00%|
  1074|         0|            0|            0|  0.00%|    def http_error_auth_reqed(self, auth_header, host, req, headers):
  1075|         0|            0|            0|  0.00%|        authreq = headers.get(auth_header, None)
  1076|         0|            0|            0|  0.00%|        if self.retried > 5:
  1077|         0|            0|            0|  0.00%|            # Don't fail endlessly - if we failed once, we'll probably
  1078|         0|            0|            0|  0.00%|            # fail a second time. Hm. Unless the Password Manager is
  1079|         0|            0|            0|  0.00%|            # prompting for the information. Crap. This isn't great
  1080|         0|            0|            0|  0.00%|            # but it's better than the current 'repeat until recursion
  1081|         0|            0|            0|  0.00%|            # depth exceeded' approach <wink>
  1082|         0|            0|            0|  0.00%|            raise HTTPError(req.full_url, 401, "digest auth failed",
  1083|         0|            0|            0|  0.00%|                            headers, None)
  1084|         0|            0|            0|  0.00%|        else:
  1085|         0|            0|            0|  0.00%|            self.retried += 1
  1086|         0|            0|            0|  0.00%|        if authreq:
  1087|         0|            0|            0|  0.00%|            scheme = authreq.split()[0]
  1088|         0|            0|            0|  0.00%|            if scheme.lower() == 'digest':
  1089|         0|            0|            0|  0.00%|                return self.retry_http_digest_auth(req, authreq)
  1090|         0|            0|            0|  0.00%|            elif scheme.lower() != 'basic':
  1091|         0|            0|            0|  0.00%|                raise ValueError("AbstractDigestAuthHandler does not support"
  1092|         0|            0|            0|  0.00%|                                 " the following scheme: '%s'" % scheme)
  1093|         0|            0|            0|  0.00%|
  1094|         0|            0|            0|  0.00%|    def retry_http_digest_auth(self, req, auth):
  1095|         0|            0|            0|  0.00%|        token, challenge = auth.split(' ', 1)
  1096|         0|            0|            0|  0.00%|        chal = parse_keqv_list(filter(None, parse_http_list(challenge)))
  1097|         0|            0|            0|  0.00%|        auth = self.get_authorization(req, chal)
  1098|         0|            0|            0|  0.00%|        if auth:
  1099|         0|            0|            0|  0.00%|            auth_val = 'Digest %s' % auth
  1100|         0|            0|            0|  0.00%|            if req.headers.get(self.auth_header, None) == auth_val:
  1101|         0|            0|            0|  0.00%|                return None
  1102|         0|            0|            0|  0.00%|            req.add_unredirected_header(self.auth_header, auth_val)
  1103|         0|            0|            0|  0.00%|            resp = self.parent.open(req, timeout=req.timeout)
  1104|         0|            0|            0|  0.00%|            return resp
  1105|         0|            0|            0|  0.00%|
  1106|         0|            0|            0|  0.00%|    def get_cnonce(self, nonce):
  1107|         0|            0|            0|  0.00%|        # The cnonce-value is an opaque
  1108|         0|            0|            0|  0.00%|        # quoted string value provided by the client and used by both client
  1109|         0|            0|            0|  0.00%|        # and server to avoid chosen plaintext attacks, to provide mutual
  1110|         0|            0|            0|  0.00%|        # authentication, and to provide some message integrity protection.
  1111|         0|            0|            0|  0.00%|        # This isn't a fabulous effort, but it's probably Good Enough.
  1112|         0|            0|            0|  0.00%|        s = "%s:%s:%s:" % (self.nonce_count, nonce, time.ctime())
  1113|         0|            0|            0|  0.00%|        b = s.encode("ascii") + _randombytes(8)
  1114|         0|            0|            0|  0.00%|        dig = hashlib.sha1(b).hexdigest()
  1115|         0|            0|            0|  0.00%|        return dig[:16]
  1116|         0|            0|            0|  0.00%|
  1117|         0|            0|            0|  0.00%|    def get_authorization(self, req, chal):
  1118|         0|            0|            0|  0.00%|        try:
  1119|         0|            0|            0|  0.00%|            realm = chal['realm']
  1120|         0|            0|            0|  0.00%|            nonce = chal['nonce']
  1121|         0|            0|            0|  0.00%|            qop = chal.get('qop')
  1122|         0|            0|            0|  0.00%|            algorithm = chal.get('algorithm', 'MD5')
  1123|         0|            0|            0|  0.00%|            # mod_digest doesn't send an opaque, even though it isn't
  1124|         0|            0|            0|  0.00%|            # supposed to be optional
  1125|         0|            0|            0|  0.00%|            opaque = chal.get('opaque', None)
  1126|         0|            0|            0|  0.00%|        except KeyError:
  1127|         0|            0|            0|  0.00%|            return None
  1128|         0|            0|            0|  0.00%|
  1129|         0|            0|            0|  0.00%|        H, KD = self.get_algorithm_impls(algorithm)
  1130|         0|            0|            0|  0.00%|        if H is None:
  1131|         0|            0|            0|  0.00%|            return None
  1132|         0|            0|            0|  0.00%|
  1133|         0|            0|            0|  0.00%|        user, pw = self.passwd.find_user_password(realm, req.full_url)
  1134|         0|            0|            0|  0.00%|        if user is None:
  1135|         0|            0|            0|  0.00%|            return None
  1136|         0|            0|            0|  0.00%|
  1137|         0|            0|            0|  0.00%|        # XXX not implemented yet
  1138|         0|            0|            0|  0.00%|        if req.data is not None:
  1139|         0|            0|            0|  0.00%|            entdig = self.get_entity_digest(req.data, chal)
  1140|         0|            0|            0|  0.00%|        else:
  1141|         0|            0|            0|  0.00%|            entdig = None
  1142|         0|            0|            0|  0.00%|
  1143|         0|            0|            0|  0.00%|        A1 = "%s:%s:%s" % (user, realm, pw)
  1144|         0|            0|            0|  0.00%|        A2 = "%s:%s" % (req.get_method(),
  1145|         0|            0|            0|  0.00%|                        # XXX selector: what about proxies and full urls
  1146|         0|            0|            0|  0.00%|                        req.selector)
  1147|         0|            0|            0|  0.00%|        if qop == 'auth':
  1148|         0|            0|            0|  0.00%|            if nonce == self.last_nonce:
  1149|         0|            0|            0|  0.00%|                self.nonce_count += 1
  1150|         0|            0|            0|  0.00%|            else:
  1151|         0|            0|            0|  0.00%|                self.nonce_count = 1
  1152|         0|            0|            0|  0.00%|                self.last_nonce = nonce
  1153|         0|            0|            0|  0.00%|            ncvalue = '%08x' % self.nonce_count
  1154|         0|            0|            0|  0.00%|            cnonce = self.get_cnonce(nonce)
  1155|         0|            0|            0|  0.00%|            noncebit = "%s:%s:%s:%s:%s" % (nonce, ncvalue, cnonce, qop, H(A2))
  1156|         0|            0|            0|  0.00%|            respdig = KD(H(A1), noncebit)
  1157|         0|            0|            0|  0.00%|        elif qop is None:
  1158|         0|            0|            0|  0.00%|            respdig = KD(H(A1), "%s:%s" % (nonce, H(A2)))
  1159|         0|            0|            0|  0.00%|        else:
  1160|         0|            0|            0|  0.00%|            # XXX handle auth-int.
  1161|         0|            0|            0|  0.00%|            raise URLError("qop '%s' is not supported." % qop)
  1162|         0|            0|            0|  0.00%|
  1163|         0|            0|            0|  0.00%|        # XXX should the partial digests be encoded too?
  1164|         0|            0|            0|  0.00%|
  1165|         0|            0|            0|  0.00%|        base = 'username="%s", realm="%s", nonce="%s", uri="%s", ' \
  1166|         0|            0|            0|  0.00%|               'response="%s"' % (user, realm, nonce, req.selector,
  1167|         0|            0|            0|  0.00%|                                  respdig)
  1168|         0|            0|            0|  0.00%|        if opaque:
  1169|         0|            0|            0|  0.00%|            base += ', opaque="%s"' % opaque
  1170|         0|            0|            0|  0.00%|        if entdig:
  1171|         0|            0|            0|  0.00%|            base += ', digest="%s"' % entdig
  1172|         0|            0|            0|  0.00%|        base += ', algorithm="%s"' % algorithm
  1173|         0|            0|            0|  0.00%|        if qop:
  1174|         0|            0|            0|  0.00%|            base += ', qop=auth, nc=%s, cnonce="%s"' % (ncvalue, cnonce)
  1175|         0|            0|            0|  0.00%|        return base
  1176|         0|            0|            0|  0.00%|
  1177|         0|            0|            0|  0.00%|    def get_algorithm_impls(self, algorithm):
  1178|         0|            0|            0|  0.00%|        # lambdas assume digest modules are imported at the top level
  1179|         0|            0|            0|  0.00%|        if algorithm == 'MD5':
  1180|         0|            0|            0|  0.00%|            H = lambda x: hashlib.md5(x.encode("ascii")).hexdigest()
  1181|         0|            0|            0|  0.00%|        elif algorithm == 'SHA':
  1182|         0|            0|            0|  0.00%|            H = lambda x: hashlib.sha1(x.encode("ascii")).hexdigest()
  1183|         0|            0|            0|  0.00%|        # XXX MD5-sess
  1184|         0|            0|            0|  0.00%|        else:
  1185|         0|            0|            0|  0.00%|            raise ValueError("Unsupported digest authentication "
  1186|         0|            0|            0|  0.00%|                             "algorithm %r" % algorithm)
  1187|         0|            0|            0|  0.00%|        KD = lambda s, d: H("%s:%s" % (s, d))
  1188|         0|            0|            0|  0.00%|        return H, KD
  1189|         0|            0|            0|  0.00%|
  1190|         0|            0|            0|  0.00%|    def get_entity_digest(self, data, chal):
  1191|         0|            0|            0|  0.00%|        # XXX not implemented yet
  1192|         0|            0|            0|  0.00%|        return None
  1193|         0|            0|            0|  0.00%|
  1194|         0|            0|            0|  0.00%|
  1195|         0|            0|            0|  0.00%|class HTTPDigestAuthHandler(BaseHandler, AbstractDigestAuthHandler):
  1196|         0|            0|            0|  0.00%|    """An authentication protocol defined by RFC 2069
  1197|         0|            0|            0|  0.00%|
  1198|         0|            0|            0|  0.00%|    Digest authentication improves on basic authentication because it
  1199|         0|            0|            0|  0.00%|    does not transmit passwords in the clear.
  1200|         0|            0|            0|  0.00%|    """
  1201|         0|            0|            0|  0.00%|
  1202|         0|            0|            0|  0.00%|    auth_header = 'Authorization'
  1203|         0|            0|            0|  0.00%|    handler_order = 490  # before Basic auth
  1204|         0|            0|            0|  0.00%|
  1205|         0|            0|            0|  0.00%|    def http_error_401(self, req, fp, code, msg, headers):
  1206|         0|            0|            0|  0.00%|        host = urlparse(req.full_url)[1]
  1207|         0|            0|            0|  0.00%|        retry = self.http_error_auth_reqed('www-authenticate',
  1208|         0|            0|            0|  0.00%|                                           host, req, headers)
  1209|         0|            0|            0|  0.00%|        self.reset_retry_count()
  1210|         0|            0|            0|  0.00%|        return retry
  1211|         0|            0|            0|  0.00%|
  1212|         0|            0|            0|  0.00%|
  1213|         0|            0|            0|  0.00%|class ProxyDigestAuthHandler(BaseHandler, AbstractDigestAuthHandler):
  1214|         0|            0|            0|  0.00%|
  1215|         0|            0|            0|  0.00%|    auth_header = 'Proxy-Authorization'
  1216|         0|            0|            0|  0.00%|    handler_order = 490  # before Basic auth
  1217|         0|            0|            0|  0.00%|
  1218|         0|            0|            0|  0.00%|    def http_error_407(self, req, fp, code, msg, headers):
  1219|         0|            0|            0|  0.00%|        host = req.host
  1220|         0|            0|            0|  0.00%|        retry = self.http_error_auth_reqed('proxy-authenticate',
  1221|         0|            0|            0|  0.00%|                                           host, req, headers)
  1222|         0|            0|            0|  0.00%|        self.reset_retry_count()
  1223|         0|            0|            0|  0.00%|        return retry
  1224|         0|            0|            0|  0.00%|
  1225|         0|            0|            0|  0.00%|class AbstractHTTPHandler(BaseHandler):
  1226|         0|            0|            0|  0.00%|
  1227|         0|            0|            0|  0.00%|    def __init__(self, debuglevel=0):
  1228|         0|            0|            0|  0.00%|        self._debuglevel = debuglevel
  1229|         0|            0|            0|  0.00%|
  1230|         0|            0|            0|  0.00%|    def set_http_debuglevel(self, level):
  1231|         0|            0|            0|  0.00%|        self._debuglevel = level
  1232|         0|            0|            0|  0.00%|
  1233|         0|            0|            0|  0.00%|    def _get_content_length(self, request):
  1234|         0|            0|            0|  0.00%|        return http.client.HTTPConnection._get_content_length(
  1235|         0|            0|            0|  0.00%|            request.data,
  1236|         0|            0|            0|  0.00%|            request.get_method())
  1237|         0|            0|            0|  0.00%|
  1238|         0|            0|            0|  0.00%|    def do_request_(self, request):
  1239|         0|            0|            0|  0.00%|        host = request.host
  1240|         0|            0|            0|  0.00%|        if not host:
  1241|         0|            0|            0|  0.00%|            raise URLError('no host given')
  1242|         0|            0|            0|  0.00%|
  1243|         0|            0|            0|  0.00%|        if request.data is not None:  # POST
  1244|         0|            0|            0|  0.00%|            data = request.data
  1245|         0|            0|            0|  0.00%|            if isinstance(data, str):
  1246|         0|            0|            0|  0.00%|                msg = "POST data should be bytes, an iterable of bytes, " \
  1247|         0|            0|            0|  0.00%|                      "or a file object. It cannot be of type str."
  1248|         0|            0|            0|  0.00%|                raise TypeError(msg)
  1249|         0|            0|            0|  0.00%|            if not request.has_header('Content-type'):
  1250|         0|            0|            0|  0.00%|                request.add_unredirected_header(
  1251|         0|            0|            0|  0.00%|                    'Content-type',
  1252|         0|            0|            0|  0.00%|                    'application/x-www-form-urlencoded')
  1253|         0|            0|            0|  0.00%|            if (not request.has_header('Content-length')
  1254|         0|            0|            0|  0.00%|                    and not request.has_header('Transfer-encoding')):
  1255|         0|            0|            0|  0.00%|                content_length = self._get_content_length(request)
  1256|         0|            0|            0|  0.00%|                if content_length is not None:
  1257|         0|            0|            0|  0.00%|                    request.add_unredirected_header(
  1258|         0|            0|            0|  0.00%|                            'Content-length', str(content_length))
  1259|         0|            0|            0|  0.00%|                else:
  1260|         0|            0|            0|  0.00%|                    request.add_unredirected_header(
  1261|         0|            0|            0|  0.00%|                            'Transfer-encoding', 'chunked')
  1262|         0|            0|            0|  0.00%|
  1263|         0|            0|            0|  0.00%|        sel_host = host
  1264|         0|            0|            0|  0.00%|        if request.has_proxy():
  1265|         0|            0|            0|  0.00%|            scheme, sel = splittype(request.selector)
  1266|         0|            0|            0|  0.00%|            sel_host, sel_path = splithost(sel)
  1267|         0|            0|            0|  0.00%|        if not request.has_header('Host'):
  1268|         0|            0|            0|  0.00%|            request.add_unredirected_header('Host', sel_host)
  1269|         0|            0|            0|  0.00%|        for name, value in self.parent.addheaders:
  1270|         0|            0|            0|  0.00%|            name = name.capitalize()
  1271|         0|            0|            0|  0.00%|            if not request.has_header(name):
  1272|         0|            0|            0|  0.00%|                request.add_unredirected_header(name, value)
  1273|         0|            0|            0|  0.00%|
  1274|         0|            0|            0|  0.00%|        return request
  1275|         0|            0|            0|  0.00%|
  1276|         0|            0|            0|  0.00%|    def do_open(self, http_class, req, **http_conn_args):
  1277|         0|            0|            0|  0.00%|        """Return an HTTPResponse object for the request, using http_class.
  1278|         0|            0|            0|  0.00%|
  1279|         0|            0|            0|  0.00%|        http_class must implement the HTTPConnection API from http.client.
  1280|         0|            0|            0|  0.00%|        """
  1281|         0|            0|            0|  0.00%|        host = req.host
  1282|         0|            0|            0|  0.00%|        if not host:
  1283|         0|            0|            0|  0.00%|            raise URLError('no host given')
  1284|         0|            0|            0|  0.00%|
  1285|         0|            0|            0|  0.00%|        # will parse host:port
  1286|         0|            0|            0|  0.00%|        h = http_class(host, timeout=req.timeout, **http_conn_args)
  1287|         0|            0|            0|  0.00%|        h.set_debuglevel(self._debuglevel)
  1288|         0|            0|            0|  0.00%|
  1289|         0|            0|            0|  0.00%|        headers = dict(req.unredirected_hdrs)
  1290|         0|            0|            0|  0.00%|        headers.update(dict((k, v) for k, v in req.headers.items()
  1291|         0|            0|            0|  0.00%|                            if k not in headers))
  1292|         0|            0|            0|  0.00%|
  1293|         0|            0|            0|  0.00%|        # TODO(jhylton): Should this be redesigned to handle
  1294|         0|            0|            0|  0.00%|        # persistent connections?
  1295|         0|            0|            0|  0.00%|
  1296|         0|            0|            0|  0.00%|        # We want to make an HTTP/1.1 request, but the addinfourl
  1297|         0|            0|            0|  0.00%|        # class isn't prepared to deal with a persistent connection.
  1298|         0|            0|            0|  0.00%|        # It will try to read all remaining data from the socket,
  1299|         0|            0|            0|  0.00%|        # which will block while the server waits for the next request.
  1300|         0|            0|            0|  0.00%|        # So make sure the connection gets closed after the (only)
  1301|         0|            0|            0|  0.00%|        # request.
  1302|         0|            0|            0|  0.00%|        headers["Connection"] = "close"
  1303|         0|            0|            0|  0.00%|        headers = dict((name.title(), val) for name, val in headers.items())
  1304|         0|            0|            0|  0.00%|
  1305|         0|            0|            0|  0.00%|        if req._tunnel_host:
  1306|         0|            0|            0|  0.00%|            tunnel_headers = {}
  1307|         0|            0|            0|  0.00%|            proxy_auth_hdr = "Proxy-Authorization"
  1308|         0|            0|            0|  0.00%|            if proxy_auth_hdr in headers:
  1309|         0|            0|            0|  0.00%|                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]
  1310|         0|            0|            0|  0.00%|                # Proxy-Authorization should not be sent to origin
  1311|         0|            0|            0|  0.00%|                # server.
  1312|         0|            0|            0|  0.00%|                del headers[proxy_auth_hdr]
  1313|         0|            0|            0|  0.00%|            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)
  1314|         0|            0|            0|  0.00%|
  1315|         0|            0|            0|  0.00%|        try:
  1316|         0|            0|            0|  0.00%|            try:
  1317|         0|            0|            0|  0.00%|                h.request(req.get_method(), req.selector, req.data, headers,
  1318|         0|            0|            0|  0.00%|                          encode_chunked=req.has_header('Transfer-encoding'))
  1319|         0|            0|            0|  0.00%|            except OSError as err: # timeout error
  1320|         0|            0|            0|  0.00%|                raise URLError(err)
  1321|         0|            0|            0|  0.00%|            r = h.getresponse()
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\http\client.py:1287 getresponse
  1322|         0|            0|            0|  0.00%|        except:
  1323|         0|            0|            0|  0.00%|            h.close()
  1324|         0|            0|            0|  0.00%|            raise
  1325|         0|            0|            0|  0.00%|
  1326|         0|            0|            0|  0.00%|        # If the server does not send us a 'Connection: close' header,
  1327|         0|            0|            0|  0.00%|        # HTTPConnection assumes the socket should be left open. Manually
  1328|         0|            0|            0|  0.00%|        # mark the socket to be closed when this response object goes away.
  1329|         0|            0|            0|  0.00%|        if h.sock:
  1330|         0|            0|            0|  0.00%|            h.sock.close()
  1331|         0|            0|            0|  0.00%|            h.sock = None
  1332|         0|            0|            0|  0.00%|
  1333|         0|            0|            0|  0.00%|        r.url = req.get_full_url()
  1334|         0|            0|            0|  0.00%|        # This line replaces the .msg attribute of the HTTPResponse
  1335|         0|            0|            0|  0.00%|        # with .headers, because urllib clients expect the response to
  1336|         0|            0|            0|  0.00%|        # have the reason in .msg.  It would be good to mark this
  1337|         0|            0|            0|  0.00%|        # attribute is deprecated and get then to use info() or
  1338|         0|            0|            0|  0.00%|        # .headers.
  1339|         0|            0|            0|  0.00%|        r.msg = r.reason
  1340|         0|            0|            0|  0.00%|        return r
  1341|         0|            0|            0|  0.00%|
  1342|         0|            0|            0|  0.00%|
  1343|         0|            0|            0|  0.00%|class HTTPHandler(AbstractHTTPHandler):
  1344|         0|            0|            0|  0.00%|
  1345|         0|            0|            0|  0.00%|    def http_open(self, req):
  1346|         0|            0|            0|  0.00%|        return self.do_open(http.client.HTTPConnection, req)
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\urllib\request.py:1276 do_open
  1347|         0|            0|            0|  0.00%|
  1348|         0|            0|            0|  0.00%|    http_request = AbstractHTTPHandler.do_request_
  1349|         0|            0|            0|  0.00%|
  1350|         0|            0|            0|  0.00%|if hasattr(http.client, 'HTTPSConnection'):
  1351|         0|            0|            0|  0.00%|
  1352|         0|            0|            0|  0.00%|    class HTTPSHandler(AbstractHTTPHandler):
  1353|         0|            0|            0|  0.00%|
  1354|         0|            0|            0|  0.00%|        def __init__(self, debuglevel=0, context=None, check_hostname=None):
  1355|         0|            0|            0|  0.00%|            AbstractHTTPHandler.__init__(self, debuglevel)
  1356|         0|            0|            0|  0.00%|            self._context = context
  1357|         0|            0|            0|  0.00%|            self._check_hostname = check_hostname
  1358|         0|            0|            0|  0.00%|
  1359|         0|            0|            0|  0.00%|        def https_open(self, req):
  1360|         0|            0|            0|  0.00%|            return self.do_open(http.client.HTTPSConnection, req,
  1361|         0|            0|            0|  0.00%|                context=self._context, check_hostname=self._check_hostname)
  1362|         0|            0|            0|  0.00%|
  1363|         0|            0|            0|  0.00%|        https_request = AbstractHTTPHandler.do_request_
  1364|         0|            0|            0|  0.00%|
  1365|         0|            0|            0|  0.00%|    __all__.append('HTTPSHandler')
  1366|         0|            0|            0|  0.00%|
  1367|         0|            0|            0|  0.00%|class HTTPCookieProcessor(BaseHandler):
  1368|         0|            0|            0|  0.00%|    def __init__(self, cookiejar=None):
  1369|         0|            0|            0|  0.00%|        import http.cookiejar
  1370|         0|            0|            0|  0.00%|        if cookiejar is None:
  1371|         0|            0|            0|  0.00%|            cookiejar = http.cookiejar.CookieJar()
  1372|         0|            0|            0|  0.00%|        self.cookiejar = cookiejar
  1373|         0|            0|            0|  0.00%|
  1374|         0|            0|            0|  0.00%|    def http_request(self, request):
  1375|         0|            0|            0|  0.00%|        self.cookiejar.add_cookie_header(request)
  1376|         0|            0|            0|  0.00%|        return request
  1377|         0|            0|            0|  0.00%|
  1378|         0|            0|            0|  0.00%|    def http_response(self, request, response):
  1379|         0|            0|            0|  0.00%|        self.cookiejar.extract_cookies(response, request)
  1380|         0|            0|            0|  0.00%|        return response
  1381|         0|            0|            0|  0.00%|
  1382|         0|            0|            0|  0.00%|    https_request = http_request
  1383|         0|            0|            0|  0.00%|    https_response = http_response
  1384|         0|            0|            0|  0.00%|
  1385|         0|            0|            0|  0.00%|class UnknownHandler(BaseHandler):
  1386|         0|            0|            0|  0.00%|    def unknown_open(self, req):
  1387|         0|            0|            0|  0.00%|        type = req.type
  1388|         0|            0|            0|  0.00%|        raise URLError('unknown url type: %s' % type)
  1389|         0|            0|            0|  0.00%|
  1390|         0|            0|            0|  0.00%|def parse_keqv_list(l):
  1391|         0|            0|            0|  0.00%|    """Parse list of key=value strings where keys are not duplicated."""
  1392|         0|            0|            0|  0.00%|    parsed = {}
  1393|         0|            0|            0|  0.00%|    for elt in l:
  1394|         0|            0|            0|  0.00%|        k, v = elt.split('=', 1)
  1395|         0|            0|            0|  0.00%|        if v[0] == '"' and v[-1] == '"':
  1396|         0|            0|            0|  0.00%|            v = v[1:-1]
  1397|         0|            0|            0|  0.00%|        parsed[k] = v
  1398|         0|            0|            0|  0.00%|    return parsed
  1399|         0|            0|            0|  0.00%|
  1400|         0|            0|            0|  0.00%|def parse_http_list(s):
  1401|         0|            0|            0|  0.00%|    """Parse lists as described by RFC 2068 Section 2.
  1402|         0|            0|            0|  0.00%|
  1403|         0|            0|            0|  0.00%|    In particular, parse comma-separated lists where the elements of
  1404|         0|            0|            0|  0.00%|    the list may include quoted-strings.  A quoted-string could
  1405|         0|            0|            0|  0.00%|    contain a comma.  A non-quoted string could have quotes in the
  1406|         0|            0|            0|  0.00%|    middle.  Neither commas nor quotes count if they are escaped.
  1407|         0|            0|            0|  0.00%|    Only double-quotes count, not single-quotes.
  1408|         0|            0|            0|  0.00%|    """
  1409|         0|            0|            0|  0.00%|    res = []
  1410|         0|            0|            0|  0.00%|    part = ''
  1411|         0|            0|            0|  0.00%|
  1412|         0|            0|            0|  0.00%|    escape = quote = False
  1413|         0|            0|            0|  0.00%|    for cur in s:
  1414|         0|            0|            0|  0.00%|        if escape:
  1415|         0|            0|            0|  0.00%|            part += cur
  1416|         0|            0|            0|  0.00%|            escape = False
  1417|         0|            0|            0|  0.00%|            continue
  1418|         0|            0|            0|  0.00%|        if quote:
  1419|         0|            0|            0|  0.00%|            if cur == '\\':
  1420|         0|            0|            0|  0.00%|                escape = True
  1421|         0|            0|            0|  0.00%|                continue
  1422|         0|            0|            0|  0.00%|            elif cur == '"':
  1423|         0|            0|            0|  0.00%|                quote = False
  1424|         0|            0|            0|  0.00%|            part += cur
  1425|         0|            0|            0|  0.00%|            continue
  1426|         0|            0|            0|  0.00%|
  1427|         0|            0|            0|  0.00%|        if cur == ',':
  1428|         0|            0|            0|  0.00%|            res.append(part)
  1429|         0|            0|            0|  0.00%|            part = ''
  1430|         0|            0|            0|  0.00%|            continue
  1431|         0|            0|            0|  0.00%|
  1432|         0|            0|            0|  0.00%|        if cur == '"':
  1433|         0|            0|            0|  0.00%|            quote = True
  1434|         0|            0|            0|  0.00%|
  1435|         0|            0|            0|  0.00%|        part += cur
  1436|         0|            0|            0|  0.00%|
  1437|         0|            0|            0|  0.00%|    # append last part
  1438|         0|            0|            0|  0.00%|    if part:
  1439|         0|            0|            0|  0.00%|        res.append(part)
  1440|         0|            0|            0|  0.00%|
  1441|         0|            0|            0|  0.00%|    return [part.strip() for part in res]
  1442|         0|            0|            0|  0.00%|
  1443|         0|            0|            0|  0.00%|class FileHandler(BaseHandler):
  1444|         0|            0|            0|  0.00%|    # Use local file or FTP depending on form of URL
  1445|         0|            0|            0|  0.00%|    def file_open(self, req):
  1446|         0|            0|            0|  0.00%|        url = req.selector
  1447|         0|            0|            0|  0.00%|        if url[:2] == '//' and url[2:3] != '/' and (req.host and
  1448|         0|            0|            0|  0.00%|                req.host != 'localhost'):
  1449|         0|            0|            0|  0.00%|            if not req.host in self.get_names():
  1450|         0|            0|            0|  0.00%|                raise URLError("file:// scheme is supported only on localhost")
  1451|         0|            0|            0|  0.00%|        else:
  1452|         0|            0|            0|  0.00%|            return self.open_local_file(req)
  1453|         0|            0|            0|  0.00%|
  1454|         0|            0|            0|  0.00%|    # names for the localhost
  1455|         0|            0|            0|  0.00%|    names = None
  1456|         0|            0|            0|  0.00%|    def get_names(self):
  1457|         0|            0|            0|  0.00%|        if FileHandler.names is None:
  1458|         0|            0|            0|  0.00%|            try:
  1459|         0|            0|            0|  0.00%|                FileHandler.names = tuple(
  1460|         0|            0|            0|  0.00%|                    socket.gethostbyname_ex('localhost')[2] +
  1461|         0|            0|            0|  0.00%|                    socket.gethostbyname_ex(socket.gethostname())[2])
  1462|         0|            0|            0|  0.00%|            except socket.gaierror:
  1463|         0|            0|            0|  0.00%|                FileHandler.names = (socket.gethostbyname('localhost'),)
  1464|         0|            0|            0|  0.00%|        return FileHandler.names
  1465|         0|            0|            0|  0.00%|
  1466|         0|            0|            0|  0.00%|    # not entirely sure what the rules are here
  1467|         0|            0|            0|  0.00%|    def open_local_file(self, req):
  1468|         0|            0|            0|  0.00%|        import email.utils
  1469|         0|            0|            0|  0.00%|        import mimetypes
  1470|         0|            0|            0|  0.00%|        host = req.host
  1471|         0|            0|            0|  0.00%|        filename = req.selector
  1472|         0|            0|            0|  0.00%|        localfile = url2pathname(filename)
  1473|         0|            0|            0|  0.00%|        try:
  1474|         0|            0|            0|  0.00%|            stats = os.stat(localfile)
  1475|         0|            0|            0|  0.00%|            size = stats.st_size
  1476|         0|            0|            0|  0.00%|            modified = email.utils.formatdate(stats.st_mtime, usegmt=True)
  1477|         0|            0|            0|  0.00%|            mtype = mimetypes.guess_type(filename)[0]
  1478|         0|            0|            0|  0.00%|            headers = email.message_from_string(
  1479|         0|            0|            0|  0.00%|                'Content-type: %s\nContent-length: %d\nLast-modified: %s\n' %
  1480|         0|            0|            0|  0.00%|                (mtype or 'text/plain', size, modified))
  1481|         0|            0|            0|  0.00%|            if host:
  1482|         0|            0|            0|  0.00%|                host, port = splitport(host)
  1483|         0|            0|            0|  0.00%|            if not host or \
  1484|         0|            0|            0|  0.00%|                (not port and _safe_gethostbyname(host) in self.get_names()):
  1485|         0|            0|            0|  0.00%|                if host:
  1486|         0|            0|            0|  0.00%|                    origurl = 'file://' + host + filename
  1487|         0|            0|            0|  0.00%|                else:
  1488|         0|            0|            0|  0.00%|                    origurl = 'file://' + filename
  1489|         0|            0|            0|  0.00%|                return addinfourl(open(localfile, 'rb'), headers, origurl)
  1490|         0|            0|            0|  0.00%|        except OSError as exp:
  1491|         0|            0|            0|  0.00%|            # users shouldn't expect OSErrors coming from urlopen()
  1492|         0|            0|            0|  0.00%|            raise URLError(exp)
  1493|         0|            0|            0|  0.00%|        raise URLError('file not on local host')
  1494|         0|            0|            0|  0.00%|
  1495|         0|            0|            0|  0.00%|def _safe_gethostbyname(host):
  1496|         0|            0|            0|  0.00%|    try:
  1497|         0|            0|            0|  0.00%|        return socket.gethostbyname(host)
  1498|         0|            0|            0|  0.00%|    except socket.gaierror:
  1499|         0|            0|            0|  0.00%|        return None
  1500|         0|            0|            0|  0.00%|
  1501|         0|            0|            0|  0.00%|class FTPHandler(BaseHandler):
  1502|         0|            0|            0|  0.00%|    def ftp_open(self, req):
  1503|         0|            0|            0|  0.00%|        import ftplib
  1504|         0|            0|            0|  0.00%|        import mimetypes
  1505|         0|            0|            0|  0.00%|        host = req.host
  1506|         0|            0|            0|  0.00%|        if not host:
  1507|         0|            0|            0|  0.00%|            raise URLError('ftp error: no host given')
  1508|         0|            0|            0|  0.00%|        host, port = splitport(host)
  1509|         0|            0|            0|  0.00%|        if port is None:
  1510|         0|            0|            0|  0.00%|            port = ftplib.FTP_PORT
  1511|         0|            0|            0|  0.00%|        else:
  1512|         0|            0|            0|  0.00%|            port = int(port)
  1513|         0|            0|            0|  0.00%|
  1514|         0|            0|            0|  0.00%|        # username/password handling
  1515|         0|            0|            0|  0.00%|        user, host = splituser(host)
  1516|         0|            0|            0|  0.00%|        if user:
  1517|         0|            0|            0|  0.00%|            user, passwd = splitpasswd(user)
  1518|         0|            0|            0|  0.00%|        else:
  1519|         0|            0|            0|  0.00%|            passwd = None
  1520|         0|            0|            0|  0.00%|        host = unquote(host)
  1521|         0|            0|            0|  0.00%|        user = user or ''
  1522|         0|            0|            0|  0.00%|        passwd = passwd or ''
  1523|         0|            0|            0|  0.00%|
  1524|         0|            0|            0|  0.00%|        try:
  1525|         0|            0|            0|  0.00%|            host = socket.gethostbyname(host)
  1526|         0|            0|            0|  0.00%|        except OSError as msg:
  1527|         0|            0|            0|  0.00%|            raise URLError(msg)
  1528|         0|            0|            0|  0.00%|        path, attrs = splitattr(req.selector)
  1529|         0|            0|            0|  0.00%|        dirs = path.split('/')
  1530|         0|            0|            0|  0.00%|        dirs = list(map(unquote, dirs))
  1531|         0|            0|            0|  0.00%|        dirs, file = dirs[:-1], dirs[-1]
  1532|         0|            0|            0|  0.00%|        if dirs and not dirs[0]:
  1533|         0|            0|            0|  0.00%|            dirs = dirs[1:]
  1534|         0|            0|            0|  0.00%|        try:
  1535|         0|            0|            0|  0.00%|            fw = self.connect_ftp(user, passwd, host, port, dirs, req.timeout)
  1536|         0|            0|            0|  0.00%|            type = file and 'I' or 'D'
  1537|         0|            0|            0|  0.00%|            for attr in attrs:
  1538|         0|            0|            0|  0.00%|                attr, value = splitvalue(attr)
  1539|         0|            0|            0|  0.00%|                if attr.lower() == 'type' and \
  1540|         0|            0|            0|  0.00%|                   value in ('a', 'A', 'i', 'I', 'd', 'D'):
  1541|         0|            0|            0|  0.00%|                    type = value.upper()
  1542|         0|            0|            0|  0.00%|            fp, retrlen = fw.retrfile(file, type)
  1543|         0|            0|            0|  0.00%|            headers = ""
  1544|         0|            0|            0|  0.00%|            mtype = mimetypes.guess_type(req.full_url)[0]
  1545|         0|            0|            0|  0.00%|            if mtype:
  1546|         0|            0|            0|  0.00%|                headers += "Content-type: %s\n" % mtype
  1547|         0|            0|            0|  0.00%|            if retrlen is not None and retrlen >= 0:
  1548|         0|            0|            0|  0.00%|                headers += "Content-length: %d\n" % retrlen
  1549|         0|            0|            0|  0.00%|            headers = email.message_from_string(headers)
  1550|         0|            0|            0|  0.00%|            return addinfourl(fp, headers, req.full_url)
  1551|         0|            0|            0|  0.00%|        except ftplib.all_errors as exp:
  1552|         0|            0|            0|  0.00%|            exc = URLError('ftp error: %r' % exp)
  1553|         0|            0|            0|  0.00%|            raise exc.with_traceback(sys.exc_info()[2])
  1554|         0|            0|            0|  0.00%|
  1555|         0|            0|            0|  0.00%|    def connect_ftp(self, user, passwd, host, port, dirs, timeout):
  1556|         0|            0|            0|  0.00%|        return ftpwrapper(user, passwd, host, port, dirs, timeout,
  1557|         0|            0|            0|  0.00%|                          persistent=False)
  1558|         0|            0|            0|  0.00%|
  1559|         0|            0|            0|  0.00%|class CacheFTPHandler(FTPHandler):
  1560|         0|            0|            0|  0.00%|    # XXX would be nice to have pluggable cache strategies
  1561|         0|            0|            0|  0.00%|    # XXX this stuff is definitely not thread safe
  1562|         0|            0|            0|  0.00%|    def __init__(self):
  1563|         0|            0|            0|  0.00%|        self.cache = {}
  1564|         0|            0|            0|  0.00%|        self.timeout = {}
  1565|         0|            0|            0|  0.00%|        self.soonest = 0
  1566|         0|            0|            0|  0.00%|        self.delay = 60
  1567|         0|            0|            0|  0.00%|        self.max_conns = 16
  1568|         0|            0|            0|  0.00%|
  1569|         0|            0|            0|  0.00%|    def setTimeout(self, t):
  1570|         0|            0|            0|  0.00%|        self.delay = t
  1571|         0|            0|            0|  0.00%|
  1572|         0|            0|            0|  0.00%|    def setMaxConns(self, m):
  1573|         0|            0|            0|  0.00%|        self.max_conns = m
  1574|         0|            0|            0|  0.00%|
  1575|         0|            0|            0|  0.00%|    def connect_ftp(self, user, passwd, host, port, dirs, timeout):
  1576|         0|            0|            0|  0.00%|        key = user, host, port, '/'.join(dirs), timeout
  1577|         0|            0|            0|  0.00%|        if key in self.cache:
  1578|         0|            0|            0|  0.00%|            self.timeout[key] = time.time() + self.delay
  1579|         0|            0|            0|  0.00%|        else:
  1580|         0|            0|            0|  0.00%|            self.cache[key] = ftpwrapper(user, passwd, host, port,
  1581|         0|            0|            0|  0.00%|                                         dirs, timeout)
  1582|         0|            0|            0|  0.00%|            self.timeout[key] = time.time() + self.delay
  1583|         0|            0|            0|  0.00%|        self.check_cache()
  1584|         0|            0|            0|  0.00%|        return self.cache[key]
  1585|         0|            0|            0|  0.00%|
  1586|         0|            0|            0|  0.00%|    def check_cache(self):
  1587|         0|            0|            0|  0.00%|        # first check for old ones
  1588|         0|            0|            0|  0.00%|        t = time.time()
  1589|         0|            0|            0|  0.00%|        if self.soonest <= t:
  1590|         0|            0|            0|  0.00%|            for k, v in list(self.timeout.items()):
  1591|         0|            0|            0|  0.00%|                if v < t:
  1592|         0|            0|            0|  0.00%|                    self.cache[k].close()
  1593|         0|            0|            0|  0.00%|                    del self.cache[k]
  1594|         0|            0|            0|  0.00%|                    del self.timeout[k]
  1595|         0|            0|            0|  0.00%|        self.soonest = min(list(self.timeout.values()))
  1596|         0|            0|            0|  0.00%|
  1597|         0|            0|            0|  0.00%|        # then check the size
  1598|         0|            0|            0|  0.00%|        if len(self.cache) == self.max_conns:
  1599|         0|            0|            0|  0.00%|            for k, v in list(self.timeout.items()):
  1600|         0|            0|            0|  0.00%|                if v == self.soonest:
  1601|         0|            0|            0|  0.00%|                    del self.cache[k]
  1602|         0|            0|            0|  0.00%|                    del self.timeout[k]
  1603|         0|            0|            0|  0.00%|                    break
  1604|         0|            0|            0|  0.00%|            self.soonest = min(list(self.timeout.values()))
  1605|         0|            0|            0|  0.00%|
  1606|         0|            0|            0|  0.00%|    def clear_cache(self):
  1607|         0|            0|            0|  0.00%|        for conn in self.cache.values():
  1608|         0|            0|            0|  0.00%|            conn.close()
  1609|         0|            0|            0|  0.00%|        self.cache.clear()
  1610|         0|            0|            0|  0.00%|        self.timeout.clear()
  1611|         0|            0|            0|  0.00%|
  1612|         0|            0|            0|  0.00%|class DataHandler(BaseHandler):
  1613|         0|            0|            0|  0.00%|    def data_open(self, req):
  1614|         0|            0|            0|  0.00%|        # data URLs as specified in RFC 2397.
  1615|         0|            0|            0|  0.00%|        #
  1616|         0|            0|            0|  0.00%|        # ignores POSTed data
  1617|         0|            0|            0|  0.00%|        #
  1618|         0|            0|            0|  0.00%|        # syntax:
  1619|         0|            0|            0|  0.00%|        # dataurl   := "data:" [ mediatype ] [ ";base64" ] "," data
  1620|         0|            0|            0|  0.00%|        # mediatype := [ type "/" subtype ] *( ";" parameter )
  1621|         0|            0|            0|  0.00%|        # data      := *urlchar
  1622|         0|            0|            0|  0.00%|        # parameter := attribute "=" value
  1623|         0|            0|            0|  0.00%|        url = req.full_url
  1624|         0|            0|            0|  0.00%|
  1625|         0|            0|            0|  0.00%|        scheme, data = url.split(":",1)
  1626|         0|            0|            0|  0.00%|        mediatype, data = data.split(",",1)
  1627|         0|            0|            0|  0.00%|
  1628|         0|            0|            0|  0.00%|        # even base64 encoded data URLs might be quoted so unquote in any case:
  1629|         0|            0|            0|  0.00%|        data = unquote_to_bytes(data)
  1630|         0|            0|            0|  0.00%|        if mediatype.endswith(";base64"):
  1631|         0|            0|            0|  0.00%|            data = base64.decodebytes(data)
  1632|         0|            0|            0|  0.00%|            mediatype = mediatype[:-7]
  1633|         0|            0|            0|  0.00%|
  1634|         0|            0|            0|  0.00%|        if not mediatype:
  1635|         0|            0|            0|  0.00%|            mediatype = "text/plain;charset=US-ASCII"
  1636|         0|            0|            0|  0.00%|
  1637|         0|            0|            0|  0.00%|        headers = email.message_from_string("Content-type: %s\nContent-length: %d\n" %
  1638|         0|            0|            0|  0.00%|            (mediatype, len(data)))
  1639|         0|            0|            0|  0.00%|
  1640|         0|            0|            0|  0.00%|        return addinfourl(io.BytesIO(data), headers, url)
  1641|         0|            0|            0|  0.00%|
  1642|         0|            0|            0|  0.00%|
  1643|         0|            0|            0|  0.00%|# Code move from the old urllib module
  1644|         0|            0|            0|  0.00%|
  1645|         0|            0|            0|  0.00%|MAXFTPCACHE = 10        # Trim the ftp cache beyond this size
  1646|         0|            0|            0|  0.00%|
  1647|         0|            0|            0|  0.00%|# Helper for non-unix systems
  1648|         0|            0|            0|  0.00%|if os.name == 'nt':
  1649|         0|            0|            0|  0.00%|    from nturl2path import url2pathname, pathname2url
  1650|         0|            0|            0|  0.00%|else:
  1651|         0|            0|            0|  0.00%|    def url2pathname(pathname):
  1652|         0|            0|            0|  0.00%|        """OS-specific conversion from a relative URL of the 'file' scheme
  1653|         0|            0|            0|  0.00%|        to a file system path; not recommended for general use."""
  1654|         0|            0|            0|  0.00%|        return unquote(pathname)
  1655|         0|            0|            0|  0.00%|
  1656|         0|            0|            0|  0.00%|    def pathname2url(pathname):
  1657|         0|            0|            0|  0.00%|        """OS-specific conversion from a file system path to a relative URL
  1658|         0|            0|            0|  0.00%|        of the 'file' scheme; not recommended for general use."""
  1659|         0|            0|            0|  0.00%|        return quote(pathname)
  1660|         0|            0|            0|  0.00%|
  1661|         0|            0|            0|  0.00%|# This really consists of two pieces:
  1662|         0|            0|            0|  0.00%|# (1) a class which handles opening of all sorts of URLs
  1663|         0|            0|            0|  0.00%|#     (plus assorted utilities etc.)
  1664|         0|            0|            0|  0.00%|# (2) a set of functions for parsing URLs
  1665|         0|            0|            0|  0.00%|# XXX Should these be separated out into different modules?
  1666|         0|            0|            0|  0.00%|
  1667|         0|            0|            0|  0.00%|
  1668|         0|            0|            0|  0.00%|ftpcache = {}
  1669|         0|            0|            0|  0.00%|class URLopener:
  1670|         0|            0|            0|  0.00%|    """Class to open URLs.
  1671|         0|            0|            0|  0.00%|    This is a class rather than just a subroutine because we may need
  1672|         0|            0|            0|  0.00%|    more than one set of global protocol-specific options.
  1673|         0|            0|            0|  0.00%|    Note -- this is a base class for those who don't want the
  1674|         0|            0|            0|  0.00%|    automatic handling of errors type 302 (relocated) and 401
  1675|         0|            0|            0|  0.00%|    (authorization needed)."""
  1676|         0|            0|            0|  0.00%|
  1677|         0|            0|            0|  0.00%|    __tempfiles = None
  1678|         0|            0|            0|  0.00%|
  1679|         0|            0|            0|  0.00%|    version = "Python-urllib/%s" % __version__
  1680|         0|            0|            0|  0.00%|
  1681|         0|            0|            0|  0.00%|    # Constructor
  1682|         0|            0|            0|  0.00%|    def __init__(self, proxies=None, **x509):
  1683|         0|            0|            0|  0.00%|        msg = "%(class)s style of invoking requests is deprecated. " \
  1684|         0|            0|            0|  0.00%|              "Use newer urlopen functions/methods" % {'class': self.__class__.__name__}
  1685|         0|            0|            0|  0.00%|        warnings.warn(msg, DeprecationWarning, stacklevel=3)
  1686|         0|            0|            0|  0.00%|        if proxies is None:
  1687|         0|            0|            0|  0.00%|            proxies = getproxies()
  1688|         0|            0|            0|  0.00%|        assert hasattr(proxies, 'keys'), "proxies must be a mapping"
  1689|         0|            0|            0|  0.00%|        self.proxies = proxies
  1690|         0|            0|            0|  0.00%|        self.key_file = x509.get('key_file')
  1691|         0|            0|            0|  0.00%|        self.cert_file = x509.get('cert_file')
  1692|         0|            0|            0|  0.00%|        self.addheaders = [('User-Agent', self.version), ('Accept', '*/*')]
  1693|         0|            0|            0|  0.00%|        self.__tempfiles = []
  1694|         0|            0|            0|  0.00%|        self.__unlink = os.unlink # See cleanup()
  1695|         0|            0|            0|  0.00%|        self.tempcache = None
  1696|         0|            0|            0|  0.00%|        # Undocumented feature: if you assign {} to tempcache,
  1697|         0|            0|            0|  0.00%|        # it is used to cache files retrieved with
  1698|         0|            0|            0|  0.00%|        # self.retrieve().  This is not enabled by default
  1699|         0|            0|            0|  0.00%|        # since it does not work for changing documents (and I
  1700|         0|            0|            0|  0.00%|        # haven't got the logic to check expiration headers
  1701|         0|            0|            0|  0.00%|        # yet).
  1702|         0|            0|            0|  0.00%|        self.ftpcache = ftpcache
  1703|         0|            0|            0|  0.00%|        # Undocumented feature: you can use a different
  1704|         0|            0|            0|  0.00%|        # ftp cache by assigning to the .ftpcache member;
  1705|         0|            0|            0|  0.00%|        # in case you want logically independent URL openers
  1706|         0|            0|            0|  0.00%|        # XXX This is not threadsafe.  Bah.
  1707|         0|            0|            0|  0.00%|
  1708|         0|            0|            0|  0.00%|    def __del__(self):
  1709|         0|            0|            0|  0.00%|        self.close()
  1710|         0|            0|            0|  0.00%|
  1711|         0|            0|            0|  0.00%|    def close(self):
  1712|         0|            0|            0|  0.00%|        self.cleanup()
  1713|         0|            0|            0|  0.00%|
  1714|         0|            0|            0|  0.00%|    def cleanup(self):
  1715|         0|            0|            0|  0.00%|        # This code sometimes runs when the rest of this module
  1716|         0|            0|            0|  0.00%|        # has already been deleted, so it can't use any globals
  1717|         0|            0|            0|  0.00%|        # or import anything.
  1718|         0|            0|            0|  0.00%|        if self.__tempfiles:
  1719|         0|            0|            0|  0.00%|            for file in self.__tempfiles:
  1720|         0|            0|            0|  0.00%|                try:
  1721|         0|            0|            0|  0.00%|                    self.__unlink(file)
  1722|         0|            0|            0|  0.00%|                except OSError:
  1723|         0|            0|            0|  0.00%|                    pass
  1724|         0|            0|            0|  0.00%|            del self.__tempfiles[:]
  1725|         0|            0|            0|  0.00%|        if self.tempcache:
  1726|         0|            0|            0|  0.00%|            self.tempcache.clear()
  1727|         0|            0|            0|  0.00%|
  1728|         0|            0|            0|  0.00%|    def addheader(self, *args):
  1729|         0|            0|            0|  0.00%|        """Add a header to be used by the HTTP interface only
  1730|         0|            0|            0|  0.00%|        e.g. u.addheader('Accept', 'sound/basic')"""
  1731|         0|            0|            0|  0.00%|        self.addheaders.append(args)
  1732|         0|            0|            0|  0.00%|
  1733|         0|            0|            0|  0.00%|    # External interface
  1734|         0|            0|            0|  0.00%|    def open(self, fullurl, data=None):
  1735|         0|            0|            0|  0.00%|        """Use URLopener().open(file) instead of open(file, 'r')."""
  1736|         0|            0|            0|  0.00%|        fullurl = unwrap(to_bytes(fullurl))
  1737|         0|            0|            0|  0.00%|        fullurl = quote(fullurl, safe="%/:=&?~#+!$,;'@()*[]|")
  1738|         0|            0|            0|  0.00%|        if self.tempcache and fullurl in self.tempcache:
  1739|         0|            0|            0|  0.00%|            filename, headers = self.tempcache[fullurl]
  1740|         0|            0|            0|  0.00%|            fp = open(filename, 'rb')
  1741|         0|            0|            0|  0.00%|            return addinfourl(fp, headers, fullurl)
  1742|         0|            0|            0|  0.00%|        urltype, url = splittype(fullurl)
  1743|         0|            0|            0|  0.00%|        if not urltype:
  1744|         0|            0|            0|  0.00%|            urltype = 'file'
  1745|         0|            0|            0|  0.00%|        if urltype in self.proxies:
  1746|         0|            0|            0|  0.00%|            proxy = self.proxies[urltype]
  1747|         0|            0|            0|  0.00%|            urltype, proxyhost = splittype(proxy)
  1748|         0|            0|            0|  0.00%|            host, selector = splithost(proxyhost)
  1749|         0|            0|            0|  0.00%|            url = (host, fullurl) # Signal special case to open_*()
  1750|         0|            0|            0|  0.00%|        else:
  1751|         0|            0|            0|  0.00%|            proxy = None
  1752|         0|            0|            0|  0.00%|        name = 'open_' + urltype
  1753|         0|            0|            0|  0.00%|        self.type = urltype
  1754|         0|            0|            0|  0.00%|        name = name.replace('-', '_')
  1755|         0|            0|            0|  0.00%|        if not hasattr(self, name):
  1756|         0|            0|            0|  0.00%|            if proxy:
  1757|         0|            0|            0|  0.00%|                return self.open_unknown_proxy(proxy, fullurl, data)
  1758|         0|            0|            0|  0.00%|            else:
  1759|         0|            0|            0|  0.00%|                return self.open_unknown(fullurl, data)
  1760|         0|            0|            0|  0.00%|        try:
  1761|         0|            0|            0|  0.00%|            if data is None:
  1762|         0|            0|            0|  0.00%|                return getattr(self, name)(url)
  1763|         0|            0|            0|  0.00%|            else:
  1764|         0|            0|            0|  0.00%|                return getattr(self, name)(url, data)
  1765|         0|            0|            0|  0.00%|        except (HTTPError, URLError):
  1766|         0|            0|            0|  0.00%|            raise
  1767|         0|            0|            0|  0.00%|        except OSError as msg:
  1768|         0|            0|            0|  0.00%|            raise OSError('socket error', msg).with_traceback(sys.exc_info()[2])
  1769|         0|            0|            0|  0.00%|
  1770|         0|            0|            0|  0.00%|    def open_unknown(self, fullurl, data=None):
  1771|         0|            0|            0|  0.00%|        """Overridable interface to open unknown URL type."""
  1772|         0|            0|            0|  0.00%|        type, url = splittype(fullurl)
  1773|         0|            0|            0|  0.00%|        raise OSError('url error', 'unknown url type', type)
  1774|         0|            0|            0|  0.00%|
  1775|         0|            0|            0|  0.00%|    def open_unknown_proxy(self, proxy, fullurl, data=None):
  1776|         0|            0|            0|  0.00%|        """Overridable interface to open unknown URL type."""
  1777|         0|            0|            0|  0.00%|        type, url = splittype(fullurl)
  1778|         0|            0|            0|  0.00%|        raise OSError('url error', 'invalid proxy for %s' % type, proxy)
  1779|         0|            0|            0|  0.00%|
  1780|         0|            0|            0|  0.00%|    # External interface
  1781|         0|            0|            0|  0.00%|    def retrieve(self, url, filename=None, reporthook=None, data=None):
  1782|         0|            0|            0|  0.00%|        """retrieve(url) returns (filename, headers) for a local object
  1783|         0|            0|            0|  0.00%|        or (tempfilename, headers) for a remote object."""
  1784|         0|            0|            0|  0.00%|        url = unwrap(to_bytes(url))
  1785|         0|            0|            0|  0.00%|        if self.tempcache and url in self.tempcache:
  1786|         0|            0|            0|  0.00%|            return self.tempcache[url]
  1787|         0|            0|            0|  0.00%|        type, url1 = splittype(url)
  1788|         0|            0|            0|  0.00%|        if filename is None and (not type or type == 'file'):
  1789|         0|            0|            0|  0.00%|            try:
  1790|         0|            0|            0|  0.00%|                fp = self.open_local_file(url1)
  1791|         0|            0|            0|  0.00%|                hdrs = fp.info()
  1792|         0|            0|            0|  0.00%|                fp.close()
  1793|         0|            0|            0|  0.00%|                return url2pathname(splithost(url1)[1]), hdrs
  1794|         0|            0|            0|  0.00%|            except OSError as msg:
  1795|         0|            0|            0|  0.00%|                pass
  1796|         0|            0|            0|  0.00%|        fp = self.open(url, data)
  1797|         0|            0|            0|  0.00%|        try:
  1798|         0|            0|            0|  0.00%|            headers = fp.info()
  1799|         0|            0|            0|  0.00%|            if filename:
  1800|         0|            0|            0|  0.00%|                tfp = open(filename, 'wb')
  1801|         0|            0|            0|  0.00%|            else:
  1802|         0|            0|            0|  0.00%|                import tempfile
  1803|         0|            0|            0|  0.00%|                garbage, path = splittype(url)
  1804|         0|            0|            0|  0.00%|                garbage, path = splithost(path or "")
  1805|         0|            0|            0|  0.00%|                path, garbage = splitquery(path or "")
  1806|         0|            0|            0|  0.00%|                path, garbage = splitattr(path or "")
  1807|         0|            0|            0|  0.00%|                suffix = os.path.splitext(path)[1]
  1808|         0|            0|            0|  0.00%|                (fd, filename) = tempfile.mkstemp(suffix)
  1809|         0|            0|            0|  0.00%|                self.__tempfiles.append(filename)
  1810|         0|            0|            0|  0.00%|                tfp = os.fdopen(fd, 'wb')
  1811|         0|            0|            0|  0.00%|            try:
  1812|         0|            0|            0|  0.00%|                result = filename, headers
  1813|         0|            0|            0|  0.00%|                if self.tempcache is not None:
  1814|         0|            0|            0|  0.00%|                    self.tempcache[url] = result
  1815|         0|            0|            0|  0.00%|                bs = 1024*8
  1816|         0|            0|            0|  0.00%|                size = -1
  1817|         0|            0|            0|  0.00%|                read = 0
  1818|         0|            0|            0|  0.00%|                blocknum = 0
  1819|         0|            0|            0|  0.00%|                if "content-length" in headers:
  1820|         0|            0|            0|  0.00%|                    size = int(headers["Content-Length"])
  1821|         0|            0|            0|  0.00%|                if reporthook:
  1822|         0|            0|            0|  0.00%|                    reporthook(blocknum, bs, size)
  1823|         0|            0|            0|  0.00%|                while 1:
  1824|         0|            0|            0|  0.00%|                    block = fp.read(bs)
  1825|         0|            0|            0|  0.00%|                    if not block:
  1826|         0|            0|            0|  0.00%|                        break
  1827|         0|            0|            0|  0.00%|                    read += len(block)
  1828|         0|            0|            0|  0.00%|                    tfp.write(block)
  1829|         0|            0|            0|  0.00%|                    blocknum += 1
  1830|         0|            0|            0|  0.00%|                    if reporthook:
  1831|         0|            0|            0|  0.00%|                        reporthook(blocknum, bs, size)
  1832|         0|            0|            0|  0.00%|            finally:
  1833|         0|            0|            0|  0.00%|                tfp.close()
  1834|         0|            0|            0|  0.00%|        finally:
  1835|         0|            0|            0|  0.00%|            fp.close()
  1836|         0|            0|            0|  0.00%|
  1837|         0|            0|            0|  0.00%|        # raise exception if actual size does not match content-length header
  1838|         0|            0|            0|  0.00%|        if size >= 0 and read < size:
  1839|         0|            0|            0|  0.00%|            raise ContentTooShortError(
  1840|         0|            0|            0|  0.00%|                "retrieval incomplete: got only %i out of %i bytes"
  1841|         0|            0|            0|  0.00%|                % (read, size), result)
  1842|         0|            0|            0|  0.00%|
  1843|         0|            0|            0|  0.00%|        return result
  1844|         0|            0|            0|  0.00%|
  1845|         0|            0|            0|  0.00%|    # Each method named open_<type> knows how to open that type of URL
  1846|         0|            0|            0|  0.00%|
  1847|         0|            0|            0|  0.00%|    def _open_generic_http(self, connection_factory, url, data):
  1848|         0|            0|            0|  0.00%|        """Make an HTTP connection using connection_class.
  1849|         0|            0|            0|  0.00%|
  1850|         0|            0|            0|  0.00%|        This is an internal method that should be called from
  1851|         0|            0|            0|  0.00%|        open_http() or open_https().
  1852|         0|            0|            0|  0.00%|
  1853|         0|            0|            0|  0.00%|        Arguments:
  1854|         0|            0|            0|  0.00%|        - connection_factory should take a host name and return an
  1855|         0|            0|            0|  0.00%|          HTTPConnection instance.
  1856|         0|            0|            0|  0.00%|        - url is the url to retrieval or a host, relative-path pair.
  1857|         0|            0|            0|  0.00%|        - data is payload for a POST request or None.
  1858|         0|            0|            0|  0.00%|        """
  1859|         0|            0|            0|  0.00%|
  1860|         0|            0|            0|  0.00%|        user_passwd = None
  1861|         0|            0|            0|  0.00%|        proxy_passwd= None
  1862|         0|            0|            0|  0.00%|        if isinstance(url, str):
  1863|         0|            0|            0|  0.00%|            host, selector = splithost(url)
  1864|         0|            0|            0|  0.00%|            if host:
  1865|         0|            0|            0|  0.00%|                user_passwd, host = splituser(host)
  1866|         0|            0|            0|  0.00%|                host = unquote(host)
  1867|         0|            0|            0|  0.00%|            realhost = host
  1868|         0|            0|            0|  0.00%|        else:
  1869|         0|            0|            0|  0.00%|            host, selector = url
  1870|         0|            0|            0|  0.00%|            # check whether the proxy contains authorization information
  1871|         0|            0|            0|  0.00%|            proxy_passwd, host = splituser(host)
  1872|         0|            0|            0|  0.00%|            # now we proceed with the url we want to obtain
  1873|         0|            0|            0|  0.00%|            urltype, rest = splittype(selector)
  1874|         0|            0|            0|  0.00%|            url = rest
  1875|         0|            0|            0|  0.00%|            user_passwd = None
  1876|         0|            0|            0|  0.00%|            if urltype.lower() != 'http':
  1877|         0|            0|            0|  0.00%|                realhost = None
  1878|         0|            0|            0|  0.00%|            else:
  1879|         0|            0|            0|  0.00%|                realhost, rest = splithost(rest)
  1880|         0|            0|            0|  0.00%|                if realhost:
  1881|         0|            0|            0|  0.00%|                    user_passwd, realhost = splituser(realhost)
  1882|         0|            0|            0|  0.00%|                if user_passwd:
  1883|         0|            0|            0|  0.00%|                    selector = "%s://%s%s" % (urltype, realhost, rest)
  1884|         0|            0|            0|  0.00%|                if proxy_bypass(realhost):
  1885|         0|            0|            0|  0.00%|                    host = realhost
  1886|         0|            0|            0|  0.00%|
  1887|         0|            0|            0|  0.00%|        if not host: raise OSError('http error', 'no host given')
  1888|         0|            0|            0|  0.00%|
  1889|         0|            0|            0|  0.00%|        if proxy_passwd:
  1890|         0|            0|            0|  0.00%|            proxy_passwd = unquote(proxy_passwd)
  1891|         0|            0|            0|  0.00%|            proxy_auth = base64.b64encode(proxy_passwd.encode()).decode('ascii')
  1892|         0|            0|            0|  0.00%|        else:
  1893|         0|            0|            0|  0.00%|            proxy_auth = None
  1894|         0|            0|            0|  0.00%|
  1895|         0|            0|            0|  0.00%|        if user_passwd:
  1896|         0|            0|            0|  0.00%|            user_passwd = unquote(user_passwd)
  1897|         0|            0|            0|  0.00%|            auth = base64.b64encode(user_passwd.encode()).decode('ascii')
  1898|         0|            0|            0|  0.00%|        else:
  1899|         0|            0|            0|  0.00%|            auth = None
  1900|         0|            0|            0|  0.00%|        http_conn = connection_factory(host)
  1901|         0|            0|            0|  0.00%|        headers = {}
  1902|         0|            0|            0|  0.00%|        if proxy_auth:
  1903|         0|            0|            0|  0.00%|            headers["Proxy-Authorization"] = "Basic %s" % proxy_auth
  1904|         0|            0|            0|  0.00%|        if auth:
  1905|         0|            0|            0|  0.00%|            headers["Authorization"] =  "Basic %s" % auth
  1906|         0|            0|            0|  0.00%|        if realhost:
  1907|         0|            0|            0|  0.00%|            headers["Host"] = realhost
  1908|         0|            0|            0|  0.00%|
  1909|         0|            0|            0|  0.00%|        # Add Connection:close as we don't support persistent connections yet.
  1910|         0|            0|            0|  0.00%|        # This helps in closing the socket and avoiding ResourceWarning
  1911|         0|            0|            0|  0.00%|
  1912|         0|            0|            0|  0.00%|        headers["Connection"] = "close"
  1913|         0|            0|            0|  0.00%|
  1914|         0|            0|            0|  0.00%|        for header, value in self.addheaders:
  1915|         0|            0|            0|  0.00%|            headers[header] = value
  1916|         0|            0|            0|  0.00%|
  1917|         0|            0|            0|  0.00%|        if data is not None:
  1918|         0|            0|            0|  0.00%|            headers["Content-Type"] = "application/x-www-form-urlencoded"
  1919|         0|            0|            0|  0.00%|            http_conn.request("POST", selector, data, headers)
  1920|         0|            0|            0|  0.00%|        else:
  1921|         0|            0|            0|  0.00%|            http_conn.request("GET", selector, headers=headers)
  1922|         0|            0|            0|  0.00%|
  1923|         0|            0|            0|  0.00%|        try:
  1924|         0|            0|            0|  0.00%|            response = http_conn.getresponse()
  1925|         0|            0|            0|  0.00%|        except http.client.BadStatusLine:
  1926|         0|            0|            0|  0.00%|            # something went wrong with the HTTP status line
  1927|         0|            0|            0|  0.00%|            raise URLError("http protocol error: bad status line")
  1928|         0|            0|            0|  0.00%|
  1929|         0|            0|            0|  0.00%|        # According to RFC 2616, "2xx" code indicates that the client's
  1930|         0|            0|            0|  0.00%|        # request was successfully received, understood, and accepted.
  1931|         0|            0|            0|  0.00%|        if 200 <= response.status < 300:
  1932|         0|            0|            0|  0.00%|            return addinfourl(response, response.msg, "http:" + url,
  1933|         0|            0|            0|  0.00%|                              response.status)
  1934|         0|            0|            0|  0.00%|        else:
  1935|         0|            0|            0|  0.00%|            return self.http_error(
  1936|         0|            0|            0|  0.00%|                url, response.fp,
  1937|         0|            0|            0|  0.00%|                response.status, response.reason, response.msg, data)
  1938|         0|            0|            0|  0.00%|
  1939|         0|            0|            0|  0.00%|    def open_http(self, url, data=None):
  1940|         0|            0|            0|  0.00%|        """Use HTTP protocol."""
  1941|         0|            0|            0|  0.00%|        return self._open_generic_http(http.client.HTTPConnection, url, data)
  1942|         0|            0|            0|  0.00%|
  1943|         0|            0|            0|  0.00%|    def http_error(self, url, fp, errcode, errmsg, headers, data=None):
  1944|         0|            0|            0|  0.00%|        """Handle http errors.
  1945|         0|            0|            0|  0.00%|
  1946|         0|            0|            0|  0.00%|        Derived class can override this, or provide specific handlers
  1947|         0|            0|            0|  0.00%|        named http_error_DDD where DDD is the 3-digit error code."""
  1948|         0|            0|            0|  0.00%|        # First check if there's a specific handler for this error
  1949|         0|            0|            0|  0.00%|        name = 'http_error_%d' % errcode
  1950|         0|            0|            0|  0.00%|        if hasattr(self, name):
  1951|         0|            0|            0|  0.00%|            method = getattr(self, name)
  1952|         0|            0|            0|  0.00%|            if data is None:
  1953|         0|            0|            0|  0.00%|                result = method(url, fp, errcode, errmsg, headers)
  1954|         0|            0|            0|  0.00%|            else:
  1955|         0|            0|            0|  0.00%|                result = method(url, fp, errcode, errmsg, headers, data)
  1956|         0|            0|            0|  0.00%|            if result: return result
  1957|         0|            0|            0|  0.00%|        return self.http_error_default(url, fp, errcode, errmsg, headers)
  1958|         0|            0|            0|  0.00%|
  1959|         0|            0|            0|  0.00%|    def http_error_default(self, url, fp, errcode, errmsg, headers):
  1960|         0|            0|            0|  0.00%|        """Default error handler: close the connection and raise OSError."""
  1961|         0|            0|            0|  0.00%|        fp.close()
  1962|         0|            0|            0|  0.00%|        raise HTTPError(url, errcode, errmsg, headers, None)
  1963|         0|            0|            0|  0.00%|
  1964|         0|            0|            0|  0.00%|    if _have_ssl:
  1965|         0|            0|            0|  0.00%|        def _https_connection(self, host):
  1966|         0|            0|            0|  0.00%|            return http.client.HTTPSConnection(host,
  1967|         0|            0|            0|  0.00%|                                           key_file=self.key_file,
  1968|         0|            0|            0|  0.00%|                                           cert_file=self.cert_file)
  1969|         0|            0|            0|  0.00%|
  1970|         0|            0|            0|  0.00%|        def open_https(self, url, data=None):
  1971|         0|            0|            0|  0.00%|            """Use HTTPS protocol."""
  1972|         0|            0|            0|  0.00%|            return self._open_generic_http(self._https_connection, url, data)
  1973|         0|            0|            0|  0.00%|
  1974|         0|            0|            0|  0.00%|    def open_file(self, url):
  1975|         0|            0|            0|  0.00%|        """Use local file or FTP depending on form of URL."""
  1976|         0|            0|            0|  0.00%|        if not isinstance(url, str):
  1977|         0|            0|            0|  0.00%|            raise URLError('file error: proxy support for file protocol currently not implemented')
  1978|         0|            0|            0|  0.00%|        if url[:2] == '//' and url[2:3] != '/' and url[2:12].lower() != 'localhost/':
  1979|         0|            0|            0|  0.00%|            raise ValueError("file:// scheme is supported only on localhost")
  1980|         0|            0|            0|  0.00%|        else:
  1981|         0|            0|            0|  0.00%|            return self.open_local_file(url)
  1982|         0|            0|            0|  0.00%|
  1983|         0|            0|            0|  0.00%|    def open_local_file(self, url):
  1984|         0|            0|            0|  0.00%|        """Use local file."""
  1985|         0|            0|            0|  0.00%|        import email.utils
  1986|         0|            0|            0|  0.00%|        import mimetypes
  1987|         0|            0|            0|  0.00%|        host, file = splithost(url)
  1988|         0|            0|            0|  0.00%|        localname = url2pathname(file)
  1989|         0|            0|            0|  0.00%|        try:
  1990|         0|            0|            0|  0.00%|            stats = os.stat(localname)
  1991|         0|            0|            0|  0.00%|        except OSError as e:
  1992|         0|            0|            0|  0.00%|            raise URLError(e.strerror, e.filename)
  1993|         0|            0|            0|  0.00%|        size = stats.st_size
  1994|         0|            0|            0|  0.00%|        modified = email.utils.formatdate(stats.st_mtime, usegmt=True)
  1995|         0|            0|            0|  0.00%|        mtype = mimetypes.guess_type(url)[0]
  1996|         0|            0|            0|  0.00%|        headers = email.message_from_string(
  1997|         0|            0|            0|  0.00%|            'Content-Type: %s\nContent-Length: %d\nLast-modified: %s\n' %
  1998|         0|            0|            0|  0.00%|            (mtype or 'text/plain', size, modified))
  1999|         0|            0|            0|  0.00%|        if not host:
  2000|         0|            0|            0|  0.00%|            urlfile = file
  2001|         0|            0|            0|  0.00%|            if file[:1] == '/':
  2002|         0|            0|            0|  0.00%|                urlfile = 'file://' + file
  2003|         0|            0|            0|  0.00%|            return addinfourl(open(localname, 'rb'), headers, urlfile)
  2004|         0|            0|            0|  0.00%|        host, port = splitport(host)
  2005|         0|            0|            0|  0.00%|        if (not port
  2006|         0|            0|            0|  0.00%|           and socket.gethostbyname(host) in ((localhost(),) + thishost())):
  2007|         0|            0|            0|  0.00%|            urlfile = file
  2008|         0|            0|            0|  0.00%|            if file[:1] == '/':
  2009|         0|            0|            0|  0.00%|                urlfile = 'file://' + file
  2010|         0|            0|            0|  0.00%|            elif file[:2] == './':
  2011|         0|            0|            0|  0.00%|                raise ValueError("local file url may start with / or file:. Unknown url of type: %s" % url)
  2012|         0|            0|            0|  0.00%|            return addinfourl(open(localname, 'rb'), headers, urlfile)
  2013|         0|            0|            0|  0.00%|        raise URLError('local file error: not on local host')
  2014|         0|            0|            0|  0.00%|
  2015|         0|            0|            0|  0.00%|    def open_ftp(self, url):
  2016|         0|            0|            0|  0.00%|        """Use FTP protocol."""
  2017|         0|            0|            0|  0.00%|        if not isinstance(url, str):
  2018|         0|            0|            0|  0.00%|            raise URLError('ftp error: proxy support for ftp protocol currently not implemented')
  2019|         0|            0|            0|  0.00%|        import mimetypes
  2020|         0|            0|            0|  0.00%|        host, path = splithost(url)
  2021|         0|            0|            0|  0.00%|        if not host: raise URLError('ftp error: no host given')
  2022|         0|            0|            0|  0.00%|        host, port = splitport(host)
  2023|         0|            0|            0|  0.00%|        user, host = splituser(host)
  2024|         0|            0|            0|  0.00%|        if user: user, passwd = splitpasswd(user)
  2025|         0|            0|            0|  0.00%|        else: passwd = None
  2026|         0|            0|            0|  0.00%|        host = unquote(host)
  2027|         0|            0|            0|  0.00%|        user = unquote(user or '')
  2028|         0|            0|            0|  0.00%|        passwd = unquote(passwd or '')
  2029|         0|            0|            0|  0.00%|        host = socket.gethostbyname(host)
  2030|         0|            0|            0|  0.00%|        if not port:
  2031|         0|            0|            0|  0.00%|            import ftplib
  2032|         0|            0|            0|  0.00%|            port = ftplib.FTP_PORT
  2033|         0|            0|            0|  0.00%|        else:
  2034|         0|            0|            0|  0.00%|            port = int(port)
  2035|         0|            0|            0|  0.00%|        path, attrs = splitattr(path)
  2036|         0|            0|            0|  0.00%|        path = unquote(path)
  2037|         0|            0|            0|  0.00%|        dirs = path.split('/')
  2038|         0|            0|            0|  0.00%|        dirs, file = dirs[:-1], dirs[-1]
  2039|         0|            0|            0|  0.00%|        if dirs and not dirs[0]: dirs = dirs[1:]
  2040|         0|            0|            0|  0.00%|        if dirs and not dirs[0]: dirs[0] = '/'
  2041|         0|            0|            0|  0.00%|        key = user, host, port, '/'.join(dirs)
  2042|         0|            0|            0|  0.00%|        # XXX thread unsafe!
  2043|         0|            0|            0|  0.00%|        if len(self.ftpcache) > MAXFTPCACHE:
  2044|         0|            0|            0|  0.00%|            # Prune the cache, rather arbitrarily
  2045|         0|            0|            0|  0.00%|            for k in list(self.ftpcache):
  2046|         0|            0|            0|  0.00%|                if k != key:
  2047|         0|            0|            0|  0.00%|                    v = self.ftpcache[k]
  2048|         0|            0|            0|  0.00%|                    del self.ftpcache[k]
  2049|         0|            0|            0|  0.00%|                    v.close()
  2050|         0|            0|            0|  0.00%|        try:
  2051|         0|            0|            0|  0.00%|            if key not in self.ftpcache:
  2052|         0|            0|            0|  0.00%|                self.ftpcache[key] = \
  2053|         0|            0|            0|  0.00%|                    ftpwrapper(user, passwd, host, port, dirs)
  2054|         0|            0|            0|  0.00%|            if not file: type = 'D'
  2055|         0|            0|            0|  0.00%|            else: type = 'I'
  2056|         0|            0|            0|  0.00%|            for attr in attrs:
  2057|         0|            0|            0|  0.00%|                attr, value = splitvalue(attr)
  2058|         0|            0|            0|  0.00%|                if attr.lower() == 'type' and \
  2059|         0|            0|            0|  0.00%|                   value in ('a', 'A', 'i', 'I', 'd', 'D'):
  2060|         0|            0|            0|  0.00%|                    type = value.upper()
  2061|         0|            0|            0|  0.00%|            (fp, retrlen) = self.ftpcache[key].retrfile(file, type)
  2062|         0|            0|            0|  0.00%|            mtype = mimetypes.guess_type("ftp:" + url)[0]
  2063|         0|            0|            0|  0.00%|            headers = ""
  2064|         0|            0|            0|  0.00%|            if mtype:
  2065|         0|            0|            0|  0.00%|                headers += "Content-Type: %s\n" % mtype
  2066|         0|            0|            0|  0.00%|            if retrlen is not None and retrlen >= 0:
  2067|         0|            0|            0|  0.00%|                headers += "Content-Length: %d\n" % retrlen
  2068|         0|            0|            0|  0.00%|            headers = email.message_from_string(headers)
  2069|         0|            0|            0|  0.00%|            return addinfourl(fp, headers, "ftp:" + url)
  2070|         0|            0|            0|  0.00%|        except ftperrors() as exp:
  2071|         0|            0|            0|  0.00%|            raise URLError('ftp error %r' % exp).with_traceback(sys.exc_info()[2])
  2072|         0|            0|            0|  0.00%|
  2073|         0|            0|            0|  0.00%|    def open_data(self, url, data=None):
  2074|         0|            0|            0|  0.00%|        """Use "data" URL."""
  2075|         0|            0|            0|  0.00%|        if not isinstance(url, str):
  2076|         0|            0|            0|  0.00%|            raise URLError('data error: proxy support for data protocol currently not implemented')
  2077|         0|            0|            0|  0.00%|        # ignore POSTed data
  2078|         0|            0|            0|  0.00%|        #
  2079|         0|            0|            0|  0.00%|        # syntax of data URLs:
  2080|         0|            0|            0|  0.00%|        # dataurl   := "data:" [ mediatype ] [ ";base64" ] "," data
  2081|         0|            0|            0|  0.00%|        # mediatype := [ type "/" subtype ] *( ";" parameter )
  2082|         0|            0|            0|  0.00%|        # data      := *urlchar
  2083|         0|            0|            0|  0.00%|        # parameter := attribute "=" value
  2084|         0|            0|            0|  0.00%|        try:
  2085|         0|            0|            0|  0.00%|            [type, data] = url.split(',', 1)
  2086|         0|            0|            0|  0.00%|        except ValueError:
  2087|         0|            0|            0|  0.00%|            raise OSError('data error', 'bad data URL')
  2088|         0|            0|            0|  0.00%|        if not type:
  2089|         0|            0|            0|  0.00%|            type = 'text/plain;charset=US-ASCII'
  2090|         0|            0|            0|  0.00%|        semi = type.rfind(';')
  2091|         0|            0|            0|  0.00%|        if semi >= 0 and '=' not in type[semi:]:
  2092|         0|            0|            0|  0.00%|            encoding = type[semi+1:]
  2093|         0|            0|            0|  0.00%|            type = type[:semi]
  2094|         0|            0|            0|  0.00%|        else:
  2095|         0|            0|            0|  0.00%|            encoding = ''
  2096|         0|            0|            0|  0.00%|        msg = []
  2097|         0|            0|            0|  0.00%|        msg.append('Date: %s'%time.strftime('%a, %d %b %Y %H:%M:%S GMT',
  2098|         0|            0|            0|  0.00%|                                            time.gmtime(time.time())))
  2099|         0|            0|            0|  0.00%|        msg.append('Content-type: %s' % type)
  2100|         0|            0|            0|  0.00%|        if encoding == 'base64':
  2101|         0|            0|            0|  0.00%|            # XXX is this encoding/decoding ok?
  2102|         0|            0|            0|  0.00%|            data = base64.decodebytes(data.encode('ascii')).decode('latin-1')
  2103|         0|            0|            0|  0.00%|        else:
  2104|         0|            0|            0|  0.00%|            data = unquote(data)
  2105|         0|            0|            0|  0.00%|        msg.append('Content-Length: %d' % len(data))
  2106|         0|            0|            0|  0.00%|        msg.append('')
  2107|         0|            0|            0|  0.00%|        msg.append(data)
  2108|         0|            0|            0|  0.00%|        msg = '\n'.join(msg)
  2109|         0|            0|            0|  0.00%|        headers = email.message_from_string(msg)
  2110|         0|            0|            0|  0.00%|        f = io.StringIO(msg)
  2111|         0|            0|            0|  0.00%|        #f.fileno = None     # needed for addinfourl
  2112|         0|            0|            0|  0.00%|        return addinfourl(f, headers, url)
  2113|         0|            0|            0|  0.00%|
  2114|         0|            0|            0|  0.00%|
  2115|         0|            0|            0|  0.00%|class FancyURLopener(URLopener):
  2116|         0|            0|            0|  0.00%|    """Derived class with handlers for errors we can handle (perhaps)."""
  2117|         0|            0|            0|  0.00%|
  2118|         0|            0|            0|  0.00%|    def __init__(self, *args, **kwargs):
  2119|         0|            0|            0|  0.00%|        URLopener.__init__(self, *args, **kwargs)
  2120|         0|            0|            0|  0.00%|        self.auth_cache = {}
  2121|         0|            0|            0|  0.00%|        self.tries = 0
  2122|         0|            0|            0|  0.00%|        self.maxtries = 10
  2123|         0|            0|            0|  0.00%|
  2124|         0|            0|            0|  0.00%|    def http_error_default(self, url, fp, errcode, errmsg, headers):
  2125|         0|            0|            0|  0.00%|        """Default error handling -- don't raise an exception."""
  2126|         0|            0|            0|  0.00%|        return addinfourl(fp, headers, "http:" + url, errcode)
  2127|         0|            0|            0|  0.00%|
  2128|         0|            0|            0|  0.00%|    def http_error_302(self, url, fp, errcode, errmsg, headers, data=None):
  2129|         0|            0|            0|  0.00%|        """Error 302 -- relocated (temporarily)."""
  2130|         0|            0|            0|  0.00%|        self.tries += 1
  2131|         0|            0|            0|  0.00%|        try:
  2132|         0|            0|            0|  0.00%|            if self.maxtries and self.tries >= self.maxtries:
  2133|         0|            0|            0|  0.00%|                if hasattr(self, "http_error_500"):
  2134|         0|            0|            0|  0.00%|                    meth = self.http_error_500
  2135|         0|            0|            0|  0.00%|                else:
  2136|         0|            0|            0|  0.00%|                    meth = self.http_error_default
  2137|         0|            0|            0|  0.00%|                return meth(url, fp, 500,
  2138|         0|            0|            0|  0.00%|                            "Internal Server Error: Redirect Recursion",
  2139|         0|            0|            0|  0.00%|                            headers)
  2140|         0|            0|            0|  0.00%|            result = self.redirect_internal(url, fp, errcode, errmsg,
  2141|         0|            0|            0|  0.00%|                                            headers, data)
  2142|         0|            0|            0|  0.00%|            return result
  2143|         0|            0|            0|  0.00%|        finally:
  2144|         0|            0|            0|  0.00%|            self.tries = 0
  2145|         0|            0|            0|  0.00%|
  2146|         0|            0|            0|  0.00%|    def redirect_internal(self, url, fp, errcode, errmsg, headers, data):
  2147|         0|            0|            0|  0.00%|        if 'location' in headers:
  2148|         0|            0|            0|  0.00%|            newurl = headers['location']
  2149|         0|            0|            0|  0.00%|        elif 'uri' in headers:
  2150|         0|            0|            0|  0.00%|            newurl = headers['uri']
  2151|         0|            0|            0|  0.00%|        else:
  2152|         0|            0|            0|  0.00%|            return
  2153|         0|            0|            0|  0.00%|        fp.close()
  2154|         0|            0|            0|  0.00%|
  2155|         0|            0|            0|  0.00%|        # In case the server sent a relative URL, join with original:
  2156|         0|            0|            0|  0.00%|        newurl = urljoin(self.type + ":" + url, newurl)
  2157|         0|            0|            0|  0.00%|
  2158|         0|            0|            0|  0.00%|        urlparts = urlparse(newurl)
  2159|         0|            0|            0|  0.00%|
  2160|         0|            0|            0|  0.00%|        # For security reasons, we don't allow redirection to anything other
  2161|         0|            0|            0|  0.00%|        # than http, https and ftp.
  2162|         0|            0|            0|  0.00%|
  2163|         0|            0|            0|  0.00%|        # We are using newer HTTPError with older redirect_internal method
  2164|         0|            0|            0|  0.00%|        # This older method will get deprecated in 3.3
  2165|         0|            0|            0|  0.00%|
  2166|         0|            0|            0|  0.00%|        if urlparts.scheme not in ('http', 'https', 'ftp', ''):
  2167|         0|            0|            0|  0.00%|            raise HTTPError(newurl, errcode,
  2168|         0|            0|            0|  0.00%|                            errmsg +
  2169|         0|            0|            0|  0.00%|                            " Redirection to url '%s' is not allowed." % newurl,
  2170|         0|            0|            0|  0.00%|                            headers, fp)
  2171|         0|            0|            0|  0.00%|
  2172|         0|            0|            0|  0.00%|        return self.open(newurl)
  2173|         0|            0|            0|  0.00%|
  2174|         0|            0|            0|  0.00%|    def http_error_301(self, url, fp, errcode, errmsg, headers, data=None):
  2175|         0|            0|            0|  0.00%|        """Error 301 -- also relocated (permanently)."""
  2176|         0|            0|            0|  0.00%|        return self.http_error_302(url, fp, errcode, errmsg, headers, data)
  2177|         0|            0|            0|  0.00%|
  2178|         0|            0|            0|  0.00%|    def http_error_303(self, url, fp, errcode, errmsg, headers, data=None):
  2179|         0|            0|            0|  0.00%|        """Error 303 -- also relocated (essentially identical to 302)."""
  2180|         0|            0|            0|  0.00%|        return self.http_error_302(url, fp, errcode, errmsg, headers, data)
  2181|         0|            0|            0|  0.00%|
  2182|         0|            0|            0|  0.00%|    def http_error_307(self, url, fp, errcode, errmsg, headers, data=None):
  2183|         0|            0|            0|  0.00%|        """Error 307 -- relocated, but turn POST into error."""
  2184|         0|            0|            0|  0.00%|        if data is None:
  2185|         0|            0|            0|  0.00%|            return self.http_error_302(url, fp, errcode, errmsg, headers, data)
  2186|         0|            0|            0|  0.00%|        else:
  2187|         0|            0|            0|  0.00%|            return self.http_error_default(url, fp, errcode, errmsg, headers)
  2188|         0|            0|            0|  0.00%|
  2189|         0|            0|            0|  0.00%|    def http_error_401(self, url, fp, errcode, errmsg, headers, data=None,
  2190|         0|            0|            0|  0.00%|            retry=False):
  2191|         0|            0|            0|  0.00%|        """Error 401 -- authentication required.
  2192|         0|            0|            0|  0.00%|        This function supports Basic authentication only."""
  2193|         0|            0|            0|  0.00%|        if 'www-authenticate' not in headers:
  2194|         0|            0|            0|  0.00%|            URLopener.http_error_default(self, url, fp,
  2195|         0|            0|            0|  0.00%|                                         errcode, errmsg, headers)
  2196|         0|            0|            0|  0.00%|        stuff = headers['www-authenticate']
  2197|         0|            0|            0|  0.00%|        match = re.match('[ \t]*([^ \t]+)[ \t]+realm="([^"]*)"', stuff)
  2198|         0|            0|            0|  0.00%|        if not match:
  2199|         0|            0|            0|  0.00%|            URLopener.http_error_default(self, url, fp,
  2200|         0|            0|            0|  0.00%|                                         errcode, errmsg, headers)
  2201|         0|            0|            0|  0.00%|        scheme, realm = match.groups()
  2202|         0|            0|            0|  0.00%|        if scheme.lower() != 'basic':
  2203|         0|            0|            0|  0.00%|            URLopener.http_error_default(self, url, fp,
  2204|         0|            0|            0|  0.00%|                                         errcode, errmsg, headers)
  2205|         0|            0|            0|  0.00%|        if not retry:
  2206|         0|            0|            0|  0.00%|            URLopener.http_error_default(self, url, fp, errcode, errmsg,
  2207|         0|            0|            0|  0.00%|                    headers)
  2208|         0|            0|            0|  0.00%|        name = 'retry_' + self.type + '_basic_auth'
  2209|         0|            0|            0|  0.00%|        if data is None:
  2210|         0|            0|            0|  0.00%|            return getattr(self,name)(url, realm)
  2211|         0|            0|            0|  0.00%|        else:
  2212|         0|            0|            0|  0.00%|            return getattr(self,name)(url, realm, data)
  2213|         0|            0|            0|  0.00%|
  2214|         0|            0|            0|  0.00%|    def http_error_407(self, url, fp, errcode, errmsg, headers, data=None,
  2215|         0|            0|            0|  0.00%|            retry=False):
  2216|         0|            0|            0|  0.00%|        """Error 407 -- proxy authentication required.
  2217|         0|            0|            0|  0.00%|        This function supports Basic authentication only."""
  2218|         0|            0|            0|  0.00%|        if 'proxy-authenticate' not in headers:
  2219|         0|            0|            0|  0.00%|            URLopener.http_error_default(self, url, fp,
  2220|         0|            0|            0|  0.00%|                                         errcode, errmsg, headers)
  2221|         0|            0|            0|  0.00%|        stuff = headers['proxy-authenticate']
  2222|         0|            0|            0|  0.00%|        match = re.match('[ \t]*([^ \t]+)[ \t]+realm="([^"]*)"', stuff)
  2223|         0|            0|            0|  0.00%|        if not match:
  2224|         0|            0|            0|  0.00%|            URLopener.http_error_default(self, url, fp,
  2225|         0|            0|            0|  0.00%|                                         errcode, errmsg, headers)
  2226|         0|            0|            0|  0.00%|        scheme, realm = match.groups()
  2227|         0|            0|            0|  0.00%|        if scheme.lower() != 'basic':
  2228|         0|            0|            0|  0.00%|            URLopener.http_error_default(self, url, fp,
  2229|         0|            0|            0|  0.00%|                                         errcode, errmsg, headers)
  2230|         0|            0|            0|  0.00%|        if not retry:
  2231|         0|            0|            0|  0.00%|            URLopener.http_error_default(self, url, fp, errcode, errmsg,
  2232|         0|            0|            0|  0.00%|                    headers)
  2233|         0|            0|            0|  0.00%|        name = 'retry_proxy_' + self.type + '_basic_auth'
  2234|         0|            0|            0|  0.00%|        if data is None:
  2235|         0|            0|            0|  0.00%|            return getattr(self,name)(url, realm)
  2236|         0|            0|            0|  0.00%|        else:
  2237|         0|            0|            0|  0.00%|            return getattr(self,name)(url, realm, data)
  2238|         0|            0|            0|  0.00%|
  2239|         0|            0|            0|  0.00%|    def retry_proxy_http_basic_auth(self, url, realm, data=None):
  2240|         0|            0|            0|  0.00%|        host, selector = splithost(url)
  2241|         0|            0|            0|  0.00%|        newurl = 'http://' + host + selector
  2242|         0|            0|            0|  0.00%|        proxy = self.proxies['http']
  2243|         0|            0|            0|  0.00%|        urltype, proxyhost = splittype(proxy)
  2244|         0|            0|            0|  0.00%|        proxyhost, proxyselector = splithost(proxyhost)
  2245|         0|            0|            0|  0.00%|        i = proxyhost.find('@') + 1
  2246|         0|            0|            0|  0.00%|        proxyhost = proxyhost[i:]
  2247|         0|            0|            0|  0.00%|        user, passwd = self.get_user_passwd(proxyhost, realm, i)
  2248|         0|            0|            0|  0.00%|        if not (user or passwd): return None
  2249|         0|            0|            0|  0.00%|        proxyhost = "%s:%s@%s" % (quote(user, safe=''),
  2250|         0|            0|            0|  0.00%|                                  quote(passwd, safe=''), proxyhost)
  2251|         0|            0|            0|  0.00%|        self.proxies['http'] = 'http://' + proxyhost + proxyselector
  2252|         0|            0|            0|  0.00%|        if data is None:
  2253|         0|            0|            0|  0.00%|            return self.open(newurl)
  2254|         0|            0|            0|  0.00%|        else:
  2255|         0|            0|            0|  0.00%|            return self.open(newurl, data)
  2256|         0|            0|            0|  0.00%|
  2257|         0|            0|            0|  0.00%|    def retry_proxy_https_basic_auth(self, url, realm, data=None):
  2258|         0|            0|            0|  0.00%|        host, selector = splithost(url)
  2259|         0|            0|            0|  0.00%|        newurl = 'https://' + host + selector
  2260|         0|            0|            0|  0.00%|        proxy = self.proxies['https']
  2261|         0|            0|            0|  0.00%|        urltype, proxyhost = splittype(proxy)
  2262|         0|            0|            0|  0.00%|        proxyhost, proxyselector = splithost(proxyhost)
  2263|         0|            0|            0|  0.00%|        i = proxyhost.find('@') + 1
  2264|         0|            0|            0|  0.00%|        proxyhost = proxyhost[i:]
  2265|         0|            0|            0|  0.00%|        user, passwd = self.get_user_passwd(proxyhost, realm, i)
  2266|         0|            0|            0|  0.00%|        if not (user or passwd): return None
  2267|         0|            0|            0|  0.00%|        proxyhost = "%s:%s@%s" % (quote(user, safe=''),
  2268|         0|            0|            0|  0.00%|                                  quote(passwd, safe=''), proxyhost)
  2269|         0|            0|            0|  0.00%|        self.proxies['https'] = 'https://' + proxyhost + proxyselector
  2270|         0|            0|            0|  0.00%|        if data is None:
  2271|         0|            0|            0|  0.00%|            return self.open(newurl)
  2272|         0|            0|            0|  0.00%|        else:
  2273|         0|            0|            0|  0.00%|            return self.open(newurl, data)
  2274|         0|            0|            0|  0.00%|
  2275|         0|            0|            0|  0.00%|    def retry_http_basic_auth(self, url, realm, data=None):
  2276|         0|            0|            0|  0.00%|        host, selector = splithost(url)
  2277|         0|            0|            0|  0.00%|        i = host.find('@') + 1
  2278|         0|            0|            0|  0.00%|        host = host[i:]
  2279|         0|            0|            0|  0.00%|        user, passwd = self.get_user_passwd(host, realm, i)
  2280|         0|            0|            0|  0.00%|        if not (user or passwd): return None
  2281|         0|            0|            0|  0.00%|        host = "%s:%s@%s" % (quote(user, safe=''),
  2282|         0|            0|            0|  0.00%|                             quote(passwd, safe=''), host)
  2283|         0|            0|            0|  0.00%|        newurl = 'http://' + host + selector
  2284|         0|            0|            0|  0.00%|        if data is None:
  2285|         0|            0|            0|  0.00%|            return self.open(newurl)
  2286|         0|            0|            0|  0.00%|        else:
  2287|         0|            0|            0|  0.00%|            return self.open(newurl, data)
  2288|         0|            0|            0|  0.00%|
  2289|         0|            0|            0|  0.00%|    def retry_https_basic_auth(self, url, realm, data=None):
  2290|         0|            0|            0|  0.00%|        host, selector = splithost(url)
  2291|         0|            0|            0|  0.00%|        i = host.find('@') + 1
  2292|         0|            0|            0|  0.00%|        host = host[i:]
  2293|         0|            0|            0|  0.00%|        user, passwd = self.get_user_passwd(host, realm, i)
  2294|         0|            0|            0|  0.00%|        if not (user or passwd): return None
  2295|         0|            0|            0|  0.00%|        host = "%s:%s@%s" % (quote(user, safe=''),
  2296|         0|            0|            0|  0.00%|                             quote(passwd, safe=''), host)
  2297|         0|            0|            0|  0.00%|        newurl = 'https://' + host + selector
  2298|         0|            0|            0|  0.00%|        if data is None:
  2299|         0|            0|            0|  0.00%|            return self.open(newurl)
  2300|         0|            0|            0|  0.00%|        else:
  2301|         0|            0|            0|  0.00%|            return self.open(newurl, data)
  2302|         0|            0|            0|  0.00%|
  2303|         0|            0|            0|  0.00%|    def get_user_passwd(self, host, realm, clear_cache=0):
  2304|         0|            0|            0|  0.00%|        key = realm + '@' + host.lower()
  2305|         0|            0|            0|  0.00%|        if key in self.auth_cache:
  2306|         0|            0|            0|  0.00%|            if clear_cache:
  2307|         0|            0|            0|  0.00%|                del self.auth_cache[key]
  2308|         0|            0|            0|  0.00%|            else:
  2309|         0|            0|            0|  0.00%|                return self.auth_cache[key]
  2310|         0|            0|            0|  0.00%|        user, passwd = self.prompt_user_passwd(host, realm)
  2311|         0|            0|            0|  0.00%|        if user or passwd: self.auth_cache[key] = (user, passwd)
  2312|         0|            0|            0|  0.00%|        return user, passwd
  2313|         0|            0|            0|  0.00%|
  2314|         0|            0|            0|  0.00%|    def prompt_user_passwd(self, host, realm):
  2315|         0|            0|            0|  0.00%|        """Override this in a GUI environment!"""
  2316|         0|            0|            0|  0.00%|        import getpass
  2317|         0|            0|            0|  0.00%|        try:
  2318|         0|            0|            0|  0.00%|            user = input("Enter username for %s at %s: " % (realm, host))
  2319|         0|            0|            0|  0.00%|            passwd = getpass.getpass("Enter password for %s in %s at %s: " %
  2320|         0|            0|            0|  0.00%|                (user, realm, host))
  2321|         0|            0|            0|  0.00%|            return user, passwd
  2322|         0|            0|            0|  0.00%|        except KeyboardInterrupt:
  2323|         0|            0|            0|  0.00%|            print()
  2324|         0|            0|            0|  0.00%|            return None, None
  2325|         0|            0|            0|  0.00%|
  2326|         0|            0|            0|  0.00%|
  2327|         0|            0|            0|  0.00%|# Utility functions
  2328|         0|            0|            0|  0.00%|
  2329|         0|            0|            0|  0.00%|_localhost = None
  2330|         0|            0|            0|  0.00%|def localhost():
  2331|         0|            0|            0|  0.00%|    """Return the IP address of the magic hostname 'localhost'."""
  2332|         0|            0|            0|  0.00%|    global _localhost
  2333|         0|            0|            0|  0.00%|    if _localhost is None:
  2334|         0|            0|            0|  0.00%|        _localhost = socket.gethostbyname('localhost')
  2335|         0|            0|            0|  0.00%|    return _localhost
  2336|         0|            0|            0|  0.00%|
  2337|         0|            0|            0|  0.00%|_thishost = None
  2338|         0|            0|            0|  0.00%|def thishost():
  2339|         0|            0|            0|  0.00%|    """Return the IP addresses of the current host."""
  2340|         0|            0|            0|  0.00%|    global _thishost
  2341|         0|            0|            0|  0.00%|    if _thishost is None:
  2342|         0|            0|            0|  0.00%|        try:
  2343|         0|            0|            0|  0.00%|            _thishost = tuple(socket.gethostbyname_ex(socket.gethostname())[2])
  2344|         0|            0|            0|  0.00%|        except socket.gaierror:
  2345|         0|            0|            0|  0.00%|            _thishost = tuple(socket.gethostbyname_ex('localhost')[2])
  2346|         0|            0|            0|  0.00%|    return _thishost
  2347|         0|            0|            0|  0.00%|
  2348|         0|            0|            0|  0.00%|_ftperrors = None
  2349|         0|            0|            0|  0.00%|def ftperrors():
  2350|         0|            0|            0|  0.00%|    """Return the set of errors raised by the FTP class."""
  2351|         0|            0|            0|  0.00%|    global _ftperrors
  2352|         0|            0|            0|  0.00%|    if _ftperrors is None:
  2353|         0|            0|            0|  0.00%|        import ftplib
  2354|         0|            0|            0|  0.00%|        _ftperrors = ftplib.all_errors
  2355|         0|            0|            0|  0.00%|    return _ftperrors
  2356|         0|            0|            0|  0.00%|
  2357|         0|            0|            0|  0.00%|_noheaders = None
  2358|         0|            0|            0|  0.00%|def noheaders():
  2359|         0|            0|            0|  0.00%|    """Return an empty email Message object."""
  2360|         0|            0|            0|  0.00%|    global _noheaders
  2361|         0|            0|            0|  0.00%|    if _noheaders is None:
  2362|         0|            0|            0|  0.00%|        _noheaders = email.message_from_string("")
  2363|         0|            0|            0|  0.00%|    return _noheaders
  2364|         0|            0|            0|  0.00%|
  2365|         0|            0|            0|  0.00%|
  2366|         0|            0|            0|  0.00%|# Utility classes
  2367|         0|            0|            0|  0.00%|
  2368|         0|            0|            0|  0.00%|class ftpwrapper:
  2369|         0|            0|            0|  0.00%|    """Class used by open_ftp() for cache of open FTP connections."""
  2370|         0|            0|            0|  0.00%|
  2371|         0|            0|            0|  0.00%|    def __init__(self, user, passwd, host, port, dirs, timeout=None,
  2372|         0|            0|            0|  0.00%|                 persistent=True):
  2373|         0|            0|            0|  0.00%|        self.user = user
  2374|         0|            0|            0|  0.00%|        self.passwd = passwd
  2375|         0|            0|            0|  0.00%|        self.host = host
  2376|         0|            0|            0|  0.00%|        self.port = port
  2377|         0|            0|            0|  0.00%|        self.dirs = dirs
  2378|         0|            0|            0|  0.00%|        self.timeout = timeout
  2379|         0|            0|            0|  0.00%|        self.refcount = 0
  2380|         0|            0|            0|  0.00%|        self.keepalive = persistent
  2381|         0|            0|            0|  0.00%|        try:
  2382|         0|            0|            0|  0.00%|            self.init()
  2383|         0|            0|            0|  0.00%|        except:
  2384|         0|            0|            0|  0.00%|            self.close()
  2385|         0|            0|            0|  0.00%|            raise
  2386|         0|            0|            0|  0.00%|
  2387|         0|            0|            0|  0.00%|    def init(self):
  2388|         0|            0|            0|  0.00%|        import ftplib
  2389|         0|            0|            0|  0.00%|        self.busy = 0
  2390|         0|            0|            0|  0.00%|        self.ftp = ftplib.FTP()
  2391|         0|            0|            0|  0.00%|        self.ftp.connect(self.host, self.port, self.timeout)
  2392|         0|            0|            0|  0.00%|        self.ftp.login(self.user, self.passwd)
  2393|         0|            0|            0|  0.00%|        _target = '/'.join(self.dirs)
  2394|         0|            0|            0|  0.00%|        self.ftp.cwd(_target)
  2395|         0|            0|            0|  0.00%|
  2396|         0|            0|            0|  0.00%|    def retrfile(self, file, type):
  2397|         0|            0|            0|  0.00%|        import ftplib
  2398|         0|            0|            0|  0.00%|        self.endtransfer()
  2399|         0|            0|            0|  0.00%|        if type in ('d', 'D'): cmd = 'TYPE A'; isdir = 1
  2400|         0|            0|            0|  0.00%|        else: cmd = 'TYPE ' + type; isdir = 0
  2401|         0|            0|            0|  0.00%|        try:
  2402|         0|            0|            0|  0.00%|            self.ftp.voidcmd(cmd)
  2403|         0|            0|            0|  0.00%|        except ftplib.all_errors:
  2404|         0|            0|            0|  0.00%|            self.init()
  2405|         0|            0|            0|  0.00%|            self.ftp.voidcmd(cmd)
  2406|         0|            0|            0|  0.00%|        conn = None
  2407|         0|            0|            0|  0.00%|        if file and not isdir:
  2408|         0|            0|            0|  0.00%|            # Try to retrieve as a file
  2409|         0|            0|            0|  0.00%|            try:
  2410|         0|            0|            0|  0.00%|                cmd = 'RETR ' + file
  2411|         0|            0|            0|  0.00%|                conn, retrlen = self.ftp.ntransfercmd(cmd)
  2412|         0|            0|            0|  0.00%|            except ftplib.error_perm as reason:
  2413|         0|            0|            0|  0.00%|                if str(reason)[:3] != '550':
  2414|         0|            0|            0|  0.00%|                    raise URLError('ftp error: %r' % reason).with_traceback(
  2415|         0|            0|            0|  0.00%|                        sys.exc_info()[2])
  2416|         0|            0|            0|  0.00%|        if not conn:
  2417|         0|            0|            0|  0.00%|            # Set transfer mode to ASCII!
  2418|         0|            0|            0|  0.00%|            self.ftp.voidcmd('TYPE A')
  2419|         0|            0|            0|  0.00%|            # Try a directory listing. Verify that directory exists.
  2420|         0|            0|            0|  0.00%|            if file:
  2421|         0|            0|            0|  0.00%|                pwd = self.ftp.pwd()
  2422|         0|            0|            0|  0.00%|                try:
  2423|         0|            0|            0|  0.00%|                    try:
  2424|         0|            0|            0|  0.00%|                        self.ftp.cwd(file)
  2425|         0|            0|            0|  0.00%|                    except ftplib.error_perm as reason:
  2426|         0|            0|            0|  0.00%|                        raise URLError('ftp error: %r' % reason) from reason
  2427|         0|            0|            0|  0.00%|                finally:
  2428|         0|            0|            0|  0.00%|                    self.ftp.cwd(pwd)
  2429|         0|            0|            0|  0.00%|                cmd = 'LIST ' + file
  2430|         0|            0|            0|  0.00%|            else:
  2431|         0|            0|            0|  0.00%|                cmd = 'LIST'
  2432|         0|            0|            0|  0.00%|            conn, retrlen = self.ftp.ntransfercmd(cmd)
  2433|         0|            0|            0|  0.00%|        self.busy = 1
  2434|         0|            0|            0|  0.00%|
  2435|         0|            0|            0|  0.00%|        ftpobj = addclosehook(conn.makefile('rb'), self.file_close)
  2436|         0|            0|            0|  0.00%|        self.refcount += 1
  2437|         0|            0|            0|  0.00%|        conn.close()
  2438|         0|            0|            0|  0.00%|        # Pass back both a suitably decorated object and a retrieval length
  2439|         0|            0|            0|  0.00%|        return (ftpobj, retrlen)
  2440|         0|            0|            0|  0.00%|
  2441|         0|            0|            0|  0.00%|    def endtransfer(self):
  2442|         0|            0|            0|  0.00%|        self.busy = 0
  2443|         0|            0|            0|  0.00%|
  2444|         0|            0|            0|  0.00%|    def close(self):
  2445|         0|            0|            0|  0.00%|        self.keepalive = False
  2446|         0|            0|            0|  0.00%|        if self.refcount <= 0:
  2447|         0|            0|            0|  0.00%|            self.real_close()
  2448|         0|            0|            0|  0.00%|
  2449|         0|            0|            0|  0.00%|    def file_close(self):
  2450|         0|            0|            0|  0.00%|        self.endtransfer()
  2451|         0|            0|            0|  0.00%|        self.refcount -= 1
  2452|         0|            0|            0|  0.00%|        if self.refcount <= 0 and not self.keepalive:
  2453|         0|            0|            0|  0.00%|            self.real_close()
  2454|         0|            0|            0|  0.00%|
  2455|         0|            0|            0|  0.00%|    def real_close(self):
  2456|         0|            0|            0|  0.00%|        self.endtransfer()
  2457|         0|            0|            0|  0.00%|        try:
  2458|         0|            0|            0|  0.00%|            self.ftp.close()
  2459|         0|            0|            0|  0.00%|        except ftperrors():
  2460|         0|            0|            0|  0.00%|            pass
  2461|         0|            0|            0|  0.00%|
  2462|         0|            0|            0|  0.00%|# Proxy handling
  2463|         0|            0|            0|  0.00%|def getproxies_environment():
  2464|         0|            0|            0|  0.00%|    """Return a dictionary of scheme -> proxy server URL mappings.
  2465|         0|            0|            0|  0.00%|
  2466|         0|            0|            0|  0.00%|    Scan the environment for variables named <scheme>_proxy;
  2467|         0|            0|            0|  0.00%|    this seems to be the standard convention.  If you need a
  2468|         0|            0|            0|  0.00%|    different way, you can pass a proxies dictionary to the
  2469|         0|            0|            0|  0.00%|    [Fancy]URLopener constructor.
  2470|         0|            0|            0|  0.00%|
  2471|         0|            0|            0|  0.00%|    """
  2472|         0|            0|            0|  0.00%|    proxies = {}
  2473|         0|            0|            0|  0.00%|    # in order to prefer lowercase variables, process environment in
  2474|         0|            0|            0|  0.00%|    # two passes: first matches any, second pass matches lowercase only
  2475|         0|            0|            0|  0.00%|    for name, value in os.environ.items():
  2476|         0|            0|            0|  0.00%|        name = name.lower()
  2477|         0|            0|            0|  0.00%|        if value and name[-6:] == '_proxy':
  2478|         0|            0|            0|  0.00%|            proxies[name[:-6]] = value
  2479|         0|            0|            0|  0.00%|    # CVE-2016-1000110 - If we are running as CGI script, forget HTTP_PROXY
  2480|         0|            0|            0|  0.00%|    # (non-all-lowercase) as it may be set from the web server by a "Proxy:"
  2481|         0|            0|            0|  0.00%|    # header from the client
  2482|         0|            0|            0|  0.00%|    # If "proxy" is lowercase, it will still be used thanks to the next block
  2483|         0|            0|            0|  0.00%|    if 'REQUEST_METHOD' in os.environ:
  2484|         0|            0|            0|  0.00%|        proxies.pop('http', None)
  2485|         0|            0|            0|  0.00%|    for name, value in os.environ.items():
  2486|         0|            0|            0|  0.00%|        if name[-6:] == '_proxy':
  2487|         0|            0|            0|  0.00%|            name = name.lower()
  2488|         0|            0|            0|  0.00%|            if value:
  2489|         0|            0|            0|  0.00%|                proxies[name[:-6]] = value
  2490|         0|            0|            0|  0.00%|            else:
  2491|         0|            0|            0|  0.00%|                proxies.pop(name[:-6], None)
  2492|         0|            0|            0|  0.00%|    return proxies
  2493|         0|            0|            0|  0.00%|
  2494|         0|            0|            0|  0.00%|def proxy_bypass_environment(host, proxies=None):
  2495|         0|            0|            0|  0.00%|    """Test if proxies should not be used for a particular host.
  2496|         0|            0|            0|  0.00%|
  2497|         0|            0|            0|  0.00%|    Checks the proxy dict for the value of no_proxy, which should
  2498|         0|            0|            0|  0.00%|    be a list of comma separated DNS suffixes, or '*' for all hosts.
  2499|         0|            0|            0|  0.00%|
  2500|         0|            0|            0|  0.00%|    """
  2501|         0|            0|            0|  0.00%|    if proxies is None:
  2502|         0|            0|            0|  0.00%|        proxies = getproxies_environment()
  2503|         0|            0|            0|  0.00%|    # don't bypass, if no_proxy isn't specified
  2504|         0|            0|            0|  0.00%|    try:
  2505|         0|            0|            0|  0.00%|        no_proxy = proxies['no']
  2506|         0|            0|            0|  0.00%|    except KeyError:
  2507|         0|            0|            0|  0.00%|        return 0
  2508|         0|            0|            0|  0.00%|    # '*' is special case for always bypass
  2509|         0|            0|            0|  0.00%|    if no_proxy == '*':
  2510|         0|            0|            0|  0.00%|        return 1
  2511|         0|            0|            0|  0.00%|    # strip port off host
  2512|         0|            0|            0|  0.00%|    hostonly, port = splitport(host)
  2513|         0|            0|            0|  0.00%|    # check if the host ends with any of the DNS suffixes
  2514|         0|            0|            0|  0.00%|    no_proxy_list = [proxy.strip() for proxy in no_proxy.split(',')]
  2515|         0|            0|            0|  0.00%|    for name in no_proxy_list:
  2516|         0|            0|            0|  0.00%|        if name:
  2517|         0|            0|            0|  0.00%|            name = name.lstrip('.')  # ignore leading dots
  2518|         0|            0|            0|  0.00%|            name = re.escape(name)
  2519|         0|            0|            0|  0.00%|            pattern = r'(.+\.)?%s$' % name
  2520|         0|            0|            0|  0.00%|            if (re.match(pattern, hostonly, re.I)
  2521|         0|            0|            0|  0.00%|                    or re.match(pattern, host, re.I)):
  2522|         0|            0|            0|  0.00%|                return 1
  2523|         0|            0|            0|  0.00%|    # otherwise, don't bypass
  2524|         0|            0|            0|  0.00%|    return 0
  2525|         0|            0|            0|  0.00%|
  2526|         0|            0|            0|  0.00%|
  2527|         0|            0|            0|  0.00%|# This code tests an OSX specific data structure but is testable on all
  2528|         0|            0|            0|  0.00%|# platforms
  2529|         0|            0|            0|  0.00%|def _proxy_bypass_macosx_sysconf(host, proxy_settings):
  2530|         0|            0|            0|  0.00%|    """
  2531|         0|            0|            0|  0.00%|    Return True iff this host shouldn't be accessed using a proxy
  2532|         0|            0|            0|  0.00%|
  2533|         0|            0|            0|  0.00%|    This function uses the MacOSX framework SystemConfiguration
  2534|         0|            0|            0|  0.00%|    to fetch the proxy information.
  2535|         0|            0|            0|  0.00%|
  2536|         0|            0|            0|  0.00%|    proxy_settings come from _scproxy._get_proxy_settings or get mocked ie:
  2537|         0|            0|            0|  0.00%|    { 'exclude_simple': bool,
  2538|         0|            0|            0|  0.00%|      'exceptions': ['foo.bar', '*.bar.com', '127.0.0.1', '10.1', '10.0/16']
  2539|         0|            0|            0|  0.00%|    }
  2540|         0|            0|            0|  0.00%|    """
  2541|         0|            0|            0|  0.00%|    from fnmatch import fnmatch
  2542|         0|            0|            0|  0.00%|
  2543|         0|            0|            0|  0.00%|    hostonly, port = splitport(host)
  2544|         0|            0|            0|  0.00%|
  2545|         0|            0|            0|  0.00%|    def ip2num(ipAddr):
  2546|         0|            0|            0|  0.00%|        parts = ipAddr.split('.')
  2547|         0|            0|            0|  0.00%|        parts = list(map(int, parts))
  2548|         0|            0|            0|  0.00%|        if len(parts) != 4:
  2549|         0|            0|            0|  0.00%|            parts = (parts + [0, 0, 0, 0])[:4]
  2550|         0|            0|            0|  0.00%|        return (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8) | parts[3]
  2551|         0|            0|            0|  0.00%|
  2552|         0|            0|            0|  0.00%|    # Check for simple host names:
  2553|         0|            0|            0|  0.00%|    if '.' not in host:
  2554|         0|            0|            0|  0.00%|        if proxy_settings['exclude_simple']:
  2555|         0|            0|            0|  0.00%|            return True
  2556|         0|            0|            0|  0.00%|
  2557|         0|            0|            0|  0.00%|    hostIP = None
  2558|         0|            0|            0|  0.00%|
  2559|         0|            0|            0|  0.00%|    for value in proxy_settings.get('exceptions', ()):
  2560|         0|            0|            0|  0.00%|        # Items in the list are strings like these: *.local, 169.254/16
  2561|         0|            0|            0|  0.00%|        if not value: continue
  2562|         0|            0|            0|  0.00%|
  2563|         0|            0|            0|  0.00%|        m = re.match(r"(\d+(?:\.\d+)*)(/\d+)?", value)
  2564|         0|            0|            0|  0.00%|        if m is not None:
  2565|         0|            0|            0|  0.00%|            if hostIP is None:
  2566|         0|            0|            0|  0.00%|                try:
  2567|         0|            0|            0|  0.00%|                    hostIP = socket.gethostbyname(hostonly)
  2568|         0|            0|            0|  0.00%|                    hostIP = ip2num(hostIP)
  2569|         0|            0|            0|  0.00%|                except OSError:
  2570|         0|            0|            0|  0.00%|                    continue
  2571|         0|            0|            0|  0.00%|
  2572|         0|            0|            0|  0.00%|            base = ip2num(m.group(1))
  2573|         0|            0|            0|  0.00%|            mask = m.group(2)
  2574|         0|            0|            0|  0.00%|            if mask is None:
  2575|         0|            0|            0|  0.00%|                mask = 8 * (m.group(1).count('.') + 1)
  2576|         0|            0|            0|  0.00%|            else:
  2577|         0|            0|            0|  0.00%|                mask = int(mask[1:])
  2578|         0|            0|            0|  0.00%|            mask = 32 - mask
  2579|         0|            0|            0|  0.00%|
  2580|         0|            0|            0|  0.00%|            if (hostIP >> mask) == (base >> mask):
  2581|         0|            0|            0|  0.00%|                return True
  2582|         0|            0|            0|  0.00%|
  2583|         0|            0|            0|  0.00%|        elif fnmatch(host, value):
  2584|         0|            0|            0|  0.00%|            return True
  2585|         0|            0|            0|  0.00%|
  2586|         0|            0|            0|  0.00%|    return False
  2587|         0|            0|            0|  0.00%|
  2588|         0|            0|            0|  0.00%|
  2589|         0|            0|            0|  0.00%|if sys.platform == 'darwin':
  2590|         0|            0|            0|  0.00%|    from _scproxy import _get_proxy_settings, _get_proxies
  2591|         0|            0|            0|  0.00%|
  2592|         0|            0|            0|  0.00%|    def proxy_bypass_macosx_sysconf(host):
  2593|         0|            0|            0|  0.00%|        proxy_settings = _get_proxy_settings()
  2594|         0|            0|            0|  0.00%|        return _proxy_bypass_macosx_sysconf(host, proxy_settings)
  2595|         0|            0|            0|  0.00%|
  2596|         0|            0|            0|  0.00%|    def getproxies_macosx_sysconf():
  2597|         0|            0|            0|  0.00%|        """Return a dictionary of scheme -> proxy server URL mappings.
  2598|         0|            0|            0|  0.00%|
  2599|         0|            0|            0|  0.00%|        This function uses the MacOSX framework SystemConfiguration
  2600|         0|            0|            0|  0.00%|        to fetch the proxy information.
  2601|         0|            0|            0|  0.00%|        """
  2602|         0|            0|            0|  0.00%|        return _get_proxies()
  2603|         0|            0|            0|  0.00%|
  2604|         0|            0|            0|  0.00%|
  2605|         0|            0|            0|  0.00%|
  2606|         0|            0|            0|  0.00%|    def proxy_bypass(host):
  2607|         0|            0|            0|  0.00%|        """Return True, if host should be bypassed.
  2608|         0|            0|            0|  0.00%|
  2609|         0|            0|            0|  0.00%|        Checks proxy settings gathered from the environment, if specified,
  2610|         0|            0|            0|  0.00%|        or from the MacOSX framework SystemConfiguration.
  2611|         0|            0|            0|  0.00%|
  2612|         0|            0|            0|  0.00%|        """
  2613|         0|            0|            0|  0.00%|        proxies = getproxies_environment()
  2614|         0|            0|            0|  0.00%|        if proxies:
  2615|         0|            0|            0|  0.00%|            return proxy_bypass_environment(host, proxies)
  2616|         0|            0|            0|  0.00%|        else:
  2617|         0|            0|            0|  0.00%|            return proxy_bypass_macosx_sysconf(host)
  2618|         0|            0|            0|  0.00%|
  2619|         0|            0|            0|  0.00%|    def getproxies():
  2620|         0|            0|            0|  0.00%|        return getproxies_environment() or getproxies_macosx_sysconf()
  2621|         0|            0|            0|  0.00%|
  2622|         0|            0|            0|  0.00%|
  2623|         0|            0|            0|  0.00%|elif os.name == 'nt':
  2624|         0|            0|            0|  0.00%|    def getproxies_registry():
  2625|         0|            0|            0|  0.00%|        """Return a dictionary of scheme -> proxy server URL mappings.
  2626|         0|            0|            0|  0.00%|
  2627|         0|            0|            0|  0.00%|        Win32 uses the registry to store proxies.
  2628|         0|            0|            0|  0.00%|
  2629|         0|            0|            0|  0.00%|        """
  2630|         0|            0|            0|  0.00%|        proxies = {}
  2631|         0|            0|            0|  0.00%|        try:
  2632|         0|            0|            0|  0.00%|            import winreg
  2633|         0|            0|            0|  0.00%|        except ImportError:
  2634|         0|            0|            0|  0.00%|            # Std module, so should be around - but you never know!
  2635|         0|            0|            0|  0.00%|            return proxies
  2636|         0|            0|            0|  0.00%|        try:
  2637|         0|            0|            0|  0.00%|            internetSettings = winreg.OpenKey(winreg.HKEY_CURRENT_USER,
  2638|         0|            0|            0|  0.00%|                r'Software\Microsoft\Windows\CurrentVersion\Internet Settings')
  2639|         0|            0|            0|  0.00%|            proxyEnable = winreg.QueryValueEx(internetSettings,
  2640|         0|            0|            0|  0.00%|                                               'ProxyEnable')[0]
  2641|         0|            0|            0|  0.00%|            if proxyEnable:
  2642|         0|            0|            0|  0.00%|                # Returned as Unicode but problems if not converted to ASCII
  2643|         0|            0|            0|  0.00%|                proxyServer = str(winreg.QueryValueEx(internetSettings,
  2644|         0|            0|            0|  0.00%|                                                       'ProxyServer')[0])
  2645|         0|            0|            0|  0.00%|                if '=' in proxyServer:
  2646|         0|            0|            0|  0.00%|                    # Per-protocol settings
  2647|         0|            0|            0|  0.00%|                    for p in proxyServer.split(';'):
  2648|         0|            0|            0|  0.00%|                        protocol, address = p.split('=', 1)
  2649|         0|            0|            0|  0.00%|                        # See if address has a type:// prefix
  2650|         0|            0|            0|  0.00%|                        if not re.match('^([^/:]+)://', address):
  2651|         0|            0|            0|  0.00%|                            address = '%s://%s' % (protocol, address)
  2652|         0|            0|            0|  0.00%|                        proxies[protocol] = address
  2653|         0|            0|            0|  0.00%|                else:
  2654|         0|            0|            0|  0.00%|                    # Use one setting for all protocols
  2655|         0|            0|            0|  0.00%|                    if proxyServer[:5] == 'http:':
  2656|         0|            0|            0|  0.00%|                        proxies['http'] = proxyServer
  2657|         0|            0|            0|  0.00%|                    else:
  2658|         0|            0|            0|  0.00%|                        proxies['http'] = 'http://%s' % proxyServer
  2659|         0|            0|            0|  0.00%|                        proxies['https'] = 'https://%s' % proxyServer
  2660|         0|            0|            0|  0.00%|                        proxies['ftp'] = 'ftp://%s' % proxyServer
  2661|         0|            0|            0|  0.00%|            internetSettings.Close()
  2662|         0|            0|            0|  0.00%|        except (OSError, ValueError, TypeError):
  2663|         0|            0|            0|  0.00%|            # Either registry key not found etc, or the value in an
  2664|         0|            0|            0|  0.00%|            # unexpected format.
  2665|         0|            0|            0|  0.00%|            # proxies already set up to be empty so nothing to do
  2666|         0|            0|            0|  0.00%|            pass
  2667|         0|            0|            0|  0.00%|        return proxies
  2668|         0|            0|            0|  0.00%|
  2669|         0|            0|            0|  0.00%|    def getproxies():
  2670|         0|            0|            0|  0.00%|        """Return a dictionary of scheme -> proxy server URL mappings.
  2671|         0|            0|            0|  0.00%|
  2672|         0|            0|            0|  0.00%|        Returns settings gathered from the environment, if specified,
  2673|         0|            0|            0|  0.00%|        or the registry.
  2674|         0|            0|            0|  0.00%|
  2675|         0|            0|            0|  0.00%|        """
  2676|         0|            0|            0|  0.00%|        return getproxies_environment() or getproxies_registry()
  2677|         0|            0|            0|  0.00%|
  2678|         0|            0|            0|  0.00%|    def proxy_bypass_registry(host):
  2679|         0|            0|            0|  0.00%|        try:
  2680|         0|            0|            0|  0.00%|            import winreg
  2681|         0|            0|            0|  0.00%|        except ImportError:
  2682|         0|            0|            0|  0.00%|            # Std modules, so should be around - but you never know!
  2683|         0|            0|            0|  0.00%|            return 0
  2684|         0|            0|            0|  0.00%|        try:
  2685|         0|            0|            0|  0.00%|            internetSettings = winreg.OpenKey(winreg.HKEY_CURRENT_USER,
  2686|         0|            0|            0|  0.00%|                r'Software\Microsoft\Windows\CurrentVersion\Internet Settings')
  2687|         0|            0|            0|  0.00%|            proxyEnable = winreg.QueryValueEx(internetSettings,
  2688|         0|            0|            0|  0.00%|                                               'ProxyEnable')[0]
  2689|         0|            0|            0|  0.00%|            proxyOverride = str(winreg.QueryValueEx(internetSettings,
  2690|         0|            0|            0|  0.00%|                                                     'ProxyOverride')[0])
  2691|         0|            0|            0|  0.00%|            # ^^^^ Returned as Unicode but problems if not converted to ASCII
  2692|         0|            0|            0|  0.00%|        except OSError:
  2693|         0|            0|            0|  0.00%|            return 0
  2694|         0|            0|            0|  0.00%|        if not proxyEnable or not proxyOverride:
  2695|         0|            0|            0|  0.00%|            return 0
  2696|         0|            0|            0|  0.00%|        # try to make a host list from name and IP address.
  2697|         0|            0|            0|  0.00%|        rawHost, port = splitport(host)
  2698|         0|            0|            0|  0.00%|        host = [rawHost]
  2699|         0|            0|            0|  0.00%|        try:
  2700|         0|            0|            0|  0.00%|            addr = socket.gethostbyname(rawHost)
  2701|         0|            0|            0|  0.00%|            if addr != rawHost:
  2702|         0|            0|            0|  0.00%|                host.append(addr)
  2703|         0|            0|            0|  0.00%|        except OSError:
  2704|         0|            0|            0|  0.00%|            pass
  2705|         0|            0|            0|  0.00%|        try:
  2706|         0|            0|            0|  0.00%|            fqdn = socket.getfqdn(rawHost)
  2707|         0|            0|            0|  0.00%|            if fqdn != rawHost:
  2708|         0|            0|            0|  0.00%|                host.append(fqdn)
  2709|         0|            0|            0|  0.00%|        except OSError:
  2710|         0|            0|            0|  0.00%|            pass
  2711|         0|            0|            0|  0.00%|        # make a check value list from the registry entry: replace the
  2712|         0|            0|            0|  0.00%|        # '<local>' string by the localhost entry and the corresponding
  2713|         0|            0|            0|  0.00%|        # canonical entry.
  2714|         0|            0|            0|  0.00%|        proxyOverride = proxyOverride.split(';')
  2715|         0|            0|            0|  0.00%|        # now check if we match one of the registry values.
  2716|         0|            0|            0|  0.00%|        for test in proxyOverride:
  2717|         0|            0|            0|  0.00%|            if test == '<local>':
  2718|         0|            0|            0|  0.00%|                if '.' not in rawHost:
  2719|         0|            0|            0|  0.00%|                    return 1
  2720|         0|            0|            0|  0.00%|            test = test.replace(".", r"\.")     # mask dots
  2721|         0|            0|            0|  0.00%|            test = test.replace("*", r".*")     # change glob sequence
  2722|         0|            0|            0|  0.00%|            test = test.replace("?", r".")      # change glob char
  2723|         0|            0|            0|  0.00%|            for val in host:
  2724|         0|            0|            0|  0.00%|                if re.match(test, val, re.I):
  2725|         0|            0|            0|  0.00%|                    return 1
  2726|         0|            0|            0|  0.00%|        return 0
  2727|         0|            0|            0|  0.00%|
  2728|         0|            0|            0|  0.00%|    def proxy_bypass(host):
  2729|         0|            0|            0|  0.00%|        """Return True, if host should be bypassed.
  2730|         0|            0|            0|  0.00%|
  2731|         0|            0|            0|  0.00%|        Checks proxy settings gathered from the environment, if specified,
  2732|         0|            0|            0|  0.00%|        or the registry.
  2733|         0|            0|            0|  0.00%|
  2734|         0|            0|            0|  0.00%|        """
  2735|         0|            0|            0|  0.00%|        proxies = getproxies_environment()
  2736|         0|            0|            0|  0.00%|        if proxies:
  2737|         0|            0|            0|  0.00%|            return proxy_bypass_environment(host, proxies)
  2738|         0|            0|            0|  0.00%|        else:
  2739|         0|            0|            0|  0.00%|            return proxy_bypass_registry(host)
  2740|         0|            0|            0|  0.00%|
  2741|         0|            0|            0|  0.00%|else:
  2742|         0|            0|            0|  0.00%|    # By default use environment variables
  2743|         0|            0|            0|  0.00%|    getproxies = getproxies_environment
  2744|         0|            0|            0|  0.00%|    proxy_bypass = proxy_bypass_environment
File: D:\Application\Anaconda\lib\http\client.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|r"""HTTP/1.1 client library
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|<intro stuff goes here>
     4|         0|            0|            0|  0.00%|<other stuff, too>
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|HTTPConnection goes through a number of "states", which define when a client
     7|         0|            0|            0|  0.00%|may legally make another request or fetch the response for a particular
     8|         0|            0|            0|  0.00%|request. This diagram details these state transitions:
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|    (null)
    11|         0|            0|            0|  0.00%|      |
    12|         0|            0|            0|  0.00%|      | HTTPConnection()
    13|         0|            0|            0|  0.00%|      v
    14|         0|            0|            0|  0.00%|    Idle
    15|         0|            0|            0|  0.00%|      |
    16|         0|            0|            0|  0.00%|      | putrequest()
    17|         0|            0|            0|  0.00%|      v
    18|         0|            0|            0|  0.00%|    Request-started
    19|         0|            0|            0|  0.00%|      |
    20|         0|            0|            0|  0.00%|      | ( putheader() )*  endheaders()
    21|         0|            0|            0|  0.00%|      v
    22|         0|            0|            0|  0.00%|    Request-sent
    23|         0|            0|            0|  0.00%|      |\_____________________________
    24|         0|            0|            0|  0.00%|      |                              | getresponse() raises
    25|         0|            0|            0|  0.00%|      | response = getresponse()     | ConnectionError
    26|         0|            0|            0|  0.00%|      v                              v
    27|         0|            0|            0|  0.00%|    Unread-response                Idle
    28|         0|            0|            0|  0.00%|    [Response-headers-read]
    29|         0|            0|            0|  0.00%|      |\____________________
    30|         0|            0|            0|  0.00%|      |                     |
    31|         0|            0|            0|  0.00%|      | response.read()     | putrequest()
    32|         0|            0|            0|  0.00%|      v                     v
    33|         0|            0|            0|  0.00%|    Idle                  Req-started-unread-response
    34|         0|            0|            0|  0.00%|                     ______/|
    35|         0|            0|            0|  0.00%|                   /        |
    36|         0|            0|            0|  0.00%|   response.read() |        | ( putheader() )*  endheaders()
    37|         0|            0|            0|  0.00%|                   v        v
    38|         0|            0|            0|  0.00%|       Request-started    Req-sent-unread-response
    39|         0|            0|            0|  0.00%|                            |
    40|         0|            0|            0|  0.00%|                            | response.read()
    41|         0|            0|            0|  0.00%|                            v
    42|         0|            0|            0|  0.00%|                          Request-sent
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|This diagram presents the following rules:
    45|         0|            0|            0|  0.00%|  -- a second request may not be started until {response-headers-read}
    46|         0|            0|            0|  0.00%|  -- a response [object] cannot be retrieved until {request-sent}
    47|         0|            0|            0|  0.00%|  -- there is no differentiation between an unread response body and a
    48|         0|            0|            0|  0.00%|     partially read response body
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|Note: this enforcement is applied by the HTTPConnection class. The
    51|         0|            0|            0|  0.00%|      HTTPResponse class does not enforce this state machine, which
    52|         0|            0|            0|  0.00%|      implies sophisticated clients may accelerate the request/response
    53|         0|            0|            0|  0.00%|      pipeline. Caution should be taken, though: accelerating the states
    54|         0|            0|            0|  0.00%|      beyond the above pattern may imply knowledge of the server's
    55|         0|            0|            0|  0.00%|      connection-close behavior for certain requests. For example, it
    56|         0|            0|            0|  0.00%|      is impossible to tell whether the server will close the connection
    57|         0|            0|            0|  0.00%|      UNTIL the response headers have been read; this means that further
    58|         0|            0|            0|  0.00%|      requests cannot be placed into the pipeline until it is known that
    59|         0|            0|            0|  0.00%|      the server will NOT be closing the connection.
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|Logical State                  __state            __response
    62|         0|            0|            0|  0.00%|-------------                  -------            ----------
    63|         0|            0|            0|  0.00%|Idle                           _CS_IDLE           None
    64|         0|            0|            0|  0.00%|Request-started                _CS_REQ_STARTED    None
    65|         0|            0|            0|  0.00%|Request-sent                   _CS_REQ_SENT       None
    66|         0|            0|            0|  0.00%|Unread-response                _CS_IDLE           <response_class>
    67|         0|            0|            0|  0.00%|Req-started-unread-response    _CS_REQ_STARTED    <response_class>
    68|         0|            0|            0|  0.00%|Req-sent-unread-response       _CS_REQ_SENT       <response_class>
    69|         0|            0|            0|  0.00%|"""
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|import email.parser
    72|         0|            0|            0|  0.00%|import email.message
    73|         0|            0|            0|  0.00%|import http
    74|         0|            0|            0|  0.00%|import io
    75|         0|            0|            0|  0.00%|import os
    76|         0|            0|            0|  0.00%|import re
    77|         0|            0|            0|  0.00%|import socket
    78|         0|            0|            0|  0.00%|import collections
    79|         0|            0|            0|  0.00%|from urllib.parse import urlsplit
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|# HTTPMessage, parse_headers(), and the HTTP status code constants are
    82|         0|            0|            0|  0.00%|# intentionally omitted for simplicity
    83|         0|            0|            0|  0.00%|__all__ = ["HTTPResponse", "HTTPConnection",
    84|         0|            0|            0|  0.00%|           "HTTPException", "NotConnected", "UnknownProtocol",
    85|         0|            0|            0|  0.00%|           "UnknownTransferEncoding", "UnimplementedFileMode",
    86|         0|            0|            0|  0.00%|           "IncompleteRead", "InvalidURL", "ImproperConnectionState",
    87|         0|            0|            0|  0.00%|           "CannotSendRequest", "CannotSendHeader", "ResponseNotReady",
    88|         0|            0|            0|  0.00%|           "BadStatusLine", "LineTooLong", "RemoteDisconnected", "error",
    89|         0|            0|            0|  0.00%|           "responses"]
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|HTTP_PORT = 80
    92|         0|            0|            0|  0.00%|HTTPS_PORT = 443
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|_UNKNOWN = 'UNKNOWN'
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|# connection states
    97|         0|            0|            0|  0.00%|_CS_IDLE = 'Idle'
    98|         0|            0|            0|  0.00%|_CS_REQ_STARTED = 'Request-started'
    99|         0|            0|            0|  0.00%|_CS_REQ_SENT = 'Request-sent'
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|# hack to maintain backwards compatibility
   103|         0|            0|            0|  0.00%|globals().update(http.HTTPStatus.__members__)
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|# another hack to maintain backwards compatibility
   106|         0|            0|            0|  0.00%|# Mapping status codes to official W3C names
   107|         0|            0|            0|  0.00%|responses = {v: v.phrase for v in http.HTTPStatus.__members__.values()}
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|# maximal amount of data to read at one time in _safe_read
   110|         0|            0|            0|  0.00%|MAXAMOUNT = 1048576
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|# maximal line length when calling readline().
   113|         0|            0|            0|  0.00%|_MAXLINE = 65536
   114|         0|            0|            0|  0.00%|_MAXHEADERS = 100
   115|         0|            0|            0|  0.00%|
   116|         0|            0|            0|  0.00%|# Header name/value ABNF (http://tools.ietf.org/html/rfc7230#section-3.2)
   117|         0|            0|            0|  0.00%|#
   118|         0|            0|            0|  0.00%|# VCHAR          = %x21-7E
   119|         0|            0|            0|  0.00%|# obs-text       = %x80-FF
   120|         0|            0|            0|  0.00%|# header-field   = field-name ":" OWS field-value OWS
   121|         0|            0|            0|  0.00%|# field-name     = token
   122|         0|            0|            0|  0.00%|# field-value    = *( field-content / obs-fold )
   123|         0|            0|            0|  0.00%|# field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
   124|         0|            0|            0|  0.00%|# field-vchar    = VCHAR / obs-text
   125|         0|            0|            0|  0.00%|#
   126|         0|            0|            0|  0.00%|# obs-fold       = CRLF 1*( SP / HTAB )
   127|         0|            0|            0|  0.00%|#                ; obsolete line folding
   128|         0|            0|            0|  0.00%|#                ; see Section 3.2.4
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|# token          = 1*tchar
   131|         0|            0|            0|  0.00%|#
   132|         0|            0|            0|  0.00%|# tchar          = "!" / "#" / "$" / "%" / "&" / "'" / "*"
   133|         0|            0|            0|  0.00%|#                / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
   134|         0|            0|            0|  0.00%|#                / DIGIT / ALPHA
   135|         0|            0|            0|  0.00%|#                ; any VCHAR, except delimiters
   136|         0|            0|            0|  0.00%|#
   137|         0|            0|            0|  0.00%|# VCHAR defined in http://tools.ietf.org/html/rfc5234#appendix-B.1
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|# the patterns for both name and value are more lenient than RFC
   140|         0|            0|            0|  0.00%|# definitions to allow for backwards compatibility
   141|         0|            0|            0|  0.00%|_is_legal_header_name = re.compile(rb'[^:\s][^:\r\n]*').fullmatch
   142|         0|            0|            0|  0.00%|_is_illegal_header_value = re.compile(rb'\n(?![ \t])|\r(?![ \t\n])').search
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|# We always set the Content-Length header for these methods because some
   145|         0|            0|            0|  0.00%|# servers will otherwise respond with a 411
   146|         0|            0|            0|  0.00%|_METHODS_EXPECTING_BODY = {'PATCH', 'POST', 'PUT'}
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|def _encode(data, name='data'):
   150|         0|            0|            0|  0.00%|    """Call data.encode("latin-1") but show a better error message."""
   151|         0|            0|            0|  0.00%|    try:
   152|         0|            0|            0|  0.00%|        return data.encode("latin-1")
   153|         0|            0|            0|  0.00%|    except UnicodeEncodeError as err:
   154|         0|            0|            0|  0.00%|        raise UnicodeEncodeError(
   155|         0|            0|            0|  0.00%|            err.encoding,
   156|         0|            0|            0|  0.00%|            err.object,
   157|         0|            0|            0|  0.00%|            err.start,
   158|         0|            0|            0|  0.00%|            err.end,
   159|         0|            0|            0|  0.00%|            "%s (%.20r) is not valid Latin-1. Use %s.encode('utf-8') "
   160|         0|            0|            0|  0.00%|            "if you want to send it encoded in UTF-8." %
   161|         0|            0|            0|  0.00%|            (name.title(), data[err.start:err.end], name)) from None
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|class HTTPMessage(email.message.Message):
   165|         0|            0|            0|  0.00%|    # XXX The only usage of this method is in
   166|         0|            0|            0|  0.00%|    # http.server.CGIHTTPRequestHandler.  Maybe move the code there so
   167|         0|            0|            0|  0.00%|    # that it doesn't need to be part of the public API.  The API has
   168|         0|            0|            0|  0.00%|    # never been defined so this could cause backwards compatibility
   169|         0|            0|            0|  0.00%|    # issues.
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|    def getallmatchingheaders(self, name):
   172|         0|            0|            0|  0.00%|        """Find all header lines matching a given header name.
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|        Look through the list of headers and find all lines matching a given
   175|         0|            0|            0|  0.00%|        header name (and their continuation lines).  A list of the lines is
   176|         0|            0|            0|  0.00%|        returned, without interpretation.  If the header does not occur, an
   177|         0|            0|            0|  0.00%|        empty list is returned.  If the header occurs multiple times, all
   178|         0|            0|            0|  0.00%|        occurrences are returned.  Case is not important in the header name.
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|        """
   181|         0|            0|            0|  0.00%|        name = name.lower() + ':'
   182|         0|            0|            0|  0.00%|        n = len(name)
   183|         0|            0|            0|  0.00%|        lst = []
   184|         0|            0|            0|  0.00%|        hit = 0
   185|         0|            0|            0|  0.00%|        for line in self.keys():
   186|         0|            0|            0|  0.00%|            if line[:n].lower() == name:
   187|         0|            0|            0|  0.00%|                hit = 1
   188|         0|            0|            0|  0.00%|            elif not line[:1].isspace():
   189|         0|            0|            0|  0.00%|                hit = 0
   190|         0|            0|            0|  0.00%|            if hit:
   191|         0|            0|            0|  0.00%|                lst.append(line)
   192|         0|            0|            0|  0.00%|        return lst
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|def parse_headers(fp, _class=HTTPMessage):
   195|         0|            0|            0|  0.00%|    """Parses only RFC2822 headers from a file pointer.
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|    email Parser wants to see strings rather than bytes.
   198|         0|            0|            0|  0.00%|    But a TextIOWrapper around self.rfile would buffer too many bytes
   199|         0|            0|            0|  0.00%|    from the stream, bytes which we later need to read as bytes.
   200|         0|            0|            0|  0.00%|    So we read the correct bytes here, as bytes, for email Parser
   201|         0|            0|            0|  0.00%|    to parse.
   202|         0|            0|            0|  0.00%|
   203|         0|            0|            0|  0.00%|    """
   204|         0|            0|            0|  0.00%|    headers = []
   205|         0|            0|            0|  0.00%|    while True:
   206|         0|            0|            0|  0.00%|        line = fp.readline(_MAXLINE + 1)
   207|         0|            0|            0|  0.00%|        if len(line) > _MAXLINE:
   208|         0|            0|            0|  0.00%|            raise LineTooLong("header line")
   209|         0|            0|            0|  0.00%|        headers.append(line)
   210|         0|            0|            0|  0.00%|        if len(headers) > _MAXHEADERS:
   211|         0|            0|            0|  0.00%|            raise HTTPException("got more than %d headers" % _MAXHEADERS)
   212|         0|            0|            0|  0.00%|        if line in (b'\r\n', b'\n', b''):
   213|         0|            0|            0|  0.00%|            break
   214|         0|            0|            0|  0.00%|    hstring = b''.join(headers).decode('iso-8859-1')
   215|         0|            0|            0|  0.00%|    return email.parser.Parser(_class=_class).parsestr(hstring)
   216|         0|            0|            0|  0.00%|
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|class HTTPResponse(io.BufferedIOBase):
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|    # See RFC 2616 sec 19.6 and RFC 1945 sec 6 for details.
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|    # The bytes from the socket object are iso-8859-1 strings.
   223|         0|            0|            0|  0.00%|    # See RFC 2616 sec 2.2 which notes an exception for MIME-encoded
   224|         0|            0|            0|  0.00%|    # text following RFC 2047.  The basic status line parsing only
   225|         0|            0|            0|  0.00%|    # accepts iso-8859-1.
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|    def __init__(self, sock, debuglevel=0, method=None, url=None):
   228|         0|            0|            0|  0.00%|        # If the response includes a content-length header, we need to
   229|         0|            0|            0|  0.00%|        # make sure that the client doesn't read more than the
   230|         0|            0|            0|  0.00%|        # specified number of bytes.  If it does, it will block until
   231|         0|            0|            0|  0.00%|        # the server times out and closes the connection.  This will
   232|         0|            0|            0|  0.00%|        # happen if a self.fp.read() is done (without a size) whether
   233|         0|            0|            0|  0.00%|        # self.fp is buffered or not.  So, no self.fp.read() by
   234|         0|            0|            0|  0.00%|        # clients unless they know what they are doing.
   235|         0|            0|            0|  0.00%|        self.fp = sock.makefile("rb")
   236|         0|            0|            0|  0.00%|        self.debuglevel = debuglevel
   237|         0|            0|            0|  0.00%|        self._method = method
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|        # The HTTPResponse object is returned via urllib.  The clients
   240|         0|            0|            0|  0.00%|        # of http and urllib expect different attributes for the
   241|         0|            0|            0|  0.00%|        # headers.  headers is used here and supports urllib.  msg is
   242|         0|            0|            0|  0.00%|        # provided as a backwards compatibility layer for http
   243|         0|            0|            0|  0.00%|        # clients.
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|        self.headers = self.msg = None
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|        # from the Status-Line of the response
   248|         0|            0|            0|  0.00%|        self.version = _UNKNOWN # HTTP-Version
   249|         0|            0|            0|  0.00%|        self.status = _UNKNOWN  # Status-Code
   250|         0|            0|            0|  0.00%|        self.reason = _UNKNOWN  # Reason-Phrase
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|        self.chunked = _UNKNOWN         # is "chunked" being used?
   253|         0|            0|            0|  0.00%|        self.chunk_left = _UNKNOWN      # bytes left to read in current chunk
   254|         0|            0|            0|  0.00%|        self.length = _UNKNOWN          # number of bytes left in response
   255|         0|            0|            0|  0.00%|        self.will_close = _UNKNOWN      # conn will close at end of response
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|    def _read_status(self):
   258|         0|            0|            0|  0.00%|        line = str(self.fp.readline(_MAXLINE + 1), "iso-8859-1")
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\socket.py:572 readinto
   259|         0|            0|            0|  0.00%|        if len(line) > _MAXLINE:
   260|         0|            0|            0|  0.00%|            raise LineTooLong("status line")
   261|         0|            0|            0|  0.00%|        if self.debuglevel > 0:
   262|         0|            0|            0|  0.00%|            print("reply:", repr(line))
   263|         0|            0|            0|  0.00%|        if not line:
   264|         0|            0|            0|  0.00%|            # Presumably, the server closed the connection before
   265|         0|            0|            0|  0.00%|            # sending a valid response.
   266|         0|            0|            0|  0.00%|            raise RemoteDisconnected("Remote end closed connection without"
   267|         0|            0|            0|  0.00%|                                     " response")
   268|         0|            0|            0|  0.00%|        try:
   269|         0|            0|            0|  0.00%|            version, status, reason = line.split(None, 2)
   270|         0|            0|            0|  0.00%|        except ValueError:
   271|         0|            0|            0|  0.00%|            try:
   272|         0|            0|            0|  0.00%|                version, status = line.split(None, 1)
   273|         0|            0|            0|  0.00%|                reason = ""
   274|         0|            0|            0|  0.00%|            except ValueError:
   275|         0|            0|            0|  0.00%|                # empty version will cause next test to fail.
   276|         0|            0|            0|  0.00%|                version = ""
   277|         0|            0|            0|  0.00%|        if not version.startswith("HTTP/"):
   278|         0|            0|            0|  0.00%|            self._close_conn()
   279|         0|            0|            0|  0.00%|            raise BadStatusLine(line)
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|        # The status code is a three-digit number
   282|         0|            0|            0|  0.00%|        try:
   283|         0|            0|            0|  0.00%|            status = int(status)
   284|         0|            0|            0|  0.00%|            if status < 100 or status > 999:
   285|         0|            0|            0|  0.00%|                raise BadStatusLine(line)
   286|         0|            0|            0|  0.00%|        except ValueError:
   287|         0|            0|            0|  0.00%|            raise BadStatusLine(line)
   288|         0|            0|            0|  0.00%|        return version, status, reason
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|    def begin(self):
   291|         0|            0|            0|  0.00%|        if self.headers is not None:
   292|         0|            0|            0|  0.00%|            # we've already started reading the response
   293|         0|            0|            0|  0.00%|            return
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|        # read until we get a non-100 response
   296|         0|            0|            0|  0.00%|        while True:
   297|         0|            0|            0|  0.00%|            version, status, reason = self._read_status()
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\http\client.py:257 _read_status
   298|         0|            0|            0|  0.00%|            if status != CONTINUE:
   299|         0|            0|            0|  0.00%|                break
   300|         0|            0|            0|  0.00%|            # skip the header from the 100 response
   301|         0|            0|            0|  0.00%|            while True:
   302|         0|            0|            0|  0.00%|                skip = self.fp.readline(_MAXLINE + 1)
   303|         0|            0|            0|  0.00%|                if len(skip) > _MAXLINE:
   304|         0|            0|            0|  0.00%|                    raise LineTooLong("header line")
   305|         0|            0|            0|  0.00%|                skip = skip.strip()
   306|         0|            0|            0|  0.00%|                if not skip:
   307|         0|            0|            0|  0.00%|                    break
   308|         0|            0|            0|  0.00%|                if self.debuglevel > 0:
   309|         0|            0|            0|  0.00%|                    print("header:", skip)
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|        self.code = self.status = status
   312|         0|            0|            0|  0.00%|        self.reason = reason.strip()
   313|         0|            0|            0|  0.00%|        if version in ("HTTP/1.0", "HTTP/0.9"):
   314|         0|            0|            0|  0.00%|            # Some servers might still return "0.9", treat it as 1.0 anyway
   315|         0|            0|            0|  0.00%|            self.version = 10
   316|         0|            0|            0|  0.00%|        elif version.startswith("HTTP/1."):
   317|         0|            0|            0|  0.00%|            self.version = 11   # use HTTP/1.1 code for HTTP/1.x where x>=1
   318|         0|            0|            0|  0.00%|        else:
   319|         0|            0|            0|  0.00%|            raise UnknownProtocol(version)
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|        self.headers = self.msg = parse_headers(self.fp)
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|        if self.debuglevel > 0:
   324|         0|            0|            0|  0.00%|            for hdr in self.headers:
   325|         0|            0|            0|  0.00%|                print("header:", hdr, end=" ")
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|        # are we using the chunked-style of transfer encoding?
   328|         0|            0|            0|  0.00%|        tr_enc = self.headers.get("transfer-encoding")
   329|         0|            0|            0|  0.00%|        if tr_enc and tr_enc.lower() == "chunked":
   330|         0|            0|            0|  0.00%|            self.chunked = True
   331|         0|            0|            0|  0.00%|            self.chunk_left = None
   332|         0|            0|            0|  0.00%|        else:
   333|         0|            0|            0|  0.00%|            self.chunked = False
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|        # will the connection close at the end of the response?
   336|         0|            0|            0|  0.00%|        self.will_close = self._check_close()
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|        # do we have a Content-Length?
   339|         0|            0|            0|  0.00%|        # NOTE: RFC 2616, S4.4, #3 says we ignore this if tr_enc is "chunked"
   340|         0|            0|            0|  0.00%|        self.length = None
   341|         0|            0|            0|  0.00%|        length = self.headers.get("content-length")
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|         # are we using the chunked-style of transfer encoding?
   344|         0|            0|            0|  0.00%|        tr_enc = self.headers.get("transfer-encoding")
   345|         0|            0|            0|  0.00%|        if length and not self.chunked:
   346|         0|            0|            0|  0.00%|            try:
   347|         0|            0|            0|  0.00%|                self.length = int(length)
   348|         0|            0|            0|  0.00%|            except ValueError:
   349|         0|            0|            0|  0.00%|                self.length = None
   350|         0|            0|            0|  0.00%|            else:
   351|         0|            0|            0|  0.00%|                if self.length < 0:  # ignore nonsensical negative lengths
   352|         0|            0|            0|  0.00%|                    self.length = None
   353|         0|            0|            0|  0.00%|        else:
   354|         0|            0|            0|  0.00%|            self.length = None
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|        # does the body have a fixed length? (of zero)
   357|         0|            0|            0|  0.00%|        if (status == NO_CONTENT or status == NOT_MODIFIED or
   358|         0|            0|            0|  0.00%|            100 <= status < 200 or      # 1xx codes
   359|         0|            0|            0|  0.00%|            self._method == "HEAD"):
   360|         0|            0|            0|  0.00%|            self.length = 0
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|        # if the connection remains open, and we aren't using chunked, and
   363|         0|            0|            0|  0.00%|        # a content-length was not provided, then assume that the connection
   364|         0|            0|            0|  0.00%|        # WILL close.
   365|         0|            0|            0|  0.00%|        if (not self.will_close and
   366|         0|            0|            0|  0.00%|            not self.chunked and
   367|         0|            0|            0|  0.00%|            self.length is None):
   368|         0|            0|            0|  0.00%|            self.will_close = True
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|    def _check_close(self):
   371|         0|            0|            0|  0.00%|        conn = self.headers.get("connection")
   372|         0|            0|            0|  0.00%|        if self.version == 11:
   373|         0|            0|            0|  0.00%|            # An HTTP/1.1 proxy is assumed to stay open unless
   374|         0|            0|            0|  0.00%|            # explicitly closed.
   375|         0|            0|            0|  0.00%|            conn = self.headers.get("connection")
   376|         0|            0|            0|  0.00%|            if conn and "close" in conn.lower():
   377|         0|            0|            0|  0.00%|                return True
   378|         0|            0|            0|  0.00%|            return False
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|        # Some HTTP/1.0 implementations have support for persistent
   381|         0|            0|            0|  0.00%|        # connections, using rules different than HTTP/1.1.
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|        # For older HTTP, Keep-Alive indicates persistent connection.
   384|         0|            0|            0|  0.00%|        if self.headers.get("keep-alive"):
   385|         0|            0|            0|  0.00%|            return False
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|        # At least Akamai returns a "Connection: Keep-Alive" header,
   388|         0|            0|            0|  0.00%|        # which was supposed to be sent by the client.
   389|         0|            0|            0|  0.00%|        if conn and "keep-alive" in conn.lower():
   390|         0|            0|            0|  0.00%|            return False
   391|         0|            0|            0|  0.00%|
   392|         0|            0|            0|  0.00%|        # Proxy-Connection is a netscape hack.
   393|         0|            0|            0|  0.00%|        pconn = self.headers.get("proxy-connection")
   394|         0|            0|            0|  0.00%|        if pconn and "keep-alive" in pconn.lower():
   395|         0|            0|            0|  0.00%|            return False
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|        # otherwise, assume it will close
   398|         0|            0|            0|  0.00%|        return True
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|    def _close_conn(self):
   401|         0|            0|            0|  0.00%|        fp = self.fp
   402|         0|            0|            0|  0.00%|        self.fp = None
   403|         0|            0|            0|  0.00%|        fp.close()
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|    def close(self):
   406|         0|            0|            0|  0.00%|        try:
   407|         0|            0|            0|  0.00%|            super().close() # set "closed" flag
   408|         0|            0|            0|  0.00%|        finally:
   409|         0|            0|            0|  0.00%|            if self.fp:
   410|         0|            0|            0|  0.00%|                self._close_conn()
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|    # These implementations are for the benefit of io.BufferedReader.
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|    # XXX This class should probably be revised to act more like
   415|         0|            0|            0|  0.00%|    # the "raw stream" that BufferedReader expects.
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|    def flush(self):
   418|         0|            0|            0|  0.00%|        super().flush()
   419|         0|            0|            0|  0.00%|        if self.fp:
   420|         0|            0|            0|  0.00%|            self.fp.flush()
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|    def readable(self):
   423|         0|            0|            0|  0.00%|        """Always returns True"""
   424|         0|            0|            0|  0.00%|        return True
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|    # End of "raw stream" methods
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|    def isclosed(self):
   429|         0|            0|            0|  0.00%|        """True if the connection is closed."""
   430|         0|            0|            0|  0.00%|        # NOTE: it is possible that we will not ever call self.close(). This
   431|         0|            0|            0|  0.00%|        #       case occurs when will_close is TRUE, length is None, and we
   432|         0|            0|            0|  0.00%|        #       read up to the last byte, but NOT past it.
   433|         0|            0|            0|  0.00%|        #
   434|         0|            0|            0|  0.00%|        # IMPLIES: if will_close is FALSE, then self.close() will ALWAYS be
   435|         0|            0|            0|  0.00%|        #          called, meaning self.isclosed() is meaningful.
   436|         0|            0|            0|  0.00%|        return self.fp is None
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|    def read(self, amt=None):
   439|         0|            0|            0|  0.00%|        if self.fp is None:
   440|         0|            0|            0|  0.00%|            return b""
   441|         0|            0|            0|  0.00%|
   442|         0|            0|            0|  0.00%|        if self._method == "HEAD":
   443|         0|            0|            0|  0.00%|            self._close_conn()
   444|         0|            0|            0|  0.00%|            return b""
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|        if amt is not None:
   447|         0|            0|            0|  0.00%|            # Amount is given, implement using readinto
   448|         0|            0|            0|  0.00%|            b = bytearray(amt)
   449|         0|            0|            0|  0.00%|            n = self.readinto(b)
   450|         0|            0|            0|  0.00%|            return memoryview(b)[:n].tobytes()
   451|         0|            0|            0|  0.00%|        else:
   452|         0|            0|            0|  0.00%|            # Amount is not given (unbounded read) so we must check self.length
   453|         0|            0|            0|  0.00%|            # and self.chunked
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|            if self.chunked:
   456|         0|            0|            0|  0.00%|                return self._readall_chunked()
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|            if self.length is None:
   459|         0|            0|            0|  0.00%|                s = self.fp.read()
   460|         0|            0|            0|  0.00%|            else:
   461|         0|            0|            0|  0.00%|                try:
   462|         0|            0|            0|  0.00%|                    s = self._safe_read(self.length)
   463|         0|            0|            0|  0.00%|                except IncompleteRead:
   464|         0|            0|            0|  0.00%|                    self._close_conn()
   465|         0|            0|            0|  0.00%|                    raise
   466|         0|            0|            0|  0.00%|                self.length = 0
   467|         0|            0|            0|  0.00%|            self._close_conn()        # we read everything
   468|         0|            0|            0|  0.00%|            return s
   469|         0|            0|            0|  0.00%|
   470|         0|            0|            0|  0.00%|    def readinto(self, b):
   471|         0|            0|            0|  0.00%|        """Read up to len(b) bytes into bytearray b and return the number
   472|         0|            0|            0|  0.00%|        of bytes read.
   473|         0|            0|            0|  0.00%|        """
   474|         0|            0|            0|  0.00%|
   475|         0|            0|            0|  0.00%|        if self.fp is None:
   476|         0|            0|            0|  0.00%|            return 0
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|        if self._method == "HEAD":
   479|         0|            0|            0|  0.00%|            self._close_conn()
   480|         0|            0|            0|  0.00%|            return 0
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|        if self.chunked:
   483|         0|            0|            0|  0.00%|            return self._readinto_chunked(b)
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|        if self.length is not None:
   486|         0|            0|            0|  0.00%|            if len(b) > self.length:
   487|         0|            0|            0|  0.00%|                # clip the read to the "end of response"
   488|         0|            0|            0|  0.00%|                b = memoryview(b)[0:self.length]
   489|         0|            0|            0|  0.00%|
   490|         0|            0|            0|  0.00%|        # we do not use _safe_read() here because this may be a .will_close
   491|         0|            0|            0|  0.00%|        # connection, and the user is reading more bytes than will be provided
   492|         0|            0|            0|  0.00%|        # (for example, reading in 1k chunks)
   493|         0|            0|            0|  0.00%|        n = self.fp.readinto(b)
   494|         0|            0|            0|  0.00%|        if not n and b:
   495|         0|            0|            0|  0.00%|            # Ideally, we would raise IncompleteRead if the content-length
   496|         0|            0|            0|  0.00%|            # wasn't satisfied, but it might break compatibility.
   497|         0|            0|            0|  0.00%|            self._close_conn()
   498|         0|            0|            0|  0.00%|        elif self.length is not None:
   499|         0|            0|            0|  0.00%|            self.length -= n
   500|         0|            0|            0|  0.00%|            if not self.length:
   501|         0|            0|            0|  0.00%|                self._close_conn()
   502|         0|            0|            0|  0.00%|        return n
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|    def _read_next_chunk_size(self):
   505|         0|            0|            0|  0.00%|        # Read the next chunk size from the file
   506|         0|            0|            0|  0.00%|        line = self.fp.readline(_MAXLINE + 1)
   507|         0|            0|            0|  0.00%|        if len(line) > _MAXLINE:
   508|         0|            0|            0|  0.00%|            raise LineTooLong("chunk size")
   509|         0|            0|            0|  0.00%|        i = line.find(b";")
   510|         0|            0|            0|  0.00%|        if i >= 0:
   511|         0|            0|            0|  0.00%|            line = line[:i] # strip chunk-extensions
   512|         0|            0|            0|  0.00%|        try:
   513|         0|            0|            0|  0.00%|            return int(line, 16)
   514|         0|            0|            0|  0.00%|        except ValueError:
   515|         0|            0|            0|  0.00%|            # close the connection as protocol synchronisation is
   516|         0|            0|            0|  0.00%|            # probably lost
   517|         0|            0|            0|  0.00%|            self._close_conn()
   518|         0|            0|            0|  0.00%|            raise
   519|         0|            0|            0|  0.00%|
   520|         0|            0|            0|  0.00%|    def _read_and_discard_trailer(self):
   521|         0|            0|            0|  0.00%|        # read and discard trailer up to the CRLF terminator
   522|         0|            0|            0|  0.00%|        ### note: we shouldn't have any trailers!
   523|         0|            0|            0|  0.00%|        while True:
   524|         0|            0|            0|  0.00%|            line = self.fp.readline(_MAXLINE + 1)
   525|         0|            0|            0|  0.00%|            if len(line) > _MAXLINE:
   526|         0|            0|            0|  0.00%|                raise LineTooLong("trailer line")
   527|         0|            0|            0|  0.00%|            if not line:
   528|         0|            0|            0|  0.00%|                # a vanishingly small number of sites EOF without
   529|         0|            0|            0|  0.00%|                # sending the trailer
   530|         0|            0|            0|  0.00%|                break
   531|         0|            0|            0|  0.00%|            if line in (b'\r\n', b'\n', b''):
   532|         0|            0|            0|  0.00%|                break
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|    def _get_chunk_left(self):
   535|         0|            0|            0|  0.00%|        # return self.chunk_left, reading a new chunk if necessary.
   536|         0|            0|            0|  0.00%|        # chunk_left == 0: at the end of the current chunk, need to close it
   537|         0|            0|            0|  0.00%|        # chunk_left == None: No current chunk, should read next.
   538|         0|            0|            0|  0.00%|        # This function returns non-zero or None if the last chunk has
   539|         0|            0|            0|  0.00%|        # been read.
   540|         0|            0|            0|  0.00%|        chunk_left = self.chunk_left
   541|         0|            0|            0|  0.00%|        if not chunk_left: # Can be 0 or None
   542|         0|            0|            0|  0.00%|            if chunk_left is not None:
   543|         0|            0|            0|  0.00%|                # We are at the end of chunk. dicard chunk end
   544|         0|            0|            0|  0.00%|                self._safe_read(2)  # toss the CRLF at the end of the chunk
   545|         0|            0|            0|  0.00%|            try:
   546|         0|            0|            0|  0.00%|                chunk_left = self._read_next_chunk_size()
   547|         0|            0|            0|  0.00%|            except ValueError:
   548|         0|            0|            0|  0.00%|                raise IncompleteRead(b'')
   549|         0|            0|            0|  0.00%|            if chunk_left == 0:
   550|         0|            0|            0|  0.00%|                # last chunk: 1*("0") [ chunk-extension ] CRLF
   551|         0|            0|            0|  0.00%|                self._read_and_discard_trailer()
   552|         0|            0|            0|  0.00%|                # we read everything; close the "file"
   553|         0|            0|            0|  0.00%|                self._close_conn()
   554|         0|            0|            0|  0.00%|                chunk_left = None
   555|         0|            0|            0|  0.00%|            self.chunk_left = chunk_left
   556|         0|            0|            0|  0.00%|        return chunk_left
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|    def _readall_chunked(self):
   559|         0|            0|            0|  0.00%|        assert self.chunked != _UNKNOWN
   560|         0|            0|            0|  0.00%|        value = []
   561|         0|            0|            0|  0.00%|        try:
   562|         0|            0|            0|  0.00%|            while True:
   563|         0|            0|            0|  0.00%|                chunk_left = self._get_chunk_left()
   564|         0|            0|            0|  0.00%|                if chunk_left is None:
   565|         0|            0|            0|  0.00%|                    break
   566|         0|            0|            0|  0.00%|                value.append(self._safe_read(chunk_left))
   567|         0|            0|            0|  0.00%|                self.chunk_left = 0
   568|         0|            0|            0|  0.00%|            return b''.join(value)
   569|         0|            0|            0|  0.00%|        except IncompleteRead:
   570|         0|            0|            0|  0.00%|            raise IncompleteRead(b''.join(value))
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|    def _readinto_chunked(self, b):
   573|         0|            0|            0|  0.00%|        assert self.chunked != _UNKNOWN
   574|         0|            0|            0|  0.00%|        total_bytes = 0
   575|         0|            0|            0|  0.00%|        mvb = memoryview(b)
   576|         0|            0|            0|  0.00%|        try:
   577|         0|            0|            0|  0.00%|            while True:
   578|         0|            0|            0|  0.00%|                chunk_left = self._get_chunk_left()
   579|         0|            0|            0|  0.00%|                if chunk_left is None:
   580|         0|            0|            0|  0.00%|                    return total_bytes
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|                if len(mvb) <= chunk_left:
   583|         0|            0|            0|  0.00%|                    n = self._safe_readinto(mvb)
   584|         0|            0|            0|  0.00%|                    self.chunk_left = chunk_left - n
   585|         0|            0|            0|  0.00%|                    return total_bytes + n
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|                temp_mvb = mvb[:chunk_left]
   588|         0|            0|            0|  0.00%|                n = self._safe_readinto(temp_mvb)
   589|         0|            0|            0|  0.00%|                mvb = mvb[n:]
   590|         0|            0|            0|  0.00%|                total_bytes += n
   591|         0|            0|            0|  0.00%|                self.chunk_left = 0
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|        except IncompleteRead:
   594|         0|            0|            0|  0.00%|            raise IncompleteRead(bytes(b[0:total_bytes]))
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|    def _safe_read(self, amt):
   597|         0|            0|            0|  0.00%|        """Read the number of bytes requested, compensating for partial reads.
   598|         0|            0|            0|  0.00%|
   599|         0|            0|            0|  0.00%|        Normally, we have a blocking socket, but a read() can be interrupted
   600|         0|            0|            0|  0.00%|        by a signal (resulting in a partial read).
   601|         0|            0|            0|  0.00%|
   602|         0|            0|            0|  0.00%|        Note that we cannot distinguish between EOF and an interrupt when zero
   603|         0|            0|            0|  0.00%|        bytes have been read. IncompleteRead() will be raised in this
   604|         0|            0|            0|  0.00%|        situation.
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|        This function should be used when <amt> bytes "should" be present for
   607|         0|            0|            0|  0.00%|        reading. If the bytes are truly not available (due to EOF), then the
   608|         0|            0|            0|  0.00%|        IncompleteRead exception can be used to detect the problem.
   609|         0|            0|            0|  0.00%|        """
   610|         0|            0|            0|  0.00%|        s = []
   611|         0|            0|            0|  0.00%|        while amt > 0:
   612|         0|            0|            0|  0.00%|            chunk = self.fp.read(min(amt, MAXAMOUNT))
   613|         0|            0|            0|  0.00%|            if not chunk:
   614|         0|            0|            0|  0.00%|                raise IncompleteRead(b''.join(s), amt)
   615|         0|            0|            0|  0.00%|            s.append(chunk)
   616|         0|            0|            0|  0.00%|            amt -= len(chunk)
   617|         0|            0|            0|  0.00%|        return b"".join(s)
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|    def _safe_readinto(self, b):
   620|         0|            0|            0|  0.00%|        """Same as _safe_read, but for reading into a buffer."""
   621|         0|            0|            0|  0.00%|        total_bytes = 0
   622|         0|            0|            0|  0.00%|        mvb = memoryview(b)
   623|         0|            0|            0|  0.00%|        while total_bytes < len(b):
   624|         0|            0|            0|  0.00%|            if MAXAMOUNT < len(mvb):
   625|         0|            0|            0|  0.00%|                temp_mvb = mvb[0:MAXAMOUNT]
   626|         0|            0|            0|  0.00%|                n = self.fp.readinto(temp_mvb)
   627|         0|            0|            0|  0.00%|            else:
   628|         0|            0|            0|  0.00%|                n = self.fp.readinto(mvb)
   629|         0|            0|            0|  0.00%|            if not n:
   630|         0|            0|            0|  0.00%|                raise IncompleteRead(bytes(mvb[0:total_bytes]), len(b))
   631|         0|            0|            0|  0.00%|            mvb = mvb[n:]
   632|         0|            0|            0|  0.00%|            total_bytes += n
   633|         0|            0|            0|  0.00%|        return total_bytes
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|    def read1(self, n=-1):
   636|         0|            0|            0|  0.00%|        """Read with at most one underlying system call.  If at least one
   637|         0|            0|            0|  0.00%|        byte is buffered, return that instead.
   638|         0|            0|            0|  0.00%|        """
   639|         0|            0|            0|  0.00%|        if self.fp is None or self._method == "HEAD":
   640|         0|            0|            0|  0.00%|            return b""
   641|         0|            0|            0|  0.00%|        if self.chunked:
   642|         0|            0|            0|  0.00%|            return self._read1_chunked(n)
   643|         0|            0|            0|  0.00%|        if self.length is not None and (n < 0 or n > self.length):
   644|         0|            0|            0|  0.00%|            n = self.length
   645|         0|            0|            0|  0.00%|        try:
   646|         0|            0|            0|  0.00%|            result = self.fp.read1(n)
   647|         0|            0|            0|  0.00%|        except ValueError:
   648|         0|            0|            0|  0.00%|            if n >= 0:
   649|         0|            0|            0|  0.00%|                raise
   650|         0|            0|            0|  0.00%|            # some implementations, like BufferedReader, don't support -1
   651|         0|            0|            0|  0.00%|            # Read an arbitrarily selected largeish chunk.
   652|         0|            0|            0|  0.00%|            result = self.fp.read1(16*1024)
   653|         0|            0|            0|  0.00%|        if not result and n:
   654|         0|            0|            0|  0.00%|            self._close_conn()
   655|         0|            0|            0|  0.00%|        elif self.length is not None:
   656|         0|            0|            0|  0.00%|            self.length -= len(result)
   657|         0|            0|            0|  0.00%|        return result
   658|         0|            0|            0|  0.00%|
   659|         0|            0|            0|  0.00%|    def peek(self, n=-1):
   660|         0|            0|            0|  0.00%|        # Having this enables IOBase.readline() to read more than one
   661|         0|            0|            0|  0.00%|        # byte at a time
   662|         0|            0|            0|  0.00%|        if self.fp is None or self._method == "HEAD":
   663|         0|            0|            0|  0.00%|            return b""
   664|         0|            0|            0|  0.00%|        if self.chunked:
   665|         0|            0|            0|  0.00%|            return self._peek_chunked(n)
   666|         0|            0|            0|  0.00%|        return self.fp.peek(n)
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|    def readline(self, limit=-1):
   669|         0|            0|            0|  0.00%|        if self.fp is None or self._method == "HEAD":
   670|         0|            0|            0|  0.00%|            return b""
   671|         0|            0|            0|  0.00%|        if self.chunked:
   672|         0|            0|            0|  0.00%|            # Fallback to IOBase readline which uses peek() and read()
   673|         0|            0|            0|  0.00%|            return super().readline(limit)
   674|         0|            0|            0|  0.00%|        if self.length is not None and (limit < 0 or limit > self.length):
   675|         0|            0|            0|  0.00%|            limit = self.length
   676|         0|            0|            0|  0.00%|        result = self.fp.readline(limit)
   677|         0|            0|            0|  0.00%|        if not result and limit:
   678|         0|            0|            0|  0.00%|            self._close_conn()
   679|         0|            0|            0|  0.00%|        elif self.length is not None:
   680|         0|            0|            0|  0.00%|            self.length -= len(result)
   681|         0|            0|            0|  0.00%|        return result
   682|         0|            0|            0|  0.00%|
   683|         0|            0|            0|  0.00%|    def _read1_chunked(self, n):
   684|         0|            0|            0|  0.00%|        # Strictly speaking, _get_chunk_left() may cause more than one read,
   685|         0|            0|            0|  0.00%|        # but that is ok, since that is to satisfy the chunked protocol.
   686|         0|            0|            0|  0.00%|        chunk_left = self._get_chunk_left()
   687|         0|            0|            0|  0.00%|        if chunk_left is None or n == 0:
   688|         0|            0|            0|  0.00%|            return b''
   689|         0|            0|            0|  0.00%|        if not (0 <= n <= chunk_left):
   690|         0|            0|            0|  0.00%|            n = chunk_left # if n is negative or larger than chunk_left
   691|         0|            0|            0|  0.00%|        read = self.fp.read1(n)
   692|         0|            0|            0|  0.00%|        self.chunk_left -= len(read)
   693|         0|            0|            0|  0.00%|        if not read:
   694|         0|            0|            0|  0.00%|            raise IncompleteRead(b"")
   695|         0|            0|            0|  0.00%|        return read
   696|         0|            0|            0|  0.00%|
   697|         0|            0|            0|  0.00%|    def _peek_chunked(self, n):
   698|         0|            0|            0|  0.00%|        # Strictly speaking, _get_chunk_left() may cause more than one read,
   699|         0|            0|            0|  0.00%|        # but that is ok, since that is to satisfy the chunked protocol.
   700|         0|            0|            0|  0.00%|        try:
   701|         0|            0|            0|  0.00%|            chunk_left = self._get_chunk_left()
   702|         0|            0|            0|  0.00%|        except IncompleteRead:
   703|         0|            0|            0|  0.00%|            return b'' # peek doesn't worry about protocol
   704|         0|            0|            0|  0.00%|        if chunk_left is None:
   705|         0|            0|            0|  0.00%|            return b'' # eof
   706|         0|            0|            0|  0.00%|        # peek is allowed to return more than requested.  Just request the
   707|         0|            0|            0|  0.00%|        # entire chunk, and truncate what we get.
   708|         0|            0|            0|  0.00%|        return self.fp.peek(chunk_left)[:chunk_left]
   709|         0|            0|            0|  0.00%|
   710|         0|            0|            0|  0.00%|    def fileno(self):
   711|         0|            0|            0|  0.00%|        return self.fp.fileno()
   712|         0|            0|            0|  0.00%|
   713|         0|            0|            0|  0.00%|    def getheader(self, name, default=None):
   714|         0|            0|            0|  0.00%|        '''Returns the value of the header matching *name*.
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|        If there are multiple matching headers, the values are
   717|         0|            0|            0|  0.00%|        combined into a single string separated by commas and spaces.
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|        If no matching header is found, returns *default* or None if
   720|         0|            0|            0|  0.00%|        the *default* is not specified.
   721|         0|            0|            0|  0.00%|
   722|         0|            0|            0|  0.00%|        If the headers are unknown, raises http.client.ResponseNotReady.
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|        '''
   725|         0|            0|            0|  0.00%|        if self.headers is None:
   726|         0|            0|            0|  0.00%|            raise ResponseNotReady()
   727|         0|            0|            0|  0.00%|        headers = self.headers.get_all(name) or default
   728|         0|            0|            0|  0.00%|        if isinstance(headers, str) or not hasattr(headers, '__iter__'):
   729|         0|            0|            0|  0.00%|            return headers
   730|         0|            0|            0|  0.00%|        else:
   731|         0|            0|            0|  0.00%|            return ', '.join(headers)
   732|         0|            0|            0|  0.00%|
   733|         0|            0|            0|  0.00%|    def getheaders(self):
   734|         0|            0|            0|  0.00%|        """Return list of (header, value) tuples."""
   735|         0|            0|            0|  0.00%|        if self.headers is None:
   736|         0|            0|            0|  0.00%|            raise ResponseNotReady()
   737|         0|            0|            0|  0.00%|        return list(self.headers.items())
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|    # We override IOBase.__iter__ so that it doesn't check for closed-ness
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|    def __iter__(self):
   742|         0|            0|            0|  0.00%|        return self
   743|         0|            0|            0|  0.00%|
   744|         0|            0|            0|  0.00%|    # For compatibility with old-style urllib responses.
   745|         0|            0|            0|  0.00%|
   746|         0|            0|            0|  0.00%|    def info(self):
   747|         0|            0|            0|  0.00%|        '''Returns an instance of the class mimetools.Message containing
   748|         0|            0|            0|  0.00%|        meta-information associated with the URL.
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|        When the method is HTTP, these headers are those returned by
   751|         0|            0|            0|  0.00%|        the server at the head of the retrieved HTML page (including
   752|         0|            0|            0|  0.00%|        Content-Length and Content-Type).
   753|         0|            0|            0|  0.00%|
   754|         0|            0|            0|  0.00%|        When the method is FTP, a Content-Length header will be
   755|         0|            0|            0|  0.00%|        present if (as is now usual) the server passed back a file
   756|         0|            0|            0|  0.00%|        length in response to the FTP retrieval request. A
   757|         0|            0|            0|  0.00%|        Content-Type header will be present if the MIME type can be
   758|         0|            0|            0|  0.00%|        guessed.
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|        When the method is local-file, returned headers will include
   761|         0|            0|            0|  0.00%|        a Date representing the file's last-modified time, a
   762|         0|            0|            0|  0.00%|        Content-Length giving file size, and a Content-Type
   763|         0|            0|            0|  0.00%|        containing a guess at the file's type. See also the
   764|         0|            0|            0|  0.00%|        description of the mimetools module.
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|        '''
   767|         0|            0|            0|  0.00%|        return self.headers
   768|         0|            0|            0|  0.00%|
   769|         0|            0|            0|  0.00%|    def geturl(self):
   770|         0|            0|            0|  0.00%|        '''Return the real URL of the page.
   771|         0|            0|            0|  0.00%|
   772|         0|            0|            0|  0.00%|        In some cases, the HTTP server redirects a client to another
   773|         0|            0|            0|  0.00%|        URL. The urlopen() function handles this transparently, but in
   774|         0|            0|            0|  0.00%|        some cases the caller needs to know which URL the client was
   775|         0|            0|            0|  0.00%|        redirected to. The geturl() method can be used to get at this
   776|         0|            0|            0|  0.00%|        redirected URL.
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|        '''
   779|         0|            0|            0|  0.00%|        return self.url
   780|         0|            0|            0|  0.00%|
   781|         0|            0|            0|  0.00%|    def getcode(self):
   782|         0|            0|            0|  0.00%|        '''Return the HTTP status code that was sent with the response,
   783|         0|            0|            0|  0.00%|        or None if the URL is not an HTTP URL.
   784|         0|            0|            0|  0.00%|
   785|         0|            0|            0|  0.00%|        '''
   786|         0|            0|            0|  0.00%|        return self.status
   787|         0|            0|            0|  0.00%|
   788|         0|            0|            0|  0.00%|class HTTPConnection:
   789|         0|            0|            0|  0.00%|
   790|         0|            0|            0|  0.00%|    _http_vsn = 11
   791|         0|            0|            0|  0.00%|    _http_vsn_str = 'HTTP/1.1'
   792|         0|            0|            0|  0.00%|
   793|         0|            0|            0|  0.00%|    response_class = HTTPResponse
   794|         0|            0|            0|  0.00%|    default_port = HTTP_PORT
   795|         0|            0|            0|  0.00%|    auto_open = 1
   796|         0|            0|            0|  0.00%|    debuglevel = 0
   797|         0|            0|            0|  0.00%|
   798|         0|            0|            0|  0.00%|    @staticmethod
   799|         0|            0|            0|  0.00%|    def _is_textIO(stream):
   800|         0|            0|            0|  0.00%|        """Test whether a file-like object is a text or a binary stream.
   801|         0|            0|            0|  0.00%|        """
   802|         0|            0|            0|  0.00%|        return isinstance(stream, io.TextIOBase)
   803|         0|            0|            0|  0.00%|
   804|         0|            0|            0|  0.00%|    @staticmethod
   805|         0|            0|            0|  0.00%|    def _get_content_length(body, method):
   806|         0|            0|            0|  0.00%|        """Get the content-length based on the body.
   807|         0|            0|            0|  0.00%|
   808|         0|            0|            0|  0.00%|        If the body is None, we set Content-Length: 0 for methods that expect
   809|         0|            0|            0|  0.00%|        a body (RFC 7230, Section 3.3.2). We also set the Content-Length for
   810|         0|            0|            0|  0.00%|        any method if the body is a str or bytes-like object and not a file.
   811|         0|            0|            0|  0.00%|        """
   812|         0|            0|            0|  0.00%|        if body is None:
   813|         0|            0|            0|  0.00%|            # do an explicit check for not None here to distinguish
   814|         0|            0|            0|  0.00%|            # between unset and set but empty
   815|         0|            0|            0|  0.00%|            if method.upper() in _METHODS_EXPECTING_BODY:
   816|         0|            0|            0|  0.00%|                return 0
   817|         0|            0|            0|  0.00%|            else:
   818|         0|            0|            0|  0.00%|                return None
   819|         0|            0|            0|  0.00%|
   820|         0|            0|            0|  0.00%|        if hasattr(body, 'read'):
   821|         0|            0|            0|  0.00%|            # file-like object.
   822|         0|            0|            0|  0.00%|            return None
   823|         0|            0|            0|  0.00%|
   824|         0|            0|            0|  0.00%|        try:
   825|         0|            0|            0|  0.00%|            # does it implement the buffer protocol (bytes, bytearray, array)?
   826|         0|            0|            0|  0.00%|            mv = memoryview(body)
   827|         0|            0|            0|  0.00%|            return mv.nbytes
   828|         0|            0|            0|  0.00%|        except TypeError:
   829|         0|            0|            0|  0.00%|            pass
   830|         0|            0|            0|  0.00%|
   831|         0|            0|            0|  0.00%|        if isinstance(body, str):
   832|         0|            0|            0|  0.00%|            return len(body)
   833|         0|            0|            0|  0.00%|
   834|         0|            0|            0|  0.00%|        return None
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|    def __init__(self, host, port=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
   837|         0|            0|            0|  0.00%|                 source_address=None):
   838|         0|            0|            0|  0.00%|        self.timeout = timeout
   839|         0|            0|            0|  0.00%|        self.source_address = source_address
   840|         0|            0|            0|  0.00%|        self.sock = None
   841|         0|            0|            0|  0.00%|        self._buffer = []
   842|         0|            0|            0|  0.00%|        self.__response = None
   843|         0|            0|            0|  0.00%|        self.__state = _CS_IDLE
   844|         0|            0|            0|  0.00%|        self._method = None
   845|         0|            0|            0|  0.00%|        self._tunnel_host = None
   846|         0|            0|            0|  0.00%|        self._tunnel_port = None
   847|         0|            0|            0|  0.00%|        self._tunnel_headers = {}
   848|         0|            0|            0|  0.00%|
   849|         0|            0|            0|  0.00%|        (self.host, self.port) = self._get_hostport(host, port)
   850|         0|            0|            0|  0.00%|
   851|         0|            0|            0|  0.00%|        # This is stored as an instance variable to allow unit
   852|         0|            0|            0|  0.00%|        # tests to replace it with a suitable mockup
   853|         0|            0|            0|  0.00%|        self._create_connection = socket.create_connection
   854|         0|            0|            0|  0.00%|
   855|         0|            0|            0|  0.00%|    def set_tunnel(self, host, port=None, headers=None):
   856|         0|            0|            0|  0.00%|        """Set up host and port for HTTP CONNECT tunnelling.
   857|         0|            0|            0|  0.00%|
   858|         0|            0|            0|  0.00%|        In a connection that uses HTTP CONNECT tunneling, the host passed to the
   859|         0|            0|            0|  0.00%|        constructor is used as a proxy server that relays all communication to
   860|         0|            0|            0|  0.00%|        the endpoint passed to `set_tunnel`. This done by sending an HTTP
   861|         0|            0|            0|  0.00%|        CONNECT request to the proxy server when the connection is established.
   862|         0|            0|            0|  0.00%|
   863|         0|            0|            0|  0.00%|        This method must be called before the HTML connection has been
   864|         0|            0|            0|  0.00%|        established.
   865|         0|            0|            0|  0.00%|
   866|         0|            0|            0|  0.00%|        The headers argument should be a mapping of extra HTTP headers to send
   867|         0|            0|            0|  0.00%|        with the CONNECT request.
   868|         0|            0|            0|  0.00%|        """
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|        if self.sock:
   871|         0|            0|            0|  0.00%|            raise RuntimeError("Can't set up tunnel for established connection")
   872|         0|            0|            0|  0.00%|
   873|         0|            0|            0|  0.00%|        self._tunnel_host, self._tunnel_port = self._get_hostport(host, port)
   874|         0|            0|            0|  0.00%|        if headers:
   875|         0|            0|            0|  0.00%|            self._tunnel_headers = headers
   876|         0|            0|            0|  0.00%|        else:
   877|         0|            0|            0|  0.00%|            self._tunnel_headers.clear()
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|    def _get_hostport(self, host, port):
   880|         0|            0|            0|  0.00%|        if port is None:
   881|         0|            0|            0|  0.00%|            i = host.rfind(':')
   882|         0|            0|            0|  0.00%|            j = host.rfind(']')         # ipv6 addresses have [...]
   883|         0|            0|            0|  0.00%|            if i > j:
   884|         0|            0|            0|  0.00%|                try:
   885|         0|            0|            0|  0.00%|                    port = int(host[i+1:])
   886|         0|            0|            0|  0.00%|                except ValueError:
   887|         0|            0|            0|  0.00%|                    if host[i+1:] == "": # http://foo.com:/ == http://foo.com/
   888|         0|            0|            0|  0.00%|                        port = self.default_port
   889|         0|            0|            0|  0.00%|                    else:
   890|         0|            0|            0|  0.00%|                        raise InvalidURL("nonnumeric port: '%s'" % host[i+1:])
   891|         0|            0|            0|  0.00%|                host = host[:i]
   892|         0|            0|            0|  0.00%|            else:
   893|         0|            0|            0|  0.00%|                port = self.default_port
   894|         0|            0|            0|  0.00%|            if host and host[0] == '[' and host[-1] == ']':
   895|         0|            0|            0|  0.00%|                host = host[1:-1]
   896|         0|            0|            0|  0.00%|
   897|         0|            0|            0|  0.00%|        return (host, port)
   898|         0|            0|            0|  0.00%|
   899|         0|            0|            0|  0.00%|    def set_debuglevel(self, level):
   900|         0|            0|            0|  0.00%|        self.debuglevel = level
   901|         0|            0|            0|  0.00%|
   902|         0|            0|            0|  0.00%|    def _tunnel(self):
   903|         0|            0|            0|  0.00%|        connect_str = "CONNECT %s:%d HTTP/1.0\r\n" % (self._tunnel_host,
   904|         0|            0|            0|  0.00%|            self._tunnel_port)
   905|         0|            0|            0|  0.00%|        connect_bytes = connect_str.encode("ascii")
   906|         0|            0|            0|  0.00%|        self.send(connect_bytes)
   907|         0|            0|            0|  0.00%|        for header, value in self._tunnel_headers.items():
   908|         0|            0|            0|  0.00%|            header_str = "%s: %s\r\n" % (header, value)
   909|         0|            0|            0|  0.00%|            header_bytes = header_str.encode("latin-1")
   910|         0|            0|            0|  0.00%|            self.send(header_bytes)
   911|         0|            0|            0|  0.00%|        self.send(b'\r\n')
   912|         0|            0|            0|  0.00%|
   913|         0|            0|            0|  0.00%|        response = self.response_class(self.sock, method=self._method)
   914|         0|            0|            0|  0.00%|        (version, code, message) = response._read_status()
   915|         0|            0|            0|  0.00%|
   916|         0|            0|            0|  0.00%|        if code != http.HTTPStatus.OK:
   917|         0|            0|            0|  0.00%|            self.close()
   918|         0|            0|            0|  0.00%|            raise OSError("Tunnel connection failed: %d %s" % (code,
   919|         0|            0|            0|  0.00%|                                                               message.strip()))
   920|         0|            0|            0|  0.00%|        while True:
   921|         0|            0|            0|  0.00%|            line = response.fp.readline(_MAXLINE + 1)
   922|         0|            0|            0|  0.00%|            if len(line) > _MAXLINE:
   923|         0|            0|            0|  0.00%|                raise LineTooLong("header line")
   924|         0|            0|            0|  0.00%|            if not line:
   925|         0|            0|            0|  0.00%|                # for sites which EOF without sending a trailer
   926|         0|            0|            0|  0.00%|                break
   927|         0|            0|            0|  0.00%|            if line in (b'\r\n', b'\n', b''):
   928|         0|            0|            0|  0.00%|                break
   929|         0|            0|            0|  0.00%|
   930|         0|            0|            0|  0.00%|            if self.debuglevel > 0:
   931|         0|            0|            0|  0.00%|                print('header:', line.decode())
   932|         0|            0|            0|  0.00%|
   933|         0|            0|            0|  0.00%|    def connect(self):
   934|         0|            0|            0|  0.00%|        """Connect to the host and port specified in __init__."""
   935|         0|            0|            0|  0.00%|        self.sock = self._create_connection(
   936|         0|            0|            0|  0.00%|            (self.host,self.port), self.timeout, self.source_address)
   937|         0|            0|            0|  0.00%|        self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
   938|         0|            0|            0|  0.00%|
   939|         0|            0|            0|  0.00%|        if self._tunnel_host:
   940|         0|            0|            0|  0.00%|            self._tunnel()
   941|         0|            0|            0|  0.00%|
   942|         0|            0|            0|  0.00%|    def close(self):
   943|         0|            0|            0|  0.00%|        """Close the connection to the HTTP server."""
   944|         0|            0|            0|  0.00%|        self.__state = _CS_IDLE
   945|         0|            0|            0|  0.00%|        try:
   946|         0|            0|            0|  0.00%|            sock = self.sock
   947|         0|            0|            0|  0.00%|            if sock:
   948|         0|            0|            0|  0.00%|                self.sock = None
   949|         0|            0|            0|  0.00%|                sock.close()   # close it manually... there may be other refs
   950|         0|            0|            0|  0.00%|        finally:
   951|         0|            0|            0|  0.00%|            response = self.__response
   952|         0|            0|            0|  0.00%|            if response:
   953|         0|            0|            0|  0.00%|                self.__response = None
   954|         0|            0|            0|  0.00%|                response.close()
   955|         0|            0|            0|  0.00%|
   956|         0|            0|            0|  0.00%|    def send(self, data):
   957|         0|            0|            0|  0.00%|        """Send `data' to the server.
   958|         0|            0|            0|  0.00%|        ``data`` can be a string object, a bytes object, an array object, a
   959|         0|            0|            0|  0.00%|        file-like object that supports a .read() method, or an iterable object.
   960|         0|            0|            0|  0.00%|        """
   961|         0|            0|            0|  0.00%|
   962|         0|            0|            0|  0.00%|        if self.sock is None:
   963|         0|            0|            0|  0.00%|            if self.auto_open:
   964|         0|            0|            0|  0.00%|                self.connect()
   965|         0|            0|            0|  0.00%|            else:
   966|         0|            0|            0|  0.00%|                raise NotConnected()
   967|         0|            0|            0|  0.00%|
   968|         0|            0|            0|  0.00%|        if self.debuglevel > 0:
   969|         0|            0|            0|  0.00%|            print("send:", repr(data))
   970|         0|            0|            0|  0.00%|        blocksize = 8192
   971|         0|            0|            0|  0.00%|        if hasattr(data, "read") :
   972|         0|            0|            0|  0.00%|            if self.debuglevel > 0:
   973|         0|            0|            0|  0.00%|                print("sendIng a read()able")
   974|         0|            0|            0|  0.00%|            encode = self._is_textIO(data)
   975|         0|            0|            0|  0.00%|            if encode and self.debuglevel > 0:
   976|         0|            0|            0|  0.00%|                print("encoding file using iso-8859-1")
   977|         0|            0|            0|  0.00%|            while 1:
   978|         0|            0|            0|  0.00%|                datablock = data.read(blocksize)
   979|         0|            0|            0|  0.00%|                if not datablock:
   980|         0|            0|            0|  0.00%|                    break
   981|         0|            0|            0|  0.00%|                if encode:
   982|         0|            0|            0|  0.00%|                    datablock = datablock.encode("iso-8859-1")
   983|         0|            0|            0|  0.00%|                self.sock.sendall(datablock)
   984|         0|            0|            0|  0.00%|            return
   985|         0|            0|            0|  0.00%|        try:
   986|         0|            0|            0|  0.00%|            self.sock.sendall(data)
   987|         0|            0|            0|  0.00%|        except TypeError:
   988|         0|            0|            0|  0.00%|            if isinstance(data, collections.Iterable):
   989|         0|            0|            0|  0.00%|                for d in data:
   990|         0|            0|            0|  0.00%|                    self.sock.sendall(d)
   991|         0|            0|            0|  0.00%|            else:
   992|         0|            0|            0|  0.00%|                raise TypeError("data should be a bytes-like object "
   993|         0|            0|            0|  0.00%|                                "or an iterable, got %r" % type(data))
   994|         0|            0|            0|  0.00%|
   995|         0|            0|            0|  0.00%|    def _output(self, s):
   996|         0|            0|            0|  0.00%|        """Add a line of output to the current request buffer.
   997|         0|            0|            0|  0.00%|
   998|         0|            0|            0|  0.00%|        Assumes that the line does *not* end with \\r\\n.
   999|         0|            0|            0|  0.00%|        """
  1000|         0|            0|            0|  0.00%|        self._buffer.append(s)
  1001|         0|            0|            0|  0.00%|
  1002|         0|            0|            0|  0.00%|    def _read_readable(self, readable):
  1003|         0|            0|            0|  0.00%|        blocksize = 8192
  1004|         0|            0|            0|  0.00%|        if self.debuglevel > 0:
  1005|         0|            0|            0|  0.00%|            print("sendIng a read()able")
  1006|         0|            0|            0|  0.00%|        encode = self._is_textIO(readable)
  1007|         0|            0|            0|  0.00%|        if encode and self.debuglevel > 0:
  1008|         0|            0|            0|  0.00%|            print("encoding file using iso-8859-1")
  1009|         0|            0|            0|  0.00%|        while True:
  1010|         0|            0|            0|  0.00%|            datablock = readable.read(blocksize)
  1011|         0|            0|            0|  0.00%|            if not datablock:
  1012|         0|            0|            0|  0.00%|                break
  1013|         0|            0|            0|  0.00%|            if encode:
  1014|         0|            0|            0|  0.00%|                datablock = datablock.encode("iso-8859-1")
  1015|         0|            0|            0|  0.00%|            yield datablock
  1016|         0|            0|            0|  0.00%|
  1017|         0|            0|            0|  0.00%|    def _send_output(self, message_body=None, encode_chunked=False):
  1018|         0|            0|            0|  0.00%|        """Send the currently buffered request and clear the buffer.
  1019|         0|            0|            0|  0.00%|
  1020|         0|            0|            0|  0.00%|        Appends an extra \\r\\n to the buffer.
  1021|         0|            0|            0|  0.00%|        A message_body may be specified, to be appended to the request.
  1022|         0|            0|            0|  0.00%|        """
  1023|         0|            0|            0|  0.00%|        self._buffer.extend((b"", b""))
  1024|         0|            0|            0|  0.00%|        msg = b"\r\n".join(self._buffer)
  1025|         0|            0|            0|  0.00%|        del self._buffer[:]
  1026|         0|            0|            0|  0.00%|        self.send(msg)
  1027|         0|            0|            0|  0.00%|
  1028|         0|            0|            0|  0.00%|        if message_body is not None:
  1029|         0|            0|            0|  0.00%|
  1030|         0|            0|            0|  0.00%|            # create a consistent interface to message_body
  1031|         0|            0|            0|  0.00%|            if hasattr(message_body, 'read'):
  1032|         0|            0|            0|  0.00%|                # Let file-like take precedence over byte-like.  This
  1033|         0|            0|            0|  0.00%|                # is needed to allow the current position of mmap'ed
  1034|         0|            0|            0|  0.00%|                # files to be taken into account.
  1035|         0|            0|            0|  0.00%|                chunks = self._read_readable(message_body)
  1036|         0|            0|            0|  0.00%|            else:
  1037|         0|            0|            0|  0.00%|                try:
  1038|         0|            0|            0|  0.00%|                    # this is solely to check to see if message_body
  1039|         0|            0|            0|  0.00%|                    # implements the buffer API.  it /would/ be easier
  1040|         0|            0|            0|  0.00%|                    # to capture if PyObject_CheckBuffer was exposed
  1041|         0|            0|            0|  0.00%|                    # to Python.
  1042|         0|            0|            0|  0.00%|                    memoryview(message_body)
  1043|         0|            0|            0|  0.00%|                except TypeError:
  1044|         0|            0|            0|  0.00%|                    try:
  1045|         0|            0|            0|  0.00%|                        chunks = iter(message_body)
  1046|         0|            0|            0|  0.00%|                    except TypeError:
  1047|         0|            0|            0|  0.00%|                        raise TypeError("message_body should be a bytes-like "
  1048|         0|            0|            0|  0.00%|                                        "object or an iterable, got %r"
  1049|         0|            0|            0|  0.00%|                                        % type(message_body))
  1050|         0|            0|            0|  0.00%|                else:
  1051|         0|            0|            0|  0.00%|                    # the object implements the buffer interface and
  1052|         0|            0|            0|  0.00%|                    # can be passed directly into socket methods
  1053|         0|            0|            0|  0.00%|                    chunks = (message_body,)
  1054|         0|            0|            0|  0.00%|
  1055|         0|            0|            0|  0.00%|            for chunk in chunks:
  1056|         0|            0|            0|  0.00%|                if not chunk:
  1057|         0|            0|            0|  0.00%|                    if self.debuglevel > 0:
  1058|         0|            0|            0|  0.00%|                        print('Zero length chunk ignored')
  1059|         0|            0|            0|  0.00%|                    continue
  1060|         0|            0|            0|  0.00%|
  1061|         0|            0|            0|  0.00%|                if encode_chunked and self._http_vsn == 11:
  1062|         0|            0|            0|  0.00%|                    # chunked encoding
  1063|         0|            0|            0|  0.00%|                    chunk = f'{len(chunk):X}\r\n'.encode('ascii') + chunk \
  1064|         0|            0|            0|  0.00%|                        + b'\r\n'
  1065|         0|            0|            0|  0.00%|                self.send(chunk)
  1066|         0|            0|            0|  0.00%|
  1067|         0|            0|            0|  0.00%|            if encode_chunked and self._http_vsn == 11:
  1068|         0|            0|            0|  0.00%|                # end chunked transfer
  1069|         0|            0|            0|  0.00%|                self.send(b'0\r\n\r\n')
  1070|         0|            0|            0|  0.00%|
  1071|         0|            0|            0|  0.00%|    def putrequest(self, method, url, skip_host=False,
  1072|         0|            0|            0|  0.00%|                   skip_accept_encoding=False):
  1073|         0|            0|            0|  0.00%|        """Send a request to the server.
  1074|         0|            0|            0|  0.00%|
  1075|         0|            0|            0|  0.00%|        `method' specifies an HTTP request method, e.g. 'GET'.
  1076|         0|            0|            0|  0.00%|        `url' specifies the object being requested, e.g. '/index.html'.
  1077|         0|            0|            0|  0.00%|        `skip_host' if True does not add automatically a 'Host:' header
  1078|         0|            0|            0|  0.00%|        `skip_accept_encoding' if True does not add automatically an
  1079|         0|            0|            0|  0.00%|           'Accept-Encoding:' header
  1080|         0|            0|            0|  0.00%|        """
  1081|         0|            0|            0|  0.00%|
  1082|         0|            0|            0|  0.00%|        # if a prior response has been completed, then forget about it.
  1083|         0|            0|            0|  0.00%|        if self.__response and self.__response.isclosed():
  1084|         0|            0|            0|  0.00%|            self.__response = None
  1085|         0|            0|            0|  0.00%|
  1086|         0|            0|            0|  0.00%|
  1087|         0|            0|            0|  0.00%|        # in certain cases, we cannot issue another request on this connection.
  1088|         0|            0|            0|  0.00%|        # this occurs when:
  1089|         0|            0|            0|  0.00%|        #   1) we are in the process of sending a request.   (_CS_REQ_STARTED)
  1090|         0|            0|            0|  0.00%|        #   2) a response to a previous request has signalled that it is going
  1091|         0|            0|            0|  0.00%|        #      to close the connection upon completion.
  1092|         0|            0|            0|  0.00%|        #   3) the headers for the previous response have not been read, thus
  1093|         0|            0|            0|  0.00%|        #      we cannot determine whether point (2) is true.   (_CS_REQ_SENT)
  1094|         0|            0|            0|  0.00%|        #
  1095|         0|            0|            0|  0.00%|        # if there is no prior response, then we can request at will.
  1096|         0|            0|            0|  0.00%|        #
  1097|         0|            0|            0|  0.00%|        # if point (2) is true, then we will have passed the socket to the
  1098|         0|            0|            0|  0.00%|        # response (effectively meaning, "there is no prior response"), and
  1099|         0|            0|            0|  0.00%|        # will open a new one when a new request is made.
  1100|         0|            0|            0|  0.00%|        #
  1101|         0|            0|            0|  0.00%|        # Note: if a prior response exists, then we *can* start a new request.
  1102|         0|            0|            0|  0.00%|        #       We are not allowed to begin fetching the response to this new
  1103|         0|            0|            0|  0.00%|        #       request, however, until that prior response is complete.
  1104|         0|            0|            0|  0.00%|        #
  1105|         0|            0|            0|  0.00%|        if self.__state == _CS_IDLE:
  1106|         0|            0|            0|  0.00%|            self.__state = _CS_REQ_STARTED
  1107|         0|            0|            0|  0.00%|        else:
  1108|         0|            0|            0|  0.00%|            raise CannotSendRequest(self.__state)
  1109|         0|            0|            0|  0.00%|
  1110|         0|            0|            0|  0.00%|        # Save the method we use, we need it later in the response phase
  1111|         0|            0|            0|  0.00%|        self._method = method
  1112|         0|            0|            0|  0.00%|        if not url:
  1113|         0|            0|            0|  0.00%|            url = '/'
  1114|         0|            0|            0|  0.00%|        request = '%s %s %s' % (method, url, self._http_vsn_str)
  1115|         0|            0|            0|  0.00%|
  1116|         0|            0|            0|  0.00%|        # Non-ASCII characters should have been eliminated earlier
  1117|         0|            0|            0|  0.00%|        self._output(request.encode('ascii'))
  1118|         0|            0|            0|  0.00%|
  1119|         0|            0|            0|  0.00%|        if self._http_vsn == 11:
  1120|         0|            0|            0|  0.00%|            # Issue some standard headers for better HTTP/1.1 compliance
  1121|         0|            0|            0|  0.00%|
  1122|         0|            0|            0|  0.00%|            if not skip_host:
  1123|         0|            0|            0|  0.00%|                # this header is issued *only* for HTTP/1.1
  1124|         0|            0|            0|  0.00%|                # connections. more specifically, this means it is
  1125|         0|            0|            0|  0.00%|                # only issued when the client uses the new
  1126|         0|            0|            0|  0.00%|                # HTTPConnection() class. backwards-compat clients
  1127|         0|            0|            0|  0.00%|                # will be using HTTP/1.0 and those clients may be
  1128|         0|            0|            0|  0.00%|                # issuing this header themselves. we should NOT issue
  1129|         0|            0|            0|  0.00%|                # it twice; some web servers (such as Apache) barf
  1130|         0|            0|            0|  0.00%|                # when they see two Host: headers
  1131|         0|            0|            0|  0.00%|
  1132|         0|            0|            0|  0.00%|                # If we need a non-standard port,include it in the
  1133|         0|            0|            0|  0.00%|                # header.  If the request is going through a proxy,
  1134|         0|            0|            0|  0.00%|                # but the host of the actual URL, not the host of the
  1135|         0|            0|            0|  0.00%|                # proxy.
  1136|         0|            0|            0|  0.00%|
  1137|         0|            0|            0|  0.00%|                netloc = ''
  1138|         0|            0|            0|  0.00%|                if url.startswith('http'):
  1139|         0|            0|            0|  0.00%|                    nil, netloc, nil, nil, nil = urlsplit(url)
  1140|         0|            0|            0|  0.00%|
  1141|         0|            0|            0|  0.00%|                if netloc:
  1142|         0|            0|            0|  0.00%|                    try:
  1143|         0|            0|            0|  0.00%|                        netloc_enc = netloc.encode("ascii")
  1144|         0|            0|            0|  0.00%|                    except UnicodeEncodeError:
  1145|         0|            0|            0|  0.00%|                        netloc_enc = netloc.encode("idna")
  1146|         0|            0|            0|  0.00%|                    self.putheader('Host', netloc_enc)
  1147|         0|            0|            0|  0.00%|                else:
  1148|         0|            0|            0|  0.00%|                    if self._tunnel_host:
  1149|         0|            0|            0|  0.00%|                        host = self._tunnel_host
  1150|         0|            0|            0|  0.00%|                        port = self._tunnel_port
  1151|         0|            0|            0|  0.00%|                    else:
  1152|         0|            0|            0|  0.00%|                        host = self.host
  1153|         0|            0|            0|  0.00%|                        port = self.port
  1154|         0|            0|            0|  0.00%|
  1155|         0|            0|            0|  0.00%|                    try:
  1156|         0|            0|            0|  0.00%|                        host_enc = host.encode("ascii")
  1157|         0|            0|            0|  0.00%|                    except UnicodeEncodeError:
  1158|         0|            0|            0|  0.00%|                        host_enc = host.encode("idna")
  1159|         0|            0|            0|  0.00%|
  1160|         0|            0|            0|  0.00%|                    # As per RFC 273, IPv6 address should be wrapped with []
  1161|         0|            0|            0|  0.00%|                    # when used as Host header
  1162|         0|            0|            0|  0.00%|
  1163|         0|            0|            0|  0.00%|                    if host.find(':') >= 0:
  1164|         0|            0|            0|  0.00%|                        host_enc = b'[' + host_enc + b']'
  1165|         0|            0|            0|  0.00%|
  1166|         0|            0|            0|  0.00%|                    if port == self.default_port:
  1167|         0|            0|            0|  0.00%|                        self.putheader('Host', host_enc)
  1168|         0|            0|            0|  0.00%|                    else:
  1169|         0|            0|            0|  0.00%|                        host_enc = host_enc.decode("ascii")
  1170|         0|            0|            0|  0.00%|                        self.putheader('Host', "%s:%s" % (host_enc, port))
  1171|         0|            0|            0|  0.00%|
  1172|         0|            0|            0|  0.00%|            # note: we are assuming that clients will not attempt to set these
  1173|         0|            0|            0|  0.00%|            #       headers since *this* library must deal with the
  1174|         0|            0|            0|  0.00%|            #       consequences. this also means that when the supporting
  1175|         0|            0|            0|  0.00%|            #       libraries are updated to recognize other forms, then this
  1176|         0|            0|            0|  0.00%|            #       code should be changed (removed or updated).
  1177|         0|            0|            0|  0.00%|
  1178|         0|            0|            0|  0.00%|            # we only want a Content-Encoding of "identity" since we don't
  1179|         0|            0|            0|  0.00%|            # support encodings such as x-gzip or x-deflate.
  1180|         0|            0|            0|  0.00%|            if not skip_accept_encoding:
  1181|         0|            0|            0|  0.00%|                self.putheader('Accept-Encoding', 'identity')
  1182|         0|            0|            0|  0.00%|
  1183|         0|            0|            0|  0.00%|            # we can accept "chunked" Transfer-Encodings, but no others
  1184|         0|            0|            0|  0.00%|            # NOTE: no TE header implies *only* "chunked"
  1185|         0|            0|            0|  0.00%|            #self.putheader('TE', 'chunked')
  1186|         0|            0|            0|  0.00%|
  1187|         0|            0|            0|  0.00%|            # if TE is supplied in the header, then it must appear in a
  1188|         0|            0|            0|  0.00%|            # Connection header.
  1189|         0|            0|            0|  0.00%|            #self.putheader('Connection', 'TE')
  1190|         0|            0|            0|  0.00%|
  1191|         0|            0|            0|  0.00%|        else:
  1192|         0|            0|            0|  0.00%|            # For HTTP/1.0, the server will assume "not chunked"
  1193|         0|            0|            0|  0.00%|            pass
  1194|         0|            0|            0|  0.00%|
  1195|         0|            0|            0|  0.00%|    def putheader(self, header, *values):
  1196|         0|            0|            0|  0.00%|        """Send a request header line to the server.
  1197|         0|            0|            0|  0.00%|
  1198|         0|            0|            0|  0.00%|        For example: h.putheader('Accept', 'text/html')
  1199|         0|            0|            0|  0.00%|        """
  1200|         0|            0|            0|  0.00%|        if self.__state != _CS_REQ_STARTED:
  1201|         0|            0|            0|  0.00%|            raise CannotSendHeader()
  1202|         0|            0|            0|  0.00%|
  1203|         0|            0|            0|  0.00%|        if hasattr(header, 'encode'):
  1204|         0|            0|            0|  0.00%|            header = header.encode('ascii')
  1205|         0|            0|            0|  0.00%|
  1206|         0|            0|            0|  0.00%|        if not _is_legal_header_name(header):
  1207|         0|            0|            0|  0.00%|            raise ValueError('Invalid header name %r' % (header,))
  1208|         0|            0|            0|  0.00%|
  1209|         0|            0|            0|  0.00%|        values = list(values)
  1210|         0|            0|            0|  0.00%|        for i, one_value in enumerate(values):
  1211|         0|            0|            0|  0.00%|            if hasattr(one_value, 'encode'):
  1212|         0|            0|            0|  0.00%|                values[i] = one_value.encode('latin-1')
  1213|         0|            0|            0|  0.00%|            elif isinstance(one_value, int):
  1214|         0|            0|            0|  0.00%|                values[i] = str(one_value).encode('ascii')
  1215|         0|            0|            0|  0.00%|
  1216|         0|            0|            0|  0.00%|            if _is_illegal_header_value(values[i]):
  1217|         0|            0|            0|  0.00%|                raise ValueError('Invalid header value %r' % (values[i],))
  1218|         0|            0|            0|  0.00%|
  1219|         0|            0|            0|  0.00%|        value = b'\r\n\t'.join(values)
  1220|         0|            0|            0|  0.00%|        header = header + b': ' + value
  1221|         0|            0|            0|  0.00%|        self._output(header)
  1222|         0|            0|            0|  0.00%|
  1223|         0|            0|            0|  0.00%|    def endheaders(self, message_body=None, *, encode_chunked=False):
  1224|         0|            0|            0|  0.00%|        """Indicate that the last header line has been sent to the server.
  1225|         0|            0|            0|  0.00%|
  1226|         0|            0|            0|  0.00%|        This method sends the request to the server.  The optional message_body
  1227|         0|            0|            0|  0.00%|        argument can be used to pass a message body associated with the
  1228|         0|            0|            0|  0.00%|        request.
  1229|         0|            0|            0|  0.00%|        """
  1230|         0|            0|            0|  0.00%|        if self.__state == _CS_REQ_STARTED:
  1231|         0|            0|            0|  0.00%|            self.__state = _CS_REQ_SENT
  1232|         0|            0|            0|  0.00%|        else:
  1233|         0|            0|            0|  0.00%|            raise CannotSendHeader()
  1234|         0|            0|            0|  0.00%|        self._send_output(message_body, encode_chunked=encode_chunked)
  1235|         0|            0|            0|  0.00%|
  1236|         0|            0|            0|  0.00%|    def request(self, method, url, body=None, headers={}, *,
  1237|         0|            0|            0|  0.00%|                encode_chunked=False):
  1238|         0|            0|            0|  0.00%|        """Send a complete request to the server."""
  1239|         0|            0|            0|  0.00%|        self._send_request(method, url, body, headers, encode_chunked)
  1240|         0|            0|            0|  0.00%|
  1241|         0|            0|            0|  0.00%|    def _send_request(self, method, url, body, headers, encode_chunked):
  1242|         0|            0|            0|  0.00%|        # Honor explicitly requested Host: and Accept-Encoding: headers.
  1243|         0|            0|            0|  0.00%|        header_names = frozenset(k.lower() for k in headers)
  1244|         0|            0|            0|  0.00%|        skips = {}
  1245|         0|            0|            0|  0.00%|        if 'host' in header_names:
  1246|         0|            0|            0|  0.00%|            skips['skip_host'] = 1
  1247|         0|            0|            0|  0.00%|        if 'accept-encoding' in header_names:
  1248|         0|            0|            0|  0.00%|            skips['skip_accept_encoding'] = 1
  1249|         0|            0|            0|  0.00%|
  1250|         0|            0|            0|  0.00%|        self.putrequest(method, url, **skips)
  1251|         0|            0|            0|  0.00%|
  1252|         0|            0|            0|  0.00%|        # chunked encoding will happen if HTTP/1.1 is used and either
  1253|         0|            0|            0|  0.00%|        # the caller passes encode_chunked=True or the following
  1254|         0|            0|            0|  0.00%|        # conditions hold:
  1255|         0|            0|            0|  0.00%|        # 1. content-length has not been explicitly set
  1256|         0|            0|            0|  0.00%|        # 2. the body is a file or iterable, but not a str or bytes-like
  1257|         0|            0|            0|  0.00%|        # 3. Transfer-Encoding has NOT been explicitly set by the caller
  1258|         0|            0|            0|  0.00%|
  1259|         0|            0|            0|  0.00%|        if 'content-length' not in header_names:
  1260|         0|            0|            0|  0.00%|            # only chunk body if not explicitly set for backwards
  1261|         0|            0|            0|  0.00%|            # compatibility, assuming the client code is already handling the
  1262|         0|            0|            0|  0.00%|            # chunking
  1263|         0|            0|            0|  0.00%|            if 'transfer-encoding' not in header_names:
  1264|         0|            0|            0|  0.00%|                # if content-length cannot be automatically determined, fall
  1265|         0|            0|            0|  0.00%|                # back to chunked encoding
  1266|         0|            0|            0|  0.00%|                encode_chunked = False
  1267|         0|            0|            0|  0.00%|                content_length = self._get_content_length(body, method)
  1268|         0|            0|            0|  0.00%|                if content_length is None:
  1269|         0|            0|            0|  0.00%|                    if body is not None:
  1270|         0|            0|            0|  0.00%|                        if self.debuglevel > 0:
  1271|         0|            0|            0|  0.00%|                            print('Unable to determine size of %r' % body)
  1272|         0|            0|            0|  0.00%|                        encode_chunked = True
  1273|         0|            0|            0|  0.00%|                        self.putheader('Transfer-Encoding', 'chunked')
  1274|         0|            0|            0|  0.00%|                else:
  1275|         0|            0|            0|  0.00%|                    self.putheader('Content-Length', str(content_length))
  1276|         0|            0|            0|  0.00%|        else:
  1277|         0|            0|            0|  0.00%|            encode_chunked = False
  1278|         0|            0|            0|  0.00%|
  1279|         0|            0|            0|  0.00%|        for hdr, value in headers.items():
  1280|         0|            0|            0|  0.00%|            self.putheader(hdr, value)
  1281|         0|            0|            0|  0.00%|        if isinstance(body, str):
  1282|         0|            0|            0|  0.00%|            # RFC 2616 Section 3.7.1 says that text default has a
  1283|         0|            0|            0|  0.00%|            # default charset of iso-8859-1.
  1284|         0|            0|            0|  0.00%|            body = _encode(body, 'body')
  1285|         0|            0|            0|  0.00%|        self.endheaders(body, encode_chunked=encode_chunked)
  1286|         0|            0|            0|  0.00%|
  1287|         0|            0|            0|  0.00%|    def getresponse(self):
  1288|         0|            0|            0|  0.00%|        """Get the response from the server.
  1289|         0|            0|            0|  0.00%|
  1290|         0|            0|            0|  0.00%|        If the HTTPConnection is in the correct state, returns an
  1291|         0|            0|            0|  0.00%|        instance of HTTPResponse or of whatever object is returned by
  1292|         0|            0|            0|  0.00%|        the response_class variable.
  1293|         0|            0|            0|  0.00%|
  1294|         0|            0|            0|  0.00%|        If a request has not been sent or if a previous response has
  1295|         0|            0|            0|  0.00%|        not be handled, ResponseNotReady is raised.  If the HTTP
  1296|         0|            0|            0|  0.00%|        response indicates that the connection should be closed, then
  1297|         0|            0|            0|  0.00%|        it will be closed before the response is returned.  When the
  1298|         0|            0|            0|  0.00%|        connection is closed, the underlying socket is closed.
  1299|         0|            0|            0|  0.00%|        """
  1300|         0|            0|            0|  0.00%|
  1301|         0|            0|            0|  0.00%|        # if a prior response has been completed, then forget about it.
  1302|         0|            0|            0|  0.00%|        if self.__response and self.__response.isclosed():
  1303|         0|            0|            0|  0.00%|            self.__response = None
  1304|         0|            0|            0|  0.00%|
  1305|         0|            0|            0|  0.00%|        # if a prior response exists, then it must be completed (otherwise, we
  1306|         0|            0|            0|  0.00%|        # cannot read this response's header to determine the connection-close
  1307|         0|            0|            0|  0.00%|        # behavior)
  1308|         0|            0|            0|  0.00%|        #
  1309|         0|            0|            0|  0.00%|        # note: if a prior response existed, but was connection-close, then the
  1310|         0|            0|            0|  0.00%|        # socket and response were made independent of this HTTPConnection
  1311|         0|            0|            0|  0.00%|        # object since a new request requires that we open a whole new
  1312|         0|            0|            0|  0.00%|        # connection
  1313|         0|            0|            0|  0.00%|        #
  1314|         0|            0|            0|  0.00%|        # this means the prior response had one of two states:
  1315|         0|            0|            0|  0.00%|        #   1) will_close: this connection was reset and the prior socket and
  1316|         0|            0|            0|  0.00%|        #                  response operate independently
  1317|         0|            0|            0|  0.00%|        #   2) persistent: the response was retained and we await its
  1318|         0|            0|            0|  0.00%|        #                  isclosed() status to become true.
  1319|         0|            0|            0|  0.00%|        #
  1320|         0|            0|            0|  0.00%|        if self.__state != _CS_REQ_SENT or self.__response:
  1321|         0|            0|            0|  0.00%|            raise ResponseNotReady(self.__state)
  1322|         0|            0|            0|  0.00%|
  1323|         0|            0|            0|  0.00%|        if self.debuglevel > 0:
  1324|         0|            0|            0|  0.00%|            response = self.response_class(self.sock, self.debuglevel,
  1325|         0|            0|            0|  0.00%|                                           method=self._method)
  1326|         0|            0|            0|  0.00%|        else:
  1327|         0|            0|            0|  0.00%|            response = self.response_class(self.sock, method=self._method)
  1328|         0|            0|            0|  0.00%|
  1329|         0|            0|            0|  0.00%|        try:
  1330|         0|            0|            0|  0.00%|            try:
  1331|         0|            0|            0|  0.00%|                response.begin()
(call)|         2|            0|            0|  0.00%|# D:\Application\Anaconda\lib\http\client.py:290 begin
  1332|         0|            0|            0|  0.00%|            except ConnectionError:
  1333|         0|            0|            0|  0.00%|                self.close()
  1334|         0|            0|            0|  0.00%|                raise
  1335|         0|            0|            0|  0.00%|            assert response.will_close != _UNKNOWN
  1336|         0|            0|            0|  0.00%|            self.__state = _CS_IDLE
  1337|         0|            0|            0|  0.00%|
  1338|         0|            0|            0|  0.00%|            if response.will_close:
  1339|         0|            0|            0|  0.00%|                # this effectively passes the connection to the response
  1340|         0|            0|            0|  0.00%|                self.close()
  1341|         0|            0|            0|  0.00%|            else:
  1342|         0|            0|            0|  0.00%|                # remember this, so we can tell when it is complete
  1343|         0|            0|            0|  0.00%|                self.__response = response
  1344|         0|            0|            0|  0.00%|
  1345|         0|            0|            0|  0.00%|            return response
  1346|         0|            0|            0|  0.00%|        except:
  1347|         0|            0|            0|  0.00%|            response.close()
  1348|         0|            0|            0|  0.00%|            raise
  1349|         0|            0|            0|  0.00%|
  1350|         0|            0|            0|  0.00%|try:
  1351|         0|            0|            0|  0.00%|    import ssl
  1352|         0|            0|            0|  0.00%|except ImportError:
  1353|         0|            0|            0|  0.00%|    pass
  1354|         0|            0|            0|  0.00%|else:
  1355|         0|            0|            0|  0.00%|    class HTTPSConnection(HTTPConnection):
  1356|         0|            0|            0|  0.00%|        "This class allows communication via SSL."
  1357|         0|            0|            0|  0.00%|
  1358|         0|            0|            0|  0.00%|        default_port = HTTPS_PORT
  1359|         0|            0|            0|  0.00%|
  1360|         0|            0|            0|  0.00%|        # XXX Should key_file and cert_file be deprecated in favour of context?
  1361|         0|            0|            0|  0.00%|
  1362|         0|            0|            0|  0.00%|        def __init__(self, host, port=None, key_file=None, cert_file=None,
  1363|         0|            0|            0|  0.00%|                     timeout=socket._GLOBAL_DEFAULT_TIMEOUT,
  1364|         0|            0|            0|  0.00%|                     source_address=None, *, context=None,
  1365|         0|            0|            0|  0.00%|                     check_hostname=None):
  1366|         0|            0|            0|  0.00%|            super(HTTPSConnection, self).__init__(host, port, timeout,
  1367|         0|            0|            0|  0.00%|                                                  source_address)
  1368|         0|            0|            0|  0.00%|            if (key_file is not None or cert_file is not None or
  1369|         0|            0|            0|  0.00%|                        check_hostname is not None):
  1370|         0|            0|            0|  0.00%|                import warnings
  1371|         0|            0|            0|  0.00%|                warnings.warn("key_file, cert_file and check_hostname are "
  1372|         0|            0|            0|  0.00%|                              "deprecated, use a custom context instead.",
  1373|         0|            0|            0|  0.00%|                              DeprecationWarning, 2)
  1374|         0|            0|            0|  0.00%|            self.key_file = key_file
  1375|         0|            0|            0|  0.00%|            self.cert_file = cert_file
  1376|         0|            0|            0|  0.00%|            if context is None:
  1377|         0|            0|            0|  0.00%|                context = ssl._create_default_https_context()
  1378|         0|            0|            0|  0.00%|            will_verify = context.verify_mode != ssl.CERT_NONE
  1379|         0|            0|            0|  0.00%|            if check_hostname is None:
  1380|         0|            0|            0|  0.00%|                check_hostname = context.check_hostname
  1381|         0|            0|            0|  0.00%|            if check_hostname and not will_verify:
  1382|         0|            0|            0|  0.00%|                raise ValueError("check_hostname needs a SSL context with "
  1383|         0|            0|            0|  0.00%|                                 "either CERT_OPTIONAL or CERT_REQUIRED")
  1384|         0|            0|            0|  0.00%|            if key_file or cert_file:
  1385|         0|            0|            0|  0.00%|                context.load_cert_chain(cert_file, key_file)
  1386|         0|            0|            0|  0.00%|            self._context = context
  1387|         0|            0|            0|  0.00%|            self._check_hostname = check_hostname
  1388|         0|            0|            0|  0.00%|
  1389|         0|            0|            0|  0.00%|        def connect(self):
  1390|         0|            0|            0|  0.00%|            "Connect to a host on a given (SSL) port."
  1391|         0|            0|            0|  0.00%|
  1392|         0|            0|            0|  0.00%|            super().connect()
  1393|         0|            0|            0|  0.00%|
  1394|         0|            0|            0|  0.00%|            if self._tunnel_host:
  1395|         0|            0|            0|  0.00%|                server_hostname = self._tunnel_host
  1396|         0|            0|            0|  0.00%|            else:
  1397|         0|            0|            0|  0.00%|                server_hostname = self.host
  1398|         0|            0|            0|  0.00%|
  1399|         0|            0|            0|  0.00%|            self.sock = self._context.wrap_socket(self.sock,
  1400|         0|            0|            0|  0.00%|                                                  server_hostname=server_hostname)
  1401|         0|            0|            0|  0.00%|            if not self._context.check_hostname and self._check_hostname:
  1402|         0|            0|            0|  0.00%|                try:
  1403|         0|            0|            0|  0.00%|                    ssl.match_hostname(self.sock.getpeercert(), server_hostname)
  1404|         0|            0|            0|  0.00%|                except Exception:
  1405|         0|            0|            0|  0.00%|                    self.sock.shutdown(socket.SHUT_RDWR)
  1406|         0|            0|            0|  0.00%|                    self.sock.close()
  1407|         0|            0|            0|  0.00%|                    raise
  1408|         0|            0|            0|  0.00%|
  1409|         0|            0|            0|  0.00%|    __all__.append("HTTPSConnection")
  1410|         0|            0|            0|  0.00%|
  1411|         0|            0|            0|  0.00%|class HTTPException(Exception):
  1412|         0|            0|            0|  0.00%|    # Subclasses that define an __init__ must call Exception.__init__
  1413|         0|            0|            0|  0.00%|    # or define self.args.  Otherwise, str() will fail.
  1414|         0|            0|            0|  0.00%|    pass
  1415|         0|            0|            0|  0.00%|
  1416|         0|            0|            0|  0.00%|class NotConnected(HTTPException):
  1417|         0|            0|            0|  0.00%|    pass
  1418|         0|            0|            0|  0.00%|
  1419|         0|            0|            0|  0.00%|class InvalidURL(HTTPException):
  1420|         0|            0|            0|  0.00%|    pass
  1421|         0|            0|            0|  0.00%|
  1422|         0|            0|            0|  0.00%|class UnknownProtocol(HTTPException):
  1423|         0|            0|            0|  0.00%|    def __init__(self, version):
  1424|         0|            0|            0|  0.00%|        self.args = version,
  1425|         0|            0|            0|  0.00%|        self.version = version
  1426|         0|            0|            0|  0.00%|
  1427|         0|            0|            0|  0.00%|class UnknownTransferEncoding(HTTPException):
  1428|         0|            0|            0|  0.00%|    pass
  1429|         0|            0|            0|  0.00%|
  1430|         0|            0|            0|  0.00%|class UnimplementedFileMode(HTTPException):
  1431|         0|            0|            0|  0.00%|    pass
  1432|         0|            0|            0|  0.00%|
  1433|         0|            0|            0|  0.00%|class IncompleteRead(HTTPException):
  1434|         0|            0|            0|  0.00%|    def __init__(self, partial, expected=None):
  1435|         0|            0|            0|  0.00%|        self.args = partial,
  1436|         0|            0|            0|  0.00%|        self.partial = partial
  1437|         0|            0|            0|  0.00%|        self.expected = expected
  1438|         0|            0|            0|  0.00%|    def __repr__(self):
  1439|         0|            0|            0|  0.00%|        if self.expected is not None:
  1440|         0|            0|            0|  0.00%|            e = ', %i more expected' % self.expected
  1441|         0|            0|            0|  0.00%|        else:
  1442|         0|            0|            0|  0.00%|            e = ''
  1443|         0|            0|            0|  0.00%|        return '%s(%i bytes read%s)' % (self.__class__.__name__,
  1444|         0|            0|            0|  0.00%|                                        len(self.partial), e)
  1445|         0|            0|            0|  0.00%|    def __str__(self):
  1446|         0|            0|            0|  0.00%|        return repr(self)
  1447|         0|            0|            0|  0.00%|
  1448|         0|            0|            0|  0.00%|class ImproperConnectionState(HTTPException):
  1449|         0|            0|            0|  0.00%|    pass
  1450|         0|            0|            0|  0.00%|
  1451|         0|            0|            0|  0.00%|class CannotSendRequest(ImproperConnectionState):
  1452|         0|            0|            0|  0.00%|    pass
  1453|         0|            0|            0|  0.00%|
  1454|         0|            0|            0|  0.00%|class CannotSendHeader(ImproperConnectionState):
  1455|         0|            0|            0|  0.00%|    pass
  1456|         0|            0|            0|  0.00%|
  1457|         0|            0|            0|  0.00%|class ResponseNotReady(ImproperConnectionState):
  1458|         0|            0|            0|  0.00%|    pass
  1459|         0|            0|            0|  0.00%|
  1460|         0|            0|            0|  0.00%|class BadStatusLine(HTTPException):
  1461|         0|            0|            0|  0.00%|    def __init__(self, line):
  1462|         0|            0|            0|  0.00%|        if not line:
  1463|         0|            0|            0|  0.00%|            line = repr(line)
  1464|         0|            0|            0|  0.00%|        self.args = line,
  1465|         0|            0|            0|  0.00%|        self.line = line
  1466|         0|            0|            0|  0.00%|
  1467|         0|            0|            0|  0.00%|class LineTooLong(HTTPException):
  1468|         0|            0|            0|  0.00%|    def __init__(self, line_type):
  1469|         0|            0|            0|  0.00%|        HTTPException.__init__(self, "got more than %d bytes when reading %s"
  1470|         0|            0|            0|  0.00%|                                     % (_MAXLINE, line_type))
  1471|         0|            0|            0|  0.00%|
  1472|         0|            0|            0|  0.00%|class RemoteDisconnected(ConnectionResetError, BadStatusLine):
  1473|         0|            0|            0|  0.00%|    def __init__(self, *pos, **kw):
  1474|         0|            0|            0|  0.00%|        BadStatusLine.__init__(self, "")
  1475|         0|            0|            0|  0.00%|        ConnectionResetError.__init__(self, *pos, **kw)
  1476|         0|            0|            0|  0.00%|
  1477|         0|            0|            0|  0.00%|# for backwards compatibility
  1478|         0|            0|            0|  0.00%|error = HTTPException
File: D:\Application\Anaconda\lib\site-packages\ipykernel\iostream.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# coding: utf-8
     2|         0|            0|            0|  0.00%|"""Wrappers for forwarding stdout/stderr over zmq"""
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|# Copyright (c) IPython Development Team.
     5|         0|            0|            0|  0.00%|# Distributed under the terms of the Modified BSD License.
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|from __future__ import print_function
     8|         0|            0|            0|  0.00%|import atexit
     9|         0|            0|            0|  0.00%|from binascii import b2a_hex
    10|         0|            0|            0|  0.00%|from collections import deque
    11|         0|            0|            0|  0.00%|try:
    12|         0|            0|            0|  0.00%|    from importlib import lock_held as import_lock_held
    13|         0|            0|            0|  0.00%|except ImportError:
    14|         0|            0|            0|  0.00%|    from imp import lock_held as import_lock_held
    15|         0|            0|            0|  0.00%|import os
    16|         0|            0|            0|  0.00%|import sys
    17|         0|            0|            0|  0.00%|import threading
    18|         0|            0|            0|  0.00%|import warnings
    19|         0|            0|            0|  0.00%|from io import StringIO, TextIOBase
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|import zmq
    22|         0|            0|            0|  0.00%|from zmq.eventloop.ioloop import IOLoop
    23|         0|            0|            0|  0.00%|from zmq.eventloop.zmqstream import ZMQStream
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|from jupyter_client.session import extract_header
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|from ipython_genutils import py3compat
    28|         0|            0|            0|  0.00%|from ipython_genutils.py3compat import unicode_type
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
    31|         0|            0|            0|  0.00%|# Globals
    32|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|MASTER = 0
    35|         0|            0|            0|  0.00%|CHILD = 1
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
    38|         0|            0|            0|  0.00%|# IO classes
    39|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|class IOPubThread(object):
    42|         0|            0|            0|  0.00%|    """An object for sending IOPub messages in a background thread
    43|         0|            0|            0|  0.00%|
    44|         0|            0|            0|  0.00%|    Prevents a blocking main thread from delaying output from threads.
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|    IOPubThread(pub_socket).background_socket is a Socket-API-providing object
    47|         0|            0|            0|  0.00%|    whose IO is always run in a thread.
    48|         0|            0|            0|  0.00%|    """
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|    def __init__(self, socket, pipe=False):
    51|         0|            0|            0|  0.00%|        """Create IOPub thread
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|        Parameters
    54|         0|            0|            0|  0.00%|        ----------
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|        socket: zmq.PUB Socket
    57|         0|            0|            0|  0.00%|            the socket on which messages will be sent.
    58|         0|            0|            0|  0.00%|        pipe: bool
    59|         0|            0|            0|  0.00%|            Whether this process should listen for IOPub messages
    60|         0|            0|            0|  0.00%|            piped from subprocesses.
    61|         0|            0|            0|  0.00%|        """
    62|         0|            0|            0|  0.00%|        self.socket = socket
    63|         0|            0|            0|  0.00%|        self.background_socket = BackgroundSocket(self)
    64|         0|            0|            0|  0.00%|        self._master_pid = os.getpid()
    65|         0|            0|            0|  0.00%|        self._pipe_flag = pipe
    66|         0|            0|            0|  0.00%|        self.io_loop = IOLoop(make_current=False)
    67|         0|            0|            0|  0.00%|        if pipe:
    68|         0|            0|            0|  0.00%|            self._setup_pipe_in()
    69|         0|            0|            0|  0.00%|        self._local = threading.local()
    70|         0|            0|            0|  0.00%|        self._events = deque()
    71|         0|            0|            0|  0.00%|        self._setup_event_pipe()
    72|         0|            0|            0|  0.00%|        self.thread = threading.Thread(target=self._thread_main)
    73|         0|            0|            0|  0.00%|        self.thread.daemon = True
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|    def _thread_main(self):
    76|         0|            0|            0|  0.00%|        """The inner loop that's actually run in a thread"""
    77|         0|            0|            0|  0.00%|        self.io_loop.make_current()
    78|         0|            0|            0|  0.00%|        self.io_loop.start()
    79|         0|            0|            0|  0.00%|        self.io_loop.close(all_fds=True)
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|    def _setup_event_pipe(self):
    82|         0|            0|            0|  0.00%|        """Create the PULL socket listening for events that should fire in this thread."""
    83|         0|            0|            0|  0.00%|        ctx = self.socket.context
    84|         0|            0|            0|  0.00%|        pipe_in = ctx.socket(zmq.PULL)
    85|         0|            0|            0|  0.00%|        pipe_in.linger = 0
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|        _uuid = b2a_hex(os.urandom(16)).decode('ascii')
    88|         0|            0|            0|  0.00%|        iface = self._event_interface = 'inproc://%s' % _uuid
    89|         0|            0|            0|  0.00%|        pipe_in.bind(iface)
    90|         0|            0|            0|  0.00%|        self._event_puller = ZMQStream(pipe_in, self.io_loop)
    91|         0|            0|            0|  0.00%|        self._event_puller.on_recv(self._handle_event)
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|    @property
    94|         0|            0|            0|  0.00%|    def _event_pipe(self):
    95|         0|            0|            0|  0.00%|        """thread-local event pipe for signaling events that should be processed in the thread"""
    96|         0|            0|            0|  0.00%|        try:
    97|         0|            0|            0|  0.00%|            event_pipe = self._local.event_pipe
    98|         0|            0|            0|  0.00%|        except AttributeError:
    99|         0|            0|            0|  0.00%|            # new thread, new event pipe
   100|         0|            0|            0|  0.00%|            ctx = self.socket.context
   101|         0|            0|            0|  0.00%|            event_pipe = ctx.socket(zmq.PUSH)
   102|         0|            0|            0|  0.00%|            event_pipe.linger = 0
   103|         0|            0|            0|  0.00%|            event_pipe.connect(self._event_interface)
   104|         0|            0|            0|  0.00%|            self._local.event_pipe = event_pipe
   105|         0|            0|            0|  0.00%|        return event_pipe
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|    def _handle_event(self, msg):
   108|         0|            0|            0|  0.00%|        """Handle an event on the event pipe
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|        Content of the message is ignored.
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|        Whenever *an* event arrives on the event stream,
   113|         0|            0|            0|  0.00%|        *all* waiting events are processed in order.
   114|         0|            0|            0|  0.00%|        """
   115|         0|            0|            0|  0.00%|        # freeze event count so new writes don't extend the queue
   116|         0|            0|            0|  0.00%|        # while we are processing
   117|         0|            0|            0|  0.00%|        n_events = len(self._events)
   118|         0|            0|            0|  0.00%|        for i in range(n_events):
   119|         0|            0|            0|  0.00%|            event_f = self._events.popleft()
   120|         0|            0|            0|  0.00%|            event_f()
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|    def _setup_pipe_in(self):
   123|         0|            0|            0|  0.00%|        """setup listening pipe for IOPub from forked subprocesses"""
   124|         0|            0|            0|  0.00%|        ctx = self.socket.context
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|        # use UUID to authenticate pipe messages
   127|         0|            0|            0|  0.00%|        self._pipe_uuid = os.urandom(16)
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|        pipe_in = ctx.socket(zmq.PULL)
   130|         0|            0|            0|  0.00%|        pipe_in.linger = 0
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|        try:
   133|         0|            0|            0|  0.00%|            self._pipe_port = pipe_in.bind_to_random_port("tcp://127.0.0.1")
   134|         0|            0|            0|  0.00%|        except zmq.ZMQError as e:
   135|         0|            0|            0|  0.00%|            warnings.warn("Couldn't bind IOPub Pipe to 127.0.0.1: %s" % e +
   136|         0|            0|            0|  0.00%|                "\nsubprocess output will be unavailable."
   137|         0|            0|            0|  0.00%|            )
   138|         0|            0|            0|  0.00%|            self._pipe_flag = False
   139|         0|            0|            0|  0.00%|            pipe_in.close()
   140|         0|            0|            0|  0.00%|            return
   141|         0|            0|            0|  0.00%|        self._pipe_in = ZMQStream(pipe_in, self.io_loop)
   142|         0|            0|            0|  0.00%|        self._pipe_in.on_recv(self._handle_pipe_msg)
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|    def _handle_pipe_msg(self, msg):
   145|         0|            0|            0|  0.00%|        """handle a pipe message from a subprocess"""
   146|         0|            0|            0|  0.00%|        if not self._pipe_flag or not self._is_master_process():
   147|         0|            0|            0|  0.00%|            return
   148|         0|            0|            0|  0.00%|        if msg[0] != self._pipe_uuid:
   149|         0|            0|            0|  0.00%|            print("Bad pipe message: %s", msg, file=sys.__stderr__)
   150|         0|            0|            0|  0.00%|            return
   151|         0|            0|            0|  0.00%|        self.send_multipart(msg[1:])
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|    def _setup_pipe_out(self):
   154|         0|            0|            0|  0.00%|        # must be new context after fork
   155|         0|            0|            0|  0.00%|        ctx = zmq.Context()
   156|         0|            0|            0|  0.00%|        pipe_out = ctx.socket(zmq.PUSH)
   157|         0|            0|            0|  0.00%|        pipe_out.linger = 3000 # 3s timeout for pipe_out sends before discarding the message
   158|         0|            0|            0|  0.00%|        pipe_out.connect("tcp://127.0.0.1:%i" % self._pipe_port)
   159|         0|            0|            0|  0.00%|        return ctx, pipe_out
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|    def _is_master_process(self):
   162|         0|            0|            0|  0.00%|        return os.getpid() == self._master_pid
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|    def _check_mp_mode(self):
   165|         0|            0|            0|  0.00%|        """check for forks, and switch to zmq pipeline if necessary"""
   166|         0|            0|            0|  0.00%|        if not self._pipe_flag or self._is_master_process():
   167|         0|            0|            0|  0.00%|            return MASTER
   168|         0|            0|            0|  0.00%|        else:
   169|         0|            0|            0|  0.00%|            return CHILD
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|    def start(self):
   172|         0|            0|            0|  0.00%|        """Start the IOPub thread"""
   173|         0|            0|            0|  0.00%|        self.thread.start()
   174|         0|            0|            0|  0.00%|        # make sure we don't prevent process exit
   175|         0|            0|            0|  0.00%|        # I'm not sure why setting daemon=True above isn't enough, but it doesn't appear to be.
   176|         0|            0|            0|  0.00%|        atexit.register(self.stop)
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    def stop(self):
   179|         0|            0|            0|  0.00%|        """Stop the IOPub thread"""
   180|         0|            0|            0|  0.00%|        if not self.thread.is_alive():
   181|         0|            0|            0|  0.00%|            return
   182|         0|            0|            0|  0.00%|        self.io_loop.add_callback(self.io_loop.stop)
   183|         0|            0|            0|  0.00%|        self.thread.join()
   184|         0|            0|            0|  0.00%|        if hasattr(self._local, 'event_pipe'):
   185|         0|            0|            0|  0.00%|            self._local.event_pipe.close()
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|    def close(self):
   188|         0|            0|            0|  0.00%|        if self.closed:
   189|         0|            0|            0|  0.00%|            return
   190|         0|            0|            0|  0.00%|        self.socket.close()
   191|         0|            0|            0|  0.00%|        self.socket = None
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|    @property
   194|         0|            0|            0|  0.00%|    def closed(self):
   195|         0|            0|            0|  0.00%|        return self.socket is None
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|    def schedule(self, f):
   198|         0|            0|            0|  0.00%|        """Schedule a function to be called in our IO thread.
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|        If the thread is not running, call immediately.
   201|         0|            0|            0|  0.00%|        """
   202|         0|            0|            0|  0.00%|        if self.thread.is_alive():
   203|         0|            0|            0|  0.00%|            self._events.append(f)
   204|         0|            0|            0|  0.00%|            # wake event thread (message content is ignored)
   205|         0|            0|            0|  0.00%|            self._event_pipe.send(b'')
(call)|         8|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\zmq\sugar\socket.py:342 send
   206|         0|            0|            0|  0.00%|        else:
   207|         0|            0|            0|  0.00%|            f()
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|    def send_multipart(self, *args, **kwargs):
   210|         0|            0|            0|  0.00%|        """send_multipart schedules actual zmq send in my thread.
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|        If my thread isn't running (e.g. forked process), send immediately.
   213|         0|            0|            0|  0.00%|        """
   214|         0|            0|            0|  0.00%|        self.schedule(lambda : self._really_send(*args, **kwargs))
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|    def _really_send(self, msg, *args, **kwargs):
   217|         0|            0|            0|  0.00%|        """The callback that actually sends messages"""
   218|         0|            0|            0|  0.00%|        mp_mode = self._check_mp_mode()
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|        if mp_mode != CHILD:
   221|         0|            0|            0|  0.00%|            # we are master, do a regular send
   222|         0|            0|            0|  0.00%|            self.socket.send_multipart(msg, *args, **kwargs)
   223|         0|            0|            0|  0.00%|        else:
   224|         0|            0|            0|  0.00%|            # we are a child, pipe to master
   225|         0|            0|            0|  0.00%|            # new context/socket for every pipe-out
   226|         0|            0|            0|  0.00%|            # since forks don't teardown politely, use ctx.term to ensure send has completed
   227|         0|            0|            0|  0.00%|            ctx, pipe_out = self._setup_pipe_out()
   228|         0|            0|            0|  0.00%|            pipe_out.send_multipart([self._pipe_uuid] + msg, *args, **kwargs)
   229|         0|            0|            0|  0.00%|            pipe_out.close()
   230|         0|            0|            0|  0.00%|            ctx.term()
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|class BackgroundSocket(object):
   234|         0|            0|            0|  0.00%|    """Wrapper around IOPub thread that provides zmq send[_multipart]"""
   235|         0|            0|            0|  0.00%|    io_thread = None
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|    def __init__(self, io_thread):
   238|         0|            0|            0|  0.00%|        self.io_thread = io_thread
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|    def __getattr__(self, attr):
   241|         0|            0|            0|  0.00%|        """Wrap socket attr access for backward-compatibility"""
   242|         0|            0|            0|  0.00%|        if attr.startswith('__') and attr.endswith('__'):
   243|         0|            0|            0|  0.00%|            # don't wrap magic methods
   244|         0|            0|            0|  0.00%|            super(BackgroundSocket, self).__getattr__(attr)
   245|         0|            0|            0|  0.00%|        if hasattr(self.io_thread.socket, attr):
   246|         0|            0|            0|  0.00%|            warnings.warn("Accessing zmq Socket attribute %s on BackgroundSocket" % attr,
   247|         0|            0|            0|  0.00%|                DeprecationWarning, stacklevel=2)
   248|         0|            0|            0|  0.00%|            return getattr(self.io_thread.socket, attr)
   249|         0|            0|            0|  0.00%|        super(BackgroundSocket, self).__getattr__(attr)
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|    def __setattr__(self, attr, value):
   252|         0|            0|            0|  0.00%|        if attr == 'io_thread' or (attr.startswith('__' and attr.endswith('__'))):
   253|         0|            0|            0|  0.00%|            super(BackgroundSocket, self).__setattr__(attr, value)
   254|         0|            0|            0|  0.00%|        else:
   255|         0|            0|            0|  0.00%|            warnings.warn("Setting zmq Socket attribute %s on BackgroundSocket" % attr,
   256|         0|            0|            0|  0.00%|                DeprecationWarning, stacklevel=2)
   257|         0|            0|            0|  0.00%|            setattr(self.io_thread.socket, attr, value)
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|    def send(self, msg, *args, **kwargs):
   260|         0|            0|            0|  0.00%|        return self.send_multipart([msg], *args, **kwargs)
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|    def send_multipart(self, *args, **kwargs):
   263|         0|            0|            0|  0.00%|        """Schedule send in IO thread"""
   264|         0|            0|            0|  0.00%|        return self.io_thread.send_multipart(*args, **kwargs)
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|class OutStream(TextIOBase):
   268|         0|            0|            0|  0.00%|    """A file like object that publishes the stream to a 0MQ PUB socket.
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|    Output is handed off to an IO Thread
   271|         0|            0|            0|  0.00%|    """
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|    # timeout for flush to avoid infinite hang
   274|         0|            0|            0|  0.00%|    # in case of misbehavior
   275|         0|            0|            0|  0.00%|    flush_timeout = 10
   276|         0|            0|            0|  0.00%|    # The time interval between automatic flushes, in seconds.
   277|         0|            0|            0|  0.00%|    flush_interval = 0.2
   278|         0|            0|            0|  0.00%|    topic = None
   279|         0|            0|            0|  0.00%|    encoding = 'UTF-8'
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|    def __init__(self, session, pub_thread, name, pipe=None, echo=None):
   282|         0|            0|            0|  0.00%|        if pipe is not None:
   283|         0|            0|            0|  0.00%|            warnings.warn("pipe argument to OutStream is deprecated and ignored",
   284|         0|            0|            0|  0.00%|                DeprecationWarning)
   285|         0|            0|            0|  0.00%|        # This is necessary for compatibility with Python built-in streams
   286|         0|            0|            0|  0.00%|        self.session = session
   287|         0|            0|            0|  0.00%|        if not isinstance(pub_thread, IOPubThread):
   288|         0|            0|            0|  0.00%|            # Backward-compat: given socket, not thread. Wrap in a thread.
   289|         0|            0|            0|  0.00%|            warnings.warn("OutStream should be created with IOPubThread, not %r" % pub_thread,
   290|         0|            0|            0|  0.00%|                DeprecationWarning, stacklevel=2)
   291|         0|            0|            0|  0.00%|            pub_thread = IOPubThread(pub_thread)
   292|         0|            0|            0|  0.00%|            pub_thread.start()
   293|         0|            0|            0|  0.00%|        self.pub_thread = pub_thread
   294|         0|            0|            0|  0.00%|        self.name = name
   295|         0|            0|            0|  0.00%|        self.topic = b'stream.' + py3compat.cast_bytes(name)
   296|         0|            0|            0|  0.00%|        self.parent_header = {}
   297|         0|            0|            0|  0.00%|        self._master_pid = os.getpid()
   298|         0|            0|            0|  0.00%|        self._flush_pending = False
   299|         0|            0|            0|  0.00%|        self._io_loop = pub_thread.io_loop
   300|         0|            0|            0|  0.00%|        self._new_buffer()
   301|         0|            0|            0|  0.00%|        self.echo = None
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|        if echo:
   304|         0|            0|            0|  0.00%|            if hasattr(echo, 'read') and hasattr(echo, 'write'):
   305|         0|            0|            0|  0.00%|                self.echo = echo
   306|         0|            0|            0|  0.00%|            else:
   307|         0|            0|            0|  0.00%|                raise ValueError("echo argument must be a file like object")
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|    def _is_master_process(self):
   310|         0|            0|            0|  0.00%|        return os.getpid() == self._master_pid
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|    def set_parent(self, parent):
   313|         0|            0|            0|  0.00%|        self.parent_header = extract_header(parent)
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|    def close(self):
   316|         0|            0|            0|  0.00%|        self.pub_thread = None
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|    @property
   319|         0|            0|            0|  0.00%|    def closed(self):
   320|         0|            0|            0|  0.00%|        return self.pub_thread is None
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|    def _schedule_flush(self):
   323|         0|            0|            0|  0.00%|        """schedule a flush in the IO thread
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|        call this on write, to indicate that flush should be called soon.
   326|         0|            0|            0|  0.00%|        """
   327|         0|            0|            0|  0.00%|        if self._flush_pending:
   328|         0|            0|            0|  0.00%|            return
   329|         0|            0|            0|  0.00%|        self._flush_pending = True
   330|         0|            0|            0|  0.00%|
   331|         0|            0|            0|  0.00%|        # add_timeout has to be handed to the io thread via event pipe
   332|         0|            0|            0|  0.00%|        def _schedule_in_thread():
   333|         0|            0|            0|  0.00%|            self._io_loop.call_later(self.flush_interval, self._flush)
   334|         0|            0|            0|  0.00%|        self.pub_thread.schedule(_schedule_in_thread)
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|    def flush(self):
   337|         0|            0|            0|  0.00%|        """trigger actual zmq send
   338|         0|            0|            0|  0.00%|
   339|         0|            0|            0|  0.00%|        send will happen in the background thread
   340|         0|            0|            0|  0.00%|        """
   341|         0|            0|            0|  0.00%|        if self.pub_thread.thread.is_alive():
   342|         0|            0|            0|  0.00%|            # request flush on the background thread
   343|         0|            0|            0|  0.00%|            self.pub_thread.schedule(self._flush)
   344|         0|            0|            0|  0.00%|            # wait for flush to actually get through, if we can.
   345|         0|            0|            0|  0.00%|            # waiting across threads during import can cause deadlocks
   346|         0|            0|            0|  0.00%|            # so only wait if import lock is not held
   347|         0|            0|            0|  0.00%|            if not import_lock_held():
   348|         0|            0|            0|  0.00%|                evt = threading.Event()
   349|         0|            0|            0|  0.00%|                self.pub_thread.schedule(evt.set)
   350|         0|            0|            0|  0.00%|                # and give a timeout to avoid
   351|         0|            0|            0|  0.00%|                if not evt.wait(self.flush_timeout):
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\threading.py:533 wait
   352|         0|            0|            0|  0.00%|                    # write directly to __stderr__ instead of warning because
   353|         0|            0|            0|  0.00%|                    # if this is happening sys.stderr may be the problem.
   354|         0|            0|            0|  0.00%|                    print("IOStream.flush timed out", file=sys.__stderr__)
   355|         0|            0|            0|  0.00%|        else:
   356|         0|            0|            0|  0.00%|            self._flush()
   357|         0|            0|            0|  0.00%|
   358|         0|            0|            0|  0.00%|    def _flush(self):
   359|         0|            0|            0|  0.00%|        """This is where the actual send happens.
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|        _flush should generally be called in the IO thread,
   362|         0|            0|            0|  0.00%|        unless the thread has been destroyed (e.g. forked subprocess).
   363|         0|            0|            0|  0.00%|        """
   364|         0|            0|            0|  0.00%|        self._flush_pending = False
   365|         0|            0|            0|  0.00%|
   366|         0|            0|            0|  0.00%|        if self.echo is not None:
   367|         0|            0|            0|  0.00%|            try:
   368|         0|            0|            0|  0.00%|                self.echo.flush()
   369|         0|            0|            0|  0.00%|            except OSError as e:
   370|         0|            0|            0|  0.00%|                if self.echo is not sys.__stderr__:
   371|         0|            0|            0|  0.00%|                    print("Flush failed: {}".format(e),
   372|         0|            0|            0|  0.00%|                          file=sys.__stderr__)
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|        data = self._flush_buffer()
   375|         0|            0|            0|  0.00%|        if data:
   376|         0|            0|            0|  0.00%|            # FIXME: this disables Session's fork-safe check,
   377|         0|            0|            0|  0.00%|            # since pub_thread is itself fork-safe.
   378|         0|            0|            0|  0.00%|            # There should be a better way to do this.
   379|         0|            0|            0|  0.00%|            self.session.pid = os.getpid()
   380|         0|            0|            0|  0.00%|            content = {u'name':self.name, u'text':data}
   381|         0|            0|            0|  0.00%|            self.session.send(self.pub_thread, u'stream', content=content,
   382|         0|            0|            0|  0.00%|                parent=self.parent_header, ident=self.topic)
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|    def write(self, string):
   385|         0|            0|            0|  0.00%|        if self.echo is not None:
   386|         0|            0|            0|  0.00%|            try:
   387|         0|            0|            0|  0.00%|                self.echo.write(string)
   388|         0|            0|            0|  0.00%|            except OSError as e:
   389|         0|            0|            0|  0.00%|                if self.echo is not sys.__stderr__:
   390|         0|            0|            0|  0.00%|                    print("Write failed: {}".format(e),
   391|         0|            0|            0|  0.00%|                          file=sys.__stderr__)
   392|         0|            0|            0|  0.00%|
   393|         0|            0|            0|  0.00%|        if self.pub_thread is None:
   394|         0|            0|            0|  0.00%|            raise ValueError('I/O operation on closed file')
   395|         0|            0|            0|  0.00%|        else:
   396|         0|            0|            0|  0.00%|            # Make sure that we're handling unicode
   397|         0|            0|            0|  0.00%|            if not isinstance(string, unicode_type):
   398|         0|            0|            0|  0.00%|                string = string.decode(self.encoding, 'replace')
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|            is_child = (not self._is_master_process())
   401|         0|            0|            0|  0.00%|            # only touch the buffer in the IO thread to avoid races
   402|         0|            0|            0|  0.00%|            self.pub_thread.schedule(lambda : self._buffer.write(string))
(call)|         8|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\ipykernel\iostream.py:197 schedule
   403|         0|            0|            0|  0.00%|            if is_child:
   404|         0|            0|            0|  0.00%|                # newlines imply flush in subprocesses
   405|         0|            0|            0|  0.00%|                # mp.Pool cannot be trusted to flush promptly (or ever),
   406|         0|            0|            0|  0.00%|                # and this helps.
   407|         0|            0|            0|  0.00%|                if '\n' in string:
   408|         0|            0|            0|  0.00%|                    self.flush()
   409|         0|            0|            0|  0.00%|            else:
   410|         0|            0|            0|  0.00%|                self._schedule_flush()
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|    def writelines(self, sequence):
   413|         0|            0|            0|  0.00%|        if self.pub_thread is None:
   414|         0|            0|            0|  0.00%|            raise ValueError('I/O operation on closed file')
   415|         0|            0|            0|  0.00%|        else:
   416|         0|            0|            0|  0.00%|            for string in sequence:
   417|         0|            0|            0|  0.00%|                self.write(string)
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|    def writable(self):
   420|         0|            0|            0|  0.00%|        return True
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|    def _flush_buffer(self):
   423|         0|            0|            0|  0.00%|        """clear the current buffer and return the current buffer data.
   424|         0|            0|            0|  0.00%|
   425|         0|            0|            0|  0.00%|        This should only be called in the IO thread.
   426|         0|            0|            0|  0.00%|        """
   427|         0|            0|            0|  0.00%|        data = u''
   428|         0|            0|            0|  0.00%|        if self._buffer is not None:
   429|         0|            0|            0|  0.00%|            buf = self._buffer
   430|         0|            0|            0|  0.00%|            self._new_buffer()
   431|         0|            0|            0|  0.00%|            data = buf.getvalue()
   432|         0|            0|            0|  0.00%|            buf.close()
   433|         0|            0|            0|  0.00%|        return data
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|    def _new_buffer(self):
   436|         0|            0|            0|  0.00%|        self._buffer = StringIO()
File: D:/Users/JCHANGI/Jason Chang/Work/Project/Mix_Run_Ratio/Mix_Run_Ratio_caller_example.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|#exec("""import os\ntry:\n    with open(os.path.join(os.path.abspath(os.path.dirname(__file__)), "package", "log_to_file", "import.txt")) as f: exec(f.read())\nexcept:pass""")
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\spyder_kernels\customize\spydercustomize.py:786 runfile
     2|         0|            0|            0|  0.00%|#exec("""import os\ntry:\n    with open(os.path.join(os.path.abspath(os.path.dirname(__file__)), "package", "line_profiler", "import.txt")) as f: exec(f.read())\nexcept:pass""")
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|from os.path import join, abspath, dirname, basename
     5|         0|            0|            0|  0.00%|import sys
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|package_path = join(dirname(abspath(__file__)))
     8|         0|            0|            0|  0.00%|if package_path not in sys.path: sys.path.insert(0, package_path)
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|from pprofile import pprofile
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|import sys
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|from Mix_Run_Ratio import Mix_Run_Ratio
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|def output_to_csv(recipe_table, ratio_table):
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|    # Output df to CSV File
    21|         0|            0|            0|  0.00%|    recipe_table.to_csv("output", "Mix_Run_Recipe.csv", index = False)
    22|         0|            0|            0|  0.00%|    ratio_table.to_csv("output", "Mix_Run_Ratio.csv", index = False)
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|def main():
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|    # Get FAB and target_function.
    28|         0|            0|            0|  0.00%|    try:
    29|         0|            0|            0|  0.00%|        FAB = sys.argv[1]
    30|         0|            0|            0|  0.00%|        target_function = sys.argv[2]
    31|         0|            0|            0|  0.00%|    except:
    32|         0|            0|            0|  0.00%|        FAB = "F12"
    33|         0|            0|            0|  0.00%|#        target_function = "combination_table"
    34|         0|            0|            0|  0.00%|#        target_function = "recipe_table"
    35|         0|            0|            0|  0.00%|        target_function = "ratio_table"
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|    # Call Mix_Run_Ratio based on target_function.
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|#    date = "last_day"
    40|         0|            0|            0|  0.00%|    date = "2019/10/23"
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|    mode = "offline"
    43|         0|            0|            0|  0.00%|#    mode = "online"
    44|         0|            0|            0|  0.00%|    mix_run_ratio = Mix_Run_Ratio(FAB, date, mode, \
    45|         0|            0|            0|  0.00%|                                  use_tqdm = True, EQP_ID_upper_limit = 50)
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|    if target_function == "combination_table":
    48|         0|            0|            0|  0.00%|        mix_run_ratio.store_combination_table()
    49|         0|            0|            0|  0.00%|    elif target_function == "recipe_table":
    50|         0|            0|            0|  0.00%|        mix_run_ratio.insert_recipe_table()
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|    elif target_function == "ratio_table":
    53|         0|            0|            0|  0.00%|        mix_run_ratio.pipeline_for_ratio_table()
(call)|       195|            0|            0|  0.00%|# D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\Mix_Run_Ratio.py:339 pipeline_for_ratio_table
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|if __name__ == "__main__":
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|#    everything_you_want_to_see = \
    59|         0|            0|            0|  0.00%|#        line_profiler( lambda: log_to_file(lambda : main()), enable = True, \
    60|         0|            0|            0|  0.00%|#                       blacklist = ["package"], output_ranking = True, \
    61|         0|            0|            0|  0.00%|#                       max_line_number = 10)
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|    # Set pprofile's profiler.
    64|         0|            0|            0|  0.00%|    profiler = pprofile.StatisticalProfile()
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|    # By default, we sample every 100ms.
    67|         0|            0|            0|  0.00%|    with profiler(period = 0.1):
(call)|         1|            0|            0|  0.00%|# D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\pprofile\pprofile.py:1114 __enter__
    68|         0|            0|            0|  0.00%|        everything_you_want_to_see = main()
(call)|       195|            0|            0|  0.00%|# D:/Users/JCHANGI/Jason Chang/Work/Project/Mix_Run_Ratio/Mix_Run_Ratio_caller_example.py:25 main
    69|         0|            0|            0|  0.00%|    profiler.dump_stats("XD.txt")
File: D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\package\tqdm\_tqdm.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|Customisable progressbar decorator for iterators.
     3|         0|            0|            0|  0.00%|Includes a default (x)range iterator printing to stderr.
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|Usage:
     6|         0|            0|            0|  0.00%|  >>> from tqdm import trange[, tqdm]
     7|         0|            0|            0|  0.00%|  >>> for i in trange(10): #same as: for i in tqdm(xrange(10))
     8|         0|            0|            0|  0.00%|  ...     ...
     9|         0|            0|            0|  0.00%|"""
    10|         0|            0|            0|  0.00%|from __future__ import absolute_import
    11|         0|            0|            0|  0.00%|# integer division / : float, // : int
    12|         0|            0|            0|  0.00%|from __future__ import division
    13|         0|            0|            0|  0.00%|# compatibility functions and utilities
    14|         0|            0|            0|  0.00%|from ._utils import _supports_unicode, _environ_cols_wrapper, _range, _unich, \
    15|         0|            0|            0|  0.00%|    _term_move_up, _unicode, WeakSet, _basestring, _OrderedDict, \
    16|         0|            0|            0|  0.00%|    Comparable, RE_ANSI, _is_ascii, SimpleTextIOWrapper
    17|         0|            0|            0|  0.00%|from ._monitor import TMonitor
    18|         0|            0|            0|  0.00%|# native libraries
    19|         0|            0|            0|  0.00%|import sys
    20|         0|            0|            0|  0.00%|from numbers import Number
    21|         0|            0|            0|  0.00%|from time import time
    22|         0|            0|            0|  0.00%|from contextlib import contextmanager
    23|         0|            0|            0|  0.00%|# For parallelism safety
    24|         0|            0|            0|  0.00%|import threading as th
    25|         0|            0|            0|  0.00%|from warnings import warn
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|__author__ = {"github.com/": ["noamraph", "obiwanus", "kmike", "hadim",
    28|         0|            0|            0|  0.00%|                              "casperdcl", "lrq3000"]}
    29|         0|            0|            0|  0.00%|__all__ = ['tqdm', 'trange',
    30|         0|            0|            0|  0.00%|           'TqdmTypeError', 'TqdmKeyError', 'TqdmWarning',
    31|         0|            0|            0|  0.00%|           'TqdmExperimentalWarning', 'TqdmDeprecationWarning',
    32|         0|            0|            0|  0.00%|           'TqdmMonitorWarning']
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|class TqdmTypeError(TypeError):
    36|         0|            0|            0|  0.00%|    pass
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|class TqdmKeyError(KeyError):
    40|         0|            0|            0|  0.00%|    pass
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|class TqdmWarning(Warning):
    44|         0|            0|            0|  0.00%|    """base class for all tqdm warnings.
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|    Used for non-external-code-breaking errors, such as garbled printing.
    47|         0|            0|            0|  0.00%|    """
    48|         0|            0|            0|  0.00%|    def __init__(self, msg, fp_write=None, *a, **k):
    49|         0|            0|            0|  0.00%|        if fp_write is not None:
    50|         0|            0|            0|  0.00%|            fp_write("\n" + self.__class__.__name__ + ": " +
    51|         0|            0|            0|  0.00%|                     str(msg).rstrip() + '\n')
    52|         0|            0|            0|  0.00%|        else:
    53|         0|            0|            0|  0.00%|            super(TqdmWarning, self).__init__(msg, *a, **k)
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|class TqdmExperimentalWarning(TqdmWarning, FutureWarning):
    57|         0|            0|            0|  0.00%|    """beta feature, unstable API and behaviour"""
    58|         0|            0|            0|  0.00%|    pass
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|class TqdmDeprecationWarning(TqdmWarning, DeprecationWarning):
    62|         0|            0|            0|  0.00%|    # not suppressed if raised
    63|         0|            0|            0|  0.00%|    pass
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|class TqdmMonitorWarning(TqdmWarning, RuntimeWarning):
    67|         0|            0|            0|  0.00%|    """tqdm monitor errors which do not affect external functionality"""
    68|         0|            0|            0|  0.00%|    pass
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|class TqdmDefaultWriteLock(object):
    72|         0|            0|            0|  0.00%|    """
    73|         0|            0|            0|  0.00%|    Provide a default write lock for thread and multiprocessing safety.
    74|         0|            0|            0|  0.00%|    Works only on platforms supporting `fork` (so Windows is excluded).
    75|         0|            0|            0|  0.00%|    You must initialise a `tqdm` or `TqdmDefaultWriteLock` instance
    76|         0|            0|            0|  0.00%|    before forking in order for the write lock to work.
    77|         0|            0|            0|  0.00%|    On Windows, you need to supply the lock from the parent to the children as
    78|         0|            0|            0|  0.00%|    an argument to joblib or the parallelism lib you use.
    79|         0|            0|            0|  0.00%|    """
    80|         0|            0|            0|  0.00%|    def __init__(self):
    81|         0|            0|            0|  0.00%|        # Create global parallelism locks to avoid racing issues with parallel
    82|         0|            0|            0|  0.00%|        # bars works only if fork available (Linux/MacOSX, but not Windows)
    83|         0|            0|            0|  0.00%|        self.create_mp_lock()
    84|         0|            0|            0|  0.00%|        self.create_th_lock()
    85|         0|            0|            0|  0.00%|        cls = type(self)
    86|         0|            0|            0|  0.00%|        self.locks = [lk for lk in [cls.mp_lock, cls.th_lock] if lk is not None]
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|    def acquire(self):
    89|         0|            0|            0|  0.00%|        for lock in self.locks:
    90|         0|            0|            0|  0.00%|            lock.acquire()
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|    def release(self):
    93|         0|            0|            0|  0.00%|        for lock in self.locks[::-1]:  # Release in inverse order of acquisition
    94|         0|            0|            0|  0.00%|            lock.release()
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|    def __enter__(self):
    97|         0|            0|            0|  0.00%|        self.acquire()
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|    def __exit__(self, *exc):
   100|         0|            0|            0|  0.00%|        self.release()
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|    @classmethod
   103|         0|            0|            0|  0.00%|    def create_mp_lock(cls):
   104|         0|            0|            0|  0.00%|        if not hasattr(cls, 'mp_lock'):
   105|         0|            0|            0|  0.00%|            try:
   106|         0|            0|            0|  0.00%|                from multiprocessing import RLock
   107|         0|            0|            0|  0.00%|                cls.mp_lock = RLock()  # multiprocessing lock
   108|         0|            0|            0|  0.00%|            except ImportError:  # pragma: no cover
   109|         0|            0|            0|  0.00%|                cls.mp_lock = None
   110|         0|            0|            0|  0.00%|            except OSError:  # pragma: no cover
   111|         0|            0|            0|  0.00%|                cls.mp_lock = None
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|    @classmethod
   114|         0|            0|            0|  0.00%|    def create_th_lock(cls):
   115|         0|            0|            0|  0.00%|        if not hasattr(cls, 'th_lock'):
   116|         0|            0|            0|  0.00%|            try:
   117|         0|            0|            0|  0.00%|                cls.th_lock = th.RLock()  # thread lock
   118|         0|            0|            0|  0.00%|            except OSError:  # pragma: no cover
   119|         0|            0|            0|  0.00%|                cls.th_lock = None
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|# Create a thread lock before instantiation so that no setup needs to be done
   123|         0|            0|            0|  0.00%|# before running in a multithreaded environment.
   124|         0|            0|            0|  0.00%|# Do not create the multiprocessing lock because it sets the multiprocessing
   125|         0|            0|            0|  0.00%|# context and does not allow the user to use 'spawn' or 'forkserver' methods.
   126|         0|            0|            0|  0.00%|TqdmDefaultWriteLock.create_th_lock()
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|ASCII_FMT = " 123456789#"
   129|         0|            0|            0|  0.00%|UTF_FMT = u" " + u''.join(map(_unich, range(0x258F, 0x2587, -1)))
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|class tqdm(Comparable):
   133|         0|            0|            0|  0.00%|    """
   134|         0|            0|            0|  0.00%|    Decorate an iterable object, returning an iterator which acts exactly
   135|         0|            0|            0|  0.00%|    like the original iterable, but prints a dynamically updating
   136|         0|            0|            0|  0.00%|    progressbar every time a value is requested.
   137|         0|            0|            0|  0.00%|    """
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|    monitor_interval = 10  # set to 0 to disable the thread
   140|         0|            0|            0|  0.00%|    monitor = None
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|    @staticmethod
   143|         0|            0|            0|  0.00%|    def format_sizeof(num, suffix='', divisor=1000):
   144|         0|            0|            0|  0.00%|        """
   145|         0|            0|            0|  0.00%|        Formats a number (greater than unity) with SI Order of Magnitude
   146|         0|            0|            0|  0.00%|        prefixes.
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|        Parameters
   149|         0|            0|            0|  0.00%|        ----------
   150|         0|            0|            0|  0.00%|        num  : float
   151|         0|            0|            0|  0.00%|            Number ( >= 1) to format.
   152|         0|            0|            0|  0.00%|        suffix  : str, optional
   153|         0|            0|            0|  0.00%|            Post-postfix [default: ''].
   154|         0|            0|            0|  0.00%|        divisor  : float, optional
   155|         0|            0|            0|  0.00%|            Divisor between prefixes [default: 1000].
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|        Returns
   158|         0|            0|            0|  0.00%|        -------
   159|         0|            0|            0|  0.00%|        out  : str
   160|         0|            0|            0|  0.00%|            Number with Order of Magnitude SI unit postfix.
   161|         0|            0|            0|  0.00%|        """
   162|         0|            0|            0|  0.00%|        for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:
   163|         0|            0|            0|  0.00%|            if abs(num) < 999.5:
   164|         0|            0|            0|  0.00%|                if abs(num) < 99.95:
   165|         0|            0|            0|  0.00%|                    if abs(num) < 9.995:
   166|         0|            0|            0|  0.00%|                        return '{0:1.2f}'.format(num) + unit + suffix
   167|         0|            0|            0|  0.00%|                    return '{0:2.1f}'.format(num) + unit + suffix
   168|         0|            0|            0|  0.00%|                return '{0:3.0f}'.format(num) + unit + suffix
   169|         0|            0|            0|  0.00%|            num /= divisor
   170|         0|            0|            0|  0.00%|        return '{0:3.1f}Y'.format(num) + suffix
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|    @staticmethod
   173|         0|            0|            0|  0.00%|    def format_interval(t):
   174|         0|            0|            0|  0.00%|        """
   175|         0|            0|            0|  0.00%|        Formats a number of seconds as a clock time, [H:]MM:SS
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|        Parameters
   178|         0|            0|            0|  0.00%|        ----------
   179|         0|            0|            0|  0.00%|        t  : int
   180|         0|            0|            0|  0.00%|            Number of seconds.
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|        Returns
   183|         0|            0|            0|  0.00%|        -------
   184|         0|            0|            0|  0.00%|        out  : str
   185|         0|            0|            0|  0.00%|            [H:]MM:SS
   186|         0|            0|            0|  0.00%|        """
   187|         0|            0|            0|  0.00%|        mins, s = divmod(int(t), 60)
   188|         0|            0|            0|  0.00%|        h, m = divmod(mins, 60)
   189|         0|            0|            0|  0.00%|        if h:
   190|         0|            0|            0|  0.00%|            return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)
   191|         0|            0|            0|  0.00%|        else:
   192|         0|            0|            0|  0.00%|            return '{0:02d}:{1:02d}'.format(m, s)
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|    @staticmethod
   195|         0|            0|            0|  0.00%|    def format_num(n):
   196|         0|            0|            0|  0.00%|        """
   197|         0|            0|            0|  0.00%|        Intelligent scientific notation (.3g).
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|        Parameters
   200|         0|            0|            0|  0.00%|        ----------
   201|         0|            0|            0|  0.00%|        n  : int or float or Numeric
   202|         0|            0|            0|  0.00%|            A Number.
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|        Returns
   205|         0|            0|            0|  0.00%|        -------
   206|         0|            0|            0|  0.00%|        out  : str
   207|         0|            0|            0|  0.00%|            Formatted number.
   208|         0|            0|            0|  0.00%|        """
   209|         0|            0|            0|  0.00%|        f = '{0:.3g}'.format(n).replace('+0', '+').replace('-0', '-')
   210|         0|            0|            0|  0.00%|        n = str(n)
   211|         0|            0|            0|  0.00%|        return f if len(f) < len(n) else n
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|    @staticmethod
   214|         0|            0|            0|  0.00%|    def ema(x, mu=None, alpha=0.3):
   215|         0|            0|            0|  0.00%|        """
   216|         0|            0|            0|  0.00%|        Exponential moving average: smoothing to give progressively lower
   217|         0|            0|            0|  0.00%|        weights to older values.
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|        Parameters
   220|         0|            0|            0|  0.00%|        ----------
   221|         0|            0|            0|  0.00%|        x  : float
   222|         0|            0|            0|  0.00%|            New value to include in EMA.
   223|         0|            0|            0|  0.00%|        mu  : float, optional
   224|         0|            0|            0|  0.00%|            Previous EMA value.
   225|         0|            0|            0|  0.00%|        alpha  : float, optional
   226|         0|            0|            0|  0.00%|            Smoothing factor in range [0, 1], [default: 0.3].
   227|         0|            0|            0|  0.00%|            Increase to give more weight to recent values.
   228|         0|            0|            0|  0.00%|            Ranges from 0 (yields mu) to 1 (yields x).
   229|         0|            0|            0|  0.00%|        """
   230|         0|            0|            0|  0.00%|        return x if mu is None else (alpha * x) + (1 - alpha) * mu
   231|         0|            0|            0|  0.00%|
   232|         0|            0|            0|  0.00%|    @staticmethod
   233|         0|            0|            0|  0.00%|    def status_printer(file):
   234|         0|            0|            0|  0.00%|        """
   235|         0|            0|            0|  0.00%|        Manage the printing and in-place updating of a line of characters.
   236|         0|            0|            0|  0.00%|        Note that if the string is longer than a line, then in-place
   237|         0|            0|            0|  0.00%|        updating may not work (it will print a new line at each refresh).
   238|         0|            0|            0|  0.00%|        """
   239|         0|            0|            0|  0.00%|        fp = file
   240|         0|            0|            0|  0.00%|        fp_flush = getattr(fp, 'flush', lambda: None)  # pragma: no cover
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|        def fp_write(s):
   243|         0|            0|            0|  0.00%|            fp.write(_unicode(s))
(call)|         8|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\ipykernel\iostream.py:384 write
   244|         0|            0|            0|  0.00%|            fp_flush()
(call)|         1|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\ipykernel\iostream.py:336 flush
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|        last_len = [0]
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|        def print_status(s):
   249|         0|            0|            0|  0.00%|            len_s = len(s)
   250|         0|            0|            0|  0.00%|            fp_write('\r' + s + (' ' * max(last_len[0] - len_s, 0)))
(call)|         9|            0|            0|  0.00%|# D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\package\tqdm\_tqdm.py:242 fp_write
   251|         0|            0|            0|  0.00%|            last_len[0] = len_s
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|        return print_status
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|    @staticmethod
   256|         0|            0|            0|  0.00%|    def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,
   257|         0|            0|            0|  0.00%|                     unit='it', unit_scale=False, rate=None, bar_format=None,
   258|         0|            0|            0|  0.00%|                     postfix=None, unit_divisor=1000, **extra_kwargs):
   259|         0|            0|            0|  0.00%|        """
   260|         0|            0|            0|  0.00%|        Return a string-based progress bar given some parameters
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|        Parameters
   263|         0|            0|            0|  0.00%|        ----------
   264|         0|            0|            0|  0.00%|        n  : int
   265|         0|            0|            0|  0.00%|            Number of finished iterations.
   266|         0|            0|            0|  0.00%|        total  : int
   267|         0|            0|            0|  0.00%|            The expected total number of iterations. If meaningless (), only
   268|         0|            0|            0|  0.00%|            basic progress statistics are displayed (no ETA).
   269|         0|            0|            0|  0.00%|        elapsed  : float
   270|         0|            0|            0|  0.00%|            Number of seconds passed since start.
   271|         0|            0|            0|  0.00%|        ncols  : int, optional
   272|         0|            0|            0|  0.00%|            The width of the entire output message. If specified,
   273|         0|            0|            0|  0.00%|            dynamically resizes the progress meter to stay within this bound
   274|         0|            0|            0|  0.00%|            [default: None]. The fallback meter width is 10 for the progress
   275|         0|            0|            0|  0.00%|            bar + no limit for the iterations counter and statistics. If 0,
   276|         0|            0|            0|  0.00%|            will not print any meter (only stats).
   277|         0|            0|            0|  0.00%|        prefix  : str, optional
   278|         0|            0|            0|  0.00%|            Prefix message (included in total width) [default: ''].
   279|         0|            0|            0|  0.00%|            Use as {desc} in bar_format string.
   280|         0|            0|            0|  0.00%|        ascii  : bool, optional or str, optional
   281|         0|            0|            0|  0.00%|            If not set, use unicode (smooth blocks) to fill the meter
   282|         0|            0|            0|  0.00%|            [default: False]. The fallback is to use ASCII characters
   283|         0|            0|            0|  0.00%|            " 123456789#".
   284|         0|            0|            0|  0.00%|        unit  : str, optional
   285|         0|            0|            0|  0.00%|            The iteration unit [default: 'it'].
   286|         0|            0|            0|  0.00%|        unit_scale  : bool or int or float, optional
   287|         0|            0|            0|  0.00%|            If 1 or True, the number of iterations will be printed with an
   288|         0|            0|            0|  0.00%|            appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)
   289|         0|            0|            0|  0.00%|            [default: False]. If any other non-zero number, will scale
   290|         0|            0|            0|  0.00%|            `total` and `n`.
   291|         0|            0|            0|  0.00%|        rate  : float, optional
   292|         0|            0|            0|  0.00%|            Manual override for iteration rate.
   293|         0|            0|            0|  0.00%|            If [default: None], uses n/elapsed.
   294|         0|            0|            0|  0.00%|        bar_format  : str, optional
   295|         0|            0|            0|  0.00%|            Specify a custom bar string formatting. May impact performance.
   296|         0|            0|            0|  0.00%|            [default: '{l_bar}{bar}{r_bar}'], where
   297|         0|            0|            0|  0.00%|            l_bar='{desc}: {percentage:3.0f}%|' and
   298|         0|            0|            0|  0.00%|            r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '
   299|         0|            0|            0|  0.00%|              '{rate_fmt}{postfix}]'
   300|         0|            0|            0|  0.00%|            Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,
   301|         0|            0|            0|  0.00%|              percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,
   302|         0|            0|            0|  0.00%|              rate_inv, rate_inv_fmt, elapsed, elapsed_s,
   303|         0|            0|            0|  0.00%|              remaining, remaining_s, desc, postfix, unit.
   304|         0|            0|            0|  0.00%|            Note that a trailing ": " is automatically removed after {desc}
   305|         0|            0|            0|  0.00%|            if the latter is empty.
   306|         0|            0|            0|  0.00%|        postfix  : *, optional
   307|         0|            0|            0|  0.00%|            Similar to `prefix`, but placed at the end
   308|         0|            0|            0|  0.00%|            (e.g. for additional stats).
   309|         0|            0|            0|  0.00%|            Note: postfix is usually a string (not a dict) for this method,
   310|         0|            0|            0|  0.00%|            and will if possible be set to postfix = ', ' + postfix.
   311|         0|            0|            0|  0.00%|            However other types are supported (#382).
   312|         0|            0|            0|  0.00%|        unit_divisor  : float, optional
   313|         0|            0|            0|  0.00%|            [default: 1000], ignored unless `unit_scale` is True.
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|        Returns
   316|         0|            0|            0|  0.00%|        -------
   317|         0|            0|            0|  0.00%|        out  : Formatted meter and stats, ready to display.
   318|         0|            0|            0|  0.00%|        """
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|        # sanity check: total
   321|         0|            0|            0|  0.00%|        if total and n > total:
   322|         0|            0|            0|  0.00%|            total = None
   323|         0|            0|            0|  0.00%|
   324|         0|            0|            0|  0.00%|        # apply custom scale if necessary
   325|         0|            0|            0|  0.00%|        if unit_scale and unit_scale not in (True, 1):
   326|         0|            0|            0|  0.00%|            if total:
   327|         0|            0|            0|  0.00%|                total *= unit_scale
   328|         0|            0|            0|  0.00%|            n *= unit_scale
   329|         0|            0|            0|  0.00%|            if rate:
   330|         0|            0|            0|  0.00%|                rate *= unit_scale  # by default rate = 1 / self.avg_time
   331|         0|            0|            0|  0.00%|            unit_scale = False
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|        elapsed_str = tqdm.format_interval(elapsed)
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|        # if unspecified, attempt to use rate = average speed
   336|         0|            0|            0|  0.00%|        # (we allow manual override since predicting time is an arcane art)
   337|         0|            0|            0|  0.00%|        if rate is None and elapsed:
   338|         0|            0|            0|  0.00%|            rate = n / elapsed
   339|         0|            0|            0|  0.00%|        inv_rate = 1 / rate if rate else None
   340|         0|            0|            0|  0.00%|        format_sizeof = tqdm.format_sizeof
   341|         0|            0|            0|  0.00%|        rate_noinv_fmt = ((format_sizeof(rate) if unit_scale else
   342|         0|            0|            0|  0.00%|                           '{0:5.2f}'.format(rate))
   343|         0|            0|            0|  0.00%|                          if rate else '?') + unit + '/s'
   344|         0|            0|            0|  0.00%|        rate_inv_fmt = ((format_sizeof(inv_rate) if unit_scale else
   345|         0|            0|            0|  0.00%|                         '{0:5.2f}'.format(inv_rate))
   346|         0|            0|            0|  0.00%|                        if inv_rate else '?') + 's/' + unit
   347|         0|            0|            0|  0.00%|        rate_fmt = rate_inv_fmt if inv_rate and inv_rate > 1 else rate_noinv_fmt
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|        if unit_scale:
   350|         0|            0|            0|  0.00%|            n_fmt = format_sizeof(n, divisor=unit_divisor)
   351|         0|            0|            0|  0.00%|            total_fmt = format_sizeof(total, divisor=unit_divisor) \
   352|         0|            0|            0|  0.00%|                if total is not None else '?'
   353|         0|            0|            0|  0.00%|        else:
   354|         0|            0|            0|  0.00%|            n_fmt = str(n)
   355|         0|            0|            0|  0.00%|            total_fmt = str(total) if total is not None else '?'
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|        try:
   358|         0|            0|            0|  0.00%|            postfix = ', ' + postfix if postfix else ''
   359|         0|            0|            0|  0.00%|        except TypeError:
   360|         0|            0|            0|  0.00%|            pass
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|        remaining = (total - n) / rate if rate and total else 0
   363|         0|            0|            0|  0.00%|        remaining_str = tqdm.format_interval(remaining) if rate else '?'
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|        # format the stats displayed to the left and right sides of the bar
   366|         0|            0|            0|  0.00%|        if prefix:
   367|         0|            0|            0|  0.00%|            # old prefix setup work around
   368|         0|            0|            0|  0.00%|            bool_prefix_colon_already = (prefix[-2:] == ": ")
   369|         0|            0|            0|  0.00%|            l_bar = prefix if bool_prefix_colon_already else prefix + ": "
   370|         0|            0|            0|  0.00%|        else:
   371|         0|            0|            0|  0.00%|            l_bar = ''
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|        r_bar = '| {0}/{1} [{2}<{3}, {4}{5}]'.format(
   374|         0|            0|            0|  0.00%|            n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt, postfix)
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|        # Custom bar formatting
   377|         0|            0|            0|  0.00%|        # Populate a dict with all available progress indicators
   378|         0|            0|            0|  0.00%|        format_dict = dict(
   379|         0|            0|            0|  0.00%|            n=n, n_fmt=n_fmt, total=total, total_fmt=total_fmt,
   380|         0|            0|            0|  0.00%|            rate=inv_rate if inv_rate and inv_rate > 1 else rate,
   381|         0|            0|            0|  0.00%|            rate_fmt=rate_fmt, rate_noinv=rate,
   382|         0|            0|            0|  0.00%|            rate_noinv_fmt=rate_noinv_fmt, rate_inv=inv_rate,
   383|         0|            0|            0|  0.00%|            rate_inv_fmt=rate_inv_fmt,
   384|         0|            0|            0|  0.00%|            elapsed=elapsed_str, elapsed_s=elapsed,
   385|         0|            0|            0|  0.00%|            remaining=remaining_str, remaining_s=remaining,
   386|         0|            0|            0|  0.00%|            l_bar=l_bar, r_bar=r_bar,
   387|         0|            0|            0|  0.00%|            desc=prefix or '', postfix=postfix, unit=unit,
   388|         0|            0|            0|  0.00%|            # bar=full_bar,  # replaced by procedure below
   389|         0|            0|            0|  0.00%|            **extra_kwargs)
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|        # total is known: we can predict some stats
   392|         0|            0|            0|  0.00%|        if total:
   393|         0|            0|            0|  0.00%|            # fractional and percentage progress
   394|         0|            0|            0|  0.00%|            frac = n / total
   395|         0|            0|            0|  0.00%|            percentage = frac * 100
   396|         0|            0|            0|  0.00%|
   397|         0|            0|            0|  0.00%|            l_bar += '{0:3.0f}%|'.format(percentage)
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|            if ncols == 0:
   400|         0|            0|            0|  0.00%|                return l_bar[:-1] + r_bar[1:]
   401|         0|            0|            0|  0.00%|
   402|         0|            0|            0|  0.00%|            if bar_format:
   403|         0|            0|            0|  0.00%|                format_dict.update(l_bar=l_bar, percentage=percentage)
   404|         0|            0|            0|  0.00%|                # , bar=full_bar  # replaced by procedure below
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|                # auto-remove colon for empty `desc`
   407|         0|            0|            0|  0.00%|                if not prefix:
   408|         0|            0|            0|  0.00%|                    bar_format = bar_format.replace("{desc}: ", '')
   409|         0|            0|            0|  0.00%|
   410|         0|            0|            0|  0.00%|                # Interpolate supplied bar format with the dict
   411|         0|            0|            0|  0.00%|                if '{bar}' in bar_format:
   412|         0|            0|            0|  0.00%|                    # Format left/right sides of the bar, and format the bar
   413|         0|            0|            0|  0.00%|                    # later in the remaining space (avoid breaking display)
   414|         0|            0|            0|  0.00%|                    l_bar_user, r_bar_user = bar_format.split('{bar}')
   415|         0|            0|            0|  0.00%|                    l_bar = l_bar_user.format(**format_dict)
   416|         0|            0|            0|  0.00%|                    r_bar = r_bar_user.format(**format_dict)
   417|         0|            0|            0|  0.00%|                else:
   418|         0|            0|            0|  0.00%|                    # Else no progress bar, we can just format and return
   419|         0|            0|            0|  0.00%|                    return bar_format.format(**format_dict)
   420|         0|            0|            0|  0.00%|
   421|         0|            0|            0|  0.00%|            # Formatting progress bar space available for bar's display
   422|         0|            0|            0|  0.00%|            if ncols:
   423|         0|            0|            0|  0.00%|                N_BARS = max(1, ncols - len(RE_ANSI.sub('', l_bar + r_bar)))
   424|         0|            0|            0|  0.00%|            else:
   425|         0|            0|            0|  0.00%|                N_BARS = 10
   426|         0|            0|            0|  0.00%|
   427|         0|            0|            0|  0.00%|            # format bar depending on availability of unicode/ascii chars
   428|         0|            0|            0|  0.00%|            if ascii is True:
   429|         0|            0|            0|  0.00%|                ascii = ASCII_FMT
   430|         0|            0|            0|  0.00%|            elif ascii is False:
   431|         0|            0|            0|  0.00%|                ascii = UTF_FMT
   432|         0|            0|            0|  0.00%|            nsyms = len(ascii) - 1
   433|         0|            0|            0|  0.00%|            bar_length, frac_bar_length = divmod(
   434|         0|            0|            0|  0.00%|                int(frac * N_BARS * nsyms), nsyms)
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|            bar = ascii[-1] * bar_length
   437|         0|            0|            0|  0.00%|            frac_bar = ascii[frac_bar_length]
   438|         0|            0|            0|  0.00%|
   439|         0|            0|            0|  0.00%|            # whitespace padding
   440|         0|            0|            0|  0.00%|            if bar_length < N_BARS:
   441|         0|            0|            0|  0.00%|                full_bar = bar + frac_bar + \
   442|         0|            0|            0|  0.00%|                    ascii[0] * (N_BARS - bar_length - 1)
   443|         0|            0|            0|  0.00%|            else:
   444|         0|            0|            0|  0.00%|                full_bar = bar + \
   445|         0|            0|            0|  0.00%|                    ascii[0] * (N_BARS - bar_length)
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|            # Piece together the bar parts
   448|         0|            0|            0|  0.00%|            return l_bar + full_bar + r_bar
   449|         0|            0|            0|  0.00%|
   450|         0|            0|            0|  0.00%|        elif bar_format:
   451|         0|            0|            0|  0.00%|            # user-specified bar_format but no total
   452|         0|            0|            0|  0.00%|            return bar_format.format(bar='?', **format_dict)
   453|         0|            0|            0|  0.00%|        else:
   454|         0|            0|            0|  0.00%|            # no total: no progressbar, ETA, just progress stats
   455|         0|            0|            0|  0.00%|            return ((prefix + ": ") if prefix else '') + \
   456|         0|            0|            0|  0.00%|                '{0}{1} [{2}, {3}{4}]'.format(
   457|         0|            0|            0|  0.00%|                    n_fmt, unit, elapsed_str, rate_fmt, postfix)
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|    def __new__(cls, *args, **kwargs):
   460|         0|            0|            0|  0.00%|        # Create a new instance
   461|         0|            0|            0|  0.00%|        instance = object.__new__(cls)
   462|         0|            0|            0|  0.00%|        # Construct the lock if it does not exist
   463|         0|            0|            0|  0.00%|        with cls.get_lock():
   464|         0|            0|            0|  0.00%|            # Add to the list of instances
   465|         0|            0|            0|  0.00%|            if not hasattr(cls, '_instances'):
   466|         0|            0|            0|  0.00%|                cls._instances = WeakSet()
   467|         0|            0|            0|  0.00%|            cls._instances.add(instance)
   468|         0|            0|            0|  0.00%|            # Create the monitoring thread
   469|         0|            0|            0|  0.00%|            if cls.monitor_interval and (cls.monitor is None or not
   470|         0|            0|            0|  0.00%|                                         cls.monitor.report()):
   471|         0|            0|            0|  0.00%|                try:
   472|         0|            0|            0|  0.00%|                    cls.monitor = TMonitor(cls, cls.monitor_interval)
   473|         0|            0|            0|  0.00%|                except Exception as e:  # pragma: nocover
   474|         0|            0|            0|  0.00%|                    warn("tqdm:disabling monitor support"
   475|         0|            0|            0|  0.00%|                         " (monitor_interval = 0) due to:\n" + str(e),
   476|         0|            0|            0|  0.00%|                         TqdmMonitorWarning)
   477|         0|            0|            0|  0.00%|                    cls.monitor_interval = 0
   478|         0|            0|            0|  0.00%|        # Return the instance
   479|         0|            0|            0|  0.00%|        return instance
   480|         0|            0|            0|  0.00%|
   481|         0|            0|            0|  0.00%|    @classmethod
   482|         0|            0|            0|  0.00%|    def _get_free_pos(cls, instance=None):
   483|         0|            0|            0|  0.00%|        """Skips specified instance."""
   484|         0|            0|            0|  0.00%|        positions = set(abs(inst.pos) for inst in cls._instances
   485|         0|            0|            0|  0.00%|                        if inst is not instance and hasattr(inst, "pos"))
   486|         0|            0|            0|  0.00%|        return min(set(range(len(positions) + 1)).difference(positions))
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|    @classmethod
   489|         0|            0|            0|  0.00%|    def _decr_instances(cls, instance):
   490|         0|            0|            0|  0.00%|        """
   491|         0|            0|            0|  0.00%|        Remove from list and reposition other bars
   492|         0|            0|            0|  0.00%|        so that newer bars won't overlap previous bars
   493|         0|            0|            0|  0.00%|        """
   494|         0|            0|            0|  0.00%|        with cls._lock:
   495|         0|            0|            0|  0.00%|            try:
   496|         0|            0|            0|  0.00%|                cls._instances.remove(instance)
   497|         0|            0|            0|  0.00%|            except KeyError:
   498|         0|            0|            0|  0.00%|                # if not instance.gui:  # pragma: no cover
   499|         0|            0|            0|  0.00%|                #     raise
   500|         0|            0|            0|  0.00%|                pass  # py2: maybe magically removed already
   501|         0|            0|            0|  0.00%|            # else:
   502|         0|            0|            0|  0.00%|            if not instance.gui:
   503|         0|            0|            0|  0.00%|                for inst in cls._instances:
   504|         0|            0|            0|  0.00%|                    # negative `pos` means fixed
   505|         0|            0|            0|  0.00%|                    if hasattr(inst, "pos") and inst.pos > abs(instance.pos):
   506|         0|            0|            0|  0.00%|                        inst.clear(nolock=True)
   507|         0|            0|            0|  0.00%|                        inst.pos -= 1
   508|         0|            0|            0|  0.00%|                        # TODO: check this doesn't overwrite another fixed bar
   509|         0|            0|            0|  0.00%|            # Kill monitor if no instances are left
   510|         0|            0|            0|  0.00%|            if not cls._instances and cls.monitor:
   511|         0|            0|            0|  0.00%|                try:
   512|         0|            0|            0|  0.00%|                    cls.monitor.exit()
   513|         0|            0|            0|  0.00%|                    del cls.monitor
   514|         0|            0|            0|  0.00%|                except AttributeError:  # pragma: nocover
   515|         0|            0|            0|  0.00%|                    pass
   516|         0|            0|            0|  0.00%|                else:
   517|         0|            0|            0|  0.00%|                    cls.monitor = None
   518|         0|            0|            0|  0.00%|
   519|         0|            0|            0|  0.00%|    @classmethod
   520|         0|            0|            0|  0.00%|    def write(cls, s, file=None, end="\n", nolock=False):
   521|         0|            0|            0|  0.00%|        """Print a message via tqdm (without overlap with bars)."""
   522|         0|            0|            0|  0.00%|        fp = file if file is not None else sys.stdout
   523|         0|            0|            0|  0.00%|        with cls.external_write_mode(file=file, nolock=nolock):
   524|         0|            0|            0|  0.00%|            # Write the message
   525|         0|            0|            0|  0.00%|            fp.write(s)
   526|         0|            0|            0|  0.00%|            fp.write(end)
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|    @classmethod
   529|         0|            0|            0|  0.00%|    @contextmanager
   530|         0|            0|            0|  0.00%|    def external_write_mode(cls, file=None, nolock=False):
   531|         0|            0|            0|  0.00%|        """
   532|         0|            0|            0|  0.00%|        Disable tqdm within context and refresh tqdm when exits.
   533|         0|            0|            0|  0.00%|        Useful when writing to standard output stream
   534|         0|            0|            0|  0.00%|        """
   535|         0|            0|            0|  0.00%|        fp = file if file is not None else sys.stdout
   536|         0|            0|            0|  0.00%|
   537|         0|            0|            0|  0.00%|        if not nolock:
   538|         0|            0|            0|  0.00%|            cls.get_lock().acquire()
   539|         0|            0|            0|  0.00%|        # Clear all bars
   540|         0|            0|            0|  0.00%|        inst_cleared = []
   541|         0|            0|            0|  0.00%|        for inst in getattr(cls, '_instances', []):
   542|         0|            0|            0|  0.00%|            # Clear instance if in the target output file
   543|         0|            0|            0|  0.00%|            # or if write output + tqdm output are both either
   544|         0|            0|            0|  0.00%|            # sys.stdout or sys.stderr (because both are mixed in terminal)
   545|         0|            0|            0|  0.00%|            if hasattr(inst, "start_t") and (inst.fp == fp or all(
   546|         0|            0|            0|  0.00%|                    f in (sys.stdout, sys.stderr) for f in (fp, inst.fp))):
   547|         0|            0|            0|  0.00%|                inst.clear(nolock=True)
   548|         0|            0|            0|  0.00%|                inst_cleared.append(inst)
   549|         0|            0|            0|  0.00%|        yield
   550|         0|            0|            0|  0.00%|        # Force refresh display of bars we cleared
   551|         0|            0|            0|  0.00%|        for inst in inst_cleared:
   552|         0|            0|            0|  0.00%|            inst.refresh(nolock=True)
   553|         0|            0|            0|  0.00%|        if not nolock:
   554|         0|            0|            0|  0.00%|            cls._lock.release()
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|    @classmethod
   557|         0|            0|            0|  0.00%|    def set_lock(cls, lock):
   558|         0|            0|            0|  0.00%|        """Set the global lock."""
   559|         0|            0|            0|  0.00%|        cls._lock = lock
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|    @classmethod
   562|         0|            0|            0|  0.00%|    def get_lock(cls):
   563|         0|            0|            0|  0.00%|        """Get the global lock. Construct it if it does not exist."""
   564|         0|            0|            0|  0.00%|        if not hasattr(cls, '_lock'):
   565|         0|            0|            0|  0.00%|            cls._lock = TqdmDefaultWriteLock()
   566|         0|            0|            0|  0.00%|        return cls._lock
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|    @classmethod
   569|         0|            0|            0|  0.00%|    def pandas(tclass, *targs, **tkwargs):
   570|         0|            0|            0|  0.00%|        """
   571|         0|            0|            0|  0.00%|        Registers the given `tqdm` class with
   572|         0|            0|            0|  0.00%|            pandas.core.
   573|         0|            0|            0|  0.00%|            ( frame.DataFrame
   574|         0|            0|            0|  0.00%|            | series.Series
   575|         0|            0|            0|  0.00%|            | groupby.(generic.)DataFrameGroupBy
   576|         0|            0|            0|  0.00%|            | groupby.(generic.)SeriesGroupBy
   577|         0|            0|            0|  0.00%|            ).progress_apply
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|        A new instance will be create every time `progress_apply` is called,
   580|         0|            0|            0|  0.00%|        and each instance will automatically close() upon completion.
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|        Parameters
   583|         0|            0|            0|  0.00%|        ----------
   584|         0|            0|            0|  0.00%|        targs, tkwargs  : arguments for the tqdm instance
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|        Examples
   587|         0|            0|            0|  0.00%|        --------
   588|         0|            0|            0|  0.00%|        >>> import pandas as pd
   589|         0|            0|            0|  0.00%|        >>> import numpy as np
   590|         0|            0|            0|  0.00%|        >>> from tqdm import tqdm, tqdm_gui
   591|         0|            0|            0|  0.00%|        >>>
   592|         0|            0|            0|  0.00%|        >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))
   593|         0|            0|            0|  0.00%|        >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc
   594|         0|            0|            0|  0.00%|        >>> # Now you can use `progress_apply` instead of `apply`
   595|         0|            0|            0|  0.00%|        >>> df.groupby(0).progress_apply(lambda x: x**2)
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|        References
   598|         0|            0|            0|  0.00%|        ----------
   599|         0|            0|            0|  0.00%|        https://stackoverflow.com/questions/18603270/
   600|         0|            0|            0|  0.00%|        progress-indicator-during-pandas-operations-python
   601|         0|            0|            0|  0.00%|        """
   602|         0|            0|            0|  0.00%|        from pandas.core.frame import DataFrame
   603|         0|            0|            0|  0.00%|        from pandas.core.series import Series
   604|         0|            0|            0|  0.00%|        from pandas import Panel
   605|         0|            0|            0|  0.00%|        try:  # pandas>=0.18.0
   606|         0|            0|            0|  0.00%|            from pandas.core.window import _Rolling_and_Expanding
   607|         0|            0|            0|  0.00%|        except ImportError:  # pragma: no cover
   608|         0|            0|            0|  0.00%|            _Rolling_and_Expanding = None
   609|         0|            0|            0|  0.00%|        try:  # pandas>=0.25.0
   610|         0|            0|            0|  0.00%|            from pandas.core.groupby.generic import DataFrameGroupBy, \
   611|         0|            0|            0|  0.00%|                SeriesGroupBy  # , NDFrameGroupBy
   612|         0|            0|            0|  0.00%|        except ImportError:
   613|         0|            0|            0|  0.00%|            try:  # pandas>=0.23.0
   614|         0|            0|            0|  0.00%|                from pandas.core.groupby.groupby import DataFrameGroupBy, \
   615|         0|            0|            0|  0.00%|                    SeriesGroupBy
   616|         0|            0|            0|  0.00%|            except ImportError:
   617|         0|            0|            0|  0.00%|                from pandas.core.groupby import DataFrameGroupBy, \
   618|         0|            0|            0|  0.00%|                    SeriesGroupBy
   619|         0|            0|            0|  0.00%|        try:  # pandas>=0.23.0
   620|         0|            0|            0|  0.00%|            from pandas.core.groupby.groupby import GroupBy
   621|         0|            0|            0|  0.00%|        except ImportError:
   622|         0|            0|            0|  0.00%|            from pandas.core.groupby import GroupBy
   623|         0|            0|            0|  0.00%|
   624|         0|            0|            0|  0.00%|        try:  # pandas>=0.23.0
   625|         0|            0|            0|  0.00%|            from pandas.core.groupby.groupby import PanelGroupBy
   626|         0|            0|            0|  0.00%|        except ImportError:
   627|         0|            0|            0|  0.00%|            try:
   628|         0|            0|            0|  0.00%|                from pandas.core.groupby import PanelGroupBy
   629|         0|            0|            0|  0.00%|            except ImportError:  # pandas>=0.25.0
   630|         0|            0|            0|  0.00%|                PanelGroupBy = None
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|        deprecated_t = [tkwargs.pop('deprecated_t', None)]
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|        def inner_generator(df_function='apply'):
   635|         0|            0|            0|  0.00%|            def inner(df, func, *args, **kwargs):
   636|         0|            0|            0|  0.00%|                """
   637|         0|            0|            0|  0.00%|                Parameters
   638|         0|            0|            0|  0.00%|                ----------
   639|         0|            0|            0|  0.00%|                df  : (DataFrame|Series)[GroupBy]
   640|         0|            0|            0|  0.00%|                    Data (may be grouped).
   641|         0|            0|            0|  0.00%|                func  : function
   642|         0|            0|            0|  0.00%|                    To be applied on the (grouped) data.
   643|         0|            0|            0|  0.00%|                **kwargs  : optional
   644|         0|            0|            0|  0.00%|                    Transmitted to `df.apply()`.
   645|         0|            0|            0|  0.00%|                """
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|                # Precompute total iterations
   648|         0|            0|            0|  0.00%|                total = tkwargs.pop("total", getattr(df, 'ngroups', None))
   649|         0|            0|            0|  0.00%|                if total is None:  # not grouped
   650|         0|            0|            0|  0.00%|                    if df_function == 'applymap':
   651|         0|            0|            0|  0.00%|                        total = df.size
   652|         0|            0|            0|  0.00%|                    elif isinstance(df, Series):
   653|         0|            0|            0|  0.00%|                        total = len(df)
   654|         0|            0|            0|  0.00%|                    elif _Rolling_and_Expanding is None or \
   655|         0|            0|            0|  0.00%|                            not isinstance(df, _Rolling_and_Expanding):
   656|         0|            0|            0|  0.00%|                        # DataFrame or Panel
   657|         0|            0|            0|  0.00%|                        axis = kwargs.get('axis', 0)
   658|         0|            0|            0|  0.00%|                        if axis == 'index':
   659|         0|            0|            0|  0.00%|                            axis = 0
   660|         0|            0|            0|  0.00%|                        elif axis == 'columns':
   661|         0|            0|            0|  0.00%|                            axis = 1
   662|         0|            0|            0|  0.00%|                        # when axis=0, total is shape[axis1]
   663|         0|            0|            0|  0.00%|                        total = df.size // df.shape[axis]
   664|         0|            0|            0|  0.00%|
   665|         0|            0|            0|  0.00%|                # Init bar
   666|         0|            0|            0|  0.00%|                if deprecated_t[0] is not None:
   667|         0|            0|            0|  0.00%|                    t = deprecated_t[0]
   668|         0|            0|            0|  0.00%|                    deprecated_t[0] = None
   669|         0|            0|            0|  0.00%|                else:
   670|         0|            0|            0|  0.00%|                    t = tclass(*targs, total=total, **tkwargs)
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|                if len(args) > 0:
   673|         0|            0|            0|  0.00%|                    # *args intentionally not supported (see #244, #299)
   674|         0|            0|            0|  0.00%|                    TqdmDeprecationWarning(
   675|         0|            0|            0|  0.00%|                        "Except func, normal arguments are intentionally" +
   676|         0|            0|            0|  0.00%|                        " not supported by" +
   677|         0|            0|            0|  0.00%|                        " `(DataFrame|Series|GroupBy).progress_apply`." +
   678|         0|            0|            0|  0.00%|                        " Use keyword arguments instead.",
   679|         0|            0|            0|  0.00%|                        fp_write=getattr(t.fp, 'write', sys.stderr.write))
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|                # Define bar updating wrapper
   682|         0|            0|            0|  0.00%|                def wrapper(*args, **kwargs):
   683|         0|            0|            0|  0.00%|                    # update tbar correctly
   684|         0|            0|            0|  0.00%|                    # it seems `pandas apply` calls `func` twice
   685|         0|            0|            0|  0.00%|                    # on the first column/row to decide whether it can
   686|         0|            0|            0|  0.00%|                    # take a fast or slow code path; so stop when t.total==t.n
   687|         0|            0|            0|  0.00%|                    t.update(n=1 if not t.total or t.n < t.total else 0)
   688|         0|            0|            0|  0.00%|                    return func(*args, **kwargs)
   689|         0|            0|            0|  0.00%|
   690|         0|            0|            0|  0.00%|                # Apply the provided function (in **kwargs)
   691|         0|            0|            0|  0.00%|                # on the df using our wrapper (which provides bar updating)
   692|         0|            0|            0|  0.00%|                result = getattr(df, df_function)(wrapper, **kwargs)
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|                # Close bar and return pandas calculation result
   695|         0|            0|            0|  0.00%|                t.close()
   696|         0|            0|            0|  0.00%|                return result
   697|         0|            0|            0|  0.00%|
   698|         0|            0|            0|  0.00%|            return inner
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|        # Monkeypatch pandas to provide easy methods
   701|         0|            0|            0|  0.00%|        # Enable custom tqdm progress in pandas!
   702|         0|            0|            0|  0.00%|        Series.progress_apply = inner_generator()
   703|         0|            0|            0|  0.00%|        SeriesGroupBy.progress_apply = inner_generator()
   704|         0|            0|            0|  0.00%|        Series.progress_map = inner_generator('map')
   705|         0|            0|            0|  0.00%|        SeriesGroupBy.progress_map = inner_generator('map')
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|        DataFrame.progress_apply = inner_generator()
   708|         0|            0|            0|  0.00%|        DataFrameGroupBy.progress_apply = inner_generator()
   709|         0|            0|            0|  0.00%|        DataFrame.progress_applymap = inner_generator('applymap')
   710|         0|            0|            0|  0.00%|
   711|         0|            0|            0|  0.00%|        Panel.progress_apply = inner_generator()
   712|         0|            0|            0|  0.00%|        if PanelGroupBy is not None:
   713|         0|            0|            0|  0.00%|            PanelGroupBy.progress_apply = inner_generator()
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|        GroupBy.progress_apply = inner_generator()
   716|         0|            0|            0|  0.00%|        GroupBy.progress_aggregate = inner_generator('aggregate')
   717|         0|            0|            0|  0.00%|        GroupBy.progress_transform = inner_generator('transform')
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|        if _Rolling_and_Expanding is not None:  # pragma: no cover
   720|         0|            0|            0|  0.00%|            _Rolling_and_Expanding.progress_apply = inner_generator()
   721|         0|            0|            0|  0.00%|
   722|         0|            0|            0|  0.00%|    def __init__(self, iterable=None, desc=None, total=None, leave=True,
   723|         0|            0|            0|  0.00%|                 file=None, ncols=None, mininterval=0.1, maxinterval=10.0,
   724|         0|            0|            0|  0.00%|                 miniters=None, ascii=None, disable=False, unit='it',
   725|         0|            0|            0|  0.00%|                 unit_scale=False, dynamic_ncols=False, smoothing=0.3,
   726|         0|            0|            0|  0.00%|                 bar_format=None, initial=0, position=None, postfix=None,
   727|         0|            0|            0|  0.00%|                 unit_divisor=1000, write_bytes=None, gui=False, **kwargs):
   728|         0|            0|            0|  0.00%|        """
   729|         0|            0|            0|  0.00%|        Parameters
   730|         0|            0|            0|  0.00%|        ----------
   731|         0|            0|            0|  0.00%|        iterable  : iterable, optional
   732|         0|            0|            0|  0.00%|            Iterable to decorate with a progressbar.
   733|         0|            0|            0|  0.00%|            Leave blank to manually manage the updates.
   734|         0|            0|            0|  0.00%|        desc  : str, optional
   735|         0|            0|            0|  0.00%|            Prefix for the progressbar.
   736|         0|            0|            0|  0.00%|        total  : int, optional
   737|         0|            0|            0|  0.00%|            The number of expected iterations. If unspecified,
   738|         0|            0|            0|  0.00%|            len(iterable) is used if possible. If float("inf") or as a last
   739|         0|            0|            0|  0.00%|            resort, only basic progress statistics are displayed
   740|         0|            0|            0|  0.00%|            (no ETA, no progressbar).
   741|         0|            0|            0|  0.00%|            If `gui` is True and this parameter needs subsequent updating,
   742|         0|            0|            0|  0.00%|            specify an initial arbitrary large positive integer,
   743|         0|            0|            0|  0.00%|            e.g. int(9e9).
   744|         0|            0|            0|  0.00%|        leave  : bool, optional
   745|         0|            0|            0|  0.00%|            If [default: True], keeps all traces of the progressbar
   746|         0|            0|            0|  0.00%|            upon termination of iteration.
   747|         0|            0|            0|  0.00%|            If `None`, will leave only if `position` is `0`.
   748|         0|            0|            0|  0.00%|        file  : `io.TextIOWrapper` or `io.StringIO`, optional
   749|         0|            0|            0|  0.00%|            Specifies where to output the progress messages
   750|         0|            0|            0|  0.00%|            (default: sys.stderr). Uses `file.write(str)` and `file.flush()`
   751|         0|            0|            0|  0.00%|            methods.  For encoding, see `write_bytes`.
   752|         0|            0|            0|  0.00%|        ncols  : int, optional
   753|         0|            0|            0|  0.00%|            The width of the entire output message. If specified,
   754|         0|            0|            0|  0.00%|            dynamically resizes the progressbar to stay within this bound.
   755|         0|            0|            0|  0.00%|            If unspecified, attempts to use environment width. The
   756|         0|            0|            0|  0.00%|            fallback is a meter width of 10 and no limit for the counter and
   757|         0|            0|            0|  0.00%|            statistics. If 0, will not print any meter (only stats).
   758|         0|            0|            0|  0.00%|        mininterval  : float, optional
   759|         0|            0|            0|  0.00%|            Minimum progress display update interval [default: 0.1] seconds.
   760|         0|            0|            0|  0.00%|        maxinterval  : float, optional
   761|         0|            0|            0|  0.00%|            Maximum progress display update interval [default: 10] seconds.
   762|         0|            0|            0|  0.00%|            Automatically adjusts `miniters` to correspond to `mininterval`
   763|         0|            0|            0|  0.00%|            after long display update lag. Only works if `dynamic_miniters`
   764|         0|            0|            0|  0.00%|            or monitor thread is enabled.
   765|         0|            0|            0|  0.00%|        miniters  : int, optional
   766|         0|            0|            0|  0.00%|            Minimum progress display update interval, in iterations.
   767|         0|            0|            0|  0.00%|            If 0 and `dynamic_miniters`, will automatically adjust to equal
   768|         0|            0|            0|  0.00%|            `mininterval` (more CPU efficient, good for tight loops).
   769|         0|            0|            0|  0.00%|            If > 0, will skip display of specified number of iterations.
   770|         0|            0|            0|  0.00%|            Tweak this and `mininterval` to get very efficient loops.
   771|         0|            0|            0|  0.00%|            If your progress is erratic with both fast and slow iterations
   772|         0|            0|            0|  0.00%|            (network, skipping items, etc) you should set miniters=1.
   773|         0|            0|            0|  0.00%|        ascii  : bool or str, optional
   774|         0|            0|            0|  0.00%|            If unspecified or False, use unicode (smooth blocks) to fill
   775|         0|            0|            0|  0.00%|            the meter. The fallback is to use ASCII characters " 123456789#".
   776|         0|            0|            0|  0.00%|        disable  : bool, optional
   777|         0|            0|            0|  0.00%|            Whether to disable the entire progressbar wrapper
   778|         0|            0|            0|  0.00%|            [default: False]. If set to None, disable on non-TTY.
   779|         0|            0|            0|  0.00%|        unit  : str, optional
   780|         0|            0|            0|  0.00%|            String that will be used to define the unit of each iteration
   781|         0|            0|            0|  0.00%|            [default: it].
   782|         0|            0|            0|  0.00%|        unit_scale  : bool or int or float, optional
   783|         0|            0|            0|  0.00%|            If 1 or True, the number of iterations will be reduced/scaled
   784|         0|            0|            0|  0.00%|            automatically and a metric prefix following the
   785|         0|            0|            0|  0.00%|            International System of Units standard will be added
   786|         0|            0|            0|  0.00%|            (kilo, mega, etc.) [default: False]. If any other non-zero
   787|         0|            0|            0|  0.00%|            number, will scale `total` and `n`.
   788|         0|            0|            0|  0.00%|        dynamic_ncols  : bool, optional
   789|         0|            0|            0|  0.00%|            If set, constantly alters `ncols` to the environment (allowing
   790|         0|            0|            0|  0.00%|            for window resizes) [default: False].
   791|         0|            0|            0|  0.00%|        smoothing  : float, optional
   792|         0|            0|            0|  0.00%|            Exponential moving average smoothing factor for speed estimates
   793|         0|            0|            0|  0.00%|            (ignored in GUI mode). Ranges from 0 (average speed) to 1
   794|         0|            0|            0|  0.00%|            (current/instantaneous speed) [default: 0.3].
   795|         0|            0|            0|  0.00%|        bar_format  : str, optional
   796|         0|            0|            0|  0.00%|            Specify a custom bar string formatting. May impact performance.
   797|         0|            0|            0|  0.00%|            [default: '{l_bar}{bar}{r_bar}'], where
   798|         0|            0|            0|  0.00%|            l_bar='{desc}: {percentage:3.0f}%|' and
   799|         0|            0|            0|  0.00%|            r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '
   800|         0|            0|            0|  0.00%|              '{rate_fmt}{postfix}]'
   801|         0|            0|            0|  0.00%|            Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,
   802|         0|            0|            0|  0.00%|              percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,
   803|         0|            0|            0|  0.00%|              rate_inv, rate_inv_fmt, elapsed, elapsed_s, remaining,
   804|         0|            0|            0|  0.00%|              remaining_s, desc, postfix, unit.
   805|         0|            0|            0|  0.00%|            Note that a trailing ": " is automatically removed after {desc}
   806|         0|            0|            0|  0.00%|            if the latter is empty.
   807|         0|            0|            0|  0.00%|        initial  : int, optional
   808|         0|            0|            0|  0.00%|            The initial counter value. Useful when restarting a progress
   809|         0|            0|            0|  0.00%|            bar [default: 0].
   810|         0|            0|            0|  0.00%|        position  : int, optional
   811|         0|            0|            0|  0.00%|            Specify the line offset to print this bar (starting from 0)
   812|         0|            0|            0|  0.00%|            Automatic if unspecified.
   813|         0|            0|            0|  0.00%|            Useful to manage multiple bars at once (eg, from threads).
   814|         0|            0|            0|  0.00%|        postfix  : dict or *, optional
   815|         0|            0|            0|  0.00%|            Specify additional stats to display at the end of the bar.
   816|         0|            0|            0|  0.00%|            Calls `set_postfix(**postfix)` if possible (dict).
   817|         0|            0|            0|  0.00%|        unit_divisor  : float, optional
   818|         0|            0|            0|  0.00%|            [default: 1000], ignored unless `unit_scale` is True.
   819|         0|            0|            0|  0.00%|        write_bytes  : bool, optional
   820|         0|            0|            0|  0.00%|            If (default: None) and `file` is unspecified,
   821|         0|            0|            0|  0.00%|            bytes will be written in Python 2. If `True` will also write
   822|         0|            0|            0|  0.00%|            bytes. In all other cases will default to unicode.
   823|         0|            0|            0|  0.00%|        gui  : bool, optional
   824|         0|            0|            0|  0.00%|            WARNING: internal parameter - do not use.
   825|         0|            0|            0|  0.00%|            Use tqdm_gui(...) instead. If set, will attempt to use
   826|         0|            0|            0|  0.00%|            matplotlib animations for a graphical output [default: False].
   827|         0|            0|            0|  0.00%|
   828|         0|            0|            0|  0.00%|        Returns
   829|         0|            0|            0|  0.00%|        -------
   830|         0|            0|            0|  0.00%|        out  : decorated iterator.
   831|         0|            0|            0|  0.00%|        """
   832|         0|            0|            0|  0.00%|        if write_bytes is None:
   833|         0|            0|            0|  0.00%|            write_bytes = file is None and sys.version_info < (3,)
   834|         0|            0|            0|  0.00%|
   835|         0|            0|            0|  0.00%|        if file is None:
   836|         0|            0|            0|  0.00%|            file = sys.stderr
   837|         0|            0|            0|  0.00%|
   838|         0|            0|            0|  0.00%|        if write_bytes:
   839|         0|            0|            0|  0.00%|            # Despite coercing unicode into bytes, py2 sys.std* streams
   840|         0|            0|            0|  0.00%|            # should have bytes written to them.
   841|         0|            0|            0|  0.00%|            file = SimpleTextIOWrapper(
   842|         0|            0|            0|  0.00%|                file, encoding=getattr(file, 'encoding', None) or 'utf-8')
   843|         0|            0|            0|  0.00%|
   844|         0|            0|            0|  0.00%|        if disable is None and hasattr(file, "isatty") and not file.isatty():
   845|         0|            0|            0|  0.00%|            disable = True
   846|         0|            0|            0|  0.00%|
   847|         0|            0|            0|  0.00%|        if total is None and iterable is not None:
   848|         0|            0|            0|  0.00%|            try:
   849|         0|            0|            0|  0.00%|                total = len(iterable)
   850|         0|            0|            0|  0.00%|            except (TypeError, AttributeError):
   851|         0|            0|            0|  0.00%|                total = None
   852|         0|            0|            0|  0.00%|        if total == float("inf"):
   853|         0|            0|            0|  0.00%|            # Infinite iterations, behave same as unknown
   854|         0|            0|            0|  0.00%|            total = None
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|        if disable:
   857|         0|            0|            0|  0.00%|            self.iterable = iterable
   858|         0|            0|            0|  0.00%|            self.disable = disable
   859|         0|            0|            0|  0.00%|            with self._lock:
   860|         0|            0|            0|  0.00%|                self.pos = self._get_free_pos(self)
   861|         0|            0|            0|  0.00%|                self._instances.remove(self)
   862|         0|            0|            0|  0.00%|            self.n = initial
   863|         0|            0|            0|  0.00%|            self.total = total
   864|         0|            0|            0|  0.00%|            return
   865|         0|            0|            0|  0.00%|
   866|         0|            0|            0|  0.00%|        if kwargs:
   867|         0|            0|            0|  0.00%|            self.disable = True
   868|         0|            0|            0|  0.00%|            with self._lock:
   869|         0|            0|            0|  0.00%|                self.pos = self._get_free_pos(self)
   870|         0|            0|            0|  0.00%|                self._instances.remove(self)
   871|         0|            0|            0|  0.00%|            from textwrap import dedent
   872|         0|            0|            0|  0.00%|            raise (TqdmDeprecationWarning(dedent("""\
   873|         0|            0|            0|  0.00%|                       `nested` is deprecated and automated.
   874|         0|            0|            0|  0.00%|                       Use `position` instead for manual control.
   875|         0|            0|            0|  0.00%|                       """), fp_write=getattr(file, 'write', sys.stderr.write))
   876|         0|            0|            0|  0.00%|                   if "nested" in kwargs else
   877|         0|            0|            0|  0.00%|                   TqdmKeyError("Unknown argument(s): " + str(kwargs)))
   878|         0|            0|            0|  0.00%|
   879|         0|            0|            0|  0.00%|        # Preprocess the arguments
   880|         0|            0|            0|  0.00%|        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \
   881|         0|            0|            0|  0.00%|                dynamic_ncols:  # pragma: no cover
   882|         0|            0|            0|  0.00%|            if dynamic_ncols:
   883|         0|            0|            0|  0.00%|                dynamic_ncols = _environ_cols_wrapper()
   884|         0|            0|            0|  0.00%|                if dynamic_ncols:
   885|         0|            0|            0|  0.00%|                    ncols = dynamic_ncols(file)
   886|         0|            0|            0|  0.00%|                # elif ncols is not None:
   887|         0|            0|            0|  0.00%|                #     ncols = 79
   888|         0|            0|            0|  0.00%|            else:
   889|         0|            0|            0|  0.00%|                _dynamic_ncols = _environ_cols_wrapper()
   890|         0|            0|            0|  0.00%|                if _dynamic_ncols:
   891|         0|            0|            0|  0.00%|                    ncols = _dynamic_ncols(file)
   892|         0|            0|            0|  0.00%|                # else:
   893|         0|            0|            0|  0.00%|                #     ncols = 79
   894|         0|            0|            0|  0.00%|
   895|         0|            0|            0|  0.00%|        if miniters is None:
   896|         0|            0|            0|  0.00%|            miniters = 0
   897|         0|            0|            0|  0.00%|            dynamic_miniters = True
   898|         0|            0|            0|  0.00%|        else:
   899|         0|            0|            0|  0.00%|            dynamic_miniters = False
   900|         0|            0|            0|  0.00%|
   901|         0|            0|            0|  0.00%|        if mininterval is None:
   902|         0|            0|            0|  0.00%|            mininterval = 0
   903|         0|            0|            0|  0.00%|
   904|         0|            0|            0|  0.00%|        if maxinterval is None:
   905|         0|            0|            0|  0.00%|            maxinterval = 0
   906|         0|            0|            0|  0.00%|
   907|         0|            0|            0|  0.00%|        if ascii is None:
   908|         0|            0|            0|  0.00%|            ascii = not _supports_unicode(file)
   909|         0|            0|            0|  0.00%|
   910|         0|            0|            0|  0.00%|        if bar_format and not ((ascii is True) or _is_ascii(ascii)):
   911|         0|            0|            0|  0.00%|            # Convert bar format into unicode since terminal uses unicode
   912|         0|            0|            0|  0.00%|            bar_format = _unicode(bar_format)
   913|         0|            0|            0|  0.00%|
   914|         0|            0|            0|  0.00%|        if smoothing is None:
   915|         0|            0|            0|  0.00%|            smoothing = 0
   916|         0|            0|            0|  0.00%|
   917|         0|            0|            0|  0.00%|        # Store the arguments
   918|         0|            0|            0|  0.00%|        self.iterable = iterable
   919|         0|            0|            0|  0.00%|        self.desc = desc or ''
   920|         0|            0|            0|  0.00%|        self.total = total
   921|         0|            0|            0|  0.00%|        self.leave = leave
   922|         0|            0|            0|  0.00%|        self.fp = file
   923|         0|            0|            0|  0.00%|        self.ncols = ncols
   924|         0|            0|            0|  0.00%|        self.mininterval = mininterval
   925|         0|            0|            0|  0.00%|        self.maxinterval = maxinterval
   926|         0|            0|            0|  0.00%|        self.miniters = miniters
   927|         0|            0|            0|  0.00%|        self.dynamic_miniters = dynamic_miniters
   928|         0|            0|            0|  0.00%|        self.ascii = ascii
   929|         0|            0|            0|  0.00%|        self.disable = disable
   930|         0|            0|            0|  0.00%|        self.unit = unit
   931|         0|            0|            0|  0.00%|        self.unit_scale = unit_scale
   932|         0|            0|            0|  0.00%|        self.unit_divisor = unit_divisor
   933|         0|            0|            0|  0.00%|        self.gui = gui
   934|         0|            0|            0|  0.00%|        self.dynamic_ncols = dynamic_ncols
   935|         0|            0|            0|  0.00%|        self.smoothing = smoothing
   936|         0|            0|            0|  0.00%|        self.avg_time = None
   937|         0|            0|            0|  0.00%|        self._time = time
   938|         0|            0|            0|  0.00%|        self.bar_format = bar_format
   939|         0|            0|            0|  0.00%|        self.postfix = None
   940|         0|            0|            0|  0.00%|        if postfix:
   941|         0|            0|            0|  0.00%|            try:
   942|         0|            0|            0|  0.00%|                self.set_postfix(refresh=False, **postfix)
   943|         0|            0|            0|  0.00%|            except TypeError:
   944|         0|            0|            0|  0.00%|                self.postfix = postfix
   945|         0|            0|            0|  0.00%|
   946|         0|            0|            0|  0.00%|        # Init the iterations counters
   947|         0|            0|            0|  0.00%|        self.last_print_n = initial
   948|         0|            0|            0|  0.00%|        self.n = initial
   949|         0|            0|            0|  0.00%|
   950|         0|            0|            0|  0.00%|        # if nested, at initial sp() call we replace '\r' by '\n' to
   951|         0|            0|            0|  0.00%|        # not overwrite the outer progress bar
   952|         0|            0|            0|  0.00%|        with self._lock:
   953|         0|            0|            0|  0.00%|            if position is None:
   954|         0|            0|            0|  0.00%|                self.pos = self._get_free_pos(self)
   955|         0|            0|            0|  0.00%|            else:  # mark fixed positions as negative
   956|         0|            0|            0|  0.00%|                self.pos = -position
   957|         0|            0|            0|  0.00%|
   958|         0|            0|            0|  0.00%|        if not gui:
   959|         0|            0|            0|  0.00%|            # Initialize the screen printer
   960|         0|            0|            0|  0.00%|            self.sp = self.status_printer(self.fp)
   961|         0|            0|            0|  0.00%|            with self._lock:
   962|         0|            0|            0|  0.00%|                self.display()
   963|         0|            0|            0|  0.00%|
   964|         0|            0|            0|  0.00%|        # Init the time counter
   965|         0|            0|            0|  0.00%|        self.last_print_t = self._time()
   966|         0|            0|            0|  0.00%|        # NB: Avoid race conditions by setting start_t at the very end of init
   967|         0|            0|            0|  0.00%|        self.start_t = self.last_print_t
   968|         0|            0|            0|  0.00%|
   969|         0|            0|            0|  0.00%|    def __bool__(self):
   970|         0|            0|            0|  0.00%|        if self.total is not None:
   971|         0|            0|            0|  0.00%|            return self.total > 0
   972|         0|            0|            0|  0.00%|        if self.iterable is None:
   973|         0|            0|            0|  0.00%|            raise TypeError('bool() undefined when iterable == total == None')
   974|         0|            0|            0|  0.00%|        return bool(self.iterable)
   975|         0|            0|            0|  0.00%|
   976|         0|            0|            0|  0.00%|    def __nonzero__(self):
   977|         0|            0|            0|  0.00%|        return self.__bool__()
   978|         0|            0|            0|  0.00%|
   979|         0|            0|            0|  0.00%|    def __len__(self):
   980|         0|            0|            0|  0.00%|        return self.total if self.iterable is None else \
   981|         0|            0|            0|  0.00%|            (self.iterable.shape[0] if hasattr(self.iterable, "shape")
   982|         0|            0|            0|  0.00%|             else len(self.iterable) if hasattr(self.iterable, "__len__")
   983|         0|            0|            0|  0.00%|             else getattr(self, "total", None))
   984|         0|            0|            0|  0.00%|
   985|         0|            0|            0|  0.00%|    def __enter__(self):
   986|         0|            0|            0|  0.00%|        return self
   987|         0|            0|            0|  0.00%|
   988|         0|            0|            0|  0.00%|    def __exit__(self, *exc):
   989|         0|            0|            0|  0.00%|        self.close()
   990|         0|            0|            0|  0.00%|        return False
   991|         0|            0|            0|  0.00%|
   992|         0|            0|            0|  0.00%|    def __del__(self):
   993|         0|            0|            0|  0.00%|        self.close()
   994|         0|            0|            0|  0.00%|
   995|         0|            0|            0|  0.00%|    def __repr__(self):
   996|         0|            0|            0|  0.00%|        return self.format_meter(**self.format_dict)
   997|         0|            0|            0|  0.00%|
   998|         0|            0|            0|  0.00%|    @property
   999|         0|            0|            0|  0.00%|    def _comparable(self):
  1000|         0|            0|            0|  0.00%|        return abs(getattr(self, "pos", 1 << 31))
  1001|         0|            0|            0|  0.00%|
  1002|         0|            0|            0|  0.00%|    def __hash__(self):
  1003|         0|            0|            0|  0.00%|        return id(self)
  1004|         0|            0|            0|  0.00%|
  1005|         0|            0|            0|  0.00%|    def __iter__(self):
  1006|         0|            0|            0|  0.00%|        """Backward-compatibility to use: for x in tqdm(iterable)"""
  1007|         0|            0|            0|  0.00%|
  1008|         0|            0|            0|  0.00%|        # Inlining instance variables as locals (speed optimisation)
  1009|         0|            0|            0|  0.00%|        iterable = self.iterable
  1010|         0|            0|            0|  0.00%|
  1011|         0|            0|            0|  0.00%|        # If the bar is disabled, then just walk the iterable
  1012|         0|            0|            0|  0.00%|        # (note: keep this check outside the loop for performance)
  1013|         0|            0|            0|  0.00%|        if self.disable:
  1014|         0|            0|            0|  0.00%|            for obj in iterable:
  1015|         0|            0|            0|  0.00%|                yield obj
  1016|         0|            0|            0|  0.00%|        else:
  1017|         0|            0|            0|  0.00%|            mininterval = self.mininterval
  1018|         0|            0|            0|  0.00%|            maxinterval = self.maxinterval
  1019|         0|            0|            0|  0.00%|            miniters = self.miniters
  1020|         0|            0|            0|  0.00%|            dynamic_miniters = self.dynamic_miniters
  1021|         0|            0|            0|  0.00%|            last_print_t = self.last_print_t
  1022|         0|            0|            0|  0.00%|            last_print_n = self.last_print_n
  1023|         0|            0|            0|  0.00%|            n = self.n
  1024|         0|            0|            0|  0.00%|            smoothing = self.smoothing
  1025|         0|            0|            0|  0.00%|            avg_time = self.avg_time
  1026|         0|            0|            0|  0.00%|            _time = self._time
  1027|         0|            0|            0|  0.00%|
  1028|         0|            0|            0|  0.00%|            if not hasattr(self, 'sp'):
  1029|         0|            0|            0|  0.00%|                from textwrap import dedent
  1030|         0|            0|            0|  0.00%|                raise TqdmDeprecationWarning(dedent("""\
  1031|         0|            0|            0|  0.00%|                Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`
  1032|         0|            0|            0|  0.00%|                """), fp_write=getattr(self.fp, 'write', sys.stderr.write))
  1033|         0|            0|            0|  0.00%|
  1034|         0|            0|            0|  0.00%|            for obj in iterable:
  1035|         0|            0|            0|  0.00%|                yield obj
  1036|         0|            0|            0|  0.00%|                # Update and possibly print the progressbar.
  1037|         0|            0|            0|  0.00%|                # Note: does not call self.update(1) for speed optimisation.
  1038|         0|            0|            0|  0.00%|                n += 1
  1039|         0|            0|            0|  0.00%|                # check counter first to avoid calls to time()
  1040|         0|            0|            0|  0.00%|                if n - last_print_n >= self.miniters:
  1041|         0|            0|            0|  0.00%|                    miniters = self.miniters  # watch monitoring thread changes
  1042|         0|            0|            0|  0.00%|                    delta_t = _time() - last_print_t
  1043|         0|            0|            0|  0.00%|                    if delta_t >= mininterval:
  1044|         0|            0|            0|  0.00%|                        cur_t = _time()
  1045|         0|            0|            0|  0.00%|                        delta_it = n - last_print_n
  1046|         0|            0|            0|  0.00%|                        # EMA (not just overall average)
  1047|         0|            0|            0|  0.00%|                        if smoothing and delta_t and delta_it:
  1048|         0|            0|            0|  0.00%|                            rate = delta_t / delta_it
  1049|         0|            0|            0|  0.00%|                            avg_time = self.ema(rate, avg_time, smoothing)
  1050|         0|            0|            0|  0.00%|                            self.avg_time = avg_time
  1051|         0|            0|            0|  0.00%|
  1052|         0|            0|            0|  0.00%|                        self.n = n
  1053|         0|            0|            0|  0.00%|                        with self._lock:
  1054|         0|            0|            0|  0.00%|                            self.display()
(call)|         9|            0|            0|  0.00%|# D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\package\tqdm\_tqdm.py:1332 display
  1055|         0|            0|            0|  0.00%|
  1056|         0|            0|            0|  0.00%|                        # If no `miniters` was specified, adjust automatically
  1057|         0|            0|            0|  0.00%|                        # to the max iteration rate seen so far between 2 prints
  1058|         0|            0|            0|  0.00%|                        if dynamic_miniters:
  1059|         0|            0|            0|  0.00%|                            if maxinterval and delta_t >= maxinterval:
  1060|         0|            0|            0|  0.00%|                                # Adjust miniters to time interval by rule of 3
  1061|         0|            0|            0|  0.00%|                                if mininterval:
  1062|         0|            0|            0|  0.00%|                                    # Set miniters to correspond to mininterval
  1063|         0|            0|            0|  0.00%|                                    miniters = delta_it * mininterval / delta_t
  1064|         0|            0|            0|  0.00%|                                else:
  1065|         0|            0|            0|  0.00%|                                    # Set miniters to correspond to maxinterval
  1066|         0|            0|            0|  0.00%|                                    miniters = delta_it * maxinterval / delta_t
  1067|         0|            0|            0|  0.00%|                            elif smoothing:
  1068|         0|            0|            0|  0.00%|                                # EMA-weight miniters to converge
  1069|         0|            0|            0|  0.00%|                                # towards the timeframe of mininterval
  1070|         0|            0|            0|  0.00%|                                rate = delta_it
  1071|         0|            0|            0|  0.00%|                                if mininterval and delta_t:
  1072|         0|            0|            0|  0.00%|                                    rate *= mininterval / delta_t
  1073|         0|            0|            0|  0.00%|                                miniters = self.ema(rate, miniters, smoothing)
  1074|         0|            0|            0|  0.00%|                            else:
  1075|         0|            0|            0|  0.00%|                                # Maximum nb of iterations between 2 prints
  1076|         0|            0|            0|  0.00%|                                miniters = max(miniters, delta_it)
  1077|         0|            0|            0|  0.00%|
  1078|         0|            0|            0|  0.00%|                        # Store old values for next call
  1079|         0|            0|            0|  0.00%|                        self.n = self.last_print_n = last_print_n = n
  1080|         0|            0|            0|  0.00%|                        self.last_print_t = last_print_t = cur_t
  1081|         0|            0|            0|  0.00%|                        self.miniters = miniters
  1082|         0|            0|            0|  0.00%|
  1083|         0|            0|            0|  0.00%|            # Closing the progress bar.
  1084|         0|            0|            0|  0.00%|            # Update some internal variables for close().
  1085|         0|            0|            0|  0.00%|            self.last_print_n = last_print_n
  1086|         0|            0|            0|  0.00%|            self.n = n
  1087|         0|            0|            0|  0.00%|            self.miniters = miniters
  1088|         0|            0|            0|  0.00%|            self.close()
  1089|         0|            0|            0|  0.00%|
  1090|         0|            0|            0|  0.00%|    def update(self, n=1):
  1091|         0|            0|            0|  0.00%|        """
  1092|         0|            0|            0|  0.00%|        Manually update the progress bar, useful for streams
  1093|         0|            0|            0|  0.00%|        such as reading files.
  1094|         0|            0|            0|  0.00%|        E.g.:
  1095|         0|            0|            0|  0.00%|        >>> t = tqdm(total=filesize) # Initialise
  1096|         0|            0|            0|  0.00%|        >>> for current_buffer in stream:
  1097|         0|            0|            0|  0.00%|        ...    ...
  1098|         0|            0|            0|  0.00%|        ...    t.update(len(current_buffer))
  1099|         0|            0|            0|  0.00%|        >>> t.close()
  1100|         0|            0|            0|  0.00%|        The last line is highly recommended, but possibly not necessary if
  1101|         0|            0|            0|  0.00%|        `t.update()` will be called in such a way that `filesize` will be
  1102|         0|            0|            0|  0.00%|        exactly reached and printed.
  1103|         0|            0|            0|  0.00%|
  1104|         0|            0|            0|  0.00%|        Parameters
  1105|         0|            0|            0|  0.00%|        ----------
  1106|         0|            0|            0|  0.00%|        n  : int, optional
  1107|         0|            0|            0|  0.00%|            Increment to add to the internal counter of iterations
  1108|         0|            0|            0|  0.00%|            [default: 1].
  1109|         0|            0|            0|  0.00%|        """
  1110|         0|            0|            0|  0.00%|        # N.B.: see __iter__() for more comments.
  1111|         0|            0|            0|  0.00%|        if self.disable:
  1112|         0|            0|            0|  0.00%|            return
  1113|         0|            0|            0|  0.00%|
  1114|         0|            0|            0|  0.00%|        if n < 0:
  1115|         0|            0|            0|  0.00%|            self.last_print_n += n  # for auto-refresh logic to work
  1116|         0|            0|            0|  0.00%|        self.n += n
  1117|         0|            0|            0|  0.00%|
  1118|         0|            0|            0|  0.00%|        # check counter first to reduce calls to time()
  1119|         0|            0|            0|  0.00%|        if self.n - self.last_print_n >= self.miniters:
  1120|         0|            0|            0|  0.00%|            delta_t = self._time() - self.last_print_t
  1121|         0|            0|            0|  0.00%|            if delta_t >= self.mininterval:
  1122|         0|            0|            0|  0.00%|                cur_t = self._time()
  1123|         0|            0|            0|  0.00%|                delta_it = self.n - self.last_print_n  # >= n
  1124|         0|            0|            0|  0.00%|                # elapsed = cur_t - self.start_t
  1125|         0|            0|            0|  0.00%|                # EMA (not just overall average)
  1126|         0|            0|            0|  0.00%|                if self.smoothing and delta_t and delta_it:
  1127|         0|            0|            0|  0.00%|                    rate = delta_t / delta_it
  1128|         0|            0|            0|  0.00%|                    self.avg_time = self.ema(
  1129|         0|            0|            0|  0.00%|                        rate, self.avg_time, self.smoothing)
  1130|         0|            0|            0|  0.00%|
  1131|         0|            0|            0|  0.00%|                if not hasattr(self, "sp"):
  1132|         0|            0|            0|  0.00%|                    from textwrap import dedent
  1133|         0|            0|            0|  0.00%|                    raise TqdmDeprecationWarning(dedent("""\
  1134|         0|            0|            0|  0.00%|                    Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`
  1135|         0|            0|            0|  0.00%|                    """), fp_write=getattr(self.fp, 'write', sys.stderr.write))
  1136|         0|            0|            0|  0.00%|
  1137|         0|            0|            0|  0.00%|                with self._lock:
  1138|         0|            0|            0|  0.00%|                    self.display()
  1139|         0|            0|            0|  0.00%|
  1140|         0|            0|            0|  0.00%|                # If no `miniters` was specified, adjust automatically to the
  1141|         0|            0|            0|  0.00%|                # maximum iteration rate seen so far between two prints.
  1142|         0|            0|            0|  0.00%|                # e.g.: After running `tqdm.update(5)`, subsequent
  1143|         0|            0|            0|  0.00%|                # calls to `tqdm.update()` will only cause an update after
  1144|         0|            0|            0|  0.00%|                # at least 5 more iterations.
  1145|         0|            0|            0|  0.00%|                if self.dynamic_miniters:
  1146|         0|            0|            0|  0.00%|                    if self.maxinterval and delta_t >= self.maxinterval:
  1147|         0|            0|            0|  0.00%|                        if self.mininterval:
  1148|         0|            0|            0|  0.00%|                            self.miniters = delta_it * self.mininterval \
  1149|         0|            0|            0|  0.00%|                                / delta_t
  1150|         0|            0|            0|  0.00%|                        else:
  1151|         0|            0|            0|  0.00%|                            self.miniters = delta_it * self.maxinterval \
  1152|         0|            0|            0|  0.00%|                                / delta_t
  1153|         0|            0|            0|  0.00%|                    elif self.smoothing:
  1154|         0|            0|            0|  0.00%|                        self.miniters = self.smoothing * delta_it * \
  1155|         0|            0|            0|  0.00%|                            (self.mininterval / delta_t
  1156|         0|            0|            0|  0.00%|                             if self.mininterval and delta_t
  1157|         0|            0|            0|  0.00%|                             else 1) + \
  1158|         0|            0|            0|  0.00%|                            (1 - self.smoothing) * self.miniters
  1159|         0|            0|            0|  0.00%|                    else:
  1160|         0|            0|            0|  0.00%|                        self.miniters = max(self.miniters, delta_it)
  1161|         0|            0|            0|  0.00%|
  1162|         0|            0|            0|  0.00%|                # Store old values for next call
  1163|         0|            0|            0|  0.00%|                self.last_print_n = self.n
  1164|         0|            0|            0|  0.00%|                self.last_print_t = cur_t
  1165|         0|            0|            0|  0.00%|
  1166|         0|            0|            0|  0.00%|    def close(self):
  1167|         0|            0|            0|  0.00%|        """Cleanup and (if leave=False) close the progressbar."""
  1168|         0|            0|            0|  0.00%|        if self.disable:
  1169|         0|            0|            0|  0.00%|            return
  1170|         0|            0|            0|  0.00%|
  1171|         0|            0|            0|  0.00%|        # Prevent multiple closures
  1172|         0|            0|            0|  0.00%|        self.disable = True
  1173|         0|            0|            0|  0.00%|
  1174|         0|            0|            0|  0.00%|        # decrement instance pos and remove from internal set
  1175|         0|            0|            0|  0.00%|        pos = abs(self.pos)
  1176|         0|            0|            0|  0.00%|        self._decr_instances(self)
  1177|         0|            0|            0|  0.00%|
  1178|         0|            0|            0|  0.00%|        # GUI mode
  1179|         0|            0|            0|  0.00%|        if not hasattr(self, "sp"):
  1180|         0|            0|            0|  0.00%|            return
  1181|         0|            0|            0|  0.00%|
  1182|         0|            0|            0|  0.00%|        # annoyingly, _supports_unicode isn't good enough
  1183|         0|            0|            0|  0.00%|        def fp_write(s):
  1184|         0|            0|            0|  0.00%|            self.fp.write(_unicode(s))
  1185|         0|            0|            0|  0.00%|
  1186|         0|            0|            0|  0.00%|        try:
  1187|         0|            0|            0|  0.00%|            fp_write('')
  1188|         0|            0|            0|  0.00%|        except ValueError as e:
  1189|         0|            0|            0|  0.00%|            if 'closed' in str(e):
  1190|         0|            0|            0|  0.00%|                return
  1191|         0|            0|            0|  0.00%|            raise  # pragma: no cover
  1192|         0|            0|            0|  0.00%|
  1193|         0|            0|            0|  0.00%|        leave = pos == 0 if self.leave is None else self.leave
  1194|         0|            0|            0|  0.00%|
  1195|         0|            0|            0|  0.00%|        with self._lock:
  1196|         0|            0|            0|  0.00%|            if leave:
  1197|         0|            0|            0|  0.00%|                # stats for overall rate (no weighted average)
  1198|         0|            0|            0|  0.00%|                self.avg_time = None
  1199|         0|            0|            0|  0.00%|                self.display(pos=0)
  1200|         0|            0|            0|  0.00%|                fp_write('\n')
  1201|         0|            0|            0|  0.00%|            else:
  1202|         0|            0|            0|  0.00%|                self.display(msg='', pos=pos)
  1203|         0|            0|            0|  0.00%|                if not pos:
  1204|         0|            0|            0|  0.00%|                    fp_write('\r')
  1205|         0|            0|            0|  0.00%|
  1206|         0|            0|            0|  0.00%|    def clear(self, nolock=False):
  1207|         0|            0|            0|  0.00%|        """Clear current bar display."""
  1208|         0|            0|            0|  0.00%|        if self.disable:
  1209|         0|            0|            0|  0.00%|            return
  1210|         0|            0|            0|  0.00%|
  1211|         0|            0|            0|  0.00%|        if not nolock:
  1212|         0|            0|            0|  0.00%|            self._lock.acquire()
  1213|         0|            0|            0|  0.00%|        self.moveto(abs(self.pos))
  1214|         0|            0|            0|  0.00%|        self.sp('')
  1215|         0|            0|            0|  0.00%|        self.fp.write('\r')  # place cursor back at the beginning of line
  1216|         0|            0|            0|  0.00%|        self.moveto(-abs(self.pos))
  1217|         0|            0|            0|  0.00%|        if not nolock:
  1218|         0|            0|            0|  0.00%|            self._lock.release()
  1219|         0|            0|            0|  0.00%|
  1220|         0|            0|            0|  0.00%|    def refresh(self, nolock=False):
  1221|         0|            0|            0|  0.00%|        """Force refresh the display of this bar."""
  1222|         0|            0|            0|  0.00%|        if self.disable:
  1223|         0|            0|            0|  0.00%|            return
  1224|         0|            0|            0|  0.00%|
  1225|         0|            0|            0|  0.00%|        if not nolock:
  1226|         0|            0|            0|  0.00%|            self._lock.acquire()
  1227|         0|            0|            0|  0.00%|        self.display()
  1228|         0|            0|            0|  0.00%|        if not nolock:
  1229|         0|            0|            0|  0.00%|            self._lock.release()
  1230|         0|            0|            0|  0.00%|
  1231|         0|            0|            0|  0.00%|    def unpause(self):
  1232|         0|            0|            0|  0.00%|        """Restart tqdm timer from last print time."""
  1233|         0|            0|            0|  0.00%|        cur_t = self._time()
  1234|         0|            0|            0|  0.00%|        self.start_t += cur_t - self.last_print_t
  1235|         0|            0|            0|  0.00%|        self.last_print_t = cur_t
  1236|         0|            0|            0|  0.00%|
  1237|         0|            0|            0|  0.00%|    def reset(self, total=None):
  1238|         0|            0|            0|  0.00%|        """
  1239|         0|            0|            0|  0.00%|        Resets to 0 iterations for repeated use.
  1240|         0|            0|            0|  0.00%|
  1241|         0|            0|            0|  0.00%|        Consider combining with `leave=True`.
  1242|         0|            0|            0|  0.00%|
  1243|         0|            0|            0|  0.00%|        Parameters
  1244|         0|            0|            0|  0.00%|        ----------
  1245|         0|            0|            0|  0.00%|        total  : int, optional. Total to use for the new bar.
  1246|         0|            0|            0|  0.00%|        """
  1247|         0|            0|            0|  0.00%|        self.last_print_n = self.n = 0
  1248|         0|            0|            0|  0.00%|        self.last_print_t = self.start_t = self._time()
  1249|         0|            0|            0|  0.00%|        if total is not None:
  1250|         0|            0|            0|  0.00%|            self.total = total
  1251|         0|            0|            0|  0.00%|        self.refresh()
  1252|         0|            0|            0|  0.00%|
  1253|         0|            0|            0|  0.00%|    def set_description(self, desc=None, refresh=True):
  1254|         0|            0|            0|  0.00%|        """
  1255|         0|            0|            0|  0.00%|        Set/modify description of the progress bar.
  1256|         0|            0|            0|  0.00%|
  1257|         0|            0|            0|  0.00%|        Parameters
  1258|         0|            0|            0|  0.00%|        ----------
  1259|         0|            0|            0|  0.00%|        desc  : str, optional
  1260|         0|            0|            0|  0.00%|        refresh  : bool, optional
  1261|         0|            0|            0|  0.00%|            Forces refresh [default: True].
  1262|         0|            0|            0|  0.00%|        """
  1263|         0|            0|            0|  0.00%|        self.desc = desc + ': ' if desc else ''
  1264|         0|            0|            0|  0.00%|        if refresh:
  1265|         0|            0|            0|  0.00%|            self.refresh()
  1266|         0|            0|            0|  0.00%|
  1267|         0|            0|            0|  0.00%|    def set_description_str(self, desc=None, refresh=True):
  1268|         0|            0|            0|  0.00%|        """Set/modify description without ': ' appended."""
  1269|         0|            0|            0|  0.00%|        self.desc = desc or ''
  1270|         0|            0|            0|  0.00%|        if refresh:
  1271|         0|            0|            0|  0.00%|            self.refresh()
  1272|         0|            0|            0|  0.00%|
  1273|         0|            0|            0|  0.00%|    def set_postfix(self, ordered_dict=None, refresh=True, **kwargs):
  1274|         0|            0|            0|  0.00%|        """
  1275|         0|            0|            0|  0.00%|        Set/modify postfix (additional stats)
  1276|         0|            0|            0|  0.00%|        with automatic formatting based on datatype.
  1277|         0|            0|            0|  0.00%|
  1278|         0|            0|            0|  0.00%|        Parameters
  1279|         0|            0|            0|  0.00%|        ----------
  1280|         0|            0|            0|  0.00%|        ordered_dict  : dict or OrderedDict, optional
  1281|         0|            0|            0|  0.00%|        refresh  : bool, optional
  1282|         0|            0|            0|  0.00%|            Forces refresh [default: True].
  1283|         0|            0|            0|  0.00%|        kwargs  : dict, optional
  1284|         0|            0|            0|  0.00%|        """
  1285|         0|            0|            0|  0.00%|        # Sort in alphabetical order to be more deterministic
  1286|         0|            0|            0|  0.00%|        postfix = _OrderedDict([] if ordered_dict is None else ordered_dict)
  1287|         0|            0|            0|  0.00%|        for key in sorted(kwargs.keys()):
  1288|         0|            0|            0|  0.00%|            postfix[key] = kwargs[key]
  1289|         0|            0|            0|  0.00%|        # Preprocess stats according to datatype
  1290|         0|            0|            0|  0.00%|        for key in postfix.keys():
  1291|         0|            0|            0|  0.00%|            # Number: limit the length of the string
  1292|         0|            0|            0|  0.00%|            if isinstance(postfix[key], Number):
  1293|         0|            0|            0|  0.00%|                postfix[key] = self.format_num(postfix[key])
  1294|         0|            0|            0|  0.00%|            # Else for any other type, try to get the string conversion
  1295|         0|            0|            0|  0.00%|            elif not isinstance(postfix[key], _basestring):
  1296|         0|            0|            0|  0.00%|                postfix[key] = str(postfix[key])
  1297|         0|            0|            0|  0.00%|            # Else if it's a string, don't need to preprocess anything
  1298|         0|            0|            0|  0.00%|        # Stitch together to get the final postfix
  1299|         0|            0|            0|  0.00%|        self.postfix = ', '.join(key + '=' + postfix[key].strip()
  1300|         0|            0|            0|  0.00%|                                 for key in postfix.keys())
  1301|         0|            0|            0|  0.00%|        if refresh:
  1302|         0|            0|            0|  0.00%|            self.refresh()
  1303|         0|            0|            0|  0.00%|
  1304|         0|            0|            0|  0.00%|    def set_postfix_str(self, s='', refresh=True):
  1305|         0|            0|            0|  0.00%|        """
  1306|         0|            0|            0|  0.00%|        Postfix without dictionary expansion, similar to prefix handling.
  1307|         0|            0|            0|  0.00%|        """
  1308|         0|            0|            0|  0.00%|        self.postfix = str(s)
  1309|         0|            0|            0|  0.00%|        if refresh:
  1310|         0|            0|            0|  0.00%|            self.refresh()
  1311|         0|            0|            0|  0.00%|
  1312|         0|            0|            0|  0.00%|    def moveto(self, n):
  1313|         0|            0|            0|  0.00%|        # TODO: private method
  1314|         0|            0|            0|  0.00%|        self.fp.write(_unicode('\n' * n + _term_move_up() * -n))
  1315|         0|            0|            0|  0.00%|        self.fp.flush()
  1316|         0|            0|            0|  0.00%|
  1317|         0|            0|            0|  0.00%|    @property
  1318|         0|            0|            0|  0.00%|    def format_dict(self):
  1319|         0|            0|            0|  0.00%|        """Public API for read-only member access."""
  1320|         0|            0|            0|  0.00%|        return dict(
  1321|         0|            0|            0|  0.00%|            n=self.n, total=self.total,
  1322|         0|            0|            0|  0.00%|            elapsed=self._time() - self.start_t
  1323|         0|            0|            0|  0.00%|            if hasattr(self, 'start_t') else 0,
  1324|         0|            0|            0|  0.00%|            ncols=self.dynamic_ncols(self.fp)
  1325|         0|            0|            0|  0.00%|            if self.dynamic_ncols else self.ncols,
  1326|         0|            0|            0|  0.00%|            prefix=self.desc, ascii=self.ascii, unit=self.unit,
  1327|         0|            0|            0|  0.00%|            unit_scale=self.unit_scale,
  1328|         0|            0|            0|  0.00%|            rate=1 / self.avg_time if self.avg_time else None,
  1329|         0|            0|            0|  0.00%|            bar_format=self.bar_format, postfix=self.postfix,
  1330|         0|            0|            0|  0.00%|            unit_divisor=self.unit_divisor)
  1331|         0|            0|            0|  0.00%|
  1332|         0|            0|            0|  0.00%|    def display(self, msg=None, pos=None):
  1333|         0|            0|            0|  0.00%|        """
  1334|         0|            0|            0|  0.00%|        Use `self.sp` to display `msg` in the specified `pos`.
  1335|         0|            0|            0|  0.00%|
  1336|         0|            0|            0|  0.00%|        Consider overloading this function when inheriting to use e.g.:
  1337|         0|            0|            0|  0.00%|        `self.some_frontend(**self.format_dict)` instead of `self.sp`.
  1338|         0|            0|            0|  0.00%|
  1339|         0|            0|            0|  0.00%|        Parameters
  1340|         0|            0|            0|  0.00%|        ----------
  1341|         0|            0|            0|  0.00%|        msg  : str, optional. What to display (default: `repr(self)`).
  1342|         0|            0|            0|  0.00%|        pos  : int, optional. Position to `moveto`
  1343|         0|            0|            0|  0.00%|          (default: `abs(self.pos)`).
  1344|         0|            0|            0|  0.00%|        """
  1345|         0|            0|            0|  0.00%|        if pos is None:
  1346|         0|            0|            0|  0.00%|            pos = abs(self.pos)
  1347|         0|            0|            0|  0.00%|
  1348|         0|            0|            0|  0.00%|        if pos:
  1349|         0|            0|            0|  0.00%|            self.moveto(pos)
  1350|         0|            0|            0|  0.00%|        self.sp(self.__repr__() if msg is None else msg)
(call)|         9|            0|            0|  0.00%|# D:\Users\JCHANGI\Jason Chang\Work\Project\Mix_Run_Ratio\package\tqdm\_tqdm.py:248 print_status
  1351|         0|            0|            0|  0.00%|        if pos:
  1352|         0|            0|            0|  0.00%|            self.moveto(-pos)
  1353|         0|            0|            0|  0.00%|
  1354|         0|            0|            0|  0.00%|
  1355|         0|            0|            0|  0.00%|def trange(*args, **kwargs):
  1356|         0|            0|            0|  0.00%|    """
  1357|         0|            0|            0|  0.00%|    A shortcut for tqdm(xrange(*args), **kwargs).
  1358|         0|            0|            0|  0.00%|    On Python3+ range is used instead of xrange.
  1359|         0|            0|            0|  0.00%|    """
  1360|         0|            0|            0|  0.00%|    return tqdm(_range(*args), **kwargs)
File: D:\Application\Anaconda\lib\runpy.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""runpy.py - locating and running Python code using the module namespace
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|Provides support for locating and running Python scripts using the Python
     4|         0|            0|            0|  0.00%|module namespace instead of the native filesystem.
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|This allows Python code to play nicely with non-filesystem based PEP 302
     7|         0|            0|            0|  0.00%|importers when locating support scripts as well as when importing modules.
     8|         0|            0|            0|  0.00%|"""
     9|         0|            0|            0|  0.00%|# Written by Nick Coghlan <ncoghlan at gmail.com>
    10|         0|            0|            0|  0.00%|#    to implement PEP 338 (Executing Modules as Scripts)
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|import sys
    14|         0|            0|            0|  0.00%|import importlib.machinery # importlib first so we can test #15386 via -m
    15|         0|            0|            0|  0.00%|import importlib.util
    16|         0|            0|            0|  0.00%|import types
    17|         0|            0|            0|  0.00%|from pkgutil import read_code, get_importer
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|__all__ = [
    20|         0|            0|            0|  0.00%|    "run_module", "run_path",
    21|         0|            0|            0|  0.00%|]
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|class _TempModule(object):
    24|         0|            0|            0|  0.00%|    """Temporarily replace a module in sys.modules with an empty namespace"""
    25|         0|            0|            0|  0.00%|    def __init__(self, mod_name):
    26|         0|            0|            0|  0.00%|        self.mod_name = mod_name
    27|         0|            0|            0|  0.00%|        self.module = types.ModuleType(mod_name)
    28|         0|            0|            0|  0.00%|        self._saved_module = []
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|    def __enter__(self):
    31|         0|            0|            0|  0.00%|        mod_name = self.mod_name
    32|         0|            0|            0|  0.00%|        try:
    33|         0|            0|            0|  0.00%|            self._saved_module.append(sys.modules[mod_name])
    34|         0|            0|            0|  0.00%|        except KeyError:
    35|         0|            0|            0|  0.00%|            pass
    36|         0|            0|            0|  0.00%|        sys.modules[mod_name] = self.module
    37|         0|            0|            0|  0.00%|        return self
    38|         0|            0|            0|  0.00%|
    39|         0|            0|            0|  0.00%|    def __exit__(self, *args):
    40|         0|            0|            0|  0.00%|        if self._saved_module:
    41|         0|            0|            0|  0.00%|            sys.modules[self.mod_name] = self._saved_module[0]
    42|         0|            0|            0|  0.00%|        else:
    43|         0|            0|            0|  0.00%|            del sys.modules[self.mod_name]
    44|         0|            0|            0|  0.00%|        self._saved_module = []
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|class _ModifiedArgv0(object):
    47|         0|            0|            0|  0.00%|    def __init__(self, value):
    48|         0|            0|            0|  0.00%|        self.value = value
    49|         0|            0|            0|  0.00%|        self._saved_value = self._sentinel = object()
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    def __enter__(self):
    52|         0|            0|            0|  0.00%|        if self._saved_value is not self._sentinel:
    53|         0|            0|            0|  0.00%|            raise RuntimeError("Already preserving saved value")
    54|         0|            0|            0|  0.00%|        self._saved_value = sys.argv[0]
    55|         0|            0|            0|  0.00%|        sys.argv[0] = self.value
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|    def __exit__(self, *args):
    58|         0|            0|            0|  0.00%|        self.value = self._sentinel
    59|         0|            0|            0|  0.00%|        sys.argv[0] = self._saved_value
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|# TODO: Replace these helpers with importlib._bootstrap_external functions.
    62|         0|            0|            0|  0.00%|def _run_code(code, run_globals, init_globals=None,
    63|         0|            0|            0|  0.00%|              mod_name=None, mod_spec=None,
    64|         0|            0|            0|  0.00%|              pkg_name=None, script_name=None):
    65|         0|            0|            0|  0.00%|    """Helper to run code in nominated namespace"""
    66|         0|            0|            0|  0.00%|    if init_globals is not None:
    67|         0|            0|            0|  0.00%|        run_globals.update(init_globals)
    68|         0|            0|            0|  0.00%|    if mod_spec is None:
    69|         0|            0|            0|  0.00%|        loader = None
    70|         0|            0|            0|  0.00%|        fname = script_name
    71|         0|            0|            0|  0.00%|        cached = None
    72|         0|            0|            0|  0.00%|    else:
    73|         0|            0|            0|  0.00%|        loader = mod_spec.loader
    74|         0|            0|            0|  0.00%|        fname = mod_spec.origin
    75|         0|            0|            0|  0.00%|        cached = mod_spec.cached
    76|         0|            0|            0|  0.00%|        if pkg_name is None:
    77|         0|            0|            0|  0.00%|            pkg_name = mod_spec.parent
    78|         0|            0|            0|  0.00%|    run_globals.update(__name__ = mod_name,
    79|         0|            0|            0|  0.00%|                       __file__ = fname,
    80|         0|            0|            0|  0.00%|                       __cached__ = cached,
    81|         0|            0|            0|  0.00%|                       __doc__ = None,
    82|         0|            0|            0|  0.00%|                       __loader__ = loader,
    83|         0|            0|            0|  0.00%|                       __package__ = pkg_name,
    84|         0|            0|            0|  0.00%|                       __spec__ = mod_spec)
    85|         0|            0|            0|  0.00%|    exec(code, run_globals)
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\site-packages\spyder_kernels\console\__main__.py:9 <module>
    86|         0|            0|            0|  0.00%|    return run_globals
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|def _run_module_code(code, init_globals=None,
    89|         0|            0|            0|  0.00%|                    mod_name=None, mod_spec=None,
    90|         0|            0|            0|  0.00%|                    pkg_name=None, script_name=None):
    91|         0|            0|            0|  0.00%|    """Helper to run code in new namespace with sys modified"""
    92|         0|            0|            0|  0.00%|    fname = script_name if mod_spec is None else mod_spec.origin
    93|         0|            0|            0|  0.00%|    with _TempModule(mod_name) as temp_module, _ModifiedArgv0(fname):
    94|         0|            0|            0|  0.00%|        mod_globals = temp_module.module.__dict__
    95|         0|            0|            0|  0.00%|        _run_code(code, mod_globals, init_globals,
    96|         0|            0|            0|  0.00%|                  mod_name, mod_spec, pkg_name, script_name)
    97|         0|            0|            0|  0.00%|    # Copy the globals of the temporary module, as they
    98|         0|            0|            0|  0.00%|    # may be cleared when the temporary module goes away
    99|         0|            0|            0|  0.00%|    return mod_globals.copy()
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|# Helper to get the full name, spec and code for a module
   102|         0|            0|            0|  0.00%|def _get_module_details(mod_name, error=ImportError):
   103|         0|            0|            0|  0.00%|    if mod_name.startswith("."):
   104|         0|            0|            0|  0.00%|        raise error("Relative module names not supported")
   105|         0|            0|            0|  0.00%|    pkg_name, _, _ = mod_name.rpartition(".")
   106|         0|            0|            0|  0.00%|    if pkg_name:
   107|         0|            0|            0|  0.00%|        # Try importing the parent to avoid catching initialization errors
   108|         0|            0|            0|  0.00%|        try:
   109|         0|            0|            0|  0.00%|            __import__(pkg_name)
   110|         0|            0|            0|  0.00%|        except ImportError as e:
   111|         0|            0|            0|  0.00%|            # If the parent or higher ancestor package is missing, let the
   112|         0|            0|            0|  0.00%|            # error be raised by find_spec() below and then be caught. But do
   113|         0|            0|            0|  0.00%|            # not allow other errors to be caught.
   114|         0|            0|            0|  0.00%|            if e.name is None or (e.name != pkg_name and
   115|         0|            0|            0|  0.00%|                    not pkg_name.startswith(e.name + ".")):
   116|         0|            0|            0|  0.00%|                raise
   117|         0|            0|            0|  0.00%|        # Warn if the module has already been imported under its normal name
   118|         0|            0|            0|  0.00%|        existing = sys.modules.get(mod_name)
   119|         0|            0|            0|  0.00%|        if existing is not None and not hasattr(existing, "__path__"):
   120|         0|            0|            0|  0.00%|            from warnings import warn
   121|         0|            0|            0|  0.00%|            msg = "{mod_name!r} found in sys.modules after import of " \
   122|         0|            0|            0|  0.00%|                "package {pkg_name!r}, but prior to execution of " \
   123|         0|            0|            0|  0.00%|                "{mod_name!r}; this may result in unpredictable " \
   124|         0|            0|            0|  0.00%|                "behaviour".format(mod_name=mod_name, pkg_name=pkg_name)
   125|         0|            0|            0|  0.00%|            warn(RuntimeWarning(msg))
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|    try:
   128|         0|            0|            0|  0.00%|        spec = importlib.util.find_spec(mod_name)
   129|         0|            0|            0|  0.00%|    except (ImportError, AttributeError, TypeError, ValueError) as ex:
   130|         0|            0|            0|  0.00%|        # This hack fixes an impedance mismatch between pkgutil and
   131|         0|            0|            0|  0.00%|        # importlib, where the latter raises other errors for cases where
   132|         0|            0|            0|  0.00%|        # pkgutil previously raised ImportError
   133|         0|            0|            0|  0.00%|        msg = "Error while finding module specification for {!r} ({}: {})"
   134|         0|            0|            0|  0.00%|        raise error(msg.format(mod_name, type(ex).__name__, ex)) from ex
   135|         0|            0|            0|  0.00%|    if spec is None:
   136|         0|            0|            0|  0.00%|        raise error("No module named %s" % mod_name)
   137|         0|            0|            0|  0.00%|    if spec.submodule_search_locations is not None:
   138|         0|            0|            0|  0.00%|        if mod_name == "__main__" or mod_name.endswith(".__main__"):
   139|         0|            0|            0|  0.00%|            raise error("Cannot use package as __main__ module")
   140|         0|            0|            0|  0.00%|        try:
   141|         0|            0|            0|  0.00%|            pkg_main_name = mod_name + ".__main__"
   142|         0|            0|            0|  0.00%|            return _get_module_details(pkg_main_name, error)
   143|         0|            0|            0|  0.00%|        except error as e:
   144|         0|            0|            0|  0.00%|            if mod_name not in sys.modules:
   145|         0|            0|            0|  0.00%|                raise  # No module loaded; being a package is irrelevant
   146|         0|            0|            0|  0.00%|            raise error(("%s; %r is a package and cannot " +
   147|         0|            0|            0|  0.00%|                               "be directly executed") %(e, mod_name))
   148|         0|            0|            0|  0.00%|    loader = spec.loader
   149|         0|            0|            0|  0.00%|    if loader is None:
   150|         0|            0|            0|  0.00%|        raise error("%r is a namespace package and cannot be executed"
   151|         0|            0|            0|  0.00%|                                                                 % mod_name)
   152|         0|            0|            0|  0.00%|    try:
   153|         0|            0|            0|  0.00%|        code = loader.get_code(mod_name)
   154|         0|            0|            0|  0.00%|    except ImportError as e:
   155|         0|            0|            0|  0.00%|        raise error(format(e)) from e
   156|         0|            0|            0|  0.00%|    if code is None:
   157|         0|            0|            0|  0.00%|        raise error("No code object available for %s" % mod_name)
   158|         0|            0|            0|  0.00%|    return mod_name, spec, code
   159|         0|            0|            0|  0.00%|
   160|         0|            0|            0|  0.00%|class _Error(Exception):
   161|         0|            0|            0|  0.00%|    """Error that _run_module_as_main() should report without a traceback"""
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|# XXX ncoghlan: Should this be documented and made public?
   164|         0|            0|            0|  0.00%|# (Current thoughts: don't repeat the mistake that lead to its
   165|         0|            0|            0|  0.00%|# creation when run_module() no longer met the needs of
   166|         0|            0|            0|  0.00%|# mainmodule.c, but couldn't be changed because it was public)
   167|         0|            0|            0|  0.00%|def _run_module_as_main(mod_name, alter_argv=True):
   168|         0|            0|            0|  0.00%|    """Runs the designated module in the __main__ namespace
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|       Note that the executed module will have full access to the
   171|         0|            0|            0|  0.00%|       __main__ namespace. If this is not desirable, the run_module()
   172|         0|            0|            0|  0.00%|       function should be used to run the module code in a fresh namespace.
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|       At the very least, these variables in __main__ will be overwritten:
   175|         0|            0|            0|  0.00%|           __name__
   176|         0|            0|            0|  0.00%|           __file__
   177|         0|            0|            0|  0.00%|           __cached__
   178|         0|            0|            0|  0.00%|           __loader__
   179|         0|            0|            0|  0.00%|           __package__
   180|         0|            0|            0|  0.00%|    """
   181|         0|            0|            0|  0.00%|    try:
   182|         0|            0|            0|  0.00%|        if alter_argv or mod_name != "__main__": # i.e. -m switch
   183|         0|            0|            0|  0.00%|            mod_name, mod_spec, code = _get_module_details(mod_name, _Error)
   184|         0|            0|            0|  0.00%|        else:          # i.e. directory or zipfile execution
   185|         0|            0|            0|  0.00%|            mod_name, mod_spec, code = _get_main_module_details(_Error)
   186|         0|            0|            0|  0.00%|    except _Error as exc:
   187|         0|            0|            0|  0.00%|        msg = "%s: %s" % (sys.executable, exc)
   188|         0|            0|            0|  0.00%|        sys.exit(msg)
   189|         0|            0|            0|  0.00%|    main_globals = sys.modules["__main__"].__dict__
   190|         0|            0|            0|  0.00%|    if alter_argv:
   191|         0|            0|            0|  0.00%|        sys.argv[0] = mod_spec.origin
   192|         0|            0|            0|  0.00%|    return _run_code(code, main_globals, None,
   193|         0|            0|            0|  0.00%|                     "__main__", mod_spec)
(call)|       196|            0|            0|  0.00%|# D:\Application\Anaconda\lib\runpy.py:62 _run_code
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|def run_module(mod_name, init_globals=None,
   196|         0|            0|            0|  0.00%|               run_name=None, alter_sys=False):
   197|         0|            0|            0|  0.00%|    """Execute a module's code without importing it
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|       Returns the resulting top level namespace dictionary
   200|         0|            0|            0|  0.00%|    """
   201|         0|            0|            0|  0.00%|    mod_name, mod_spec, code = _get_module_details(mod_name)
   202|         0|            0|            0|  0.00%|    if run_name is None:
   203|         0|            0|            0|  0.00%|        run_name = mod_name
   204|         0|            0|            0|  0.00%|    if alter_sys:
   205|         0|            0|            0|  0.00%|        return _run_module_code(code, init_globals, run_name, mod_spec)
   206|         0|            0|            0|  0.00%|    else:
   207|         0|            0|            0|  0.00%|        # Leave the sys module alone
   208|         0|            0|            0|  0.00%|        return _run_code(code, {}, init_globals, run_name, mod_spec)
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|def _get_main_module_details(error=ImportError):
   211|         0|            0|            0|  0.00%|    # Helper that gives a nicer error message when attempting to
   212|         0|            0|            0|  0.00%|    # execute a zipfile or directory by invoking __main__.py
   213|         0|            0|            0|  0.00%|    # Also moves the standard __main__ out of the way so that the
   214|         0|            0|            0|  0.00%|    # preexisting __loader__ entry doesn't cause issues
   215|         0|            0|            0|  0.00%|    main_name = "__main__"
   216|         0|            0|            0|  0.00%|    saved_main = sys.modules[main_name]
   217|         0|            0|            0|  0.00%|    del sys.modules[main_name]
   218|         0|            0|            0|  0.00%|    try:
   219|         0|            0|            0|  0.00%|        return _get_module_details(main_name)
   220|         0|            0|            0|  0.00%|    except ImportError as exc:
   221|         0|            0|            0|  0.00%|        if main_name in str(exc):
   222|         0|            0|            0|  0.00%|            raise error("can't find %r module in %r" %
   223|         0|            0|            0|  0.00%|                              (main_name, sys.path[0])) from exc
   224|         0|            0|            0|  0.00%|        raise
   225|         0|            0|            0|  0.00%|    finally:
   226|         0|            0|            0|  0.00%|        sys.modules[main_name] = saved_main
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|def _get_code_from_file(run_name, fname):
   230|         0|            0|            0|  0.00%|    # Check for a compiled file first
   231|         0|            0|            0|  0.00%|    with open(fname, "rb") as f:
   232|         0|            0|            0|  0.00%|        code = read_code(f)
   233|         0|            0|            0|  0.00%|    if code is None:
   234|         0|            0|            0|  0.00%|        # That didn't work, so try it as normal source code
   235|         0|            0|            0|  0.00%|        with open(fname, "rb") as f:
   236|         0|            0|            0|  0.00%|            code = compile(f.read(), fname, 'exec')
   237|         0|            0|            0|  0.00%|    return code, fname
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|def run_path(path_name, init_globals=None, run_name=None):
   240|         0|            0|            0|  0.00%|    """Execute code located at the specified filesystem location
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|       Returns the resulting top level namespace dictionary
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|       The file path may refer directly to a Python script (i.e.
   245|         0|            0|            0|  0.00%|       one that could be directly executed with execfile) or else
   246|         0|            0|            0|  0.00%|       it may refer to a zipfile or directory containing a top
   247|         0|            0|            0|  0.00%|       level __main__.py script.
   248|         0|            0|            0|  0.00%|    """
   249|         0|            0|            0|  0.00%|    if run_name is None:
   250|         0|            0|            0|  0.00%|        run_name = "<run_path>"
   251|         0|            0|            0|  0.00%|    pkg_name = run_name.rpartition(".")[0]
   252|         0|            0|            0|  0.00%|    importer = get_importer(path_name)
   253|         0|            0|            0|  0.00%|    # Trying to avoid importing imp so as to not consume the deprecation warning.
   254|         0|            0|            0|  0.00%|    is_NullImporter = False
   255|         0|            0|            0|  0.00%|    if type(importer).__module__ == 'imp':
   256|         0|            0|            0|  0.00%|        if type(importer).__name__ == 'NullImporter':
   257|         0|            0|            0|  0.00%|            is_NullImporter = True
   258|         0|            0|            0|  0.00%|    if isinstance(importer, type(None)) or is_NullImporter:
   259|         0|            0|            0|  0.00%|        # Not a valid sys.path entry, so run the code directly
   260|         0|            0|            0|  0.00%|        # execfile() doesn't help as we want to allow compiled files
   261|         0|            0|            0|  0.00%|        code, fname = _get_code_from_file(run_name, path_name)
   262|         0|            0|            0|  0.00%|        return _run_module_code(code, init_globals, run_name,
   263|         0|            0|            0|  0.00%|                                pkg_name=pkg_name, script_name=fname)
   264|         0|            0|            0|  0.00%|    else:
   265|         0|            0|            0|  0.00%|        # Finder is defined for path, so add it to
   266|         0|            0|            0|  0.00%|        # the start of sys.path
   267|         0|            0|            0|  0.00%|        sys.path.insert(0, path_name)
   268|         0|            0|            0|  0.00%|        try:
   269|         0|            0|            0|  0.00%|            # Here's where things are a little different from the run_module
   270|         0|            0|            0|  0.00%|            # case. There, we only had to replace the module in sys while the
   271|         0|            0|            0|  0.00%|            # code was running and doing so was somewhat optional. Here, we
   272|         0|            0|            0|  0.00%|            # have no choice and we have to remove it even while we read the
   273|         0|            0|            0|  0.00%|            # code. If we don't do this, a __loader__ attribute in the
   274|         0|            0|            0|  0.00%|            # existing __main__ module may prevent location of the new module.
   275|         0|            0|            0|  0.00%|            mod_name, mod_spec, code = _get_main_module_details()
   276|         0|            0|            0|  0.00%|            with _TempModule(run_name) as temp_module, \
   277|         0|            0|            0|  0.00%|                 _ModifiedArgv0(path_name):
   278|         0|            0|            0|  0.00%|                mod_globals = temp_module.module.__dict__
   279|         0|            0|            0|  0.00%|                return _run_code(code, mod_globals, init_globals,
   280|         0|            0|            0|  0.00%|                                    run_name, mod_spec, pkg_name).copy()
   281|         0|            0|            0|  0.00%|        finally:
   282|         0|            0|            0|  0.00%|            try:
   283|         0|            0|            0|  0.00%|                sys.path.remove(path_name)
   284|         0|            0|            0|  0.00%|            except ValueError:
   285|         0|            0|            0|  0.00%|                pass
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|if __name__ == "__main__":
   289|         0|            0|            0|  0.00%|    # Run the module specified as the next command line argument
   290|         0|            0|            0|  0.00%|    if len(sys.argv) < 2:
   291|         0|            0|            0|  0.00%|        print("No module specified for execution", file=sys.stderr)
   292|         0|            0|            0|  0.00%|    else:
   293|         0|            0|            0|  0.00%|        del sys.argv[0] # Make the requested module sys.argv[0]
   294|         0|            0|            0|  0.00%|        _run_module_as_main(sys.argv[0])
